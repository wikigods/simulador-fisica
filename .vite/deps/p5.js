import {
  __commonJS,
  __esm,
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField,
  __toCommonJS,
  __toESM
} from "./chunk-MJOZMRNF.js";

// node_modules/file-saver/FileSaver.js
var require_FileSaver = __commonJS({
  "node_modules/file-saver/FileSaver.js"(exports, module) {
    var saveAs2 = saveAs2 || function(view) {
      "use strict";
      if (typeof view === "undefined" || typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
        return;
      }
      var doc = view.document, get_URL = function() {
        return view.URL || view.webkitURL || view;
      }, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"), can_use_save_link = "download" in save_link, click = function(node) {
        var event = new MouseEvent("click");
        node.dispatchEvent(event);
      }, is_safari = /constructor/i.test(view.HTMLElement) || view.safari, is_chrome_ios = /CriOS\/[\d]+/.test(navigator.userAgent), throw_outside = function(ex) {
        (view.setImmediate || view.setTimeout)(function() {
          throw ex;
        }, 0);
      }, force_saveable_type = "application/octet-stream", arbitrary_revoke_timeout = 1e3 * 40, revoke = function(file3) {
        var revoker = function() {
          if (typeof file3 === "string") {
            get_URL().revokeObjectURL(file3);
          } else {
            file3.remove();
          }
        };
        setTimeout(revoker, arbitrary_revoke_timeout);
      }, dispatch = function(filesaver, event_types, event) {
        event_types = [].concat(event_types);
        var i = event_types.length;
        while (i--) {
          var listener = filesaver["on" + event_types[i]];
          if (typeof listener === "function") {
            try {
              listener.call(filesaver, event || filesaver);
            } catch (ex) {
              throw_outside(ex);
            }
          }
        }
      }, auto_bom = function(blob) {
        if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
          return new Blob([String.fromCharCode(65279), blob], { type: blob.type });
        }
        return blob;
      }, FileSaver = function(blob, name, no_auto_bom) {
        if (!no_auto_bom) {
          blob = auto_bom(blob);
        }
        var filesaver = this, type3 = blob.type, force = type3 === force_saveable_type, object_url, dispatch_all = function() {
          dispatch(filesaver, "writestart progress write writeend".split(" "));
        }, fs_error = function() {
          if ((is_chrome_ios || force && is_safari) && view.FileReader) {
            var reader = new FileReader();
            reader.onloadend = function() {
              var url2 = is_chrome_ios ? reader.result : reader.result.replace(/^data:[^;]*;/, "data:attachment/file;");
              var popup = view.open(url2, "_blank");
              if (!popup) view.location.href = url2;
              url2 = void 0;
              filesaver.readyState = filesaver.DONE;
              dispatch_all();
            };
            reader.readAsDataURL(blob);
            filesaver.readyState = filesaver.INIT;
            return;
          }
          if (!object_url) {
            object_url = get_URL().createObjectURL(blob);
          }
          if (force) {
            view.location.href = object_url;
          } else {
            var opened = view.open(object_url, "_blank");
            if (!opened) {
              view.location.href = object_url;
            }
          }
          filesaver.readyState = filesaver.DONE;
          dispatch_all();
          revoke(object_url);
        };
        filesaver.readyState = filesaver.INIT;
        if (can_use_save_link) {
          object_url = get_URL().createObjectURL(blob);
          setTimeout(function() {
            save_link.href = object_url;
            save_link.download = name;
            click(save_link);
            dispatch_all();
            revoke(object_url);
            filesaver.readyState = filesaver.DONE;
          });
          return;
        }
        fs_error();
      }, FS_proto = FileSaver.prototype, saveAs3 = function(blob, name, no_auto_bom) {
        return new FileSaver(blob, name || blob.name || "download", no_auto_bom);
      };
      if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
        return function(blob, name, no_auto_bom) {
          name = name || blob.name || "download";
          if (!no_auto_bom) {
            blob = auto_bom(blob);
          }
          return navigator.msSaveOrOpenBlob(blob, name);
        };
      }
      FS_proto.abort = function() {
      };
      FS_proto.readyState = FS_proto.INIT = 0;
      FS_proto.WRITING = 1;
      FS_proto.DONE = 2;
      FS_proto.error = FS_proto.onwritestart = FS_proto.onprogress = FS_proto.onwrite = FS_proto.onabort = FS_proto.onerror = FS_proto.onwriteend = null;
      return saveAs3;
    }(
      typeof self !== "undefined" && self || typeof window !== "undefined" && window || exports.content
    );
    if (typeof module !== "undefined" && module.exports) {
      module.exports.saveAs = saveAs2;
    } else if (typeof define !== "undefined" && define !== null && define.amd !== null) {
      define("FileSaver.js", function() {
        return saveAs2;
      });
    }
  }
});

// node_modules/omggif/omggif.js
var require_omggif = __commonJS({
  "node_modules/omggif/omggif.js"(exports) {
    "use strict";
    function GifWriter2(buf, width, height, gopts) {
      var p2 = 0;
      var gopts = gopts === void 0 ? {} : gopts;
      var loop_count = gopts.loop === void 0 ? null : gopts.loop;
      var global_palette = gopts.palette === void 0 ? null : gopts.palette;
      if (width <= 0 || height <= 0 || width > 65535 || height > 65535)
        throw new Error("Width/Height invalid.");
      function check_palette_and_num_colors(palette) {
        var num_colors = palette.length;
        if (num_colors < 2 || num_colors > 256 || num_colors & num_colors - 1) {
          throw new Error(
            "Invalid code/color length, must be power of 2 and 2 .. 256."
          );
        }
        return num_colors;
      }
      buf[p2++] = 71;
      buf[p2++] = 73;
      buf[p2++] = 70;
      buf[p2++] = 56;
      buf[p2++] = 57;
      buf[p2++] = 97;
      var gp_num_colors_pow2 = 0;
      var background = 0;
      if (global_palette !== null) {
        var gp_num_colors = check_palette_and_num_colors(global_palette);
        while (gp_num_colors >>= 1) ++gp_num_colors_pow2;
        gp_num_colors = 1 << gp_num_colors_pow2;
        --gp_num_colors_pow2;
        if (gopts.background !== void 0) {
          background = gopts.background;
          if (background >= gp_num_colors)
            throw new Error("Background index out of range.");
          if (background === 0)
            throw new Error("Background index explicitly passed as 0.");
        }
      }
      buf[p2++] = width & 255;
      buf[p2++] = width >> 8 & 255;
      buf[p2++] = height & 255;
      buf[p2++] = height >> 8 & 255;
      buf[p2++] = (global_palette !== null ? 128 : 0) | // Global Color Table Flag.
      gp_num_colors_pow2;
      buf[p2++] = background;
      buf[p2++] = 0;
      if (global_palette !== null) {
        for (var i = 0, il = global_palette.length; i < il; ++i) {
          var rgb = global_palette[i];
          buf[p2++] = rgb >> 16 & 255;
          buf[p2++] = rgb >> 8 & 255;
          buf[p2++] = rgb & 255;
        }
      }
      if (loop_count !== null) {
        if (loop_count < 0 || loop_count > 65535)
          throw new Error("Loop count invalid.");
        buf[p2++] = 33;
        buf[p2++] = 255;
        buf[p2++] = 11;
        buf[p2++] = 78;
        buf[p2++] = 69;
        buf[p2++] = 84;
        buf[p2++] = 83;
        buf[p2++] = 67;
        buf[p2++] = 65;
        buf[p2++] = 80;
        buf[p2++] = 69;
        buf[p2++] = 50;
        buf[p2++] = 46;
        buf[p2++] = 48;
        buf[p2++] = 3;
        buf[p2++] = 1;
        buf[p2++] = loop_count & 255;
        buf[p2++] = loop_count >> 8 & 255;
        buf[p2++] = 0;
      }
      var ended = false;
      this.addFrame = function(x, y, w, h, indexed_pixels, opts) {
        if (ended === true) {
          --p2;
          ended = false;
        }
        opts = opts === void 0 ? {} : opts;
        if (x < 0 || y < 0 || x > 65535 || y > 65535)
          throw new Error("x/y invalid.");
        if (w <= 0 || h <= 0 || w > 65535 || h > 65535)
          throw new Error("Width/Height invalid.");
        if (indexed_pixels.length < w * h)
          throw new Error("Not enough pixels for the frame size.");
        var using_local_palette = true;
        var palette = opts.palette;
        if (palette === void 0 || palette === null) {
          using_local_palette = false;
          palette = global_palette;
        }
        if (palette === void 0 || palette === null)
          throw new Error("Must supply either a local or global palette.");
        var num_colors = check_palette_and_num_colors(palette);
        var min_code_size = 0;
        while (num_colors >>= 1) ++min_code_size;
        num_colors = 1 << min_code_size;
        var delay = opts.delay === void 0 ? 0 : opts.delay;
        var disposal = opts.disposal === void 0 ? 0 : opts.disposal;
        if (disposal < 0 || disposal > 3)
          throw new Error("Disposal out of range.");
        var use_transparency = false;
        var transparent_index = 0;
        if (opts.transparent !== void 0 && opts.transparent !== null) {
          use_transparency = true;
          transparent_index = opts.transparent;
          if (transparent_index < 0 || transparent_index >= num_colors)
            throw new Error("Transparent color index.");
        }
        if (disposal !== 0 || use_transparency || delay !== 0) {
          buf[p2++] = 33;
          buf[p2++] = 249;
          buf[p2++] = 4;
          buf[p2++] = disposal << 2 | (use_transparency === true ? 1 : 0);
          buf[p2++] = delay & 255;
          buf[p2++] = delay >> 8 & 255;
          buf[p2++] = transparent_index;
          buf[p2++] = 0;
        }
        buf[p2++] = 44;
        buf[p2++] = x & 255;
        buf[p2++] = x >> 8 & 255;
        buf[p2++] = y & 255;
        buf[p2++] = y >> 8 & 255;
        buf[p2++] = w & 255;
        buf[p2++] = w >> 8 & 255;
        buf[p2++] = h & 255;
        buf[p2++] = h >> 8 & 255;
        buf[p2++] = using_local_palette === true ? 128 | min_code_size - 1 : 0;
        if (using_local_palette === true) {
          for (var i2 = 0, il2 = palette.length; i2 < il2; ++i2) {
            var rgb2 = palette[i2];
            buf[p2++] = rgb2 >> 16 & 255;
            buf[p2++] = rgb2 >> 8 & 255;
            buf[p2++] = rgb2 & 255;
          }
        }
        p2 = GifWriterOutputLZWCodeStream(
          buf,
          p2,
          min_code_size < 2 ? 2 : min_code_size,
          indexed_pixels
        );
        return p2;
      };
      this.end = function() {
        if (ended === false) {
          buf[p2++] = 59;
          ended = true;
        }
        return p2;
      };
      this.getOutputBuffer = function() {
        return buf;
      };
      this.setOutputBuffer = function(v) {
        buf = v;
      };
      this.getOutputBufferPosition = function() {
        return p2;
      };
      this.setOutputBufferPosition = function(v) {
        p2 = v;
      };
    }
    function GifWriterOutputLZWCodeStream(buf, p2, min_code_size, index_stream) {
      buf[p2++] = min_code_size;
      var cur_subblock = p2++;
      var clear_code = 1 << min_code_size;
      var code_mask = clear_code - 1;
      var eoi_code = clear_code + 1;
      var next_code = eoi_code + 1;
      var cur_code_size = min_code_size + 1;
      var cur_shift = 0;
      var cur = 0;
      function emit_bytes_to_buffer(bit_block_size) {
        while (cur_shift >= bit_block_size) {
          buf[p2++] = cur & 255;
          cur >>= 8;
          cur_shift -= 8;
          if (p2 === cur_subblock + 256) {
            buf[cur_subblock] = 255;
            cur_subblock = p2++;
          }
        }
      }
      function emit_code(c4) {
        cur |= c4 << cur_shift;
        cur_shift += cur_code_size;
        emit_bytes_to_buffer(8);
      }
      var ib_code = index_stream[0] & code_mask;
      var code_table = {};
      emit_code(clear_code);
      for (var i = 1, il = index_stream.length; i < il; ++i) {
        var k = index_stream[i] & code_mask;
        var cur_key = ib_code << 8 | k;
        var cur_code = code_table[cur_key];
        if (cur_code === void 0) {
          cur |= ib_code << cur_shift;
          cur_shift += cur_code_size;
          while (cur_shift >= 8) {
            buf[p2++] = cur & 255;
            cur >>= 8;
            cur_shift -= 8;
            if (p2 === cur_subblock + 256) {
              buf[cur_subblock] = 255;
              cur_subblock = p2++;
            }
          }
          if (next_code === 4096) {
            emit_code(clear_code);
            next_code = eoi_code + 1;
            cur_code_size = min_code_size + 1;
            code_table = {};
          } else {
            if (next_code >= 1 << cur_code_size) ++cur_code_size;
            code_table[cur_key] = next_code++;
          }
          ib_code = k;
        } else {
          ib_code = cur_code;
        }
      }
      emit_code(ib_code);
      emit_code(eoi_code);
      emit_bytes_to_buffer(1);
      if (cur_subblock + 1 === p2) {
        buf[cur_subblock] = 0;
      } else {
        buf[cur_subblock] = p2 - cur_subblock - 1;
        buf[p2++] = 0;
      }
      return p2;
    }
    function GifReader2(buf) {
      var p2 = 0;
      if (buf[p2++] !== 71 || buf[p2++] !== 73 || buf[p2++] !== 70 || buf[p2++] !== 56 || (buf[p2++] + 1 & 253) !== 56 || buf[p2++] !== 97) {
        throw new Error("Invalid GIF 87a/89a header.");
      }
      var width = buf[p2++] | buf[p2++] << 8;
      var height = buf[p2++] | buf[p2++] << 8;
      var pf0 = buf[p2++];
      var global_palette_flag = pf0 >> 7;
      var num_global_colors_pow2 = pf0 & 7;
      var num_global_colors = 1 << num_global_colors_pow2 + 1;
      var background = buf[p2++];
      buf[p2++];
      var global_palette_offset = null;
      var global_palette_size = null;
      if (global_palette_flag) {
        global_palette_offset = p2;
        global_palette_size = num_global_colors;
        p2 += num_global_colors * 3;
      }
      var no_eof = true;
      var frames = [];
      var delay = 0;
      var transparent_index = null;
      var disposal = 0;
      var loop_count = null;
      this.width = width;
      this.height = height;
      while (no_eof && p2 < buf.length) {
        switch (buf[p2++]) {
          case 33:
            switch (buf[p2++]) {
              case 255:
                if (buf[p2] !== 11 || // 21 FF already read, check block size.
                // NETSCAPE2.0
                buf[p2 + 1] == 78 && buf[p2 + 2] == 69 && buf[p2 + 3] == 84 && buf[p2 + 4] == 83 && buf[p2 + 5] == 67 && buf[p2 + 6] == 65 && buf[p2 + 7] == 80 && buf[p2 + 8] == 69 && buf[p2 + 9] == 50 && buf[p2 + 10] == 46 && buf[p2 + 11] == 48 && // Sub-block
                buf[p2 + 12] == 3 && buf[p2 + 13] == 1 && buf[p2 + 16] == 0) {
                  p2 += 14;
                  loop_count = buf[p2++] | buf[p2++] << 8;
                  p2++;
                } else {
                  p2 += 12;
                  while (true) {
                    var block_size = buf[p2++];
                    if (!(block_size >= 0)) throw Error("Invalid block size");
                    if (block_size === 0) break;
                    p2 += block_size;
                  }
                }
                break;
              case 249:
                if (buf[p2++] !== 4 || buf[p2 + 4] !== 0)
                  throw new Error("Invalid graphics extension block.");
                var pf1 = buf[p2++];
                delay = buf[p2++] | buf[p2++] << 8;
                transparent_index = buf[p2++];
                if ((pf1 & 1) === 0) transparent_index = null;
                disposal = pf1 >> 2 & 7;
                p2++;
                break;
              case 254:
                while (true) {
                  var block_size = buf[p2++];
                  if (!(block_size >= 0)) throw Error("Invalid block size");
                  if (block_size === 0) break;
                  p2 += block_size;
                }
                break;
              default:
                throw new Error(
                  "Unknown graphic control label: 0x" + buf[p2 - 1].toString(16)
                );
            }
            break;
          case 44:
            var x = buf[p2++] | buf[p2++] << 8;
            var y = buf[p2++] | buf[p2++] << 8;
            var w = buf[p2++] | buf[p2++] << 8;
            var h = buf[p2++] | buf[p2++] << 8;
            var pf2 = buf[p2++];
            var local_palette_flag = pf2 >> 7;
            var interlace_flag = pf2 >> 6 & 1;
            var num_local_colors_pow2 = pf2 & 7;
            var num_local_colors = 1 << num_local_colors_pow2 + 1;
            var palette_offset = global_palette_offset;
            var palette_size = global_palette_size;
            var has_local_palette = false;
            if (local_palette_flag) {
              var has_local_palette = true;
              palette_offset = p2;
              palette_size = num_local_colors;
              p2 += num_local_colors * 3;
            }
            var data_offset = p2;
            p2++;
            while (true) {
              var block_size = buf[p2++];
              if (!(block_size >= 0)) throw Error("Invalid block size");
              if (block_size === 0) break;
              p2 += block_size;
            }
            frames.push({
              x,
              y,
              width: w,
              height: h,
              has_local_palette,
              palette_offset,
              palette_size,
              data_offset,
              data_length: p2 - data_offset,
              transparent_index,
              interlaced: !!interlace_flag,
              delay,
              disposal
            });
            break;
          case 59:
            no_eof = false;
            break;
          default:
            throw new Error("Unknown gif block: 0x" + buf[p2 - 1].toString(16));
            break;
        }
      }
      this.numFrames = function() {
        return frames.length;
      };
      this.loopCount = function() {
        return loop_count;
      };
      this.frameInfo = function(frame_num) {
        if (frame_num < 0 || frame_num >= frames.length)
          throw new Error("Frame index out of range.");
        return frames[frame_num];
      };
      this.decodeAndBlitFrameBGRA = function(frame_num, pixels2) {
        var frame = this.frameInfo(frame_num);
        var num_pixels = frame.width * frame.height;
        var index_stream = new Uint8Array(num_pixels);
        GifReaderLZWOutputIndexStream(
          buf,
          frame.data_offset,
          index_stream,
          num_pixels
        );
        var palette_offset2 = frame.palette_offset;
        var trans = frame.transparent_index;
        if (trans === null) trans = 256;
        var framewidth = frame.width;
        var framestride = width - framewidth;
        var xleft = framewidth;
        var opbeg = (frame.y * width + frame.x) * 4;
        var opend = ((frame.y + frame.height) * width + frame.x) * 4;
        var op = opbeg;
        var scanstride = framestride * 4;
        if (frame.interlaced === true) {
          scanstride += width * 4 * 7;
        }
        var interlaceskip = 8;
        for (var i = 0, il = index_stream.length; i < il; ++i) {
          var index = index_stream[i];
          if (xleft === 0) {
            op += scanstride;
            xleft = framewidth;
            if (op >= opend) {
              scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
              op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
              interlaceskip >>= 1;
            }
          }
          if (index === trans) {
            op += 4;
          } else {
            var r = buf[palette_offset2 + index * 3];
            var g2 = buf[palette_offset2 + index * 3 + 1];
            var b3 = buf[palette_offset2 + index * 3 + 2];
            pixels2[op++] = b3;
            pixels2[op++] = g2;
            pixels2[op++] = r;
            pixels2[op++] = 255;
          }
          --xleft;
        }
      };
      this.decodeAndBlitFrameRGBA = function(frame_num, pixels2) {
        var frame = this.frameInfo(frame_num);
        var num_pixels = frame.width * frame.height;
        var index_stream = new Uint8Array(num_pixels);
        GifReaderLZWOutputIndexStream(
          buf,
          frame.data_offset,
          index_stream,
          num_pixels
        );
        var palette_offset2 = frame.palette_offset;
        var trans = frame.transparent_index;
        if (trans === null) trans = 256;
        var framewidth = frame.width;
        var framestride = width - framewidth;
        var xleft = framewidth;
        var opbeg = (frame.y * width + frame.x) * 4;
        var opend = ((frame.y + frame.height) * width + frame.x) * 4;
        var op = opbeg;
        var scanstride = framestride * 4;
        if (frame.interlaced === true) {
          scanstride += width * 4 * 7;
        }
        var interlaceskip = 8;
        for (var i = 0, il = index_stream.length; i < il; ++i) {
          var index = index_stream[i];
          if (xleft === 0) {
            op += scanstride;
            xleft = framewidth;
            if (op >= opend) {
              scanstride = framestride * 4 + width * 4 * (interlaceskip - 1);
              op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
              interlaceskip >>= 1;
            }
          }
          if (index === trans) {
            op += 4;
          } else {
            var r = buf[palette_offset2 + index * 3];
            var g2 = buf[palette_offset2 + index * 3 + 1];
            var b3 = buf[palette_offset2 + index * 3 + 2];
            pixels2[op++] = r;
            pixels2[op++] = g2;
            pixels2[op++] = b3;
            pixels2[op++] = 255;
          }
          --xleft;
        }
      };
    }
    function GifReaderLZWOutputIndexStream(code_stream, p2, output2, output_length) {
      var min_code_size = code_stream[p2++];
      var clear_code = 1 << min_code_size;
      var eoi_code = clear_code + 1;
      var next_code = eoi_code + 1;
      var cur_code_size = min_code_size + 1;
      var code_mask = (1 << cur_code_size) - 1;
      var cur_shift = 0;
      var cur = 0;
      var op = 0;
      var subblock_size = code_stream[p2++];
      var code_table = new Int32Array(4096);
      var prev_code = null;
      while (true) {
        while (cur_shift < 16) {
          if (subblock_size === 0) break;
          cur |= code_stream[p2++] << cur_shift;
          cur_shift += 8;
          if (subblock_size === 1) {
            subblock_size = code_stream[p2++];
          } else {
            --subblock_size;
          }
        }
        if (cur_shift < cur_code_size)
          break;
        var code = cur & code_mask;
        cur >>= cur_code_size;
        cur_shift -= cur_code_size;
        if (code === clear_code) {
          next_code = eoi_code + 1;
          cur_code_size = min_code_size + 1;
          code_mask = (1 << cur_code_size) - 1;
          prev_code = null;
          continue;
        } else if (code === eoi_code) {
          break;
        }
        var chase_code = code < next_code ? code : prev_code;
        var chase_length = 0;
        var chase = chase_code;
        while (chase > clear_code) {
          chase = code_table[chase] >> 8;
          ++chase_length;
        }
        var k = chase;
        var op_end = op + chase_length + (chase_code !== code ? 1 : 0);
        if (op_end > output_length) {
          console.log("Warning, gif stream longer than expected.");
          return;
        }
        output2[op++] = k;
        op += chase_length;
        var b3 = op;
        if (chase_code !== code)
          output2[op++] = k;
        chase = chase_code;
        while (chase_length--) {
          chase = code_table[chase];
          output2[--b3] = chase & 255;
          chase >>= 8;
        }
        if (prev_code !== null && next_code < 4096) {
          code_table[next_code++] = prev_code << 8 | k;
          if (next_code >= code_mask + 1 && cur_code_size < 12) {
            ++cur_code_size;
            code_mask = code_mask << 1 | 1;
          }
        }
        prev_code = code;
      }
      if (op !== output_length) {
        console.log("Warning, gif stream shorter than expected.");
      }
      return output2;
    }
    try {
      exports.GifWriter = GifWriter2;
      exports.GifReader = GifReader2;
    } catch (e2) {
    }
  }
});

// node_modules/libtess/libtess.min.js
var require_libtess_min = __commonJS({
  "node_modules/libtess/libtess.min.js"(exports, module) {
    "use strict";
    var n3;
    function t(a2, b3) {
      return a2.b === b3.b && a2.a === b3.a;
    }
    function u(a2, b3) {
      return a2.b < b3.b || a2.b === b3.b && a2.a <= b3.a;
    }
    function v(a2, b3, c4) {
      var d2 = b3.b - a2.b, e2 = c4.b - b3.b;
      return 0 < d2 + e2 ? d2 < e2 ? b3.a - a2.a + d2 / (d2 + e2) * (a2.a - c4.a) : b3.a - c4.a + e2 / (d2 + e2) * (c4.a - a2.a) : 0;
    }
    function x(a2, b3, c4) {
      var d2 = b3.b - a2.b, e2 = c4.b - b3.b;
      return 0 < d2 + e2 ? (b3.a - c4.a) * d2 + (b3.a - a2.a) * e2 : 0;
    }
    function z(a2, b3) {
      return a2.a < b3.a || a2.a === b3.a && a2.b <= b3.b;
    }
    function aa(a2, b3, c4) {
      var d2 = b3.a - a2.a, e2 = c4.a - b3.a;
      return 0 < d2 + e2 ? d2 < e2 ? b3.b - a2.b + d2 / (d2 + e2) * (a2.b - c4.b) : b3.b - c4.b + e2 / (d2 + e2) * (c4.b - a2.b) : 0;
    }
    function ba(a2, b3, c4) {
      var d2 = b3.a - a2.a, e2 = c4.a - b3.a;
      return 0 < d2 + e2 ? (b3.b - c4.b) * d2 + (b3.b - a2.b) * e2 : 0;
    }
    function ca(a2) {
      return u(a2.b.a, a2.a);
    }
    function da(a2) {
      return u(a2.a, a2.b.a);
    }
    function A(a2, b3, c4, d2) {
      a2 = 0 > a2 ? 0 : a2;
      c4 = 0 > c4 ? 0 : c4;
      return a2 <= c4 ? 0 === c4 ? (b3 + d2) / 2 : b3 + a2 / (a2 + c4) * (d2 - b3) : d2 + c4 / (a2 + c4) * (b3 - d2);
    }
    function ea(a2) {
      var b3 = B(a2.b);
      C(b3, a2.c);
      C(b3.b, a2.c);
      D2(b3, a2.a);
      return b3;
    }
    function E(a2, b3) {
      var c4 = false, d2 = false;
      a2 !== b3 && (b3.a !== a2.a && (d2 = true, F2(b3.a, a2.a)), b3.d !== a2.d && (c4 = true, G2(b3.d, a2.d)), H2(b3, a2), d2 || (C(b3, a2.a), a2.a.c = a2), c4 || (D2(b3, a2.d), a2.d.a = a2));
    }
    function I(a2) {
      var b3 = a2.b, c4 = false;
      a2.d !== a2.b.d && (c4 = true, G2(a2.d, a2.b.d));
      a2.c === a2 ? F2(a2.a, null) : (a2.b.d.a = J2(a2), a2.a.c = a2.c, H2(a2, J2(a2)), c4 || D2(a2, a2.d));
      b3.c === b3 ? (F2(b3.a, null), G2(b3.d, null)) : (a2.d.a = J2(b3), b3.a.c = b3.c, H2(b3, J2(b3)));
      fa(a2);
    }
    function K(a2) {
      var b3 = B(a2), c4 = b3.b;
      H2(b3, a2.e);
      b3.a = a2.b.a;
      C(c4, b3.a);
      b3.d = c4.d = a2.d;
      b3 = b3.b;
      H2(a2.b, J2(a2.b));
      H2(a2.b, b3);
      a2.b.a = b3.a;
      b3.b.a.c = b3.b;
      b3.b.d = a2.b.d;
      b3.f = a2.f;
      b3.b.f = a2.b.f;
      return b3;
    }
    function L(a2, b3) {
      var c4 = false, d2 = B(a2), e2 = d2.b;
      b3.d !== a2.d && (c4 = true, G2(b3.d, a2.d));
      H2(d2, a2.e);
      H2(e2, b3);
      d2.a = a2.b.a;
      e2.a = b3.a;
      d2.d = e2.d = a2.d;
      a2.d.a = e2;
      c4 || D2(d2, a2.d);
      return d2;
    }
    function B(a2) {
      var b3 = new M(), c4 = new M(), d2 = a2.b.h;
      c4.h = d2;
      d2.b.h = b3;
      b3.h = a2;
      a2.b.h = c4;
      b3.b = c4;
      b3.c = b3;
      b3.e = c4;
      c4.b = b3;
      c4.c = c4;
      return c4.e = b3;
    }
    function H2(a2, b3) {
      var c4 = a2.c, d2 = b3.c;
      c4.b.e = b3;
      d2.b.e = a2;
      a2.c = d2;
      b3.c = c4;
    }
    function C(a2, b3) {
      var c4 = b3.f, d2 = new N(b3, c4);
      c4.e = d2;
      b3.f = d2;
      c4 = d2.c = a2;
      do
        c4.a = d2, c4 = c4.c;
      while (c4 !== a2);
    }
    function D2(a2, b3) {
      var c4 = b3.d, d2 = new ga(b3, c4);
      c4.b = d2;
      b3.d = d2;
      d2.a = a2;
      d2.c = b3.c;
      c4 = a2;
      do
        c4.d = d2, c4 = c4.e;
      while (c4 !== a2);
    }
    function fa(a2) {
      var b3 = a2.h;
      a2 = a2.b.h;
      b3.b.h = a2;
      a2.b.h = b3;
    }
    function F2(a2, b3) {
      var c4 = a2.c, d2 = c4;
      do
        d2.a = b3, d2 = d2.c;
      while (d2 !== c4);
      c4 = a2.f;
      d2 = a2.e;
      d2.f = c4;
      c4.e = d2;
    }
    function G2(a2, b3) {
      var c4 = a2.a, d2 = c4;
      do
        d2.d = b3, d2 = d2.e;
      while (d2 !== c4);
      c4 = a2.d;
      d2 = a2.b;
      d2.d = c4;
      c4.b = d2;
    }
    function ha(a2) {
      var b3 = 0;
      Math.abs(a2[1]) > Math.abs(a2[0]) && (b3 = 1);
      Math.abs(a2[2]) > Math.abs(a2[b3]) && (b3 = 2);
      return b3;
    }
    var O2 = 4 * 1e150;
    function P(a2, b3) {
      a2.f += b3.f;
      a2.b.f += b3.b.f;
    }
    function ia(a2, b3, c4) {
      a2 = a2.a;
      b3 = b3.a;
      c4 = c4.a;
      if (b3.b.a === a2) return c4.b.a === a2 ? u(b3.a, c4.a) ? 0 >= x(c4.b.a, b3.a, c4.a) : 0 <= x(b3.b.a, c4.a, b3.a) : 0 >= x(c4.b.a, a2, c4.a);
      if (c4.b.a === a2) return 0 <= x(b3.b.a, a2, b3.a);
      b3 = v(b3.b.a, a2, b3.a);
      a2 = v(c4.b.a, a2, c4.a);
      return b3 >= a2;
    }
    function Q2(a2) {
      a2.a.i = null;
      var b3 = a2.e;
      b3.a.c = b3.c;
      b3.c.a = b3.a;
      a2.e = null;
    }
    function ja(a2, b3) {
      I(a2.a);
      a2.c = false;
      a2.a = b3;
      b3.i = a2;
    }
    function ka(a2) {
      var b3 = a2.a.a;
      do
        a2 = R2(a2);
      while (a2.a.a === b3);
      a2.c && (b3 = L(S2(a2).a.b, a2.a.e), ja(a2, b3), a2 = R2(a2));
      return a2;
    }
    function la(a2, b3, c4) {
      var d2 = new ma();
      d2.a = c4;
      d2.e = na(a2.f, b3.e, d2);
      return c4.i = d2;
    }
    function oa(a2, b3) {
      switch (a2.s) {
        case 100130:
          return 0 !== (b3 & 1);
        case 100131:
          return 0 !== b3;
        case 100132:
          return 0 < b3;
        case 100133:
          return 0 > b3;
        case 100134:
          return 2 <= b3 || -2 >= b3;
      }
      return false;
    }
    function pa(a2) {
      var b3 = a2.a, c4 = b3.d;
      c4.c = a2.d;
      c4.a = b3;
      Q2(a2);
    }
    function T2(a2, b3, c4) {
      a2 = b3;
      for (b3 = b3.a; a2 !== c4; ) {
        a2.c = false;
        var d2 = S2(a2), e2 = d2.a;
        if (e2.a !== b3.a) {
          if (!d2.c) {
            pa(a2);
            break;
          }
          e2 = L(b3.c.b, e2.b);
          ja(d2, e2);
        }
        b3.c !== e2 && (E(J2(e2), e2), E(b3, e2));
        pa(a2);
        b3 = d2.a;
        a2 = d2;
      }
      return b3;
    }
    function U2(a2, b3, c4, d2, e2, f) {
      var g2 = true;
      do
        la(a2, b3, c4.b), c4 = c4.c;
      while (c4 !== d2);
      for (null === e2 && (e2 = S2(b3).a.b.c); ; ) {
        d2 = S2(b3);
        c4 = d2.a.b;
        if (c4.a !== e2.a) break;
        c4.c !== e2 && (E(J2(c4), c4), E(J2(e2), c4));
        d2.f = b3.f - c4.f;
        d2.d = oa(a2, d2.f);
        b3.b = true;
        !g2 && qa(a2, b3) && (P(c4, e2), Q2(b3), I(e2));
        g2 = false;
        b3 = d2;
        e2 = c4;
      }
      b3.b = true;
      f && ra(a2, b3);
    }
    function sa(a2, b3, c4, d2, e2) {
      var f = [b3.g[0], b3.g[1], b3.g[2]];
      b3.d = null;
      b3.d = a2.o ? a2.o(f, c4, d2, a2.c) || null : null;
      null === b3.d && (e2 ? a2.n || (V(a2, 100156), a2.n = true) : b3.d = c4[0]);
    }
    function ta(a2, b3, c4) {
      var d2 = [null, null, null, null];
      d2[0] = b3.a.d;
      d2[1] = c4.a.d;
      sa(a2, b3.a, d2, [0.5, 0.5, 0, 0], false);
      E(b3, c4);
    }
    function ua(a2, b3, c4, d2, e2) {
      var f = Math.abs(b3.b - a2.b) + Math.abs(b3.a - a2.a), g2 = Math.abs(c4.b - a2.b) + Math.abs(c4.a - a2.a), h = e2 + 1;
      d2[e2] = 0.5 * g2 / (f + g2);
      d2[h] = 0.5 * f / (f + g2);
      a2.g[0] += d2[e2] * b3.g[0] + d2[h] * c4.g[0];
      a2.g[1] += d2[e2] * b3.g[1] + d2[h] * c4.g[1];
      a2.g[2] += d2[e2] * b3.g[2] + d2[h] * c4.g[2];
    }
    function qa(a2, b3) {
      var c4 = S2(b3), d2 = b3.a, e2 = c4.a;
      if (u(d2.a, e2.a)) {
        if (0 < x(e2.b.a, d2.a, e2.a)) return false;
        if (!t(d2.a, e2.a)) K(e2.b), E(d2, J2(e2)), b3.b = c4.b = true;
        else if (d2.a !== e2.a) {
          var c4 = a2.e, f = d2.a.h;
          if (0 <= f) {
            var c4 = c4.b, g2 = c4.d, h = c4.e, k = c4.c, l = k[f];
            g2[l] = g2[c4.a];
            k[g2[l]] = l;
            l <= --c4.a && (1 >= l ? W2(c4, l) : u(h[g2[l >> 1]], h[g2[l]]) ? W2(c4, l) : va(c4, l));
            h[f] = null;
            k[f] = c4.b;
            c4.b = f;
          } else for (c4.c[-(f + 1)] = null; 0 < c4.a && null === c4.c[c4.d[c4.a - 1]]; ) --c4.a;
          ta(a2, J2(e2), d2);
        }
      } else {
        if (0 > x(d2.b.a, e2.a, d2.a)) return false;
        R2(b3).b = b3.b = true;
        K(d2.b);
        E(J2(e2), d2);
      }
      return true;
    }
    function wa(a2, b3) {
      var c4 = S2(b3), d2 = b3.a, e2 = c4.a, f = d2.a, g2 = e2.a, h = d2.b.a, k = e2.b.a, l = new N();
      x(h, a2.a, f);
      x(k, a2.a, g2);
      if (f === g2 || Math.min(f.a, h.a) > Math.max(g2.a, k.a)) return false;
      if (u(f, g2)) {
        if (0 < x(k, f, g2)) return false;
      } else if (0 > x(h, g2, f)) return false;
      var r = h, p2 = f, q = k, y = g2, m3, w;
      u(r, p2) || (m3 = r, r = p2, p2 = m3);
      u(q, y) || (m3 = q, q = y, y = m3);
      u(r, q) || (m3 = r, r = q, q = m3, m3 = p2, p2 = y, y = m3);
      u(q, p2) ? u(p2, y) ? (m3 = v(r, q, p2), w = v(q, p2, y), 0 > m3 + w && (m3 = -m3, w = -w), l.b = A(m3, q.b, w, p2.b)) : (m3 = x(r, q, p2), w = -x(r, y, p2), 0 > m3 + w && (m3 = -m3, w = -w), l.b = A(m3, q.b, w, y.b)) : l.b = (q.b + p2.b) / 2;
      z(r, p2) || (m3 = r, r = p2, p2 = m3);
      z(q, y) || (m3 = q, q = y, y = m3);
      z(r, q) || (m3 = r, r = q, q = m3, m3 = p2, p2 = y, y = m3);
      z(q, p2) ? z(p2, y) ? (m3 = aa(r, q, p2), w = aa(q, p2, y), 0 > m3 + w && (m3 = -m3, w = -w), l.a = A(m3, q.a, w, p2.a)) : (m3 = ba(r, q, p2), w = -ba(r, y, p2), 0 > m3 + w && (m3 = -m3, w = -w), l.a = A(m3, q.a, w, y.a)) : l.a = (q.a + p2.a) / 2;
      u(l, a2.a) && (l.b = a2.a.b, l.a = a2.a.a);
      r = u(f, g2) ? f : g2;
      u(r, l) && (l.b = r.b, l.a = r.a);
      if (t(l, f) || t(l, g2)) return qa(a2, b3), false;
      if (!t(h, a2.a) && 0 <= x(h, a2.a, l) || !t(k, a2.a) && 0 >= x(k, a2.a, l)) {
        if (k === a2.a) return K(d2.b), E(e2.b, d2), b3 = ka(b3), d2 = S2(b3).a, T2(a2, S2(b3), c4), U2(a2, b3, J2(d2), d2, d2, true), true;
        if (h === a2.a) {
          K(e2.b);
          E(d2.e, J2(e2));
          f = c4 = b3;
          g2 = f.a.b.a;
          do
            f = R2(f);
          while (f.a.b.a === g2);
          b3 = f;
          f = S2(b3).a.b.c;
          c4.a = J2(e2);
          e2 = T2(a2, c4, null);
          U2(a2, b3, e2.c, d2.b.c, f, true);
          return true;
        }
        0 <= x(h, a2.a, l) && (R2(b3).b = b3.b = true, K(d2.b), d2.a.b = a2.a.b, d2.a.a = a2.a.a);
        0 >= x(k, a2.a, l) && (b3.b = c4.b = true, K(e2.b), e2.a.b = a2.a.b, e2.a.a = a2.a.a);
        return false;
      }
      K(d2.b);
      K(e2.b);
      E(J2(e2), d2);
      d2.a.b = l.b;
      d2.a.a = l.a;
      d2.a.h = xa(a2.e, d2.a);
      d2 = d2.a;
      e2 = [0, 0, 0, 0];
      l = [f.d, h.d, g2.d, k.d];
      d2.g[0] = d2.g[1] = d2.g[2] = 0;
      ua(d2, f, h, e2, 0);
      ua(d2, g2, k, e2, 2);
      sa(a2, d2, l, e2, true);
      R2(b3).b = b3.b = c4.b = true;
      return false;
    }
    function ra(a2, b3) {
      for (var c4 = S2(b3); ; ) {
        for (; c4.b; ) b3 = c4, c4 = S2(c4);
        if (!b3.b && (c4 = b3, b3 = R2(b3), null === b3 || !b3.b)) break;
        b3.b = false;
        var d2 = b3.a, e2 = c4.a, f;
        if (f = d2.b.a !== e2.b.a) a: {
          f = b3;
          var g2 = S2(f), h = f.a, k = g2.a, l = void 0;
          if (u(h.b.a, k.b.a)) {
            if (0 > x(h.b.a, k.b.a, h.a)) {
              f = false;
              break a;
            }
            R2(f).b = f.b = true;
            l = K(h);
            E(k.b, l);
            l.d.c = f.d;
          } else {
            if (0 < x(k.b.a, h.b.a, k.a)) {
              f = false;
              break a;
            }
            f.b = g2.b = true;
            l = K(k);
            E(h.e, k.b);
            l.b.d.c = f.d;
          }
          f = true;
        }
        f && (c4.c ? (Q2(c4), I(e2), c4 = S2(b3), e2 = c4.a) : b3.c && (Q2(b3), I(d2), b3 = R2(c4), d2 = b3.a));
        if (d2.a !== e2.a) {
          if (d2.b.a === e2.b.a || b3.c || c4.c || d2.b.a !== a2.a && e2.b.a !== a2.a) qa(
            a2,
            b3
          );
          else if (wa(a2, b3)) break;
        }
        d2.a === e2.a && d2.b.a === e2.b.a && (P(e2, d2), Q2(b3), I(d2), b3 = R2(c4));
      }
    }
    function ya(a2, b3) {
      a2.a = b3;
      for (var c4 = b3.c; null === c4.i; ) if (c4 = c4.c, c4 === b3.c) {
        var c4 = a2, d2 = b3, e2 = new ma();
        e2.a = d2.c.b;
        var f = c4.f, g2 = f.a;
        do
          g2 = g2.a;
        while (null !== g2.b && !f.c(f.b, e2, g2.b));
        var f = g2.b, h = S2(f), e2 = f.a, g2 = h.a;
        if (0 === x(e2.b.a, d2, e2.a)) e2 = f.a, t(e2.a, d2) || t(e2.b.a, d2) || (K(e2.b), f.c && (I(e2.c), f.c = false), E(d2.c, e2), ya(c4, d2));
        else {
          var k = u(g2.b.a, e2.b.a) ? f : h, h = void 0;
          f.d || k.c ? (k === f ? h = L(d2.c.b, e2.e) : h = L(g2.b.c.b, d2.c).b, k.c ? ja(k, h) : (e2 = c4, f = la(c4, f, h), f.f = R2(f).f + f.a.f, f.d = oa(e2, f.f)), ya(c4, d2)) : U2(c4, f, d2.c, d2.c, null, true);
        }
        return;
      }
      c4 = ka(c4.i);
      e2 = S2(c4);
      f = e2.a;
      e2 = T2(
        a2,
        e2,
        null
      );
      if (e2.c === f) {
        var f = e2, e2 = f.c, g2 = S2(c4), h = c4.a, k = g2.a, l = false;
        h.b.a !== k.b.a && wa(a2, c4);
        t(h.a, a2.a) && (E(J2(e2), h), c4 = ka(c4), e2 = S2(c4).a, T2(a2, S2(c4), g2), l = true);
        t(k.a, a2.a) && (E(f, J2(k)), f = T2(a2, g2, null), l = true);
        l ? U2(a2, c4, f.c, e2, e2, true) : (u(k.a, h.a) ? d2 = J2(k) : d2 = h, d2 = L(f.c.b, d2), U2(a2, c4, d2, d2.c, d2.c, false), d2.b.i.c = true, ra(a2, c4));
      } else U2(a2, c4, e2.c, f, f, true);
    }
    function za(a2, b3) {
      var c4 = new ma(), d2 = ea(a2.b);
      d2.a.b = O2;
      d2.a.a = b3;
      d2.b.a.b = -O2;
      d2.b.a.a = b3;
      a2.a = d2.b.a;
      c4.a = d2;
      c4.f = 0;
      c4.d = false;
      c4.c = false;
      c4.h = true;
      c4.b = false;
      d2 = a2.f;
      d2 = na(d2, d2.a, c4);
      c4.e = d2;
    }
    function Aa(a2) {
      this.a = new Ba();
      this.b = a2;
      this.c = ia;
    }
    function na(a2, b3, c4) {
      do
        b3 = b3.c;
      while (null !== b3.b && !a2.c(a2.b, b3.b, c4));
      a2 = new Ba(c4, b3.a, b3);
      b3.a.c = a2;
      return b3.a = a2;
    }
    function Ba(a2, b3, c4) {
      this.b = a2 || null;
      this.a = b3 || this;
      this.c = c4 || this;
    }
    function X2() {
      this.d = Y;
      this.p = this.b = this.q = null;
      this.j = [0, 0, 0];
      this.s = 100130;
      this.n = false;
      this.o = this.a = this.e = this.f = null;
      this.m = false;
      this.c = this.r = this.i = this.k = this.l = this.h = null;
    }
    var Y = 0;
    n3 = X2.prototype;
    n3.x = function() {
      Z2(this, Y);
    };
    n3.B = function(a2, b3) {
      switch (a2) {
        case 100142:
          return;
        case 100140:
          switch (b3) {
            case 100130:
            case 100131:
            case 100132:
            case 100133:
            case 100134:
              this.s = b3;
              return;
          }
          break;
        case 100141:
          this.m = !!b3;
          return;
        default:
          V(this, 100900);
          return;
      }
      V(this, 100901);
    };
    n3.y = function(a2) {
      switch (a2) {
        case 100142:
          return 0;
        case 100140:
          return this.s;
        case 100141:
          return this.m;
        default:
          V(this, 100900);
      }
      return false;
    };
    n3.A = function(a2, b3, c4) {
      this.j[0] = a2;
      this.j[1] = b3;
      this.j[2] = c4;
    };
    n3.z = function(a2, b3) {
      var c4 = b3 ? b3 : null;
      switch (a2) {
        case 100100:
        case 100106:
          this.h = c4;
          break;
        case 100104:
        case 100110:
          this.l = c4;
          break;
        case 100101:
        case 100107:
          this.k = c4;
          break;
        case 100102:
        case 100108:
          this.i = c4;
          break;
        case 100103:
        case 100109:
          this.p = c4;
          break;
        case 100105:
        case 100111:
          this.o = c4;
          break;
        case 100112:
          this.r = c4;
          break;
        default:
          V(this, 100900);
      }
    };
    n3.C = function(a2, b3) {
      var c4 = false, d2 = [0, 0, 0];
      Z2(this, 2);
      for (var e2 = 0; 3 > e2; ++e2) {
        var f = a2[e2];
        -1e150 > f && (f = -1e150, c4 = true);
        1e150 < f && (f = 1e150, c4 = true);
        d2[e2] = f;
      }
      c4 && V(this, 100155);
      c4 = this.q;
      null === c4 ? (c4 = ea(this.b), E(c4, c4.b)) : (K(c4), c4 = c4.e);
      c4.a.d = b3;
      c4.a.g[0] = d2[0];
      c4.a.g[1] = d2[1];
      c4.a.g[2] = d2[2];
      c4.f = 1;
      c4.b.f = -1;
      this.q = c4;
    };
    n3.u = function(a2) {
      Z2(this, Y);
      this.d = 1;
      this.b = new Ca();
      this.c = a2;
    };
    n3.t = function() {
      Z2(this, 1);
      this.d = 2;
      this.q = null;
    };
    n3.v = function() {
      Z2(this, 2);
      this.d = 1;
    };
    n3.w = function() {
      Z2(this, 1);
      this.d = Y;
      var a2 = this.j[0], b3 = this.j[1], c4 = this.j[2], d2 = false, e2 = [a2, b3, c4];
      if (0 === a2 && 0 === b3 && 0 === c4) {
        for (var b3 = [-2 * 1e150, -2 * 1e150, -2 * 1e150], f = [2 * 1e150, 2 * 1e150, 2 * 1e150], c4 = [], g2 = [], d2 = this.b.c, a2 = d2.e; a2 !== d2; a2 = a2.e) for (var h = 0; 3 > h; ++h) {
          var k = a2.g[h];
          k < f[h] && (f[h] = k, g2[h] = a2);
          k > b3[h] && (b3[h] = k, c4[h] = a2);
        }
        a2 = 0;
        b3[1] - f[1] > b3[0] - f[0] && (a2 = 1);
        b3[2] - f[2] > b3[a2] - f[a2] && (a2 = 2);
        if (f[a2] >= b3[a2]) e2[0] = 0, e2[1] = 0, e2[2] = 1;
        else {
          b3 = 0;
          f = g2[a2];
          c4 = c4[a2];
          g2 = [0, 0, 0];
          f = [f.g[0] - c4.g[0], f.g[1] - c4.g[1], f.g[2] - c4.g[2]];
          h = [0, 0, 0];
          for (a2 = d2.e; a2 !== d2; a2 = a2.e) h[0] = a2.g[0] - c4.g[0], h[1] = a2.g[1] - c4.g[1], h[2] = a2.g[2] - c4.g[2], g2[0] = f[1] * h[2] - f[2] * h[1], g2[1] = f[2] * h[0] - f[0] * h[2], g2[2] = f[0] * h[1] - f[1] * h[0], k = g2[0] * g2[0] + g2[1] * g2[1] + g2[2] * g2[2], k > b3 && (b3 = k, e2[0] = g2[0], e2[1] = g2[1], e2[2] = g2[2]);
          0 >= b3 && (e2[0] = e2[1] = e2[2] = 0, e2[ha(f)] = 1);
        }
        d2 = true;
      }
      g2 = ha(e2);
      a2 = this.b.c;
      b3 = (g2 + 1) % 3;
      c4 = (g2 + 2) % 3;
      g2 = 0 < e2[g2] ? 1 : -1;
      for (e2 = a2.e; e2 !== a2; e2 = e2.e) e2.b = e2.g[b3], e2.a = g2 * e2.g[c4];
      if (d2) {
        e2 = 0;
        d2 = this.b.a;
        for (a2 = d2.b; a2 !== d2; a2 = a2.b) if (b3 = a2.a, !(0 >= b3.f)) {
          do
            e2 += (b3.a.b - b3.b.a.b) * (b3.a.a + b3.b.a.a), b3 = b3.e;
          while (b3 !== a2.a);
        }
        if (0 > e2) for (e2 = this.b.c, d2 = e2.e; d2 !== e2; d2 = d2.e) d2.a = -d2.a;
      }
      this.n = false;
      e2 = this.b.b;
      for (a2 = e2.h; a2 !== e2; a2 = d2) if (d2 = a2.h, b3 = a2.e, t(a2.a, a2.b.a) && a2.e.e !== a2 && (ta(this, b3, a2), I(a2), a2 = b3, b3 = a2.e), b3.e === a2) {
        if (b3 !== a2) {
          if (b3 === d2 || b3 === d2.b) d2 = d2.h;
          I(b3);
        }
        if (a2 === d2 || a2 === d2.b) d2 = d2.h;
        I(a2);
      }
      this.e = e2 = new Da();
      d2 = this.b.c;
      for (a2 = d2.e; a2 !== d2; a2 = a2.e) a2.h = xa(e2, a2);
      Ea(e2);
      this.f = new Aa(this);
      za(this, -O2);
      for (za(this, O2); null !== (e2 = Fa(this.e)); ) {
        for (; ; ) {
          a: if (a2 = this.e, 0 === a2.a) d2 = Ga(a2.b);
          else if (d2 = a2.c[a2.d[a2.a - 1]], 0 !== a2.b.a && (a2 = Ga(a2.b), u(a2, d2))) {
            d2 = a2;
            break a;
          }
          if (null === d2 || !t(d2, e2)) break;
          d2 = Fa(this.e);
          ta(
            this,
            e2.c,
            d2.c
          );
        }
        ya(this, e2);
      }
      this.a = this.f.a.a.b.a.a;
      for (e2 = 0; null !== (d2 = this.f.a.a.b); ) d2.h || ++e2, Q2(d2);
      this.f = null;
      e2 = this.e;
      e2.b = null;
      e2.d = null;
      this.e = e2.c = null;
      e2 = this.b;
      for (a2 = e2.a.b; a2 !== e2.a; a2 = d2) d2 = a2.b, a2 = a2.a, a2.e.e === a2 && (P(a2.c, a2), I(a2));
      if (!this.n) {
        e2 = this.b;
        if (this.m) for (a2 = e2.b.h; a2 !== e2.b; a2 = d2) d2 = a2.h, a2.b.d.c !== a2.d.c ? a2.f = a2.d.c ? 1 : -1 : I(a2);
        else for (a2 = e2.a.b; a2 !== e2.a; a2 = d2) if (d2 = a2.b, a2.c) {
          for (a2 = a2.a; u(a2.b.a, a2.a); a2 = a2.c.b) ;
          for (; u(a2.a, a2.b.a); a2 = a2.e) ;
          b3 = a2.c.b;
          for (c4 = void 0; a2.e !== b3; ) if (u(a2.b.a, b3.a)) {
            for (; b3.e !== a2 && (ca(b3.e) || 0 >= x(b3.a, b3.b.a, b3.e.b.a)); ) c4 = L(b3.e, b3), b3 = c4.b;
            b3 = b3.c.b;
          } else {
            for (; b3.e !== a2 && (da(a2.c.b) || 0 <= x(a2.b.a, a2.a, a2.c.b.a)); ) c4 = L(a2, a2.c.b), a2 = c4.b;
            a2 = a2.e;
          }
          for (; b3.e.e !== a2; ) c4 = L(b3.e, b3), b3 = c4.b;
        }
        if (this.h || this.i || this.k || this.l) if (this.m) for (e2 = this.b, d2 = e2.a.b; d2 !== e2.a; d2 = d2.b) {
          if (d2.c) {
            this.h && this.h(2, this.c);
            a2 = d2.a;
            do
              this.k && this.k(a2.a.d, this.c), a2 = a2.e;
            while (a2 !== d2.a);
            this.i && this.i(this.c);
          }
        }
        else {
          e2 = this.b;
          d2 = !!this.l;
          a2 = false;
          b3 = -1;
          for (c4 = e2.a.d; c4 !== e2.a; c4 = c4.d) if (c4.c) {
            a2 || (this.h && this.h(4, this.c), a2 = true);
            g2 = c4.a;
            do
              d2 && (f = g2.b.d.c ? 0 : 1, b3 !== f && (b3 = f, this.l && this.l(!!b3, this.c))), this.k && this.k(g2.a.d, this.c), g2 = g2.e;
            while (g2 !== c4.a);
          }
          a2 && this.i && this.i(this.c);
        }
        if (this.r) {
          e2 = this.b;
          for (a2 = e2.a.b; a2 !== e2.a; a2 = d2) if (d2 = a2.b, !a2.c) {
            b3 = a2.a;
            c4 = b3.e;
            g2 = void 0;
            do
              g2 = c4, c4 = g2.e, g2.d = null, null === g2.b.d && (g2.c === g2 ? F2(g2.a, null) : (g2.a.c = g2.c, H2(g2, J2(g2))), f = g2.b, f.c === f ? F2(f.a, null) : (f.a.c = f.c, H2(f, J2(f))), fa(g2));
            while (g2 !== b3);
            b3 = a2.d;
            a2 = a2.b;
            a2.d = b3;
            b3.b = a2;
          }
          this.r(this.b);
          this.c = this.b = null;
          return;
        }
      }
      this.b = this.c = null;
    };
    function Z2(a2, b3) {
      if (a2.d !== b3) for (; a2.d !== b3; ) if (a2.d < b3) switch (a2.d) {
        case Y:
          V(a2, 100151);
          a2.u(null);
          break;
        case 1:
          V(a2, 100152), a2.t();
      }
      else switch (a2.d) {
        case 2:
          V(a2, 100154);
          a2.v();
          break;
        case 1:
          V(a2, 100153), a2.w();
      }
    }
    function V(a2, b3) {
      a2.p && a2.p(b3, a2.c);
    }
    function ga(a2, b3) {
      this.b = a2 || this;
      this.d = b3 || this;
      this.a = null;
      this.c = false;
    }
    function M() {
      this.h = this;
      this.i = this.d = this.a = this.e = this.c = this.b = null;
      this.f = 0;
    }
    function J2(a2) {
      return a2.b.e;
    }
    function Ca() {
      this.c = new N();
      this.a = new ga();
      this.b = new M();
      this.d = new M();
      this.b.b = this.d;
      this.d.b = this.b;
    }
    function N(a2, b3) {
      this.e = a2 || this;
      this.f = b3 || this;
      this.d = this.c = null;
      this.g = [0, 0, 0];
      this.h = this.a = this.b = 0;
    }
    function Da() {
      this.c = [];
      this.d = null;
      this.a = 0;
      this.e = false;
      this.b = new Ha();
    }
    function Ea(a2) {
      a2.d = [];
      for (var b3 = 0; b3 < a2.a; b3++) a2.d[b3] = b3;
      a2.d.sort(/* @__PURE__ */ function(a3) {
        return function(b4, e2) {
          return u(a3[b4], a3[e2]) ? 1 : -1;
        };
      }(a2.c));
      a2.e = true;
      Ia(a2.b);
    }
    function xa(a2, b3) {
      if (a2.e) {
        var c4 = a2.b, d2 = ++c4.a;
        2 * d2 > c4.f && (c4.f *= 2, c4.c = Ja(c4.c, c4.f + 1));
        var e2;
        0 === c4.b ? e2 = d2 : (e2 = c4.b, c4.b = c4.c[c4.b]);
        c4.e[e2] = b3;
        c4.c[e2] = d2;
        c4.d[d2] = e2;
        c4.h && va(c4, d2);
        return e2;
      }
      c4 = a2.a++;
      a2.c[c4] = b3;
      return -(c4 + 1);
    }
    function Fa(a2) {
      if (0 === a2.a) return Ka(a2.b);
      var b3 = a2.c[a2.d[a2.a - 1]];
      if (0 !== a2.b.a && u(Ga(a2.b), b3)) return Ka(a2.b);
      do
        --a2.a;
      while (0 < a2.a && null === a2.c[a2.d[a2.a - 1]]);
      return b3;
    }
    function Ha() {
      this.d = Ja([0], 33);
      this.e = [null, null];
      this.c = [0, 0];
      this.a = 0;
      this.f = 32;
      this.b = 0;
      this.h = false;
      this.d[1] = 1;
    }
    function Ja(a2, b3) {
      for (var c4 = Array(b3), d2 = 0; d2 < a2.length; d2++) c4[d2] = a2[d2];
      for (; d2 < b3; d2++) c4[d2] = 0;
      return c4;
    }
    function Ia(a2) {
      for (var b3 = a2.a; 1 <= b3; --b3) W2(a2, b3);
      a2.h = true;
    }
    function Ga(a2) {
      return a2.e[a2.d[1]];
    }
    function Ka(a2) {
      var b3 = a2.d, c4 = a2.e, d2 = a2.c, e2 = b3[1], f = c4[e2];
      0 < a2.a && (b3[1] = b3[a2.a], d2[b3[1]] = 1, c4[e2] = null, d2[e2] = a2.b, a2.b = e2, 0 < --a2.a && W2(a2, 1));
      return f;
    }
    function W2(a2, b3) {
      for (var c4 = a2.d, d2 = a2.e, e2 = a2.c, f = b3, g2 = c4[f]; ; ) {
        var h = f << 1;
        h < a2.a && u(d2[c4[h + 1]], d2[c4[h]]) && (h += 1);
        var k = c4[h];
        if (h > a2.a || u(d2[g2], d2[k])) {
          c4[f] = g2;
          e2[g2] = f;
          break;
        }
        c4[f] = k;
        e2[k] = f;
        f = h;
      }
    }
    function va(a2, b3) {
      for (var c4 = a2.d, d2 = a2.e, e2 = a2.c, f = b3, g2 = c4[f]; ; ) {
        var h = f >> 1, k = c4[h];
        if (0 === h || u(d2[k], d2[g2])) {
          c4[f] = g2;
          e2[g2] = f;
          break;
        }
        c4[f] = k;
        e2[k] = f;
        f = h;
      }
    }
    function ma() {
      this.e = this.a = null;
      this.f = 0;
      this.c = this.b = this.h = this.d = false;
    }
    function S2(a2) {
      return a2.e.c.b;
    }
    function R2(a2) {
      return a2.e.a.b;
    }
    exports.libtess = {
      GluTesselator: X2,
      windingRule: { GLU_TESS_WINDING_ODD: 100130, GLU_TESS_WINDING_NONZERO: 100131, GLU_TESS_WINDING_POSITIVE: 100132, GLU_TESS_WINDING_NEGATIVE: 100133, GLU_TESS_WINDING_ABS_GEQ_TWO: 100134 },
      primitiveType: { GL_LINE_LOOP: 2, GL_TRIANGLES: 4, GL_TRIANGLE_STRIP: 5, GL_TRIANGLE_FAN: 6 },
      errorType: { GLU_TESS_MISSING_BEGIN_POLYGON: 100151, GLU_TESS_MISSING_END_POLYGON: 100153, GLU_TESS_MISSING_BEGIN_CONTOUR: 100152, GLU_TESS_MISSING_END_CONTOUR: 100154, GLU_TESS_COORD_TOO_LARGE: 100155, GLU_TESS_NEED_COMBINE_CALLBACK: 100156 },
      gluEnum: { GLU_TESS_MESH: 100112, GLU_TESS_TOLERANCE: 100142, GLU_TESS_WINDING_RULE: 100140, GLU_TESS_BOUNDARY_ONLY: 100141, GLU_INVALID_ENUM: 100900, GLU_INVALID_VALUE: 100901, GLU_TESS_BEGIN: 100100, GLU_TESS_VERTEX: 100101, GLU_TESS_END: 100102, GLU_TESS_ERROR: 100103, GLU_TESS_EDGE_FLAG: 100104, GLU_TESS_COMBINE: 100105, GLU_TESS_BEGIN_DATA: 100106, GLU_TESS_VERTEX_DATA: 100107, GLU_TESS_END_DATA: 100108, GLU_TESS_ERROR_DATA: 100109, GLU_TESS_EDGE_FLAG_DATA: 100110, GLU_TESS_COMBINE_DATA: 100111 }
    };
    X2.prototype.gluDeleteTess = X2.prototype.x;
    X2.prototype.gluTessProperty = X2.prototype.B;
    X2.prototype.gluGetTessProperty = X2.prototype.y;
    X2.prototype.gluTessNormal = X2.prototype.A;
    X2.prototype.gluTessCallback = X2.prototype.z;
    X2.prototype.gluTessVertex = X2.prototype.C;
    X2.prototype.gluTessBeginPolygon = X2.prototype.u;
    X2.prototype.gluTessBeginContour = X2.prototype.t;
    X2.prototype.gluTessEndContour = X2.prototype.v;
    X2.prototype.gluTessEndPolygon = X2.prototype.w;
    if (typeof module !== "undefined") {
      module.exports = exports.libtess;
    }
  }
});

// node_modules/p5/translations/en/translation.json
var translation_default;
var init_translation = __esm({
  "node_modules/p5/translations/en/translation.json"() {
    translation_default = {
      fes: {
        autoplay: "The media that tried to play (with '{{src}}') wasn't allowed to by this browser, most likely due to the browser's autoplay policy.\n\n+ More info: {{url}}",
        checkUserDefinedFns: "It seems that you may have accidentally written {{name}} instead of {{actualName}}. Please correct it if it's not intentional.",
        fileLoadError: {
          bytes: "It looks like there was a problem loading your file. {{suggestion}}",
          font: "It looks like there was a problem loading your font. {{suggestion}}",
          gif: "There was some trouble loading your GIF. Make sure that your GIF is using 87a or 89a encoding.",
          image: "It looks like there was a problem loading your image. {{suggestion}}",
          json: "It looks like there was a problem loading your JSON file. {{suggestion}}",
          large: "If your large file isn't fetched successfully, we recommend splitting the file into smaller segments and fetching those.",
          strings: "It looks like there was a problem loading your text file. {{suggestion}}",
          suggestion: "Try checking if the file path ({{filePath}}) is correct, hosting the file online, or running a local server.\n\n+ More info: {{url}}",
          table: "It looks like there was a problem loading your table file. {{suggestion}}",
          xml: "It looks like there was a problem loading your XML file. {{suggestion}}"
        },
        friendlyParamError: {
          type_EMPTY_VAR: "{{location}} {{func}}() was expecting {{formatType}} for the {{position}} parameter, received an empty variable instead. If not intentional, this is often a problem with scope.\n\n+ More info: {{url}}",
          type_TOO_FEW_ARGUMENTS: "{{location}} {{func}}() was expecting at least {{minParams}} arguments, but received only {{argCount}}.",
          type_TOO_MANY_ARGUMENTS: "{{location}} {{func}}() was expecting no more than {{maxParams}} arguments, but received {{argCount}}.",
          type_WRONG_TYPE: "{{location}} {{func}}() was expecting {{formatType}} for the {{position}} parameter, received {{argType}} instead."
        },
        globalErrors: {
          reference: {
            cannotAccess: '\n{{location}} "{{symbol}}" is used before declaration. Make sure you have declared the variable before using it.\n\n+ More info: {{url}}',
            notDefined: '\n{{location}} "{{symbol}}" is not defined in the current scope. If you have defined it in your code, you should check its scope, spelling, and letter-casing (JavaScript is case-sensitive).\n\n+ More info: {{url}}'
          },
          stackSubseq: "└[{{location}}] \n	 Called from line {{line}} in {{func}}()\n",
          stackTop: "┌[{{location}}] \n	 Error at line {{line}} in {{func}}()\n",
          syntax: {
            badReturnOrYield: "\nSyntax Error - return lies outside of a function. Make sure you’re not missing any brackets, so that return lies inside a function.\n\n+ More info: {{url}}",
            invalidToken: "\nSyntax Error - Found a symbol that JavaScript doesn't recognize or didn't expect at it's place.\n\n+ More info: {{url}}",
            missingInitializer: "\nSyntax Error - A const variable is declared but not initialized. In JavaScript, an initializer for a const is required. A value must be specified in the same statement in which the variable is declared. Check the line number in the error and assign the const variable a value.\n\n+ More info: {{url}}",
            redeclaredVariable: `
Syntax Error - "{{symbol}}" is being redeclared. JavaScript doesn't allow declaring a variable more than once. Check the line number in error for redeclaration of the variable.

+ More info: {{url}}`,
            unexpectedToken: "\nSyntax Error - Symbol present at a place that wasn't expected.\nUsually this is due to a typo. Check the line number in the error for anything missing/extra.\n\n+ More info: {{url}}"
          },
          type: {
            constAssign: "\n{{location}} A const variable is being re-assigned. In javascript, re-assigning a value to a constant is not allowed. If you want to re-assign new values to a variable, make sure it is declared as var or let.\n\n+ More info: {{url}}",
            notfunc: '\n{{location}} "{{symbol}}" could not be called as a function.\nCheck the spelling, letter-casing (JavaScript is case-sensitive) and its type.\n\n+ More info: {{url}}',
            notfuncObj: '\n{{location}} "{{symbol}}" could not be called as a function.\nVerify whether "{{obj}}" has "{{symbol}}" in it and check the spelling, letter-casing (JavaScript is case-sensitive) and its type.\n\n+ More info: {{url}}',
            readFromNull: "\n{{location}} The property of null can't be read. In javascript the value null indicates that an object has no value.\n\n+ More info: {{url}}",
            readFromUndefined: "\n{{location}} Cannot read property of undefined. Check the line number in error and make sure the variable which is being operated is not undefined.\n\n + More info: {{url}}"
          }
        },
        libraryError: '{{location}} An error with message "{{error}}" occurred inside the p5js library when {{func}} was called. If not stated otherwise, it might be an issue with the arguments passed to {{func}}.',
        location: "[{{file}}, line {{line}}]",
        misspelling: '{{location}} It seems that you may have accidentally written "{{name}}" instead of "{{actualName}}". Please correct it to {{actualName}} if you wish to use the {{type}} from p5.js.',
        misspelling_plural: '{{location}} It seems that you may have accidentally written "{{name}}".\nYou may have meant one of the following: \n{{suggestions}}',
        misusedTopLevel: "Did you just try to use p5.js's {{symbolName}} {{symbolType}}? If so, you may want to move it into your sketch's setup() function.\n\n+ More info: {{url}}",
        preloadDisabled: "The preload() function has been removed in p5.js 2.0. Please load assets in setup() using async / await keywords or callbacks instead. See https://dev.to/limzykenneth/asynchronous-p5js-20-458f for more information.",
        positions: {
          p_1: "first",
          p_10: "tenth",
          p_11: "eleventh",
          p_12: "twelfth",
          p_2: "second",
          p_3: "third",
          p_4: "fourth",
          p_5: "fifth",
          p_6: "sixth",
          p_7: "seventh",
          p_8: "eighth",
          p_9: "ninth"
        },
        pre: "\n🌸 p5.js says: {{message}}",
        sketchReaderErrors: {
          reservedConst: 'you have used a p5.js reserved variable "{{symbol}}" make sure you change the variable name to something else.\n\n+ More info: {{url}}',
          reservedFunc: 'you have used a p5.js reserved function "{{symbol}}" make sure you change the function name to something else.\n\n+ More info: {{url}}'
        },
        welcome: "Welcome! This is your friendly debugger. To turn me off, switch to using p5.min.js.",
        wrongPreload: '{{location}} An error with message "{{error}}" occurred inside the p5js library when "{{func}}" was called. If not stated otherwise, it might be due to "{{func}}" being called from preload. Nothing besides load calls (loadImage, loadJSON, loadFont, loadStrings, etc.) should be inside the preload function.'
      }
    };
  }
});

// node_modules/p5/translations/es/translation.json
var translation_default2;
var init_translation2 = __esm({
  "node_modules/p5/translations/es/translation.json"() {
    translation_default2 = {
      fes: {
        autoplay: "Su browser impidío un medio tocar (de '{{src}}'), posiblemente porque las reglas de autoplay. Para aprender más, visite {{link}}.",
        checkUserDefinedFns: "",
        fileLoadError: {
          bytes: "",
          font: "",
          gif: "",
          image: "",
          json: "",
          large: "",
          strings: "",
          suggestion: "",
          table: "",
          xml: ""
        },
        friendlyParamError: {
          type_EMPTY_VAR: "",
          type_TOO_FEW_ARGUMENTS: "",
          type_TOO_MANY_ARGUMENTS: "",
          type_WRONG_TYPE: ""
        },
        globalErrors: {
          reference: {
            cannotAccess: "",
            notDefined: ""
          },
          stackSubseq: "",
          stackTop: "",
          syntax: {
            badReturnOrYield: "",
            invalidToken: "",
            missingInitializer: "",
            redeclaredVariable: "",
            unexpectedToken: ""
          },
          type: {
            constAssign: "",
            notfunc: "",
            notfuncObj: "",
            readFromNull: "",
            readFromUndefined: ""
          }
        },
        libraryError: "",
        location: "",
        misspelling: "",
        misspelling_plural: "",
        misusedTopLevel: "",
        positions: {
          p_1: "",
          p_10: "",
          p_11: "",
          p_12: "",
          p_2: "",
          p_3: "",
          p_4: "",
          p_5: "",
          p_6: "",
          p_7: "",
          p_8: "",
          p_9: ""
        },
        pre: "🌸 p5.js dice: {{message}}",
        sketchReaderErrors: {
          reservedConst: "",
          reservedFunc: ""
        },
        welcome: "",
        wrongPreload: ""
      }
    };
  }
});

// node_modules/p5/translations/ko/translation.json
var translation_default3;
var init_translation3 = __esm({
  "node_modules/p5/translations/ko/translation.json"() {
    translation_default3 = {
      fes: {
        autoplay: "미디어('{{src}}')가 이 브라우저에서는 재생되지 않았습니다. 사용하고 계신 브라우저의 자동 재생 정책 때문일 수 있습니다.\n\n+ 추가 정보: {{url}}",
        checkUserDefinedFns: "혹시 {{actualName}} 대신 {{name}}를 쓴 것이 아닌지 살펴보세요.",
        fileLoadError: {
          bytes: "파일을 로드하는 중에 문제가 발생했습니다. {{suggestion}}",
          font: "글꼴을 로드하는 중에 문제가 발생했습니다. {{suggestion}}",
          gif: "GIF 파일을 로드하는 중에 문제가 발생했습니다. GIF 파일의 인코딩 방식이 87a이거나 89a인지를 확인해보세요.",
          image: "이미지를 로드하는 중에 문제가 발생했습니다. {{suggestion}}",
          json: "JSON 파일을 로드하는 중에 문제가 발생했습니다. {{suggestion}}",
          large: "용량이 큰 파일을 한꺼번에 로드하는 중에 문제가 발생했습니다. 파일 용량을 줄여 보세요.",
          strings: "텍스트 파일을 로드하는 중에 문제가 발생했습니다. {{suggestion}}",
          suggestion: "파일 경로({{filePath}})가 올바른지 확인해보세요. 혹은 해당 파일을 호스팅 서비스를 이용하거나 로컬 서버를 구동하여 웹에 올리는 방법을 고려해 보세요.\n\n+ 추가 정보: {{url}}",
          table: "테이블 파일을 로드하는 중에 문제가 발생했습니다. {{suggestion}}",
          xml: "XML 파일을 로드하는 중에 문제가 발생했습니다. {{suggestion}}"
        },
        friendlyParamError: {
          type_EMPTY_VAR: "{{location}} {{formatType}} 타입 값을 받는 {{func}}()의 {{position}} 매개변수(parameter)에 아무 값도 전달되지 않았습니다. 범위(scope)와 관련된 문제일 수 있습니다.\n\n+ 추가 정보: {{url}}",
          type_TOO_FEW_ARGUMENTS: "{{location}} 최소 {{minParams}}개의 인수(argument)를 받는 함수 {{func}}()에 인수가 {{argCount}}개만 입력되었습니다.",
          type_TOO_MANY_ARGUMENTS: "{{location}} 최대 {{maxParams}}개의 인수(argument)를 받는 함수 {{func}}()에 인수가 {{argCount}}개나 입력되었습니다.",
          type_WRONG_TYPE: "{{location}} {{formatType}} 타입의 값을 받는 {{func}}()의 {{position}} 매개변수(parameter)에 {{argType}} 타입의 값이 입력되었습니다."
        },
        globalErrors: {
          reference: {
            cannotAccess: '\n{{location}} "{{symbol}}"가 선언되지 않은 채 사용되었습니다. 변수를 사용하기 전, 먼저 선언했는지 확인해보세요.\n\n+ 추가 정보: {{url}}',
            notDefined: '\n{{location}} "{{symbol}}"은 현재 범위(scope) 안에 정의되지 않았습니다. 만약 정의를 했다면, 해당 범위와 오탈자, 대소문자 등을 확인해보세요 (자바스크립트에서는 대소문자를 구분합니다).\n\n+ 추가 정보: {{url}}'
          },
          stackSubseq: "└[{{location}}] \n	 {{func}}()에 있는 줄{{line}}에서 호출\n",
          stackTop: "┌[{{location}}] \n	 {{func}}()에 있는 줄{{line}}에서 오류 발생\n",
          syntax: {
            badReturnOrYield: "\n구문 오류 - 대괄호가 제대로 쓰였는지 확인해 본 후, return을 함수 안에 넣어주세요.\n\n+ 추가 정보: {{url}}",
            invalidToken: "\n구문 오류 - 자바스크립트가 인식할 수 없거나, 적합하지 않은 기호나 문구가 입력되었습니다.\n\n+ 추가 정보: {{url}}",
            missingInitializer: "\n구문 오류 - const 변수가 선언되었지만 초기화되지 않았습니다. 변수가 선언된 명령문 안에서 값을 지정해주세요.\n\n+ 추가 정보: {{url}}",
            redeclaredVariable: '\n구문 오류 - 이미 선언된 "{{symbol}}"가 재선언되었습니다. 자바스크립트에서는 같은 변수를 한 번 이상 선언할 수 없습니다.\n\n+ 추가 정보: {{url}}',
            unexpectedToken: "\n구문 오류 - 입력된 문구가 예상하지 못한 위치에 있습니다.보통 이런 상황은 오탈자 때문에 일어나는 경우가 많습니다. 누락되거나 추가된 내용이 없는지 확인하세요.\n\n+ 추가 정보: {{url}}"
          },
          type: {
            constAssign: "\n{{location}} const 변수가 재지정되었습니다. 자바스크립트에서는 const 변수에 다른 값을 여러 번 지정할 수 없으므로 새로운 값을 여러 번 지정하시려면, const 대신 var나 let을 써서 변수를 선언해 주세요.\n\n+ 추가 정보: {{url}}",
            notfunc: '\n{{location}} "{{symbol}}"는 함수로 호출할 수 없습니다. 타입과 오탈자, 대소문자 등을 확인해주세요.\n\n+ 추가 정보: {{url}}',
            notfuncObj: '\n{{location}} "{{symbol}}"는 함수로 호출할 수 없습니다. "{{obj}}"가 "{{symbol}}"를 가지고 있는지 살펴보고, 타입과 오탈자, 대소문자 등을 확인해주세요.\n\n+ 추가 정보: {{url}}',
            readFromNull: "\n{{location}} null의 속성(property)을 읽을 수 없습니다. 자바스크립트에서 null이란, 객체(object)에 주어진 값이 비어있다는 뜻입니다.\n\n+ 추가 정보: {{url}}",
            readFromUndefined: "\n{{location}} undefined의 속성(property)을 읽을 수 없습니다. 혹시 연산 중인 변수가 정의되지 않았는지 확인하세요.\n\n+ 추가 정보: {{url}}"
          }
        },
        libraryError: '{{location}} 함수 {{func}}가 호출되었을 때,  "{{error}}" 오류가 p5js 라이브러리 내에서 발생했습니다. 함수 {{func}}에 전달한 인수(argument)가 문제일 수 있습니다.',
        location: "[{{file}}, 줄{{line}}]",
        misspelling: '{{location}} 혹시 p5.js의 {{type}}를 사용하시려면 "{{name}}"를 {{actualName}}로 고쳐 보세요.',
        misspelling_plural: '{{location}} 혹시 p5.js의 {{type}}를 사용하시려면 "{{name}}"를 다음 중 하나로 고쳐보세요: \n{{suggestions}}',
        misusedTopLevel: "{{location}} 혹시 p5.js의 {{symbolType}} 타입 {{symbolName}}을 사용하셨나요? 그렇다면 {{symbolName}}을 작성 중인 setup() 함수의 대괄호 안으로 옮겨보세요.\n\n+ 추가 정보: {{url}}",
        positions: {
          p_1: "1번째",
          p_10: "10번째",
          p_11: "11번째",
          p_12: "12번째",
          p_2: "2번째",
          p_3: "3번째",
          p_4: "4번째",
          p_5: "5번째",
          p_6: "6번째",
          p_7: "7번째",
          p_8: "8번째",
          p_9: "9번째"
        },
        pre: "\n🌸 p5.js says: {{message}}",
        sketchReaderErrors: {
          reservedConst: 'p5.js에서 이미 쓰고 있는 변수 "{{symbol}}"를 사용하셨습니다. 해당 변수를 다른 이름으로 바꾸어 주세요.\n\n+ 추가 정보: {{url}}',
          reservedFunc: 'p5.js에서 이미 쓰고 있는 함수 "{{symbol}}"를 사용하셨습니다. 해당 함수를 다른 이름으로 바꾸어 주세요.\n\n+ 추가 정보: {{url}}'
        },
        welcome: "{{logo}} 환영합니다, 이 메세지는 에러를 찾는 디버깅 안내문입니다. 안내가 필요없는 경우 p5.js대신 p5.min.js를 사용하세요.",
        wrongPreload: '{{location}} "{{func}}"가 호출되며 p5js 라이브러리 내부에서 다음 오류가 발생했습니다: "{{error}}".\n\n 함수 "{{func}}"가 preload()에서 호출되었기 때문일 수 있습니다. preload() 함수 안에서는 지정된 함수(예: loadImage, loadJSON, loadFont, loadStrings 등)만 호출할 수 있습니다.'
      }
    };
  }
});

// node_modules/p5/translations/zh/translation.json
var translation_default4;
var init_translation4 = __esm({
  "node_modules/p5/translations/zh/translation.json"() {
    translation_default4 = {
      fes: {
        autoplay: "尝试播放（使用'{{src}}'）的媒体在此浏览器中被禁止，很可能是由于浏览器的自动播放策略。\n\n+ 更多信息：{{url}}",
        checkUserDefinedFns: "看起来您可能在{{name}}处意外写错了，应该是{{actualName}}。如果这不是故意的，请进行更正。",
        fileLoadError: {
          bytes: "似乎在加载文件时出现了问题。{{suggestion}}",
          font: "似乎在加载字体时出现了问题。{{suggestion}}",
          gif: "加载GIF时出现了问题。请确保您的GIF使用87a或89a编码。",
          image: "似乎在加载图像时出现了问题。{{suggestion}}",
          json: "似乎在加载JSON文件时出现了问题。{{suggestion}}",
          large: "如果您无法成功获取大型文件，我们建议将文件分割成较小的段并获取这些段。",
          strings: "似乎在加载文本文件时出现了问题。{{suggestion}}",
          suggestion: "尝试检查文件路径（{{filePath}}）是否正确，将文件托管在线上或运行本地服务器。\n\n+ 更多信息：{{url}}",
          table: "似乎在加载表格文件时出现了问题。{{suggestion}}",
          xml: "似乎在加载XML文件时出现了问题。{{suggestion}}"
        },
        friendlyParamError: {
          type_EMPTY_VAR: "{{location}} {{func}}() 期望的是{{formatType}}类型的{{position}}参数，而接收到了一个空变量。如果这不是故意的，通常是作用域的问题。\n\n+ 更多信息：{{url}}",
          type_TOO_FEW_ARGUMENTS: "{{location}} {{func}}() 期望至少{{minParams}}个参数，但只收到了{{argCount}}个。",
          type_TOO_MANY_ARGUMENTS: "{{location}} {{func}}() 期望最多{{maxParams}}个参数，但收到了{{argCount}}个。",
          type_WRONG_TYPE: "{{location}} {{func}}() 期望的是{{formatType}}类型的{{position}}参数，而接收到了{{argType}}类型。"
        },
        globalErrors: {
          reference: {
            cannotAccess: '\n{{location}} 在声明之前使用了"{{symbol}}"。请确保在使用之前已经声明了该变量。\n\n+ 更多信息：{{url}}',
            notDefined: '\n{{location}} 在当前范围中未定义"{{symbol}}"。如果您已经在代码中定义了它，请检查其作用域、拼写和大小写（JavaScript区分大小写）。\n\n+ 更多信息：{{url}}'
          },
          stackSubseq: "└[{{location}}] \n	 在{{func}}()中的第{{line}}行调用\n",
          stackTop: "┌[{{location}}] \n	 在{{func}}()的第{{line}}行出现错误\n",
          syntax: {
            badReturnOrYield: "\n语法错误 - return位于函数外部。请确保没有漏掉任何括号，以便return位于函数内部。\n\n+ 更多信息：{{url}}",
            invalidToken: "\n语法错误 - 发现了JavaScript不识别或不期望的符号。\n\n+ 更多信息：{{url}}",
            missingInitializer: "\n语法错误 - 声明了一个const变量但没有初始化。在JavaScript中，const必须要有初始值。在同一语句中必须指定值来声明变量。请检查错误中的行号并给const变量赋值。\n\n+ 更多信息：{{url}}",
            redeclaredVariable: '\n语法错误 - "{{symbol}}" 正在被重新声明。JavaScript不允许重复声明变量。请检查错误中的行号是否重新声明了该变量。\n\n+ 更多信息：{{url}}',
            unexpectedToken: "\n语法错误 - 符号出现在不应该出现的位置。\n通常这是由于拼写错误。请检查错误中的行号是否有缺少或多余的内容。\n\n+ 更多信息：{{url}}"
          },
          type: {
            constAssign: "\n{{location}} 正在重新赋值const变量。在JavaScript中，不允许对常量进行重新赋值。如果要给变量重新赋值，请确保声明为var或let。\n\n+ 更多信息：{{url}}",
            notfunc: '\n{{location}} 无法将"{{symbol}}" 调用为函数。\n请检查拼写、大小写（JavaScript区分大小写）和其类型。\n\n+ 更多信息：{{url}}',
            notfuncObj: '\n{{location}} 无法将"{{symbol}}" 调用为函数。\n请验证"{{obj}}"是否包含"{{symbol}}"，并检查拼写、大小写（JavaScript区分大小写）和其类型。\n\n+ 更多信息：{{url}}',
            readFromNull: "\n{{location}} 无法读取null的属性。在JavaScript中，null表示对象没有值。\n\n+ 更多信息：{{url}}",
            readFromUndefined: "\n{{location}} 无法读取undefined的属性。请检查错误中的行号并确保正在操作的变量不是undefined。\n\n+ 更多信息：{{url}}"
          }
        },
        libraryError: '{{location}} 在调用{{func}}时，在p5js库内部出现了一条错误消息"{{error}}"。除非另有说明，否则可能是与传递给{{func}}的参数有关的问题。',
        location: "[{{file}}，第{{line}}行]",
        misspelling: '{{location}} 看起来您可能在{{name}}处意外写错了，应该是"{{actualName}}"。如果希望使用p5.js中的{{type}}，请将其更正为{{actualName}}。',
        misspelling_plural: "{{location}} 看起来您可能在{{name}}处意外写错了。\n您可能指的是以下之一：\n{{suggestions}}",
        misusedTopLevel: "您刚刚尝试使用了p5.js的{{symbolType}} {{symbolName}}吗？如果是，请将其移到您的sketch的setup()函数中。\n\n+ 更多信息：{{url}}",
        positions: {
          p_1: "第一",
          p_10: "第十",
          p_11: "第十一",
          p_12: "第十二",
          p_2: "第二",
          p_3: "第三",
          p_4: "第四",
          p_5: "第五",
          p_6: "第六",
          p_7: "第七",
          p_8: "第八",
          p_9: "第九"
        },
        pre: "\n🌸 p5.js 说：{{message}}",
        sketchReaderErrors: {
          reservedConst: '您使用了p5.js的保留变量"{{symbol}}"，请确保将变量名更改为其他名称。\n\n+ 更多信息：{{url}}',
          reservedFunc: '您使用了p5.js的保留函数"{{symbol}}"，请确保将函数名更改为其他名称。\n\n+ 更多信息：{{url}}'
        },
        welcome: "欢迎！这是您友好的调试程序。要关闭我，请切换到使用p5.min.js。",
        wrongPreload: '{{location}} 在调用"{{func}}"时，在p5js库内部出现了一条错误消息"{{error}}"。除非另有说明，否则可能是由于在preload中调用了"{{func}}"。preload函数之外不应该包含除load函数（loadImage、loadJSON、loadFont、loadStrings等）以外的内容。'
      }
    };
  }
});

// node_modules/p5/translations/hi/translation.json
var translation_default5;
var init_translation5 = __esm({
  "node_modules/p5/translations/hi/translation.json"() {
    translation_default5 = {
      fes: {
        autoplay: "जिस मीडिया को चलाने की कोशिश की गई ('{{src}}' के साथ) उसे इस ब्राउज़र द्वारा अनुमति नहीं दी गई, संभवतः ब्राउज़र की स्वत: प्ले नीति के कारण।\n\n+ अधिक जानकारी: {{url}}",
        checkUserDefinedFns: "ऐसा लगता है कि आपने गलती से {{actualName}} की जगह {{name}} लिख दिया है। यदि यह जानबूझकर नहीं किया गया है तो कृपया इसे सुधारें।",
        fileLoadError: {
          bytes: "ऐसा लगता है कि आपकी फ़ाइल लोड करने में कोई समस्या थी। {{suggestion}}",
          font: "ऐसा लगता है कि आपका मुद्रलिपि लोड करने में कोई समस्या थी। {{suggestion}}",
          gif: "आपकी GIF लोड करने में कुछ समस्या हुई। सुनिश्चित करें कि आपका GIF 87a या 89a एन्कोडिंग का उपयोग कर रहा है।",
          image: "ऐसा लगता है कि आपकी छवि लोड करने में कोई समस्या थी। {{suggestion}}",
          json: "ऐसा लगता है कि आपकी JSON फ़ाइल लोड करने में कोई समस्या थी। {{suggestion}}",
          large: "यदि आपकी बड़ी फ़ाइल सफलतापूर्वक नहीं लाई गई है, तो हम फ़ाइल को छोटे खंडों में विभाजित करने और उन्हें लाने की सलाह देते हैं।",
          strings: "ऐसा लगता है कि आपकी पाठ फ़ाइल लोड करने में कोई समस्या थी। {{suggestion}}",
          suggestion: "यह जाँचने का प्रयास करें कि फ़ाइल पथ ({{filePath}}) सही है या नहीं, फ़ाइल को ऑनलाइन होस्ट करना, या स्थानीय सर्वर चलाना।\n\n+ अधिक जानकारी: {{url}}",
          table: "ऐसा लगता है कि आपकी तालिका फ़ाइल लोड करने में कोई समस्या थी। {{suggestion}}",
          xml: "ऐसा लगता है कि आपकी XML फ़ाइल लोड करने में कोई समस्या थी। {{suggestion}}"
        },
        friendlyParamError: {
          type_EMPTY_VAR: "{{location}} {{func}}() {{position}} प्राचल के लिए {{formatType}} की अपेक्षा कर रहा था, इसके बजाय एक खाली चर प्राप्त हुआ। यदि जानबूझकर नहीं किया गया है, तो यह अक्सर दायरे के साथ एक समस्या है।\n\n+ अधिक जानकारी:{{url}}",
          type_TOO_FEW_ARGUMENTS: "{{location}} {{func}}() कम से कम {{minParams}} तर्कों की अपेक्षा थी, लेकिन केवल प्राप्त हुए {{argCount}}.",
          type_TOO_MANY_ARGUMENTS: "{{location}} {{func}}() {{maxParams}} से अधिक तर्कों की अपेक्षा नहीं कर रहा था, लेकिन प्राप्त हुआ {{argCount}}.",
          type_WRONG_TYPE: "{{location}} {{func}}() {{position}} प्राचल के लिए {{formatType}} की अपेक्षा कर रहा था, इसके बजाय {{argType}} प्राप्त हुआ।"
        },
        globalErrors: {
          reference: {
            cannotAccess: '\n{{location}} "{{symbol}}" घोषणा से पहले प्रयोग किया जाता है। सुनिश्चित करें कि आपने चर का उपयोग करने से पहले उसे घोषित कर दिया है।\n\n+ अधिक जानकारी: {{url}}',
            notDefined: '\n{{location}} "{{symbol}}" वर्तमान दायरे में परिभाषित नहीं है। यदि आपने इसे अपने कोड में परिभाषित किया है, तो आपको इसका दायरा, वर्तनी और अक्षर-आवरण जांचना चाहिए (JavaScript केस-संवेदी है)।\n\n+ अधिक जानकारी: {{url}}'
          },
          stackSubseq: "└[{{location}}] \n	 {{func}}() में पंक्ति {{line}} से आह्वान किया गया\n",
          stackTop: "┌[{{location}}] \n	 {{func}}() में पंक्ति {{line}} पर त्रुटि\n",
          syntax: {
            badReturnOrYield: "\nवाक्य - विन्यास त्रुटि - रिटर्न किसी फ़ंक्शन के बाहर होता है। सुनिश्चित करें कि आपसे कोई कोष्ठक नहीं छूट रहा है, ताकि रिटर्न किसी फ़ंक्शन के अंदर हो।\n\n+ अधिक जानकारी: {{url}}",
            invalidToken: "\nवाक्य - विन्यास त्रुटि - एक ऐसा प्रतीक मिला जिसे जावास्क्रिप्ट नहीं पहचानता या अपने स्थान पर अपेक्षित नहीं था।\n\n+ अधिक जानकारी: {{url}}",
            missingInitializer: "\nवाक्य - विन्यास त्रुटि - एक नियत चर घोषित किया गया है लेकिन प्रारंभ नहीं किया गया है। जावास्क्रिप्ट में, एक नियत के लिए प्रारंभकर्ता की आवश्यकता होती है। एक मान उसी कथन में निर्दिष्ट किया जाना चाहिए जिसमें चर घोषित किया गया है। त्रुटि में पंक्ति संख्या की जाँच करें और स्थिरांक चर को एक मान निर्दिष्ट करें।\n\n+ अधिक जानकारी: {{url}}",
            redeclaredVariable: '\nवाक्य - विन्यास त्रुटि - "{{symbol}}" पुनः घोषित किया जा रहा है। जावास्क्रिप्ट एक चर को एक से अधिक बार घोषित करने की अनुमति नहीं देता है। चर की पुनः घोषणा के लिए त्रुटि वाली पंक्ति संख्या की जाँच करें।\n\n+ अधिक जानकारी: {{url}}',
            unexpectedToken: "\nवाक्य - विन्यास त्रुटि - प्रतीक ऐसे स्थान पर मौजूद है जिसकी अपेक्षा नहीं थी।\nआम तौर पर यह टंकण त्रुटि के कारण होता है। किसी भी गुम/अतिरिक्त चीज़ के लिए त्रुटि में पंक्ति नंबर की जाँच करें।\n\n+ अधिक जानकारी: {{url}}"
          },
          type: {
            constAssign: "\n{{location}} एक नियत चर को फिर से असाइन किया जा रहा है। जावास्क्रिप्ट में, किसी स्थिरांक को दोबारा मान निर्दिष्ट करने की अनुमति नहीं है। यदि आप किसी चर के लिए नए मान पुनः निर्दिष्ट करना चाहते हैं, तो सुनिश्चित करें कि इसे var या Let के रूप में घोषित किया गया है।\n\n+ अधिक जानकारी: {{url}}",
            notfunc: '\n{{location}} "{{symbol}}" फ़ंक्शन के रूप में नहीं बुलाया जा सका।\nवर्तनी, अक्षर-आवरण (जावास्क्रिप्ट केस-संवेदी है) और उसके प्रकार की जाँच करें।\n\n+ अधिक जानकारी: {{url}}',
            notfuncObj: '\n{{location}} "{{symbol}}" फ़ंक्शन के रूप में नहीं बुलाया जा सका।\nसत्यापित करें कि क्या "{{obj}}" में "{{symbol}}" है और वर्तनी, अक्षर-आवरण (जावास्क्रिप्ट केस-संवेदी है) और उसके प्रकार की जांच करें।\n\n+ अधिक जानकारी: {{url}}',
            readFromNull: "\n{{location}} null की संपत्ति को पढ़ा नहीं जा सकता. जावास्क्रिप्ट में मान null इंगित करता है कि किसी ऑब्जेक्ट का कोई मूल्य नहीं है।\n\n+ अधिक जानकारी: {{url}}",
            readFromUndefined: "\n{{location}} undefined की संपत्ति नहीं पढ़ सकता. त्रुटि वाली पंक्ति संख्या की जाँच करें और सुनिश्चित करें कि जो चर संचालित किया जा रहा है वह अपरिभाषित नहीं है।\n\n + अधिक जानकारी: {{url}}"
          }
        },
        libraryError: '{{location}} जब {{func}} को आह्वान किया गया तो p5js लाइब्रेरी के अंदर "{{error}}" संदेश के साथ एक त्रुटि उत्पन्न हुई। यदि अन्यथा नहीं कहा गया है, तो यह {{func}} को दिए गए तर्कों के साथ एक समस्या हो सकती है।',
        location: "[{{file}}, पंक्ति {{line}}]",
        misspelling: '{{location}} ऐसा लगता है कि आपने गलती से "{{actualName}}" के स्थान पर "{{name}}" लिख दिया होगा। यदि आप p5.js से {{type}} का उपयोग करना चाहते हैं तो कृपया इसे सही करके {{actualName}} कर दें।',
        misspelling_plural: '{{location}} ऐसा लगता है कि आपने गलती से "{{name}}" लिख दिया होगा।\nआपका मतलब निम्नलिखित में से कोई एक हो सकता है: \n{{suggestions}}',
        misusedTopLevel: "क्या आपने अभी p5.js के {{symbolName}} {{symbolType}} का उपयोग करने का प्रयास किया? यदि ऐसा है, तो आप इसे अपने रेखा-चित्र के setup() फ़ंक्शन में ले जाना चाह सकते हैं।\n\n+ अधिक जानकारी: {{url}}",
        positions: {
          p_1: "पहला",
          p_10: "दसवां",
          p_11: "ग्यारहवें",
          p_12: "बारहवें",
          p_2: "दूसरा",
          p_3: "तीसरा",
          p_4: "चौथी",
          p_5: "पांचवां",
          p_6: "छठा",
          p_7: "सातवीं",
          p_8: "आठवाँ",
          p_9: "नौवां"
        },
        pre: "\n🌸 p5.js कहता है: {{message}}",
        sketchReaderErrors: {
          reservedConst: 'आपने एक p5.js आरक्षित चर "{{symbol}}" का उपयोग किया है, सुनिश्चित करें कि आपने चर नाम को किसी और चीज़ में बदल दिया है।\n\n+ अधिक जानकारी: {{url}}',
          reservedFunc: 'आपने एक p5.js आरक्षित फ़ंक्शन "{{symbol}}" का उपयोग किया है, सुनिश्चित करें कि आपने फ़ंक्शन का नाम किसी और चीज़ में बदल दिया है।\n\n+ अधिक जानकारी: {{url}}'
        },
        welcome: "स्वागत! यह आपका मित्रवत डिबगर है. मुझे बंद करने के लिए, p5.min.js का उपयोग करें।",
        wrongPreload: '{{location}} जब "{{func}}" को आह्वान किया गया तो p5js लाइब्रेरी के अंदर "{{error}}" संदेश के साथ एक त्रुटि उत्पन्न हुई। यदि अन्यथा नहीं कहा गया है, तो यह "{{func}}" को प्रीलोड से आह्वान किए जाने के कारण हो सकता है। प्रीलोड फ़ंक्शन के अंदर लोड आह्वान (लोडछवि, लोडजेएसओएन, लोडमुद्रलिपि, लोडस्ट्रिंग्स इत्यादि) के अलावा कुछ भी नहीं होना चाहिए।'
      }
    };
  }
});

// node_modules/p5/translations/ja/translation.json
var translation_default6;
var init_translation6 = __esm({
  "node_modules/p5/translations/ja/translation.json"() {
    translation_default6 = {
      fes: {
        autoplay: "再生しようとしたメディア({{src}})は、ブラウザから許可されませんでした。おそらくはブラウザの自動再生ポリシーによるものです。\n\n+ 詳細情報: {{url}}",
        checkUserDefinedFns: "{{actualName}} ではなく、誤って {{name}} と書いてしまったようです。これが意図的でなければ修正してください。",
        fileLoadError: {
          bytes: "ファイルをロードする際に問題が発生したようです。 {{suggestion}}",
          font: "フォントをロードする際に問題が発生したようです。 {{suggestion}}",
          gif: "GIFをロードする際に問題が発生しました。GIFのエンコーディングが 87a または 89a であることを確認してください。",
          image: "画像をロードする際に問題が発生したようです。 {{suggestion}}",
          json: "JSONファイルをロードする際に問題が発生したようです。 {{suggestion}}",
          large: "大きなファイルを正常に取得できない場合は、ファイルをより小さなセグメントに分割して、それらを取得することをおすすめします。",
          strings: "テキストファイルをロードする際に問題が発生したようです。 {{suggestion}}",
          suggestion: "まずはファイルパス({{filePath}})が正しいかを確認し、次にファイルがオンラインでホストされているか、ローカルサーバーを実行しているかを確認してみてください。\n\n+ 詳細情報: {{url}}",
          table: "テーブルファイルをロードする際に問題が発生したようです。 {{suggestion}}",
          xml: "XMLファイルをロードする際に問題が発生したようです。 {{suggestion}}"
        },
        friendlyParamError: {
          type_EMPTY_VAR: "{{location}} {{func}}()は{{position}}引数に {{formatType}} を期待していましたが、空の変数を受け取りました。これが意図的でなければ、通常はスコープの問題です。\n\n+ 詳細情報: {{url}}",
          type_TOO_FEW_ARGUMENTS: "{{location}} {{func}}()は少なくとも{{minParams}}個の引数を期待していましたが、{{argCount}}個しか受け取っていません。",
          type_TOO_MANY_ARGUMENTS: "{{location}} {{func}}()は最大{{maxParams}}個の引数を期待していますが、{{argCount}}個を受け取りました。",
          type_WRONG_TYPE: "{{location}} {{func}}()は{{position}}引数に {{formatType}}タイプを期待していましたが、{{argType}}タイプを受け取りました。"
        },
        globalErrors: {
          reference: {
            cannotAccess: '\n{{location}} "{{symbol}}" が宣言前に使用されています。変数を使用する前に必ず宣言してください。\n\n+ 詳細情報：: {{url}}',
            notDefined: '\n{{location}} "{{symbol}}" が現在のスコープに定義されていません。コード内で定義している場合は、そのスコープ、スペル、大文字と小文字(JavaScriptは大文字と小文字を区別します)を確認してください。\n\n+ 詳細情報： {{url}}'
          },
          stackSubseq: "└[{{location}}] \n	 {{line}}行目( {{func}}()内 )から呼び出されました\n",
          stackTop: "┌[{{location}}] \n	 {{line}}行目( {{func}}()内 )でエラーが発生しました\n",
          syntax: {
            badReturnOrYield: "\n構文エラー - returnが関数外で使用されています。括弧を忘れずに、returnが関数内で使用されていることを確認してください。\n\n+ 詳細情報: {{url}}",
            invalidToken: "\n構文エラー - JavaScriptが認識しないか、期待していないシンボルが見つかりました。\n\n+ 詳細情報: {{url}}",
            missingInitializer: "\n構文エラー - 定数が宣言されていますが初期化されていません。JavaScriptでは const には初期値が必要です。変数を宣言する際に同じ文内で値を指定する必要があります。エラーの行番号を確認して定数に値を割り当ててください。\n\n+ 詳細情報: {{url}}",
            redeclaredVariable: '\n構文エラー - "{{symbol}}" が再宣言されています。JavaScriptでは変数を再宣言することはできません。エラーの行番号でその変数が再宣言されていないか確認してください。\n\n+ 詳細情報: {{url}}',
            unexpectedToken: "\n構文エラー - 予期しない場所にシンボルがあります。\n通常はタイプミスが原因です。エラー内の行番号を確認し、不足や余分なものがないか確認してください。\n\n+ 詳細情報: {{url}}"
          },
          type: {
            constAssign: "\n{{location}} 定数に再代入しています。JavaScriptでは定数に対する再代入は許可されていません。変数に再代入したい場合は、 var または let で宣言してください。\n\n+ 詳細情報: {{url}}",
            notfunc: '\n{{location}} "{{symbol}}" を関数として呼び出すことができません。\nスペル、大文字と小文字(JavaScriptは大文字と小文字を区別します)、そのタイプを確認してください。\n\n+ 詳細情報: {{url}}',
            notfuncObj: '\n{{location}} "{{symbol}}" を関数として呼び出すことができません。\n{{obj}} の中に "{{symbol}}" があるかどうか、スペル、大文字と小文字(JavaScriptは大文字と小文字を区別します)、およびそのタイプを確認してください。\n\n+ 詳細情報: {{url}}',
            readFromNull: "\n{{location}} null のプロパティを読み取ることができません。JavaScriptでは、null はオブジェクトが値を持たないことを意味します。\n\n+ 詳細情報: {{url}}",
            readFromUndefined: "\n{{location}} undefined のプロパティを読み取ることができません。エラーの行番号を確認し、操作しようとしている変数が undefined でないことを確認してください。\n\n+ 詳細情報: {{url}}"
          }
        },
        libraryError: '{{location}} {{func}} を呼び出した際に、p5jsライブラリ内でメッセージ "{{error}}" のエラーが発生しました。特に記述がなければ、 {{func}} に渡された引数に関する問題があることが多いです。',
        location: "[{{file}}, {{line}}行目]",
        misspelling: '{{location}} "{{actualName}}" ではなく、誤って "{{name}}" と書いてしまったようです。p5.js内の {{type}} を使用したい場合は、 {{actualName}} に修正してください。',
        misspelling_plural: '{{location}} もしかすると誤って "{{name}}" と書いているかもしれません。\n以下のいずれかの候補があります: \n{{suggestions}}',
        misusedTopLevel: "p5.jsの {{symbolType}} {{symbolName}} を使用しようとしましたか？もしそうなら、それをスケッチの setup()関数内に移動させてください。\n\n+ 詳細情報: {{url}}",
        positions: {
          p_1: "第1",
          p_10: "第10",
          p_11: "第11",
          p_12: "第12",
          p_2: "第2",
          p_3: "第3",
          p_4: "第4",
          p_5: "第5",
          p_6: "第6",
          p_7: "第7",
          p_8: "第8",
          p_9: "第9"
        },
        pre: "\n🌸 p5.jsが言っています: {{message}}",
        sketchReaderErrors: {
          reservedConst: 'p5.jsの予約済み変数 "{{symbol}}" を使用しました。変数名を他の名前に変更してください。\n\n+ 詳細情報: {{url}}',
          reservedFunc: 'p5.jsの予約済み関数 "{{symbol}}" を使用しました。関数名を他の名前に変更してください。\n\n+ 詳細情報: {{url}}'
        },
        welcome: "ようこそ！これはあなたのフレンドリーなデバッガーです。オフにするには、p5.min.jsに切り替えてください。",
        wrongPreload: '{{location}} p5.jsライブラリ内部で "{{error}}" というメッセージのエラーが発生しました。特に記載がない場合、preloadから "{{func}}" が呼び出されたことが原因かもしれません。load呼び出し(loadImage、loadJSON、loadFont、loadStringsなど)以外のものは、preload関数の中に入れてはなりません。'
      }
    };
  }
});

// node_modules/p5/translations/dev.js
var dev_exports = {};
__export(dev_exports, {
  en_translation: () => translation_default,
  es_translation: () => translation_default2,
  hi_translation: () => translation_default5,
  ja_translation: () => translation_default6,
  ko_translation: () => translation_default3,
  zh_translation: () => translation_default4
});
var init_dev = __esm({
  "node_modules/p5/translations/dev.js"() {
    init_translation();
    init_translation2();
    init_translation3();
    init_translation4();
    init_translation5();
    init_translation6();
  }
});

// node_modules/@japont/unicode-range/lib/index.js
var require_lib = __commonJS({
  "node_modules/@japont/unicode-range/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var UnicodeRange2 = (
      /** @class */
      function() {
        function UnicodeRange3() {
        }
        UnicodeRange3.parse = function(arr2) {
          var result = /* @__PURE__ */ new Set();
          for (var _i = 0, arr_1 = arr2; _i < arr_1.length; _i++) {
            var range2 = arr_1[_i];
            if (!UnicodeRange3.REGEXP.test(range2)) {
              throw new TypeError('"' + range2 + '" is invalid unicode-range.');
            }
            var _a2 = range2.match(UnicodeRange3.REGEXP), single = _a2[1], start = _a2[2], end = _a2[3];
            if (single) {
              if (/\?[^?]+$/.test(single)) {
                throw new TypeError('"' + range2 + '" is invalid unicode-range.');
              }
              if (single.includes("?")) {
                var start_1 = single.replace(/\?/g, "0");
                var end_1 = single.replace(/\?/g, "F");
                var tmp = UnicodeRange3.parse(["U+" + start_1 + "-" + end_1]);
                for (var _b2 = 0, tmp_1 = tmp; _b2 < tmp_1.length; _b2++) {
                  var codePoint = tmp_1[_b2];
                  result.add(codePoint);
                }
              } else {
                result.add(parseInt(single, 16));
              }
            }
            if (start && end) {
              var startCodePoint = parseInt(start, 16);
              var endCodePoint = parseInt(end, 16);
              for (var codePoint = startCodePoint; codePoint <= endCodePoint; codePoint++) {
                result.add(codePoint);
              }
            }
          }
          return Array.from(result).sort(function(a2, b3) {
            return a2 - b3;
          });
        };
        UnicodeRange3.stringify = function(arr2) {
          var sorted = Array.from(new Set(arr2)).sort(function(a2, b3) {
            return a2 - b3;
          });
          var results = [];
          var rangeStart;
          for (var idx = 0; idx < sorted.length; idx++) {
            var current2 = sorted[idx];
            var prev = sorted[idx - 1];
            if (rangeStart && current2 - prev !== 1) {
              results.push(UnicodeRange3.rangeString(rangeStart, prev));
              rangeStart = current2;
            }
            if (!rangeStart) {
              rangeStart = current2;
            }
            if (idx === sorted.length - 1) {
              if (rangeStart === current2) {
                results.push(UnicodeRange3.rangeString(current2));
              } else {
                results.push(UnicodeRange3.rangeString(rangeStart, current2));
              }
            }
          }
          return results;
        };
        UnicodeRange3.rangeString = function(start, end) {
          if (!end || start === end) {
            return "U+" + start.toString(16);
          }
          return "U+" + start.toString(16) + "-" + end.toString(16);
        };
        UnicodeRange3.REGEXP = /^u\+(?:([0-9a-f]?[0-9a-f?]{1,5})|([0-9a-f]{1,6})-([0-9a-f]{1,6}))?$/i;
        return UnicodeRange3;
      }()
    );
    exports.UnicodeRange = UnicodeRange2;
  }
});

// node_modules/@davepagurek/bezier-path/build/bezier-path.js
var require_bezier_path = __commonJS({
  "node_modules/@davepagurek/bezier-path/build/bezier-path.js"(exports, module) {
    !function(t, e2) {
      "object" == typeof exports && "object" == typeof module ? module.exports = e2() : "function" == typeof define && define.amd ? define([], e2) : "object" == typeof exports ? exports.BezierPath = e2() : t.BezierPath = e2();
    }(self, () => (() => {
      "use strict";
      var t = { 177: (t2, e3, s) => {
        Object.defineProperty(e3, "__esModule", { value: true }), e3.BezierPath = void 0;
        const i = s(558), h = s(188);
        e3.BezierPath = class {
          constructor(t3) {
            this.samples = [], this.segments = t3;
            const e4 = t3.map((t4) => t4.getTotalLength()), s2 = [0];
            for (let t4 = 1; t4 < e4.length; t4++) s2.push(s2[t4 - 1] + e4[t4 - 1]);
            this._totalLength = s2[s2.length - 1] + e4[e4.length - 1];
            const a2 = t3.map((t4) => Math.max(4, Math.ceil(t4.getTotalLength() / i.BezierSegment.sampleSpacing()))), n3 = a2.reduce((t4, e5) => t4 + e5), r = 1 / n3 / 10, o = this._totalLength / n3;
            this.samples.push({ dist: 0, pt: this.segments[0].A, tan: this.segments[0].tangentAtParameter(0), segIdx: 0, t: 0 }), t3.forEach((t4, e5) => {
              const i2 = a2[e5], n4 = (0, h.times)(i2 + 1).map((t5) => t5 / i2), x = n4.map((e6) => t4.pointAtParameter(e6));
              let y;
              for (let e6 = 0; e6 < 4; e6++) {
                y = (0, h.times)(i2).map((t5) => Math.hypot(x[t5 + 1].x - x[t5].x, x[t5 + 1].y - x[t5].y));
                const e7 = y.map((t5) => t5 - o);
                let s3 = 0;
                for (let i3 = 1; i3 < n4.length - 1; i3++) s3 += e7[i3 - 1], n4[i3] -= r * s3, x[i3] = t4.pointAtParameter(n4[i3]);
              }
              let p2 = 0;
              x.slice(1).forEach((t5, i3) => {
                p2 += y[i3], this.samples.push({ dist: s2[e5] + p2, pt: t5, tan: this.segments[e5].tangentAtParameter(n4[i3 + 1]), segIdx: e5, t: n4[i3 + 1] });
              });
            }), this._jumps = [], this.segmentStartEnds = [{ start: 0, end: 0 }];
            for (let t4 = 1; t4 < this.samples.length; t4++) {
              const e5 = this.samples[t4 - 1], s3 = this.samples[t4];
              if (s3.segIdx === e5.segIdx ? this.segmentStartEnds[this.segmentStartEnds.length - 1].end = s3.dist : this.segmentStartEnds[s3.segIdx] = { start: s3.dist, end: s3.dist }, e5.segIdx !== s3.segIdx && (this.segments[e5.segIdx].D.x !== this.segments[s3.segIdx].A.x || this.segments[e5.segIdx].D.y !== this.segments[s3.segIdx].A.y)) {
                const i2 = (e5.dist + s3.dist) / 2, h2 = { dist: i2 - 1e-8, pt: this.segments[e5.segIdx].D, tan: this.segments[e5.segIdx].tangentAtParameter(1), segIdx: e5.segIdx, t: 1 }, a3 = { dist: i2 + 1e-8, pt: this.segments[s3.segIdx].A, tan: this.segments[s3.segIdx].tangentAtParameter(0), segIdx: s3.segIdx, t: 0 };
                this._jumps.push(i2), this.samples.splice(t4, 0, h2, a3), t4 += 2;
              }
            }
          }
          jumps() {
            return [...this._jumps];
          }
          getTotalLength() {
            return this._totalLength;
          }
          findClosestSampleIdx(t3) {
            let e4 = 0, s2 = this.samples.length - 1;
            for (; e4 < s2; ) {
              const i2 = Math.floor((e4 + s2) / 2);
              if (this.samples[i2].dist > t3) s2 = i2 - 1;
              else {
                if (!(this.samples[i2].dist < t3)) return i2;
                e4 = i2 + 1;
              }
            }
            return Math.max(0, Math.min(this.samples.length - 1, Math.floor((e4 + s2) / 2)));
          }
          getPointAtLength(t3, e4 = false) {
            if (t3 <= 0) return this.samples[0].pt;
            if (t3 >= this._totalLength) return this.samples[this.samples.length - 1].pt;
            const s2 = this.findClosestSampleIdx(t3), i2 = this.samples[s2].dist < t3 ? Math.min(s2 + 1, this.samples.length - 1) : Math.max(0, s2 - 1), h2 = Math.abs(this.samples[i2].dist - this.samples[s2].dist) < 1e-6 ? 0 : (t3 - this.samples[s2].dist) / (this.samples[i2].dist - this.samples[s2].dist);
            if (e4 || this.samples[s2].segIdx > this.samples[i2].segIdx) return { x: (1 - h2) * this.samples[s2].pt.x + h2 * this.samples[i2].pt.x, y: (1 - h2) * this.samples[s2].pt.y + h2 * this.samples[i2].pt.y };
            if (this.samples[s2].segIdx !== this.samples[i2].segIdx) {
              if (h2 < 0.5) {
                const t4 = this.segments[this.samples[s2].segIdx], e5 = 2 * h2, i3 = (1 - e5) * this.samples[s2].t + e5;
                return t4.pointAtParameter(i3);
              }
              {
                const t4 = this.segments[this.samples[i2].segIdx], e5 = 2 * (h2 - 0.5) * this.samples[i2].t;
                return t4.pointAtParameter(e5);
              }
            }
            {
              const t4 = this.segments[this.samples[s2].segIdx], e5 = (1 - h2) * this.samples[s2].t + h2 * this.samples[i2].t;
              return t4.pointAtParameter(e5);
            }
          }
          getAngleAtLength(t3, e4 = false) {
            const s2 = this.getTangentAtLength(t3, e4);
            return Math.atan2(s2.y, s2.x);
          }
          getTangentAtLength(t3, e4 = false) {
            if (t3 <= 0) return this.samples[0].tan;
            if (t3 >= this._totalLength) return this.samples[this.samples.length - 1].tan;
            const s2 = this.findClosestSampleIdx(t3), i2 = this.samples[s2].dist < t3 ? Math.min(s2 + 1, this.samples.length - 1) : Math.max(0, s2 - 1), h2 = (t3 - this.samples[s2].dist) / (this.samples[i2].dist - this.samples[s2].dist);
            if (e4 || this.samples[s2].segIdx > this.samples[i2].segIdx) {
              let t4 = (1 - h2) * this.samples[s2].tan.x + h2 * this.samples[i2].tan.x, e5 = (1 - h2) * this.samples[s2].tan.y + h2 * this.samples[i2].tan.y;
              const a2 = Math.max(Math.hypot(t4, e5), 1e-4);
              return t4 /= a2, e5 /= a2, { x: t4, y: e5 };
            }
            if (this.samples[s2].segIdx !== this.samples[i2].segIdx) {
              if (h2 < 0.5) {
                const t4 = this.segments[this.samples[s2].segIdx], e5 = 2 * h2, i3 = (1 - e5) * this.samples[s2].t + e5;
                return t4.tangentAtParameter(i3);
              }
              {
                const t4 = this.segments[this.samples[i2].segIdx], e5 = 2 * (h2 - 0.5) * this.samples[i2].t;
                return t4.tangentAtParameter(e5);
              }
            }
            {
              const t4 = this.segments[this.samples[s2].segIdx], e5 = (1 - h2) * this.samples[s2].t + h2 * this.samples[i2].t;
              return t4.tangentAtParameter(e5);
            }
          }
        };
      }, 558: (t2, e3, s) => {
        Object.defineProperty(e3, "__esModule", { value: true }), e3.BezierSegment = void 0;
        const i = s(188);
        class h {
          constructor(t3, e4, s2, i2) {
            this._totalLength = void 0, this.A = t3, this.B = e4, this.C = s2, this.D = i2;
          }
          static sampleSpacing() {
            return 2;
          }
          tangentAtParameter(t3) {
            const e4 = Math.max(0, Math.min(1, t3));
            if (0 === e4 || 1 === e4) {
              let t4, s3;
              0 === e4 ? this.A.x === this.B.x && this.A.y === this.B.y ? (t4 = this.C.x - this.A.x, s3 = this.C.y - this.A.y) : (t4 = this.B.x - this.A.x, s3 = this.B.y - this.A.y) : this.D.x === this.C.x && this.D.y === this.C.y ? (t4 = this.D.x - this.B.x, s3 = this.D.y - this.B.y) : (t4 = this.D.x - this.C.x, s3 = this.D.y - this.C.y);
              const i3 = Math.hypot(t4, s3);
              return Math.abs(i3) > 1e-4 && (t4 /= i3, s3 /= i3), { x: t4, y: s3 };
            }
            const s2 = 1 - e4;
            let i2 = 3 * this.D.x * Math.pow(e4, 2) - 3 * this.C.x * Math.pow(e4, 2) + 6 * this.C.x * s2 * e4 - 6 * this.B.x * s2 * e4 + 3 * this.B.x * Math.pow(s2, 2) - 3 * this.A.x * Math.pow(s2, 2), h2 = 3 * this.D.y * Math.pow(e4, 2) - 3 * this.C.y * Math.pow(e4, 2) + 6 * this.C.y * s2 * e4 - 6 * this.B.y * s2 * e4 + 3 * this.B.y * Math.pow(s2, 2) - 3 * this.A.y * Math.pow(s2, 2);
            const a2 = Math.hypot(i2, h2);
            return Math.abs(a2) > 1e-4 && (i2 /= a2, h2 /= a2), { x: i2, y: h2 };
          }
          isLinear() {
            return this.A.x === this.B.x && this.A.y === this.B.y && this.C.x === this.D.x && this.C.y === this.D.y;
          }
          pointAtParameter(t3) {
            const e4 = Math.max(0, Math.min(1, t3));
            return { x: Math.pow(1 - e4, 3) * this.A.x + 3 * Math.pow(1 - e4, 2) * e4 * this.B.x + 3 * (1 - e4) * Math.pow(e4, 2) * this.C.x + Math.pow(e4, 3) * this.D.x, y: Math.pow(1 - e4, 3) * this.A.y + 3 * Math.pow(1 - e4, 2) * e4 * this.B.y + 3 * (1 - e4) * Math.pow(e4, 2) * this.C.y + Math.pow(e4, 3) * this.D.y };
          }
          getTotalLength() {
            if (void 0 === this._totalLength) if (this.isLinear()) this._totalLength = Math.hypot(this.D.x - this.A.x, this.D.y - this.A.y);
            else {
              const t3 = Math.max(10, Math.ceil((Math.hypot(this.B.x - this.A.x, this.B.y - this.A.y) + Math.hypot(this.C.x - this.B.x, this.C.y - this.B.y) + Math.hypot(this.D.x - this.C.x, this.D.y - this.C.y)) / h.sampleSpacing())), e4 = (0, i.times)(t3).map((e5) => this.pointAtParameter(e5 / (t3 - 1)));
              let s2 = 0;
              for (let t4 = 1; t4 < e4.length; t4++) s2 += Math.hypot(e4[t4].x - e4[t4 - 1].x, e4[t4].y - e4[t4 - 1].y);
              this._totalLength = s2;
            }
            return this._totalLength;
          }
        }
        e3.BezierSegment = h;
      }, 729: (t2, e3, s) => {
        Object.defineProperty(e3, "__esModule", { value: true }), e3.createFromCommands = e3.create = e3.createFromElement = e3.createFromCircle = e3.createFromLine = e3.createFromPath = void 0;
        const i = s(821), h = s(558), a2 = { M: ["x", "y"], m: ["dx", "dy"], H: ["x"], h: ["dx"], V: ["y"], v: ["dy"], L: ["x", "y"], l: ["dx", "dy"], Z: [], C: ["x1", "y1", "x2", "y2", "x", "y"], c: ["dx1", "dy1", "dx2", "dy2", "dx", "dy"], S: ["x2", "y2", "x", "y"], s: ["dx2", "dy2", "dx", "dy"], Q: ["x1", "y1", "x", "y"], q: ["dx1", "dy1", "dx", "dy"], T: ["x", "y"], t: ["dx", "dy"], A: ["rx", "ry", "rotation", "large-arc", "sweep", "x", "y"], a: ["rx", "ry", "rotation", "large-arc", "sweep", "dx", "dy"] };
        e3.createFromPath = (t3) => {
          const e4 = function(t4) {
            const e5 = t4.replace(/[\n\r]/g, "").replace(/-/g, " -").replace(/(\d*\.)(\d+)(?=\.)/g, "$1$2 ").replace(/(\d)([A-Za-z])/g, "$1 $2").replace(/([A-Za-z])(\d)/g, "$1 $2").trim().split(/\s*,|\s+/), s3 = [];
            let i2 = "", h2 = {};
            for (; e5.length > 0; ) {
              let t5 = e5.shift();
              a2.hasOwnProperty(t5) ? i2 = t5 : e5.unshift(t5), h2 = { type: i2 }, a2[i2].forEach((s4) => {
                t5 = e5.shift(), h2[s4] = parseFloat(t5);
              }), "M" === i2 ? i2 = "L" : "m" === i2 && (i2 = "l"), s3.push(h2);
            }
            return s3;
          }(t3.getAttribute("d"));
          if (e4.length < 2) throw new Error(`Path doesn't have enough commands: ${JSON.stringify(e4)}`);
          if ("M" !== e4[0].type) throw new Error(`Path starts with ${e4[0].type} instead of M!`);
          let s2 = { x: e4[0].x, y: e4[0].y };
          e4.shift();
          const n3 = [];
          for (; e4.length > 0; ) {
            const t4 = e4.shift();
            if ("C" === t4.type) n3.push(new h.BezierSegment(s2, { x: t4.x1, y: t4.y1 }, { x: t4.x2, y: t4.y2 }, { x: t4.x, y: t4.y })), s2 = { x: t4.x, y: t4.y };
            else if ("L" === t4.type) n3.push(new h.BezierSegment(s2, s2, { x: t4.x, y: t4.y }, { x: t4.x, y: t4.y })), s2 = { x: t4.x, y: t4.y };
            else if ("H" === t4.type) n3.push(new h.BezierSegment(s2, s2, { x: t4.x, y: s2.y }, { x: t4.x, y: s2.y })), s2 = { x: t4.x, y: s2.y };
            else if ("V" === t4.type) n3.push(new h.BezierSegment(s2, s2, { x: s2.x, y: t4.y }, { x: s2.x, y: t4.y })), s2 = { x: s2.x, y: t4.y };
            else if ("Z" !== t4.type) throw new Error(`Unsupported path command ${t4.type}; use only H, V, M, L, C, Z!`);
          }
          return new i.BezierPath(n3);
        }, e3.createFromLine = (t3) => {
          const [e4, s2, a3, n3] = ["x1", "x2", "y1", "y2"].map((e5) => parseFloat(t3.getAttribute(e5) || "0"));
          return new i.BezierPath([new h.BezierSegment({ x: e4, y: a3 }, { x: e4, y: a3 }, { x: s2, y: n3 }, { x: s2, y: n3 })]);
        }, e3.createFromCircle = (t3) => {
          const [e4, s2, a3] = ["cx", "cy", "r"].map((e5) => parseFloat(t3.getAttribute(e5) || "0")), n3 = 1.3;
          return new i.BezierPath([new h.BezierSegment({ x: e4 - a3, y: s2 }, { x: e4 - a3, y: s2 - n3 * a3 }, { x: e4 + a3, y: s2 - n3 * a3 }, { x: e4 + a3, y: s2 }), new h.BezierSegment({ x: e4 + a3, y: s2 }, { x: e4 + a3, y: s2 + n3 * a3 }, { x: e4 - a3, y: s2 + n3 * a3 }, { x: e4 - a3, y: s2 })]);
        }, e3.createFromElement = (t3) => {
          const s2 = t3.tagName.toLowerCase();
          if ("path" === s2) return (0, e3.createFromPath)(t3);
          if ("line" === s2) return (0, e3.createFromLine)(t3);
          if ("circle" === s2) return (0, e3.createFromCircle)(t3);
          throw new Error(`Unsupported SVG tag: ${s2}`);
        }, e3.create = (t3) => {
          const e4 = [];
          for (let s2 = 1; s2 < t3.length; s2++) {
            const i2 = t3[s2 - 1], a3 = t3[s2];
            e4.push(new h.BezierSegment(i2.pt, i2.right || i2.pt, a3.left || a3.pt, a3.pt));
          }
          return new i.BezierPath(e4);
        }, e3.createFromCommands = (t3) => {
          const e4 = t3.slice();
          if (e4.length < 2) throw new Error(`Path doesn't have enough commands: ${JSON.stringify(e4)}`);
          if ("M" !== e4[0].type) throw new Error(`Path starts with ${e4[0].type} instead of M!`);
          let s2 = { x: e4[0].x, y: e4[0].y }, a3 = Object.assign({}, s2);
          const n3 = [];
          for (; e4.length > 0; ) {
            const t4 = e4.shift();
            if ("M" === t4.type) a3 = { x: t4.x, y: t4.y }, s2 = a3;
            else if ("C" === t4.type) n3.push(new h.BezierSegment(s2, { x: t4.x1, y: t4.y1 }, { x: t4.x2, y: t4.y2 }, { x: t4.x, y: t4.y })), s2 = { x: t4.x, y: t4.y };
            else if ("L" === t4.type) t4.x === s2.x && t4.y === s2.y || n3.push(new h.BezierSegment(s2, s2, { x: t4.x, y: t4.y }, { x: t4.x, y: t4.y })), s2 = { x: t4.x, y: t4.y };
            else if ("H" === t4.type) t4.x !== s2.x && n3.push(new h.BezierSegment(s2, s2, { x: t4.x, y: s2.y }, { x: t4.x, y: s2.y })), s2 = { x: t4.x, y: s2.y };
            else if ("V" === t4.type) t4.y !== s2.y && n3.push(new h.BezierSegment(s2, s2, { x: s2.x, y: t4.y }, { x: s2.x, y: t4.y })), s2 = { x: s2.x, y: t4.y };
            else if ("Q" === t4.type) n3.push(new h.BezierSegment(s2, { x: s2.x + 2 / 3 * (t4.x1 - s2.x), y: s2.y + 2 / 3 * (t4.y1 - s2.y) }, { x: t4.x + 2 / 3 * (t4.x1 - t4.x), y: t4.y + 2 / 3 * (t4.y1 - t4.y) }, { x: t4.x, y: t4.y })), s2 = { x: t4.x, y: t4.y };
            else {
              if ("Z" !== t4.type) throw new Error(`Unsupported path command ${t4.type}; use only H, V, M, L, C, Z!`);
              Math.hypot(s2.x - a3.x, s2.y - a3.y) > 0 && n3.push(new h.BezierSegment(s2, s2, a3, a3));
            }
          }
          return new i.BezierPath(n3);
        };
      }, 821: function(t2, e3, s) {
        var i = this && this.__createBinding || (Object.create ? function(t3, e4, s2, i2) {
          void 0 === i2 && (i2 = s2);
          var h2 = Object.getOwnPropertyDescriptor(e4, s2);
          h2 && !("get" in h2 ? !e4.__esModule : h2.writable || h2.configurable) || (h2 = { enumerable: true, get: function() {
            return e4[s2];
          } }), Object.defineProperty(t3, i2, h2);
        } : function(t3, e4, s2, i2) {
          void 0 === i2 && (i2 = s2), t3[i2] = e4[s2];
        }), h = this && this.__exportStar || function(t3, e4) {
          for (var s2 in t3) "default" === s2 || Object.prototype.hasOwnProperty.call(e4, s2) || i(e4, t3, s2);
        };
        Object.defineProperty(e3, "__esModule", { value: true }), h(s(177), e3), h(s(558), e3), h(s(729), e3), h(s(856), e3);
      }, 856: (t2, e3) => {
        Object.defineProperty(e3, "__esModule", { value: true });
      }, 188: (t2, e3) => {
        Object.defineProperty(e3, "__esModule", { value: true }), e3.times = void 0, e3.times = function(t3) {
          const e4 = [];
          for (let s = 0; s < t3; s++) e4.push(s);
          return e4;
        };
      } }, e2 = {};
      return function s(i) {
        var h = e2[i];
        if (void 0 !== h) return h.exports;
        var a2 = e2[i] = { exports: {} };
        return t[i].call(a2.exports, a2, a2.exports, s), a2.exports;
      }(821);
    })());
  }
});

// node_modules/estraverse/estraverse.js
var require_estraverse = __commonJS({
  "node_modules/estraverse/estraverse.js"(exports) {
    (function clone3(exports2) {
      "use strict";
      var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE2;
      function deepCopy(obj) {
        var ret = {}, key, val2;
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            val2 = obj[key];
            if (typeof val2 === "object" && val2 !== null) {
              ret[key] = deepCopy(val2);
            } else {
              ret[key] = val2;
            }
          }
        }
        return ret;
      }
      function upperBound(array2, func) {
        var diff, len, i, current2;
        len = array2.length;
        i = 0;
        while (len) {
          diff = len >>> 1;
          current2 = i + diff;
          if (func(array2[current2])) {
            len = diff;
          } else {
            i = current2 + 1;
            len -= diff + 1;
          }
        }
        return i;
      }
      Syntax = {
        AssignmentExpression: "AssignmentExpression",
        AssignmentPattern: "AssignmentPattern",
        ArrayExpression: "ArrayExpression",
        ArrayPattern: "ArrayPattern",
        ArrowFunctionExpression: "ArrowFunctionExpression",
        AwaitExpression: "AwaitExpression",
        // CAUTION: It's deferred to ES7.
        BlockStatement: "BlockStatement",
        BinaryExpression: "BinaryExpression",
        BreakStatement: "BreakStatement",
        CallExpression: "CallExpression",
        CatchClause: "CatchClause",
        ChainExpression: "ChainExpression",
        ClassBody: "ClassBody",
        ClassDeclaration: "ClassDeclaration",
        ClassExpression: "ClassExpression",
        ComprehensionBlock: "ComprehensionBlock",
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: "ComprehensionExpression",
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: "ConditionalExpression",
        ContinueStatement: "ContinueStatement",
        DebuggerStatement: "DebuggerStatement",
        DirectiveStatement: "DirectiveStatement",
        DoWhileStatement: "DoWhileStatement",
        EmptyStatement: "EmptyStatement",
        ExportAllDeclaration: "ExportAllDeclaration",
        ExportDefaultDeclaration: "ExportDefaultDeclaration",
        ExportNamedDeclaration: "ExportNamedDeclaration",
        ExportSpecifier: "ExportSpecifier",
        ExpressionStatement: "ExpressionStatement",
        ForStatement: "ForStatement",
        ForInStatement: "ForInStatement",
        ForOfStatement: "ForOfStatement",
        FunctionDeclaration: "FunctionDeclaration",
        FunctionExpression: "FunctionExpression",
        GeneratorExpression: "GeneratorExpression",
        // CAUTION: It's deferred to ES7.
        Identifier: "Identifier",
        IfStatement: "IfStatement",
        ImportExpression: "ImportExpression",
        ImportDeclaration: "ImportDeclaration",
        ImportDefaultSpecifier: "ImportDefaultSpecifier",
        ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
        ImportSpecifier: "ImportSpecifier",
        Literal: "Literal",
        LabeledStatement: "LabeledStatement",
        LogicalExpression: "LogicalExpression",
        MemberExpression: "MemberExpression",
        MetaProperty: "MetaProperty",
        MethodDefinition: "MethodDefinition",
        ModuleSpecifier: "ModuleSpecifier",
        NewExpression: "NewExpression",
        ObjectExpression: "ObjectExpression",
        ObjectPattern: "ObjectPattern",
        PrivateIdentifier: "PrivateIdentifier",
        Program: "Program",
        Property: "Property",
        PropertyDefinition: "PropertyDefinition",
        RestElement: "RestElement",
        ReturnStatement: "ReturnStatement",
        SequenceExpression: "SequenceExpression",
        SpreadElement: "SpreadElement",
        Super: "Super",
        SwitchStatement: "SwitchStatement",
        SwitchCase: "SwitchCase",
        TaggedTemplateExpression: "TaggedTemplateExpression",
        TemplateElement: "TemplateElement",
        TemplateLiteral: "TemplateLiteral",
        ThisExpression: "ThisExpression",
        ThrowStatement: "ThrowStatement",
        TryStatement: "TryStatement",
        UnaryExpression: "UnaryExpression",
        UpdateExpression: "UpdateExpression",
        VariableDeclaration: "VariableDeclaration",
        VariableDeclarator: "VariableDeclarator",
        WhileStatement: "WhileStatement",
        WithStatement: "WithStatement",
        YieldExpression: "YieldExpression"
      };
      VisitorKeys = {
        AssignmentExpression: ["left", "right"],
        AssignmentPattern: ["left", "right"],
        ArrayExpression: ["elements"],
        ArrayPattern: ["elements"],
        ArrowFunctionExpression: ["params", "body"],
        AwaitExpression: ["argument"],
        // CAUTION: It's deferred to ES7.
        BlockStatement: ["body"],
        BinaryExpression: ["left", "right"],
        BreakStatement: ["label"],
        CallExpression: ["callee", "arguments"],
        CatchClause: ["param", "body"],
        ChainExpression: ["expression"],
        ClassBody: ["body"],
        ClassDeclaration: ["id", "superClass", "body"],
        ClassExpression: ["id", "superClass", "body"],
        ComprehensionBlock: ["left", "right"],
        // CAUTION: It's deferred to ES7.
        ComprehensionExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        ConditionalExpression: ["test", "consequent", "alternate"],
        ContinueStatement: ["label"],
        DebuggerStatement: [],
        DirectiveStatement: [],
        DoWhileStatement: ["body", "test"],
        EmptyStatement: [],
        ExportAllDeclaration: ["source"],
        ExportDefaultDeclaration: ["declaration"],
        ExportNamedDeclaration: ["declaration", "specifiers", "source"],
        ExportSpecifier: ["exported", "local"],
        ExpressionStatement: ["expression"],
        ForStatement: ["init", "test", "update", "body"],
        ForInStatement: ["left", "right", "body"],
        ForOfStatement: ["left", "right", "body"],
        FunctionDeclaration: ["id", "params", "body"],
        FunctionExpression: ["id", "params", "body"],
        GeneratorExpression: ["blocks", "filter", "body"],
        // CAUTION: It's deferred to ES7.
        Identifier: [],
        IfStatement: ["test", "consequent", "alternate"],
        ImportExpression: ["source"],
        ImportDeclaration: ["specifiers", "source"],
        ImportDefaultSpecifier: ["local"],
        ImportNamespaceSpecifier: ["local"],
        ImportSpecifier: ["imported", "local"],
        Literal: [],
        LabeledStatement: ["label", "body"],
        LogicalExpression: ["left", "right"],
        MemberExpression: ["object", "property"],
        MetaProperty: ["meta", "property"],
        MethodDefinition: ["key", "value"],
        ModuleSpecifier: [],
        NewExpression: ["callee", "arguments"],
        ObjectExpression: ["properties"],
        ObjectPattern: ["properties"],
        PrivateIdentifier: [],
        Program: ["body"],
        Property: ["key", "value"],
        PropertyDefinition: ["key", "value"],
        RestElement: ["argument"],
        ReturnStatement: ["argument"],
        SequenceExpression: ["expressions"],
        SpreadElement: ["argument"],
        Super: [],
        SwitchStatement: ["discriminant", "cases"],
        SwitchCase: ["test", "consequent"],
        TaggedTemplateExpression: ["tag", "quasi"],
        TemplateElement: [],
        TemplateLiteral: ["quasis", "expressions"],
        ThisExpression: [],
        ThrowStatement: ["argument"],
        TryStatement: ["block", "handler", "finalizer"],
        UnaryExpression: ["argument"],
        UpdateExpression: ["argument"],
        VariableDeclaration: ["declarations"],
        VariableDeclarator: ["id", "init"],
        WhileStatement: ["test", "body"],
        WithStatement: ["object", "body"],
        YieldExpression: ["argument"]
      };
      BREAK = {};
      SKIP = {};
      REMOVE2 = {};
      VisitorOption = {
        Break: BREAK,
        Skip: SKIP,
        Remove: REMOVE2
      };
      function Reference(parent, key) {
        this.parent = parent;
        this.key = key;
      }
      Reference.prototype.replace = function replace2(node) {
        this.parent[this.key] = node;
      };
      Reference.prototype.remove = function remove3() {
        if (Array.isArray(this.parent)) {
          this.parent.splice(this.key, 1);
          return true;
        } else {
          this.replace(null);
          return false;
        }
      };
      function Element2(node, path2, wrap, ref2) {
        this.node = node;
        this.path = path2;
        this.wrap = wrap;
        this.ref = ref2;
      }
      function Controller() {
      }
      Controller.prototype.path = function path2() {
        var i, iz, j2, jz, result, element2;
        function addToPath(result2, path3) {
          if (Array.isArray(path3)) {
            for (j2 = 0, jz = path3.length; j2 < jz; ++j2) {
              result2.push(path3[j2]);
            }
          } else {
            result2.push(path3);
          }
        }
        if (!this.__current.path) {
          return null;
        }
        result = [];
        for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
          element2 = this.__leavelist[i];
          addToPath(result, element2.path);
        }
        addToPath(result, this.__current.path);
        return result;
      };
      Controller.prototype.type = function() {
        var node = this.current();
        return node.type || this.__current.wrap;
      };
      Controller.prototype.parents = function parents() {
        var i, iz, result;
        result = [];
        for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
          result.push(this.__leavelist[i].node);
        }
        return result;
      };
      Controller.prototype.current = function current2() {
        return this.__current.node;
      };
      Controller.prototype.__execute = function __execute(callback, element2) {
        var previous, result;
        result = void 0;
        previous = this.__current;
        this.__current = element2;
        this.__state = null;
        if (callback) {
          result = callback.call(this, element2.node, this.__leavelist[this.__leavelist.length - 1].node);
        }
        this.__current = previous;
        return result;
      };
      Controller.prototype.notify = function notify(flag) {
        this.__state = flag;
      };
      Controller.prototype.skip = function() {
        this.notify(SKIP);
      };
      Controller.prototype["break"] = function() {
        this.notify(BREAK);
      };
      Controller.prototype.remove = function() {
        this.notify(REMOVE2);
      };
      Controller.prototype.__initialize = function(root, visitor) {
        this.visitor = visitor;
        this.root = root;
        this.__worklist = [];
        this.__leavelist = [];
        this.__current = null;
        this.__state = null;
        this.__fallback = null;
        if (visitor.fallback === "iteration") {
          this.__fallback = Object.keys;
        } else if (typeof visitor.fallback === "function") {
          this.__fallback = visitor.fallback;
        }
        this.__keys = VisitorKeys;
        if (visitor.keys) {
          this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
        }
      };
      function isNode(node) {
        if (node == null) {
          return false;
        }
        return typeof node === "object" && typeof node.type === "string";
      }
      function isProperty(nodeType, key) {
        return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && "properties" === key;
      }
      function candidateExistsInLeaveList(leavelist, candidate) {
        for (var i = leavelist.length - 1; i >= 0; --i) {
          if (leavelist[i].node === candidate) {
            return true;
          }
        }
        return false;
      }
      Controller.prototype.traverse = function traverse2(root, visitor) {
        var worklist, leavelist, element2, node, nodeType, ret, key, current2, current22, candidates, candidate, sentinel;
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        worklist.push(new Element2(root, null, null, null));
        leavelist.push(new Element2(null, null, null, null));
        while (worklist.length) {
          element2 = worklist.pop();
          if (element2 === sentinel) {
            element2 = leavelist.pop();
            ret = this.__execute(visitor.leave, element2);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            continue;
          }
          if (element2.node) {
            ret = this.__execute(visitor.enter, element2);
            if (this.__state === BREAK || ret === BREAK) {
              return;
            }
            worklist.push(sentinel);
            leavelist.push(element2);
            if (this.__state === SKIP || ret === SKIP) {
              continue;
            }
            node = element2.node;
            nodeType = node.type || element2.wrap;
            candidates = this.__keys[nodeType];
            if (!candidates) {
              if (this.__fallback) {
                candidates = this.__fallback(node);
              } else {
                throw new Error("Unknown node type " + nodeType + ".");
              }
            }
            current2 = candidates.length;
            while ((current2 -= 1) >= 0) {
              key = candidates[current2];
              candidate = node[key];
              if (!candidate) {
                continue;
              }
              if (Array.isArray(candidate)) {
                current22 = candidate.length;
                while ((current22 -= 1) >= 0) {
                  if (!candidate[current22]) {
                    continue;
                  }
                  if (candidateExistsInLeaveList(leavelist, candidate[current22])) {
                    continue;
                  }
                  if (isProperty(nodeType, candidates[current2])) {
                    element2 = new Element2(candidate[current22], [key, current22], "Property", null);
                  } else if (isNode(candidate[current22])) {
                    element2 = new Element2(candidate[current22], [key, current22], null, null);
                  } else {
                    continue;
                  }
                  worklist.push(element2);
                }
              } else if (isNode(candidate)) {
                if (candidateExistsInLeaveList(leavelist, candidate)) {
                  continue;
                }
                worklist.push(new Element2(candidate, key, null, null));
              }
            }
          }
        }
      };
      Controller.prototype.replace = function replace2(root, visitor) {
        var worklist, leavelist, node, nodeType, target, element2, current2, current22, candidates, candidate, sentinel, outer, key;
        function removeElem(element3) {
          var i, key2, nextElem, parent;
          if (element3.ref.remove()) {
            key2 = element3.ref.key;
            parent = element3.ref.parent;
            i = worklist.length;
            while (i--) {
              nextElem = worklist[i];
              if (nextElem.ref && nextElem.ref.parent === parent) {
                if (nextElem.ref.key < key2) {
                  break;
                }
                --nextElem.ref.key;
              }
            }
          }
        }
        this.__initialize(root, visitor);
        sentinel = {};
        worklist = this.__worklist;
        leavelist = this.__leavelist;
        outer = {
          root
        };
        element2 = new Element2(root, null, null, new Reference(outer, "root"));
        worklist.push(element2);
        leavelist.push(element2);
        while (worklist.length) {
          element2 = worklist.pop();
          if (element2 === sentinel) {
            element2 = leavelist.pop();
            target = this.__execute(visitor.leave, element2);
            if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE2) {
              element2.ref.replace(target);
            }
            if (this.__state === REMOVE2 || target === REMOVE2) {
              removeElem(element2);
            }
            if (this.__state === BREAK || target === BREAK) {
              return outer.root;
            }
            continue;
          }
          target = this.__execute(visitor.enter, element2);
          if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE2) {
            element2.ref.replace(target);
            element2.node = target;
          }
          if (this.__state === REMOVE2 || target === REMOVE2) {
            removeElem(element2);
            element2.node = null;
          }
          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          }
          node = element2.node;
          if (!node) {
            continue;
          }
          worklist.push(sentinel);
          leavelist.push(element2);
          if (this.__state === SKIP || target === SKIP) {
            continue;
          }
          nodeType = node.type || element2.wrap;
          candidates = this.__keys[nodeType];
          if (!candidates) {
            if (this.__fallback) {
              candidates = this.__fallback(node);
            } else {
              throw new Error("Unknown node type " + nodeType + ".");
            }
          }
          current2 = candidates.length;
          while ((current2 -= 1) >= 0) {
            key = candidates[current2];
            candidate = node[key];
            if (!candidate) {
              continue;
            }
            if (Array.isArray(candidate)) {
              current22 = candidate.length;
              while ((current22 -= 1) >= 0) {
                if (!candidate[current22]) {
                  continue;
                }
                if (isProperty(nodeType, candidates[current2])) {
                  element2 = new Element2(candidate[current22], [key, current22], "Property", new Reference(candidate, current22));
                } else if (isNode(candidate[current22])) {
                  element2 = new Element2(candidate[current22], [key, current22], null, new Reference(candidate, current22));
                } else {
                  continue;
                }
                worklist.push(element2);
              }
            } else if (isNode(candidate)) {
              worklist.push(new Element2(candidate, key, null, new Reference(node, key)));
            }
          }
        }
        return outer.root;
      };
      function traverse(root, visitor) {
        var controller = new Controller();
        return controller.traverse(root, visitor);
      }
      function replace(root, visitor) {
        var controller = new Controller();
        return controller.replace(root, visitor);
      }
      function extendCommentRange(comment, tokens) {
        var target;
        target = upperBound(tokens, function search(token) {
          return token.range[0] > comment.range[0];
        });
        comment.extendedRange = [comment.range[0], comment.range[1]];
        if (target !== tokens.length) {
          comment.extendedRange[1] = tokens[target].range[0];
        }
        target -= 1;
        if (target >= 0) {
          comment.extendedRange[0] = tokens[target].range[1];
        }
        return comment;
      }
      function attachComments(tree, providedComments, tokens) {
        var comments = [], comment, len, i, cursor;
        if (!tree.range) {
          throw new Error("attachComments needs range information");
        }
        if (!tokens.length) {
          if (providedComments.length) {
            for (i = 0, len = providedComments.length; i < len; i += 1) {
              comment = deepCopy(providedComments[i]);
              comment.extendedRange = [0, tree.range[0]];
              comments.push(comment);
            }
            tree.leadingComments = comments;
          }
          return tree;
        }
        for (i = 0, len = providedComments.length; i < len; i += 1) {
          comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
        }
        cursor = 0;
        traverse(tree, {
          enter: function(node) {
            var comment2;
            while (cursor < comments.length) {
              comment2 = comments[cursor];
              if (comment2.extendedRange[1] > node.range[0]) {
                break;
              }
              if (comment2.extendedRange[1] === node.range[0]) {
                if (!node.leadingComments) {
                  node.leadingComments = [];
                }
                node.leadingComments.push(comment2);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        cursor = 0;
        traverse(tree, {
          leave: function(node) {
            var comment2;
            while (cursor < comments.length) {
              comment2 = comments[cursor];
              if (node.range[1] < comment2.extendedRange[0]) {
                break;
              }
              if (node.range[1] === comment2.extendedRange[0]) {
                if (!node.trailingComments) {
                  node.trailingComments = [];
                }
                node.trailingComments.push(comment2);
                comments.splice(cursor, 1);
              } else {
                cursor += 1;
              }
            }
            if (cursor === comments.length) {
              return VisitorOption.Break;
            }
            if (comments[cursor].extendedRange[0] > node.range[1]) {
              return VisitorOption.Skip;
            }
          }
        });
        return tree;
      }
      exports2.Syntax = Syntax;
      exports2.traverse = traverse;
      exports2.replace = replace;
      exports2.attachComments = attachComments;
      exports2.VisitorKeys = VisitorKeys;
      exports2.VisitorOption = VisitorOption;
      exports2.Controller = Controller;
      exports2.cloneEnvironment = function() {
        return clone3({});
      };
      return exports2;
    })(exports);
  }
});

// node_modules/esutils/lib/ast.js
var require_ast = __commonJS({
  "node_modules/esutils/lib/ast.js"(exports, module) {
    (function() {
      "use strict";
      function isExpression(node) {
        if (node == null) {
          return false;
        }
        switch (node.type) {
          case "ArrayExpression":
          case "AssignmentExpression":
          case "BinaryExpression":
          case "CallExpression":
          case "ConditionalExpression":
          case "FunctionExpression":
          case "Identifier":
          case "Literal":
          case "LogicalExpression":
          case "MemberExpression":
          case "NewExpression":
          case "ObjectExpression":
          case "SequenceExpression":
          case "ThisExpression":
          case "UnaryExpression":
          case "UpdateExpression":
            return true;
        }
        return false;
      }
      function isIterationStatement(node) {
        if (node == null) {
          return false;
        }
        switch (node.type) {
          case "DoWhileStatement":
          case "ForInStatement":
          case "ForStatement":
          case "WhileStatement":
            return true;
        }
        return false;
      }
      function isStatement(node) {
        if (node == null) {
          return false;
        }
        switch (node.type) {
          case "BlockStatement":
          case "BreakStatement":
          case "ContinueStatement":
          case "DebuggerStatement":
          case "DoWhileStatement":
          case "EmptyStatement":
          case "ExpressionStatement":
          case "ForInStatement":
          case "ForStatement":
          case "IfStatement":
          case "LabeledStatement":
          case "ReturnStatement":
          case "SwitchStatement":
          case "ThrowStatement":
          case "TryStatement":
          case "VariableDeclaration":
          case "WhileStatement":
          case "WithStatement":
            return true;
        }
        return false;
      }
      function isSourceElement(node) {
        return isStatement(node) || node != null && node.type === "FunctionDeclaration";
      }
      function trailingStatement(node) {
        switch (node.type) {
          case "IfStatement":
            if (node.alternate != null) {
              return node.alternate;
            }
            return node.consequent;
          case "LabeledStatement":
          case "ForStatement":
          case "ForInStatement":
          case "WhileStatement":
          case "WithStatement":
            return node.body;
        }
        return null;
      }
      function isProblematicIfStatement(node) {
        var current2;
        if (node.type !== "IfStatement") {
          return false;
        }
        if (node.alternate == null) {
          return false;
        }
        current2 = node.consequent;
        do {
          if (current2.type === "IfStatement") {
            if (current2.alternate == null) {
              return true;
            }
          }
          current2 = trailingStatement(current2);
        } while (current2);
        return false;
      }
      module.exports = {
        isExpression,
        isStatement,
        isIterationStatement,
        isSourceElement,
        isProblematicIfStatement,
        trailingStatement
      };
    })();
  }
});

// node_modules/esutils/lib/code.js
var require_code = __commonJS({
  "node_modules/esutils/lib/code.js"(exports, module) {
    (function() {
      "use strict";
      var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;
      ES5Regex = {
        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
      };
      ES6Regex = {
        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
      };
      function isDecimalDigit2(ch2) {
        return 48 <= ch2 && ch2 <= 57;
      }
      function isHexDigit2(ch2) {
        return 48 <= ch2 && ch2 <= 57 || // 0..9
        97 <= ch2 && ch2 <= 102 || // a..f
        65 <= ch2 && ch2 <= 70;
      }
      function isOctalDigit2(ch2) {
        return ch2 >= 48 && ch2 <= 55;
      }
      NON_ASCII_WHITESPACES = [
        5760,
        8192,
        8193,
        8194,
        8195,
        8196,
        8197,
        8198,
        8199,
        8200,
        8201,
        8202,
        8239,
        8287,
        12288,
        65279
      ];
      function isWhiteSpace(ch2) {
        return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && NON_ASCII_WHITESPACES.indexOf(ch2) >= 0;
      }
      function isLineTerminator(ch2) {
        return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
      }
      function fromCodePoint(cp) {
        if (cp <= 65535) {
          return String.fromCharCode(cp);
        }
        var cu1 = String.fromCharCode(Math.floor((cp - 65536) / 1024) + 55296);
        var cu2 = String.fromCharCode((cp - 65536) % 1024 + 56320);
        return cu1 + cu2;
      }
      IDENTIFIER_START = new Array(128);
      for (ch = 0; ch < 128; ++ch) {
        IDENTIFIER_START[ch] = ch >= 97 && ch <= 122 || // a..z
        ch >= 65 && ch <= 90 || // A..Z
        ch === 36 || ch === 95;
      }
      IDENTIFIER_PART = new Array(128);
      for (ch = 0; ch < 128; ++ch) {
        IDENTIFIER_PART[ch] = ch >= 97 && ch <= 122 || // a..z
        ch >= 65 && ch <= 90 || // A..Z
        ch >= 48 && ch <= 57 || // 0..9
        ch === 36 || ch === 95;
      }
      function isIdentifierStartES5(ch2) {
        return ch2 < 128 ? IDENTIFIER_START[ch2] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));
      }
      function isIdentifierPartES5(ch2) {
        return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));
      }
      function isIdentifierStartES6(ch2) {
        return ch2 < 128 ? IDENTIFIER_START[ch2] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));
      }
      function isIdentifierPartES6(ch2) {
        return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));
      }
      module.exports = {
        isDecimalDigit: isDecimalDigit2,
        isHexDigit: isHexDigit2,
        isOctalDigit: isOctalDigit2,
        isWhiteSpace,
        isLineTerminator,
        isIdentifierStartES5,
        isIdentifierPartES5,
        isIdentifierStartES6,
        isIdentifierPartES6
      };
    })();
  }
});

// node_modules/esutils/lib/keyword.js
var require_keyword = __commonJS({
  "node_modules/esutils/lib/keyword.js"(exports, module) {
    (function() {
      "use strict";
      var code = require_code();
      function isStrictModeReservedWordES6(id) {
        switch (id) {
          case "implements":
          case "interface":
          case "package":
          case "private":
          case "protected":
          case "public":
          case "static":
          case "let":
            return true;
          default:
            return false;
        }
      }
      function isKeywordES5(id, strict) {
        if (!strict && id === "yield") {
          return false;
        }
        return isKeywordES6(id, strict);
      }
      function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
          return true;
        }
        switch (id.length) {
          case 2:
            return id === "if" || id === "in" || id === "do";
          case 3:
            return id === "var" || id === "for" || id === "new" || id === "try";
          case 4:
            return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
          case 5:
            return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
          case 6:
            return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
          case 7:
            return id === "default" || id === "finally" || id === "extends";
          case 8:
            return id === "function" || id === "continue" || id === "debugger";
          case 10:
            return id === "instanceof";
          default:
            return false;
        }
      }
      function isReservedWordES5(id, strict) {
        return id === "null" || id === "true" || id === "false" || isKeywordES5(id, strict);
      }
      function isReservedWordES6(id, strict) {
        return id === "null" || id === "true" || id === "false" || isKeywordES6(id, strict);
      }
      function isRestrictedWord(id) {
        return id === "eval" || id === "arguments";
      }
      function isIdentifierNameES5(id) {
        var i, iz, ch;
        if (id.length === 0) {
          return false;
        }
        ch = id.charCodeAt(0);
        if (!code.isIdentifierStartES5(ch)) {
          return false;
        }
        for (i = 1, iz = id.length; i < iz; ++i) {
          ch = id.charCodeAt(i);
          if (!code.isIdentifierPartES5(ch)) {
            return false;
          }
        }
        return true;
      }
      function decodeUtf16(lead, trail) {
        return (lead - 55296) * 1024 + (trail - 56320) + 65536;
      }
      function isIdentifierNameES6(id) {
        var i, iz, ch, lowCh, check2;
        if (id.length === 0) {
          return false;
        }
        check2 = code.isIdentifierStartES6;
        for (i = 0, iz = id.length; i < iz; ++i) {
          ch = id.charCodeAt(i);
          if (55296 <= ch && ch <= 56319) {
            ++i;
            if (i >= iz) {
              return false;
            }
            lowCh = id.charCodeAt(i);
            if (!(56320 <= lowCh && lowCh <= 57343)) {
              return false;
            }
            ch = decodeUtf16(ch, lowCh);
          }
          if (!check2(ch)) {
            return false;
          }
          check2 = code.isIdentifierPartES6;
        }
        return true;
      }
      function isIdentifierES5(id, strict) {
        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
      }
      function isIdentifierES6(id, strict) {
        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
      }
      module.exports = {
        isKeywordES5,
        isKeywordES6,
        isReservedWordES5,
        isReservedWordES6,
        isRestrictedWord,
        isIdentifierNameES5,
        isIdentifierNameES6,
        isIdentifierES5,
        isIdentifierES6
      };
    })();
  }
});

// node_modules/esutils/lib/utils.js
var require_utils = __commonJS({
  "node_modules/esutils/lib/utils.js"(exports) {
    (function() {
      "use strict";
      exports.ast = require_ast();
      exports.code = require_code();
      exports.keyword = require_keyword();
    })();
  }
});

// node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map/lib/base64.js"(exports) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports.encode = function(number4) {
      if (0 <= number4 && number4 < intToCharMap.length) {
        return intToCharMap[number4];
      }
      throw new TypeError("Must be between 0 and 63: " + number4);
    };
    exports.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero2 = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero2 <= charCode && charCode <= nine) {
        return charCode - zero2 + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map/lib/base64-vlq.js"(exports) {
    var base643 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base643.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base643.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map/lib/util.js
var require_util = __commonJS({
  "node_modules/source-map/lib/util.js"(exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url2 = "";
      if (aParsedUrl.scheme) {
        url2 += aParsedUrl.scheme + ":";
      }
      url2 += "//";
      if (aParsedUrl.auth) {
        url2 += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url2 += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url2 += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url2 += aParsedUrl.path;
      }
      return url2;
    }
    exports.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path2 = aPath;
      var url2 = urlParse(aPath);
      if (url2) {
        if (!url2.path) {
          return aPath;
        }
        path2 = url2.path;
      }
      var isAbsolute = exports.isAbsolute(path2);
      var parts = path2.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path2 = parts.join("/");
      if (path2 === "") {
        path2 = isAbsolute ? "/" : ".";
      }
      if (url2) {
        url2.path = path2;
        return urlGenerate(url2);
      }
      return path2;
    }
    exports.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
  }
});

// node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map/lib/array-set.js"(exports) {
    var util = require_util();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set3 = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set3.add(aArray[i], aAllowDuplicates);
      }
      return set3;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports.ArraySet = ArraySet;
  }
});

// node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map/lib/mapping-list.js"(exports) {
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports.MappingList = MappingList;
  }
});

// node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map/lib/source-map-generator.js"(exports) {
    var base64VLQ = require_base64_vlq();
    var util = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
        );
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map3 = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map3.file = this._file;
      }
      if (this._sourceRoot != null) {
        map3.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map3.sourcesContent = this._generateSourcesContent(map3.sources, map3.sourceRoot);
      }
      return map3;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/source-map/lib/binary-search.js
var require_binary_search = __commonJS({
  "node_modules/source-map/lib/binary-search.js"(exports) {
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports.GREATEST_LOWER_BOUND
      );
      if (index < 0) {
        return -1;
      }
      while (index - 1 >= 0) {
        if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
          break;
        }
        --index;
      }
      return index;
    };
  }
});

// node_modules/source-map/lib/quick-sort.js
var require_quick_sort = __commonJS({
  "node_modules/source-map/lib/quick-sort.js"(exports) {
    function swap(ary, x, y) {
      var temp = ary[x];
      ary[x] = ary[y];
      ary[y] = temp;
    }
    function randomIntInRange(low, high) {
      return Math.round(low + Math.random() * (high - low));
    }
    function doQuickSort(ary, comparator, p2, r) {
      if (p2 < r) {
        var pivotIndex = randomIntInRange(p2, r);
        var i = p2 - 1;
        swap(ary, pivotIndex, r);
        var pivot = ary[r];
        for (var j2 = p2; j2 < r; j2++) {
          if (comparator(ary[j2], pivot) <= 0) {
            i += 1;
            swap(ary, i, j2);
          }
        }
        swap(ary, i + 1, j2);
        var q = i + 1;
        doQuickSort(ary, comparator, p2, q - 1);
        doQuickSort(ary, comparator, q + 1, r);
      }
    }
    exports.quickSort = function(ary, comparator) {
      doQuickSort(ary, comparator, 0, ary.length - 1);
    };
  }
});

// node_modules/source-map/lib/source-map-consumer.js
var require_source_map_consumer = __commonJS({
  "node_modules/source-map/lib/source-map-consumer.js"(exports) {
    var util = require_util();
    var binarySearch = require_binary_search();
    var ArraySet = require_array_set().ArraySet;
    var base64VLQ = require_base64_vlq();
    var quickSort = require_quick_sort().quickSort;
    function SourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
    }
    SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
      return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
    };
    SourceMapConsumer.prototype._version = 3;
    SourceMapConsumer.prototype.__generatedMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__generatedMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__generatedMappings;
      }
    });
    SourceMapConsumer.prototype.__originalMappings = null;
    Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
      configurable: true,
      enumerable: true,
      get: function() {
        if (!this.__originalMappings) {
          this._parseMappings(this._mappings, this.sourceRoot);
        }
        return this.__originalMappings;
      }
    });
    SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
      var c4 = aStr.charAt(index);
      return c4 === ";" || c4 === ",";
    };
    SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      throw new Error("Subclasses must implement _parseMappings");
    };
    SourceMapConsumer.GENERATED_ORDER = 1;
    SourceMapConsumer.ORIGINAL_ORDER = 2;
    SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
    SourceMapConsumer.LEAST_UPPER_BOUND = 2;
    SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
      var context = aContext || null;
      var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
      var mappings;
      switch (order) {
        case SourceMapConsumer.GENERATED_ORDER:
          mappings = this._generatedMappings;
          break;
        case SourceMapConsumer.ORIGINAL_ORDER:
          mappings = this._originalMappings;
          break;
        default:
          throw new Error("Unknown order of iteration.");
      }
      var sourceRoot = this.sourceRoot;
      mappings.map(function(mapping) {
        var source = mapping.source === null ? null : this._sources.at(mapping.source);
        source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
        return {
          source,
          generatedLine: mapping.generatedLine,
          generatedColumn: mapping.generatedColumn,
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: mapping.name === null ? null : this._names.at(mapping.name)
        };
      }, this).forEach(aCallback, context);
    };
    SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
      var line = util.getArg(aArgs, "line");
      var needle = {
        source: util.getArg(aArgs, "source"),
        originalLine: line,
        originalColumn: util.getArg(aArgs, "column", 0)
      };
      needle.source = this._findSourceIndex(needle.source);
      if (needle.source < 0) {
        return [];
      }
      var mappings = [];
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        binarySearch.LEAST_UPPER_BOUND
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (aArgs.column === void 0) {
          var originalLine = mapping.originalLine;
          while (mapping && mapping.originalLine === originalLine) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        } else {
          var originalColumn = mapping.originalColumn;
          while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
            mappings.push({
              line: util.getArg(mapping, "generatedLine", null),
              column: util.getArg(mapping, "generatedColumn", null),
              lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
            });
            mapping = this._originalMappings[++index];
          }
        }
      }
      return mappings;
    };
    exports.SourceMapConsumer = SourceMapConsumer;
    function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version3 = util.getArg(sourceMap, "version");
      var sources = util.getArg(sourceMap, "sources");
      var names = util.getArg(sourceMap, "names", []);
      var sourceRoot = util.getArg(sourceMap, "sourceRoot", null);
      var sourcesContent = util.getArg(sourceMap, "sourcesContent", null);
      var mappings = util.getArg(sourceMap, "mappings");
      var file3 = util.getArg(sourceMap, "file", null);
      if (version3 != this._version) {
        throw new Error("Unsupported version: " + version3);
      }
      if (sourceRoot) {
        sourceRoot = util.normalize(sourceRoot);
      }
      sources = sources.map(String).map(util.normalize).map(function(source) {
        return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
      });
      this._names = ArraySet.fromArray(names.map(String), true);
      this._sources = ArraySet.fromArray(sources, true);
      this._absoluteSources = this._sources.toArray().map(function(s) {
        return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
      });
      this.sourceRoot = sourceRoot;
      this.sourcesContent = sourcesContent;
      this._mappings = mappings;
      this._sourceMapURL = aSourceMapURL;
      this.file = file3;
    }
    BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
    BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      if (this._sources.has(relativeSource)) {
        return this._sources.indexOf(relativeSource);
      }
      var i;
      for (i = 0; i < this._absoluteSources.length; ++i) {
        if (this._absoluteSources[i] == aSource) {
          return i;
        }
      }
      return -1;
    };
    BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
      var smc = Object.create(BasicSourceMapConsumer.prototype);
      var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
      var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
      smc.sourceRoot = aSourceMap._sourceRoot;
      smc.sourcesContent = aSourceMap._generateSourcesContent(
        smc._sources.toArray(),
        smc.sourceRoot
      );
      smc.file = aSourceMap._file;
      smc._sourceMapURL = aSourceMapURL;
      smc._absoluteSources = smc._sources.toArray().map(function(s) {
        return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
      });
      var generatedMappings = aSourceMap._mappings.toArray().slice();
      var destGeneratedMappings = smc.__generatedMappings = [];
      var destOriginalMappings = smc.__originalMappings = [];
      for (var i = 0, length = generatedMappings.length; i < length; i++) {
        var srcMapping = generatedMappings[i];
        var destMapping = new Mapping();
        destMapping.generatedLine = srcMapping.generatedLine;
        destMapping.generatedColumn = srcMapping.generatedColumn;
        if (srcMapping.source) {
          destMapping.source = sources.indexOf(srcMapping.source);
          destMapping.originalLine = srcMapping.originalLine;
          destMapping.originalColumn = srcMapping.originalColumn;
          if (srcMapping.name) {
            destMapping.name = names.indexOf(srcMapping.name);
          }
          destOriginalMappings.push(destMapping);
        }
        destGeneratedMappings.push(destMapping);
      }
      quickSort(smc.__originalMappings, util.compareByOriginalPositions);
      return smc;
    };
    BasicSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
      get: function() {
        return this._absoluteSources.slice();
      }
    });
    function Mapping() {
      this.generatedLine = 0;
      this.generatedColumn = 0;
      this.source = null;
      this.originalLine = null;
      this.originalColumn = null;
      this.name = null;
    }
    BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      var generatedLine = 1;
      var previousGeneratedColumn = 0;
      var previousOriginalLine = 0;
      var previousOriginalColumn = 0;
      var previousSource = 0;
      var previousName = 0;
      var length = aStr.length;
      var index = 0;
      var cachedSegments = {};
      var temp = {};
      var originalMappings = [];
      var generatedMappings = [];
      var mapping, str, segment, end, value;
      while (index < length) {
        if (aStr.charAt(index) === ";") {
          generatedLine++;
          index++;
          previousGeneratedColumn = 0;
        } else if (aStr.charAt(index) === ",") {
          index++;
        } else {
          mapping = new Mapping();
          mapping.generatedLine = generatedLine;
          for (end = index; end < length; end++) {
            if (this._charIsMappingSeparator(aStr, end)) {
              break;
            }
          }
          str = aStr.slice(index, end);
          segment = cachedSegments[str];
          if (segment) {
            index += str.length;
          } else {
            segment = [];
            while (index < end) {
              base64VLQ.decode(aStr, index, temp);
              value = temp.value;
              index = temp.rest;
              segment.push(value);
            }
            if (segment.length === 2) {
              throw new Error("Found a source, but no line and column");
            }
            if (segment.length === 3) {
              throw new Error("Found a source and line, but no column");
            }
            cachedSegments[str] = segment;
          }
          mapping.generatedColumn = previousGeneratedColumn + segment[0];
          previousGeneratedColumn = mapping.generatedColumn;
          if (segment.length > 1) {
            mapping.source = previousSource + segment[1];
            previousSource += segment[1];
            mapping.originalLine = previousOriginalLine + segment[2];
            previousOriginalLine = mapping.originalLine;
            mapping.originalLine += 1;
            mapping.originalColumn = previousOriginalColumn + segment[3];
            previousOriginalColumn = mapping.originalColumn;
            if (segment.length > 4) {
              mapping.name = previousName + segment[4];
              previousName += segment[4];
            }
          }
          generatedMappings.push(mapping);
          if (typeof mapping.originalLine === "number") {
            originalMappings.push(mapping);
          }
        }
      }
      quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
      this.__generatedMappings = generatedMappings;
      quickSort(originalMappings, util.compareByOriginalPositions);
      this.__originalMappings = originalMappings;
    };
    BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
      if (aNeedle[aLineName] <= 0) {
        throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
      }
      if (aNeedle[aColumnName] < 0) {
        throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
      }
      return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
    };
    BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
      for (var index = 0; index < this._generatedMappings.length; ++index) {
        var mapping = this._generatedMappings[index];
        if (index + 1 < this._generatedMappings.length) {
          var nextMapping = this._generatedMappings[index + 1];
          if (mapping.generatedLine === nextMapping.generatedLine) {
            mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
            continue;
          }
        }
        mapping.lastGeneratedColumn = Infinity;
      }
    };
    BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._generatedMappings,
        "generatedLine",
        "generatedColumn",
        util.compareByGeneratedPositionsDeflated,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._generatedMappings[index];
        if (mapping.generatedLine === needle.generatedLine) {
          var source = util.getArg(mapping, "source", null);
          if (source !== null) {
            source = this._sources.at(source);
            source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
          }
          var name = util.getArg(mapping, "name", null);
          if (name !== null) {
            name = this._names.at(name);
          }
          return {
            source,
            line: util.getArg(mapping, "originalLine", null),
            column: util.getArg(mapping, "originalColumn", null),
            name
          };
        }
      }
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    };
    BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
      if (!this.sourcesContent) {
        return false;
      }
      return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
        return sc == null;
      });
    };
    BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      if (!this.sourcesContent) {
        return null;
      }
      var index = this._findSourceIndex(aSource);
      if (index >= 0) {
        return this.sourcesContent[index];
      }
      var relativeSource = aSource;
      if (this.sourceRoot != null) {
        relativeSource = util.relative(this.sourceRoot, relativeSource);
      }
      var url2;
      if (this.sourceRoot != null && (url2 = util.urlParse(this.sourceRoot))) {
        var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
        if (url2.scheme == "file" && this._sources.has(fileUriAbsPath)) {
          return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
        }
        if ((!url2.path || url2.path == "/") && this._sources.has("/" + relativeSource)) {
          return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + relativeSource + '" is not in the SourceMap.');
      }
    };
    BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
      var source = util.getArg(aArgs, "source");
      source = this._findSourceIndex(source);
      if (source < 0) {
        return {
          line: null,
          column: null,
          lastColumn: null
        };
      }
      var needle = {
        source,
        originalLine: util.getArg(aArgs, "line"),
        originalColumn: util.getArg(aArgs, "column")
      };
      var index = this._findMapping(
        needle,
        this._originalMappings,
        "originalLine",
        "originalColumn",
        util.compareByOriginalPositions,
        util.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
      );
      if (index >= 0) {
        var mapping = this._originalMappings[index];
        if (mapping.source === needle.source) {
          return {
            line: util.getArg(mapping, "generatedLine", null),
            column: util.getArg(mapping, "generatedColumn", null),
            lastColumn: util.getArg(mapping, "lastGeneratedColumn", null)
          };
        }
      }
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    };
    exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
    function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
      var sourceMap = aSourceMap;
      if (typeof aSourceMap === "string") {
        sourceMap = util.parseSourceMapInput(aSourceMap);
      }
      var version3 = util.getArg(sourceMap, "version");
      var sections = util.getArg(sourceMap, "sections");
      if (version3 != this._version) {
        throw new Error("Unsupported version: " + version3);
      }
      this._sources = new ArraySet();
      this._names = new ArraySet();
      var lastOffset = {
        line: -1,
        column: 0
      };
      this._sections = sections.map(function(s) {
        if (s.url) {
          throw new Error("Support for url field in sections not implemented.");
        }
        var offset2 = util.getArg(s, "offset");
        var offsetLine = util.getArg(offset2, "line");
        var offsetColumn = util.getArg(offset2, "column");
        if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
          throw new Error("Section offsets must be ordered and non-overlapping.");
        }
        lastOffset = offset2;
        return {
          generatedOffset: {
            // The offset fields are 0-based, but we use 1-based indices when
            // encoding/decoding from VLQ.
            generatedLine: offsetLine + 1,
            generatedColumn: offsetColumn + 1
          },
          consumer: new SourceMapConsumer(util.getArg(s, "map"), aSourceMapURL)
        };
      });
    }
    IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
    IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
    IndexedSourceMapConsumer.prototype._version = 3;
    Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
      get: function() {
        var sources = [];
        for (var i = 0; i < this._sections.length; i++) {
          for (var j2 = 0; j2 < this._sections[i].consumer.sources.length; j2++) {
            sources.push(this._sections[i].consumer.sources[j2]);
          }
        }
        return sources;
      }
    });
    IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
      var needle = {
        generatedLine: util.getArg(aArgs, "line"),
        generatedColumn: util.getArg(aArgs, "column")
      };
      var sectionIndex = binarySearch.search(
        needle,
        this._sections,
        function(needle2, section2) {
          var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
          if (cmp) {
            return cmp;
          }
          return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
        }
      );
      var section = this._sections[sectionIndex];
      if (!section) {
        return {
          source: null,
          line: null,
          column: null,
          name: null
        };
      }
      return section.consumer.originalPositionFor({
        line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
        column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        bias: aArgs.bias
      });
    };
    IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
      return this._sections.every(function(s) {
        return s.consumer.hasContentsOfAllSources();
      });
    };
    IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var content = section.consumer.sourceContentFor(aSource, true);
        if (content) {
          return content;
        }
      }
      if (nullOnMissing) {
        return null;
      } else {
        throw new Error('"' + aSource + '" is not in the SourceMap.');
      }
    };
    IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        if (section.consumer._findSourceIndex(util.getArg(aArgs, "source")) === -1) {
          continue;
        }
        var generatedPosition = section.consumer.generatedPositionFor(aArgs);
        if (generatedPosition) {
          var ret = {
            line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
            column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
          };
          return ret;
        }
      }
      return {
        line: null,
        column: null
      };
    };
    IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
      this.__generatedMappings = [];
      this.__originalMappings = [];
      for (var i = 0; i < this._sections.length; i++) {
        var section = this._sections[i];
        var sectionMappings = section.consumer._generatedMappings;
        for (var j2 = 0; j2 < sectionMappings.length; j2++) {
          var mapping = sectionMappings[j2];
          var source = section.consumer._sources.at(mapping.source);
          source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
          this._sources.add(source);
          source = this._sources.indexOf(source);
          var name = null;
          if (mapping.name) {
            name = section.consumer._names.at(mapping.name);
            this._names.add(name);
            name = this._names.indexOf(name);
          }
          var adjustedMapping = {
            source,
            generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
            generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
            originalLine: mapping.originalLine,
            originalColumn: mapping.originalColumn,
            name
          };
          this.__generatedMappings.push(adjustedMapping);
          if (typeof adjustedMapping.originalLine === "number") {
            this.__originalMappings.push(adjustedMapping);
          }
        }
      }
      quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
      quickSort(this.__originalMappings, util.compareByOriginalPositions);
    };
    exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  }
});

// node_modules/source-map/lib/source-node.js
var require_source_node = __commonJS({
  "node_modules/source-map/lib/source-node.js"(exports) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var util = require_util();
    var REGEX_NEWLINE = /(\r?\n)/;
    var NEWLINE_CODE = 10;
    var isSourceNode = "$$$isSourceNode$$$";
    function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
      this.children = [];
      this.sourceContents = {};
      this.line = aLine == null ? null : aLine;
      this.column = aColumn == null ? null : aColumn;
      this.source = aSource == null ? null : aSource;
      this.name = aName == null ? null : aName;
      this[isSourceNode] = true;
      if (aChunks != null) this.add(aChunks);
    }
    SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
      var node = new SourceNode();
      var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
      var remainingLinesIndex = 0;
      var shiftNextLine = function() {
        var lineContents = getNextLine();
        var newLine = getNextLine() || "";
        return lineContents + newLine;
        function getNextLine() {
          return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
        }
      };
      var lastGeneratedLine = 1, lastGeneratedColumn = 0;
      var lastMapping = null;
      aSourceMapConsumer.eachMapping(function(mapping) {
        if (lastMapping !== null) {
          if (lastGeneratedLine < mapping.generatedLine) {
            addMappingWithCode(lastMapping, shiftNextLine());
            lastGeneratedLine++;
            lastGeneratedColumn = 0;
          } else {
            var nextLine = remainingLines[remainingLinesIndex] || "";
            var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
            remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
            lastGeneratedColumn = mapping.generatedColumn;
            addMappingWithCode(lastMapping, code);
            lastMapping = mapping;
            return;
          }
        }
        while (lastGeneratedLine < mapping.generatedLine) {
          node.add(shiftNextLine());
          lastGeneratedLine++;
        }
        if (lastGeneratedColumn < mapping.generatedColumn) {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          node.add(nextLine.substr(0, mapping.generatedColumn));
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
        }
        lastMapping = mapping;
      }, this);
      if (remainingLinesIndex < remainingLines.length) {
        if (lastMapping) {
          addMappingWithCode(lastMapping, shiftNextLine());
        }
        node.add(remainingLines.splice(remainingLinesIndex).join(""));
      }
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          if (aRelativePath != null) {
            sourceFile = util.join(aRelativePath, sourceFile);
          }
          node.setSourceContent(sourceFile, content);
        }
      });
      return node;
      function addMappingWithCode(mapping, code) {
        if (mapping === null || mapping.source === void 0) {
          node.add(code);
        } else {
          var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
          node.add(new SourceNode(
            mapping.originalLine,
            mapping.originalColumn,
            source,
            code,
            mapping.name
          ));
        }
      }
    };
    SourceNode.prototype.add = function SourceNode_add(aChunk) {
      if (Array.isArray(aChunk)) {
        aChunk.forEach(function(chunk) {
          this.add(chunk);
        }, this);
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        if (aChunk) {
          this.children.push(aChunk);
        }
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
      if (Array.isArray(aChunk)) {
        for (var i = aChunk.length - 1; i >= 0; i--) {
          this.prepend(aChunk[i]);
        }
      } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
        this.children.unshift(aChunk);
      } else {
        throw new TypeError(
          "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
        );
      }
      return this;
    };
    SourceNode.prototype.walk = function SourceNode_walk(aFn) {
      var chunk;
      for (var i = 0, len = this.children.length; i < len; i++) {
        chunk = this.children[i];
        if (chunk[isSourceNode]) {
          chunk.walk(aFn);
        } else {
          if (chunk !== "") {
            aFn(chunk, {
              source: this.source,
              line: this.line,
              column: this.column,
              name: this.name
            });
          }
        }
      }
    };
    SourceNode.prototype.join = function SourceNode_join(aSep) {
      var newChildren;
      var i;
      var len = this.children.length;
      if (len > 0) {
        newChildren = [];
        for (i = 0; i < len - 1; i++) {
          newChildren.push(this.children[i]);
          newChildren.push(aSep);
        }
        newChildren.push(this.children[i]);
        this.children = newChildren;
      }
      return this;
    };
    SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
      var lastChild = this.children[this.children.length - 1];
      if (lastChild[isSourceNode]) {
        lastChild.replaceRight(aPattern, aReplacement);
      } else if (typeof lastChild === "string") {
        this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
      } else {
        this.children.push("".replace(aPattern, aReplacement));
      }
      return this;
    };
    SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
      this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
    };
    SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
      for (var i = 0, len = this.children.length; i < len; i++) {
        if (this.children[i][isSourceNode]) {
          this.children[i].walkSourceContents(aFn);
        }
      }
      var sources = Object.keys(this.sourceContents);
      for (var i = 0, len = sources.length; i < len; i++) {
        aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
      }
    };
    SourceNode.prototype.toString = function SourceNode_toString() {
      var str = "";
      this.walk(function(chunk) {
        str += chunk;
      });
      return str;
    };
    SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
      var generated = {
        code: "",
        line: 1,
        column: 0
      };
      var map3 = new SourceMapGenerator(aArgs);
      var sourceMappingActive = false;
      var lastOriginalSource = null;
      var lastOriginalLine = null;
      var lastOriginalColumn = null;
      var lastOriginalName = null;
      this.walk(function(chunk, original) {
        generated.code += chunk;
        if (original.source !== null && original.line !== null && original.column !== null) {
          if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
            map3.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
          lastOriginalSource = original.source;
          lastOriginalLine = original.line;
          lastOriginalColumn = original.column;
          lastOriginalName = original.name;
          sourceMappingActive = true;
        } else if (sourceMappingActive) {
          map3.addMapping({
            generated: {
              line: generated.line,
              column: generated.column
            }
          });
          lastOriginalSource = null;
          sourceMappingActive = false;
        }
        for (var idx = 0, length = chunk.length; idx < length; idx++) {
          if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
            generated.line++;
            generated.column = 0;
            if (idx + 1 === length) {
              lastOriginalSource = null;
              sourceMappingActive = false;
            } else if (sourceMappingActive) {
              map3.addMapping({
                source: original.source,
                original: {
                  line: original.line,
                  column: original.column
                },
                generated: {
                  line: generated.line,
                  column: generated.column
                },
                name: original.name
              });
            }
          } else {
            generated.column++;
          }
        }
      });
      this.walkSourceContents(function(sourceFile, sourceContent) {
        map3.setSourceContent(sourceFile, sourceContent);
      });
      return { code: generated.code, map: map3 };
    };
    exports.SourceNode = SourceNode;
  }
});

// node_modules/source-map/source-map.js
var require_source_map = __commonJS({
  "node_modules/source-map/source-map.js"(exports) {
    exports.SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    exports.SourceMapConsumer = require_source_map_consumer().SourceMapConsumer;
    exports.SourceNode = require_source_node().SourceNode;
  }
});

// node_modules/escodegen/package.json
var require_package = __commonJS({
  "node_modules/escodegen/package.json"(exports, module) {
    module.exports = {
      name: "escodegen",
      description: "ECMAScript code generator",
      homepage: "http://github.com/estools/escodegen",
      main: "escodegen.js",
      bin: {
        esgenerate: "./bin/esgenerate.js",
        escodegen: "./bin/escodegen.js"
      },
      files: [
        "LICENSE.BSD",
        "README.md",
        "bin",
        "escodegen.js",
        "package.json"
      ],
      version: "2.1.0",
      engines: {
        node: ">=6.0"
      },
      maintainers: [
        {
          name: "Yusuke Suzuki",
          email: "utatane.tea@gmail.com",
          web: "http://github.com/Constellation"
        }
      ],
      repository: {
        type: "git",
        url: "http://github.com/estools/escodegen.git"
      },
      dependencies: {
        estraverse: "^5.2.0",
        esutils: "^2.0.2",
        esprima: "^4.0.1"
      },
      optionalDependencies: {
        "source-map": "~0.6.1"
      },
      devDependencies: {
        acorn: "^8.0.4",
        bluebird: "^3.4.7",
        "bower-registry-client": "^1.0.0",
        chai: "^4.2.0",
        "chai-exclude": "^2.0.2",
        "commonjs-everywhere": "^0.9.7",
        gulp: "^4.0.2",
        "gulp-eslint": "^6.0.0",
        "gulp-mocha": "^7.0.2",
        minimist: "^1.2.5",
        optionator: "^0.9.1",
        semver: "^7.3.4"
      },
      license: "BSD-2-Clause",
      scripts: {
        test: "gulp travis",
        "unit-test": "gulp test",
        lint: "gulp lint",
        release: "node tools/release.js",
        "build-min": "./node_modules/.bin/cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js",
        build: "./node_modules/.bin/cjsify -a path: tools/entry-point.js > escodegen.browser.js"
      }
    };
  }
});

// node_modules/escodegen/escodegen.js
var require_escodegen = __commonJS({
  "node_modules/escodegen/escodegen.js"(exports) {
    (function() {
      "use strict";
      var Syntax, Precedence, BinaryPrecedence, SourceNode, estraverse, esutils, base2, indent, json2, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra, parse8, sourceMap, sourceCode, preserveBlankLines, FORMAT_MINIFY, FORMAT_DEFAULTS;
      estraverse = require_estraverse();
      esutils = require_utils();
      Syntax = estraverse.Syntax;
      function isExpression(node) {
        return CodeGenerator.Expression.hasOwnProperty(node.type);
      }
      function isStatement(node) {
        return CodeGenerator.Statement.hasOwnProperty(node.type);
      }
      Precedence = {
        Sequence: 0,
        Yield: 1,
        Assignment: 1,
        Conditional: 2,
        ArrowFunction: 2,
        Coalesce: 3,
        LogicalOR: 4,
        LogicalAND: 5,
        BitwiseOR: 6,
        BitwiseXOR: 7,
        BitwiseAND: 8,
        Equality: 9,
        Relational: 10,
        BitwiseSHIFT: 11,
        Additive: 12,
        Multiplicative: 13,
        Exponentiation: 14,
        Await: 15,
        Unary: 15,
        Postfix: 16,
        OptionalChaining: 17,
        Call: 18,
        New: 19,
        TaggedTemplate: 20,
        Member: 21,
        Primary: 22
      };
      BinaryPrecedence = {
        "??": Precedence.Coalesce,
        "||": Precedence.LogicalOR,
        "&&": Precedence.LogicalAND,
        "|": Precedence.BitwiseOR,
        "^": Precedence.BitwiseXOR,
        "&": Precedence.BitwiseAND,
        "==": Precedence.Equality,
        "!=": Precedence.Equality,
        "===": Precedence.Equality,
        "!==": Precedence.Equality,
        "is": Precedence.Equality,
        "isnt": Precedence.Equality,
        "<": Precedence.Relational,
        ">": Precedence.Relational,
        "<=": Precedence.Relational,
        ">=": Precedence.Relational,
        "in": Precedence.Relational,
        "instanceof": Precedence.Relational,
        "<<": Precedence.BitwiseSHIFT,
        ">>": Precedence.BitwiseSHIFT,
        ">>>": Precedence.BitwiseSHIFT,
        "+": Precedence.Additive,
        "-": Precedence.Additive,
        "*": Precedence.Multiplicative,
        "%": Precedence.Multiplicative,
        "/": Precedence.Multiplicative,
        "**": Precedence.Exponentiation
      };
      var F_ALLOW_IN = 1, F_ALLOW_CALL = 1 << 1, F_ALLOW_UNPARATH_NEW = 1 << 2, F_FUNC_BODY = 1 << 3, F_DIRECTIVE_CTX = 1 << 4, F_SEMICOLON_OPT = 1 << 5, F_FOUND_COALESCE = 1 << 6;
      var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW, E_TTF = F_ALLOW_IN | F_ALLOW_CALL, E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW, E_TFF = F_ALLOW_IN, E_FFT = F_ALLOW_UNPARATH_NEW, E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;
      var S_TFFF = F_ALLOW_IN, S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT, S_FFFF = 0, S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX, S_TTFF = F_ALLOW_IN | F_FUNC_BODY;
      function getDefaultOptions() {
        return {
          indent: null,
          base: null,
          parse: null,
          comment: false,
          format: {
            indent: {
              style: "    ",
              base: 0,
              adjustMultilineComment: false
            },
            newline: "\n",
            space: " ",
            json: false,
            renumber: false,
            hexadecimal: false,
            quotes: "single",
            escapeless: false,
            compact: false,
            parentheses: true,
            semicolons: true,
            safeConcatenation: false,
            preserveBlankLines: false
          },
          moz: {
            comprehensionExpressionStartsWithAssignment: false,
            starlessGenerator: false
          },
          sourceMap: null,
          sourceMapRoot: null,
          sourceMapWithCode: false,
          directive: false,
          raw: true,
          verbatim: null,
          sourceCode: null
        };
      }
      function stringRepeat(str, num) {
        var result = "";
        for (num |= 0; num > 0; num >>>= 1, str += str) {
          if (num & 1) {
            result += str;
          }
        }
        return result;
      }
      function hasLineTerminator(str) {
        return /[\r\n]/g.test(str);
      }
      function endsWithLineTerminator(str) {
        var len = str.length;
        return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
      }
      function merge2(target, override) {
        var key;
        for (key in override) {
          if (override.hasOwnProperty(key)) {
            target[key] = override[key];
          }
        }
        return target;
      }
      function updateDeeply(target, override) {
        var key, val2;
        function isHashObject(target2) {
          return typeof target2 === "object" && target2 instanceof Object && !(target2 instanceof RegExp);
        }
        for (key in override) {
          if (override.hasOwnProperty(key)) {
            val2 = override[key];
            if (isHashObject(val2)) {
              if (isHashObject(target[key])) {
                updateDeeply(target[key], val2);
              } else {
                target[key] = updateDeeply({}, val2);
              }
            } else {
              target[key] = val2;
            }
          }
        }
        return target;
      }
      function generateNumber(value) {
        var result, point, temp, exponent, pos;
        if (value !== value) {
          throw new Error("Numeric literal whose value is NaN");
        }
        if (value < 0 || value === 0 && 1 / value < 0) {
          throw new Error("Numeric literal whose value is negative");
        }
        if (value === 1 / 0) {
          return json2 ? "null" : renumber ? "1e400" : "1e+400";
        }
        result = "" + value;
        if (!renumber || result.length < 3) {
          return result;
        }
        point = result.indexOf(".");
        if (!json2 && result.charCodeAt(0) === 48 && point === 1) {
          point = 0;
          result = result.slice(1);
        }
        temp = result;
        result = result.replace("e+", "e");
        exponent = 0;
        if ((pos = temp.indexOf("e")) > 0) {
          exponent = +temp.slice(pos + 1);
          temp = temp.slice(0, pos);
        }
        if (point >= 0) {
          exponent -= temp.length - point - 1;
          temp = +(temp.slice(0, point) + temp.slice(point + 1)) + "";
        }
        pos = 0;
        while (temp.charCodeAt(temp.length + pos - 1) === 48) {
          --pos;
        }
        if (pos !== 0) {
          exponent -= pos;
          temp = temp.slice(0, pos);
        }
        if (exponent !== 0) {
          temp += "e" + exponent;
        }
        if ((temp.length < result.length || hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = "0x" + value.toString(16)).length < result.length) && +temp === value) {
          result = temp;
        }
        return result;
      }
      function escapeRegExpCharacter(ch, previousIsBackslash) {
        if ((ch & ~1) === 8232) {
          return (previousIsBackslash ? "u" : "\\u") + (ch === 8232 ? "2028" : "2029");
        } else if (ch === 10 || ch === 13) {
          return (previousIsBackslash ? "" : "\\") + (ch === 10 ? "n" : "r");
        }
        return String.fromCharCode(ch);
      }
      function generateRegExp(reg) {
        var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;
        result = reg.toString();
        if (reg.source) {
          match = result.match(/\/([^/]*)$/);
          if (!match) {
            return result;
          }
          flags = match[1];
          result = "";
          characterInBrack = false;
          previousIsBackslash = false;
          for (i = 0, iz = reg.source.length; i < iz; ++i) {
            ch = reg.source.charCodeAt(i);
            if (!previousIsBackslash) {
              if (characterInBrack) {
                if (ch === 93) {
                  characterInBrack = false;
                }
              } else {
                if (ch === 47) {
                  result += "\\";
                } else if (ch === 91) {
                  characterInBrack = true;
                }
              }
              result += escapeRegExpCharacter(ch, previousIsBackslash);
              previousIsBackslash = ch === 92;
            } else {
              result += escapeRegExpCharacter(ch, previousIsBackslash);
              previousIsBackslash = false;
            }
          }
          return "/" + result + "/" + flags;
        }
        return result;
      }
      function escapeAllowedCharacter(code, next) {
        var hex;
        if (code === 8) {
          return "\\b";
        }
        if (code === 12) {
          return "\\f";
        }
        if (code === 9) {
          return "\\t";
        }
        hex = code.toString(16).toUpperCase();
        if (json2 || code > 255) {
          return "\\u" + "0000".slice(hex.length) + hex;
        } else if (code === 0 && !esutils.code.isDecimalDigit(next)) {
          return "\\0";
        } else if (code === 11) {
          return "\\x0B";
        } else {
          return "\\x" + "00".slice(hex.length) + hex;
        }
      }
      function escapeDisallowedCharacter(code) {
        if (code === 92) {
          return "\\\\";
        }
        if (code === 10) {
          return "\\n";
        }
        if (code === 13) {
          return "\\r";
        }
        if (code === 8232) {
          return "\\u2028";
        }
        if (code === 8233) {
          return "\\u2029";
        }
        throw new Error("Incorrectly classified character");
      }
      function escapeDirective(str) {
        var i, iz, code, quote;
        quote = quotes === "double" ? '"' : "'";
        for (i = 0, iz = str.length; i < iz; ++i) {
          code = str.charCodeAt(i);
          if (code === 39) {
            quote = '"';
            break;
          } else if (code === 34) {
            quote = "'";
            break;
          } else if (code === 92) {
            ++i;
          }
        }
        return quote + str + quote;
      }
      function escapeString(str) {
        var result = "", i, len, code, singleQuotes = 0, doubleQuotes = 0, single, quote;
        for (i = 0, len = str.length; i < len; ++i) {
          code = str.charCodeAt(i);
          if (code === 39) {
            ++singleQuotes;
          } else if (code === 34) {
            ++doubleQuotes;
          } else if (code === 47 && json2) {
            result += "\\";
          } else if (esutils.code.isLineTerminator(code) || code === 92) {
            result += escapeDisallowedCharacter(code);
            continue;
          } else if (!esutils.code.isIdentifierPartES5(code) && (json2 && code < 32 || !json2 && !escapeless && (code < 32 || code > 126))) {
            result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
            continue;
          }
          result += String.fromCharCode(code);
        }
        single = !(quotes === "double" || quotes === "auto" && doubleQuotes < singleQuotes);
        quote = single ? "'" : '"';
        if (!(single ? singleQuotes : doubleQuotes)) {
          return quote + result + quote;
        }
        str = result;
        result = quote;
        for (i = 0, len = str.length; i < len; ++i) {
          code = str.charCodeAt(i);
          if (code === 39 && single || code === 34 && !single) {
            result += "\\";
          }
          result += String.fromCharCode(code);
        }
        return result + quote;
      }
      function flattenToString(arr2) {
        var i, iz, elem, result = "";
        for (i = 0, iz = arr2.length; i < iz; ++i) {
          elem = arr2[i];
          result += Array.isArray(elem) ? flattenToString(elem) : elem;
        }
        return result;
      }
      function toSourceNodeWhenNeeded(generated, node) {
        if (!sourceMap) {
          if (Array.isArray(generated)) {
            return flattenToString(generated);
          } else {
            return generated;
          }
        }
        if (node == null) {
          if (generated instanceof SourceNode) {
            return generated;
          } else {
            node = {};
          }
        }
        if (node.loc == null) {
          return new SourceNode(null, null, sourceMap, generated, node.name || null);
        }
        return new SourceNode(node.loc.start.line, node.loc.start.column, sourceMap === true ? node.loc.source || null : sourceMap, generated, node.name || null);
      }
      function noEmptySpace() {
        return space ? space : " ";
      }
      function join(left, right) {
        var leftSource, rightSource, leftCharCode, rightCharCode;
        leftSource = toSourceNodeWhenNeeded(left).toString();
        if (leftSource.length === 0) {
          return [right];
        }
        rightSource = toSourceNodeWhenNeeded(right).toString();
        if (rightSource.length === 0) {
          return [left];
        }
        leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
        rightCharCode = rightSource.charCodeAt(0);
        if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) || leftCharCode === 47 && rightCharCode === 105) {
          return [left, noEmptySpace(), right];
        } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) || esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
          return [left, right];
        }
        return [left, space, right];
      }
      function addIndent(stmt) {
        return [base2, stmt];
      }
      function withIndent(fn2) {
        var previousBase;
        previousBase = base2;
        base2 += indent;
        fn2(base2);
        base2 = previousBase;
      }
      function calculateSpaces(str) {
        var i;
        for (i = str.length - 1; i >= 0; --i) {
          if (esutils.code.isLineTerminator(str.charCodeAt(i))) {
            break;
          }
        }
        return str.length - 1 - i;
      }
      function adjustMultilineComment(value, specialBase) {
        var array2, i, len, line, j2, spaces, previousBase, sn;
        array2 = value.split(/\r\n|[\r\n]/);
        spaces = Number.MAX_VALUE;
        for (i = 1, len = array2.length; i < len; ++i) {
          line = array2[i];
          j2 = 0;
          while (j2 < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j2))) {
            ++j2;
          }
          if (spaces > j2) {
            spaces = j2;
          }
        }
        if (typeof specialBase !== "undefined") {
          previousBase = base2;
          if (array2[1][spaces] === "*") {
            specialBase += " ";
          }
          base2 = specialBase;
        } else {
          if (spaces & 1) {
            --spaces;
          }
          previousBase = base2;
        }
        for (i = 1, len = array2.length; i < len; ++i) {
          sn = toSourceNodeWhenNeeded(addIndent(array2[i].slice(spaces)));
          array2[i] = sourceMap ? sn.join("") : sn;
        }
        base2 = previousBase;
        return array2.join("\n");
      }
      function generateComment(comment, specialBase) {
        if (comment.type === "Line") {
          if (endsWithLineTerminator(comment.value)) {
            return "//" + comment.value;
          } else {
            var result = "//" + comment.value;
            if (!preserveBlankLines) {
              result += "\n";
            }
            return result;
          }
        }
        if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
          return adjustMultilineComment("/*" + comment.value + "*/", specialBase);
        }
        return "/*" + comment.value + "*/";
      }
      function addComments(stmt, result) {
        var i, len, comment, save, tailingToStatement, specialBase, fragment, extRange, range2, prevRange, prefix, infix, suffix, count;
        if (stmt.leadingComments && stmt.leadingComments.length > 0) {
          save = result;
          if (preserveBlankLines) {
            comment = stmt.leadingComments[0];
            result = [];
            extRange = comment.extendedRange;
            range2 = comment.range;
            prefix = sourceCode.substring(extRange[0], range2[0]);
            count = (prefix.match(/\n/g) || []).length;
            if (count > 0) {
              result.push(stringRepeat("\n", count));
              result.push(addIndent(generateComment(comment)));
            } else {
              result.push(prefix);
              result.push(generateComment(comment));
            }
            prevRange = range2;
            for (i = 1, len = stmt.leadingComments.length; i < len; i++) {
              comment = stmt.leadingComments[i];
              range2 = comment.range;
              infix = sourceCode.substring(prevRange[1], range2[0]);
              count = (infix.match(/\n/g) || []).length;
              result.push(stringRepeat("\n", count));
              result.push(addIndent(generateComment(comment)));
              prevRange = range2;
            }
            suffix = sourceCode.substring(range2[1], extRange[1]);
            count = (suffix.match(/\n/g) || []).length;
            result.push(stringRepeat("\n", count));
          } else {
            comment = stmt.leadingComments[0];
            result = [];
            if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
              result.push("\n");
            }
            result.push(generateComment(comment));
            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
              result.push("\n");
            }
            for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {
              comment = stmt.leadingComments[i];
              fragment = [generateComment(comment)];
              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                fragment.push("\n");
              }
              result.push(addIndent(fragment));
            }
          }
          result.push(addIndent(save));
        }
        if (stmt.trailingComments) {
          if (preserveBlankLines) {
            comment = stmt.trailingComments[0];
            extRange = comment.extendedRange;
            range2 = comment.range;
            prefix = sourceCode.substring(extRange[0], range2[0]);
            count = (prefix.match(/\n/g) || []).length;
            if (count > 0) {
              result.push(stringRepeat("\n", count));
              result.push(addIndent(generateComment(comment)));
            } else {
              result.push(prefix);
              result.push(generateComment(comment));
            }
          } else {
            tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
            specialBase = stringRepeat(" ", calculateSpaces(toSourceNodeWhenNeeded([base2, result, indent]).toString()));
            for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {
              comment = stmt.trailingComments[i];
              if (tailingToStatement) {
                if (i === 0) {
                  result = [result, indent];
                } else {
                  result = [result, specialBase];
                }
                result.push(generateComment(comment, specialBase));
              } else {
                result = [result, addIndent(generateComment(comment))];
              }
              if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result = [result, "\n"];
              }
            }
          }
        }
        return result;
      }
      function generateBlankLines(start, end, result) {
        var j2, newlineCount = 0;
        for (j2 = start; j2 < end; j2++) {
          if (sourceCode[j2] === "\n") {
            newlineCount++;
          }
        }
        for (j2 = 1; j2 < newlineCount; j2++) {
          result.push(newline);
        }
      }
      function parenthesize(text2, current2, should) {
        if (current2 < should) {
          return ["(", text2, ")"];
        }
        return text2;
      }
      function generateVerbatimString(string4) {
        var i, iz, result;
        result = string4.split(/\r\n|\n/);
        for (i = 1, iz = result.length; i < iz; i++) {
          result[i] = newline + base2 + result[i];
        }
        return result;
      }
      function generateVerbatim(expr, precedence) {
        var verbatim, result, prec;
        verbatim = expr[extra.verbatim];
        if (typeof verbatim === "string") {
          result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);
        } else {
          result = generateVerbatimString(verbatim.content);
          prec = verbatim.precedence != null ? verbatim.precedence : Precedence.Sequence;
          result = parenthesize(result, prec, precedence);
        }
        return toSourceNodeWhenNeeded(result, expr);
      }
      function CodeGenerator() {
      }
      CodeGenerator.prototype.maybeBlock = function(stmt, flags) {
        var result, noLeadingComment, that = this;
        noLeadingComment = !extra.comment || !stmt.leadingComments;
        if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
          return [space, this.generateStatement(stmt, flags)];
        }
        if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
          return ";";
        }
        withIndent(function() {
          result = [
            newline,
            addIndent(that.generateStatement(stmt, flags))
          ];
        });
        return result;
      };
      CodeGenerator.prototype.maybeBlockSuffix = function(stmt, result) {
        var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
        if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
          return [result, space];
        }
        if (ends) {
          return [result, base2];
        }
        return [result, newline, base2];
      };
      function generateIdentifier(node) {
        return toSourceNodeWhenNeeded(node.name, node);
      }
      function generateAsyncPrefix(node, spaceRequired) {
        return node.async ? "async" + (spaceRequired ? noEmptySpace() : space) : "";
      }
      function generateStarSuffix(node) {
        var isGenerator = node.generator && !extra.moz.starlessGenerator;
        return isGenerator ? "*" + space : "";
      }
      function generateMethodPrefix(prop) {
        var func = prop.value, prefix = "";
        if (func.async) {
          prefix += generateAsyncPrefix(func, !prop.computed);
        }
        if (func.generator) {
          prefix += generateStarSuffix(func) ? "*" : "";
        }
        return prefix;
      }
      CodeGenerator.prototype.generatePattern = function(node, precedence, flags) {
        if (node.type === Syntax.Identifier) {
          return generateIdentifier(node);
        }
        return this.generateExpression(node, precedence, flags);
      };
      CodeGenerator.prototype.generateFunctionParams = function(node) {
        var i, iz, result, hasDefault;
        hasDefault = false;
        if (node.type === Syntax.ArrowFunctionExpression && !node.rest && (!node.defaults || node.defaults.length === 0) && node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
          result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];
        } else {
          result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];
          result.push("(");
          if (node.defaults) {
            hasDefault = true;
          }
          for (i = 0, iz = node.params.length; i < iz; ++i) {
            if (hasDefault && node.defaults[i]) {
              result.push(this.generateAssignment(node.params[i], node.defaults[i], "=", Precedence.Assignment, E_TTT));
            } else {
              result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));
            }
            if (i + 1 < iz) {
              result.push("," + space);
            }
          }
          if (node.rest) {
            if (node.params.length) {
              result.push("," + space);
            }
            result.push("...");
            result.push(generateIdentifier(node.rest));
          }
          result.push(")");
        }
        return result;
      };
      CodeGenerator.prototype.generateFunctionBody = function(node) {
        var result, expr;
        result = this.generateFunctionParams(node);
        if (node.type === Syntax.ArrowFunctionExpression) {
          result.push(space);
          result.push("=>");
        }
        if (node.expression) {
          result.push(space);
          expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);
          if (expr.toString().charAt(0) === "{") {
            expr = ["(", expr, ")"];
          }
          result.push(expr);
        } else {
          result.push(this.maybeBlock(node.body, S_TTFF));
        }
        return result;
      };
      CodeGenerator.prototype.generateIterationForStatement = function(operator, stmt, flags) {
        var result = ["for" + (stmt.await ? noEmptySpace() + "await" : "") + space + "("], that = this;
        withIndent(function() {
          if (stmt.left.type === Syntax.VariableDeclaration) {
            withIndent(function() {
              result.push(stmt.left.kind + noEmptySpace());
              result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));
            });
          } else {
            result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));
          }
          result = join(result, operator);
          result = [join(
            result,
            that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)
          ), ")"];
        });
        result.push(this.maybeBlock(stmt.body, flags));
        return result;
      };
      CodeGenerator.prototype.generatePropertyKey = function(expr, computed) {
        var result = [];
        if (computed) {
          result.push("[");
        }
        result.push(this.generateExpression(expr, Precedence.Assignment, E_TTT));
        if (computed) {
          result.push("]");
        }
        return result;
      };
      CodeGenerator.prototype.generateAssignment = function(left, right, operator, precedence, flags) {
        if (Precedence.Assignment < precedence) {
          flags |= F_ALLOW_IN;
        }
        return parenthesize(
          [
            this.generateExpression(left, Precedence.Call, flags),
            space + operator + space,
            this.generateExpression(right, Precedence.Assignment, flags)
          ],
          Precedence.Assignment,
          precedence
        );
      };
      CodeGenerator.prototype.semicolon = function(flags) {
        if (!semicolons && flags & F_SEMICOLON_OPT) {
          return "";
        }
        return ";";
      };
      CodeGenerator.Statement = {
        BlockStatement: function(stmt, flags) {
          var range2, content, result = ["{", newline], that = this;
          withIndent(function() {
            if (stmt.body.length === 0 && preserveBlankLines) {
              range2 = stmt.range;
              if (range2[1] - range2[0] > 2) {
                content = sourceCode.substring(range2[0] + 1, range2[1] - 1);
                if (content[0] === "\n") {
                  result = ["{"];
                }
                result.push(content);
              }
            }
            var i, iz, fragment, bodyFlags;
            bodyFlags = S_TFFF;
            if (flags & F_FUNC_BODY) {
              bodyFlags |= F_DIRECTIVE_CTX;
            }
            for (i = 0, iz = stmt.body.length; i < iz; ++i) {
              if (preserveBlankLines) {
                if (i === 0) {
                  if (stmt.body[0].leadingComments) {
                    range2 = stmt.body[0].leadingComments[0].extendedRange;
                    content = sourceCode.substring(range2[0], range2[1]);
                    if (content[0] === "\n") {
                      result = ["{"];
                    }
                  }
                  if (!stmt.body[0].leadingComments) {
                    generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);
                  }
                }
                if (i > 0) {
                  if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
                    generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                  }
                }
              }
              if (i === iz - 1) {
                bodyFlags |= F_SEMICOLON_OPT;
              }
              if (stmt.body[i].leadingComments && preserveBlankLines) {
                fragment = that.generateStatement(stmt.body[i], bodyFlags);
              } else {
                fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));
              }
              result.push(fragment);
              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                if (preserveBlankLines && i < iz - 1) {
                  if (!stmt.body[i + 1].leadingComments) {
                    result.push(newline);
                  }
                } else {
                  result.push(newline);
                }
              }
              if (preserveBlankLines) {
                if (i === iz - 1) {
                  if (!stmt.body[i].trailingComments) {
                    generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                  }
                }
              }
            }
          });
          result.push(addIndent("}"));
          return result;
        },
        BreakStatement: function(stmt, flags) {
          if (stmt.label) {
            return "break " + stmt.label.name + this.semicolon(flags);
          }
          return "break" + this.semicolon(flags);
        },
        ContinueStatement: function(stmt, flags) {
          if (stmt.label) {
            return "continue " + stmt.label.name + this.semicolon(flags);
          }
          return "continue" + this.semicolon(flags);
        },
        ClassBody: function(stmt, flags) {
          var result = ["{", newline], that = this;
          withIndent(function(indent2) {
            var i, iz;
            for (i = 0, iz = stmt.body.length; i < iz; ++i) {
              result.push(indent2);
              result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));
              if (i + 1 < iz) {
                result.push(newline);
              }
            }
          });
          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(newline);
          }
          result.push(base2);
          result.push("}");
          return result;
        },
        ClassDeclaration: function(stmt, flags) {
          var result, fragment;
          result = ["class"];
          if (stmt.id) {
            result = join(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));
          }
          if (stmt.superClass) {
            fragment = join("extends", this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT));
            result = join(result, fragment);
          }
          result.push(space);
          result.push(this.generateStatement(stmt.body, S_TFFT));
          return result;
        },
        DirectiveStatement: function(stmt, flags) {
          if (extra.raw && stmt.raw) {
            return stmt.raw + this.semicolon(flags);
          }
          return escapeDirective(stmt.directive) + this.semicolon(flags);
        },
        DoWhileStatement: function(stmt, flags) {
          var result = join("do", this.maybeBlock(stmt.body, S_TFFF));
          result = this.maybeBlockSuffix(stmt.body, result);
          return join(result, [
            "while" + space + "(",
            this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
            ")" + this.semicolon(flags)
          ]);
        },
        CatchClause: function(stmt, flags) {
          var result, that = this;
          withIndent(function() {
            var guard;
            if (stmt.param) {
              result = [
                "catch" + space + "(",
                that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),
                ")"
              ];
              if (stmt.guard) {
                guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);
                result.splice(2, 0, " if ", guard);
              }
            } else {
              result = ["catch"];
            }
          });
          result.push(this.maybeBlock(stmt.body, S_TFFF));
          return result;
        },
        DebuggerStatement: function(stmt, flags) {
          return "debugger" + this.semicolon(flags);
        },
        EmptyStatement: function(stmt, flags) {
          return ";";
        },
        ExportDefaultDeclaration: function(stmt, flags) {
          var result = ["export"], bodyFlags;
          bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;
          result = join(result, "default");
          if (isStatement(stmt.declaration)) {
            result = join(result, this.generateStatement(stmt.declaration, bodyFlags));
          } else {
            result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));
          }
          return result;
        },
        ExportNamedDeclaration: function(stmt, flags) {
          var result = ["export"], bodyFlags, that = this;
          bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;
          if (stmt.declaration) {
            return join(result, this.generateStatement(stmt.declaration, bodyFlags));
          }
          if (stmt.specifiers) {
            if (stmt.specifiers.length === 0) {
              result = join(result, "{" + space + "}");
            } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {
              result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));
            } else {
              result = join(result, "{");
              withIndent(function(indent2) {
                var i, iz;
                result.push(newline);
                for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {
                  result.push(indent2);
                  result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                  if (i + 1 < iz) {
                    result.push("," + newline);
                  }
                }
              });
              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
              }
              result.push(base2 + "}");
            }
            if (stmt.source) {
              result = join(result, [
                "from" + space,
                // ModuleSpecifier
                this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
                this.semicolon(flags)
              ]);
            } else {
              result.push(this.semicolon(flags));
            }
          }
          return result;
        },
        ExportAllDeclaration: function(stmt, flags) {
          return [
            "export" + space,
            "*" + space,
            "from" + space,
            // ModuleSpecifier
            this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
            this.semicolon(flags)
          ];
        },
        ExpressionStatement: function(stmt, flags) {
          var result, fragment;
          function isClassPrefixed(fragment2) {
            var code;
            if (fragment2.slice(0, 5) !== "class") {
              return false;
            }
            code = fragment2.charCodeAt(5);
            return code === 123 || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);
          }
          function isFunctionPrefixed(fragment2) {
            var code;
            if (fragment2.slice(0, 8) !== "function") {
              return false;
            }
            code = fragment2.charCodeAt(8);
            return code === 40 || esutils.code.isWhiteSpace(code) || code === 42 || esutils.code.isLineTerminator(code);
          }
          function isAsyncPrefixed(fragment2) {
            var code, i, iz;
            if (fragment2.slice(0, 5) !== "async") {
              return false;
            }
            if (!esutils.code.isWhiteSpace(fragment2.charCodeAt(5))) {
              return false;
            }
            for (i = 6, iz = fragment2.length; i < iz; ++i) {
              if (!esutils.code.isWhiteSpace(fragment2.charCodeAt(i))) {
                break;
              }
            }
            if (i === iz) {
              return false;
            }
            if (fragment2.slice(i, i + 8) !== "function") {
              return false;
            }
            code = fragment2.charCodeAt(i + 8);
            return code === 40 || esutils.code.isWhiteSpace(code) || code === 42 || esutils.code.isLineTerminator(code);
          }
          result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];
          fragment = toSourceNodeWhenNeeded(result).toString();
          if (fragment.charCodeAt(0) === 123 || // ObjectExpression
          isClassPrefixed(fragment) || isFunctionPrefixed(fragment) || isAsyncPrefixed(fragment) || directive && flags & F_DIRECTIVE_CTX && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === "string") {
            result = ["(", result, ")" + this.semicolon(flags)];
          } else {
            result.push(this.semicolon(flags));
          }
          return result;
        },
        ImportDeclaration: function(stmt, flags) {
          var result, cursor, that = this;
          if (stmt.specifiers.length === 0) {
            return [
              "import",
              space,
              // ModuleSpecifier
              this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
              this.semicolon(flags)
            ];
          }
          result = [
            "import"
          ];
          cursor = 0;
          if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {
            result = join(result, [
              this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
            ]);
            ++cursor;
          }
          if (stmt.specifiers[cursor]) {
            if (cursor !== 0) {
              result.push(",");
            }
            if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {
              result = join(result, [
                space,
                this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
              ]);
            } else {
              result.push(space + "{");
              if (stmt.specifiers.length - cursor === 1) {
                result.push(space);
                result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));
                result.push(space + "}" + space);
              } else {
                withIndent(function(indent2) {
                  var i, iz;
                  result.push(newline);
                  for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {
                    result.push(indent2);
                    result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                    if (i + 1 < iz) {
                      result.push("," + newline);
                    }
                  }
                });
                if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                  result.push(newline);
                }
                result.push(base2 + "}" + space);
              }
            }
          }
          result = join(result, [
            "from" + space,
            // ModuleSpecifier
            this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
            this.semicolon(flags)
          ]);
          return result;
        },
        VariableDeclarator: function(stmt, flags) {
          var itemFlags = flags & F_ALLOW_IN ? E_TTT : E_FTT;
          if (stmt.init) {
            return [
              this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),
              space,
              "=",
              space,
              this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)
            ];
          }
          return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);
        },
        VariableDeclaration: function(stmt, flags) {
          var result, i, iz, node, bodyFlags, that = this;
          result = [stmt.kind];
          bodyFlags = flags & F_ALLOW_IN ? S_TFFF : S_FFFF;
          function block() {
            node = stmt.declarations[0];
            if (extra.comment && node.leadingComments) {
              result.push("\n");
              result.push(addIndent(that.generateStatement(node, bodyFlags)));
            } else {
              result.push(noEmptySpace());
              result.push(that.generateStatement(node, bodyFlags));
            }
            for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {
              node = stmt.declarations[i];
              if (extra.comment && node.leadingComments) {
                result.push("," + newline);
                result.push(addIndent(that.generateStatement(node, bodyFlags)));
              } else {
                result.push("," + space);
                result.push(that.generateStatement(node, bodyFlags));
              }
            }
          }
          if (stmt.declarations.length > 1) {
            withIndent(block);
          } else {
            block();
          }
          result.push(this.semicolon(flags));
          return result;
        },
        ThrowStatement: function(stmt, flags) {
          return [join(
            "throw",
            this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
          ), this.semicolon(flags)];
        },
        TryStatement: function(stmt, flags) {
          var result, i, iz, guardedHandlers;
          result = ["try", this.maybeBlock(stmt.block, S_TFFF)];
          result = this.maybeBlockSuffix(stmt.block, result);
          if (stmt.handlers) {
            for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {
              result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));
              if (stmt.finalizer || i + 1 !== iz) {
                result = this.maybeBlockSuffix(stmt.handlers[i].body, result);
              }
            }
          } else {
            guardedHandlers = stmt.guardedHandlers || [];
            for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {
              result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));
              if (stmt.finalizer || i + 1 !== iz) {
                result = this.maybeBlockSuffix(guardedHandlers[i].body, result);
              }
            }
            if (stmt.handler) {
              if (Array.isArray(stmt.handler)) {
                for (i = 0, iz = stmt.handler.length; i < iz; ++i) {
                  result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));
                  if (stmt.finalizer || i + 1 !== iz) {
                    result = this.maybeBlockSuffix(stmt.handler[i].body, result);
                  }
                }
              } else {
                result = join(result, this.generateStatement(stmt.handler, S_TFFF));
                if (stmt.finalizer) {
                  result = this.maybeBlockSuffix(stmt.handler.body, result);
                }
              }
            }
          }
          if (stmt.finalizer) {
            result = join(result, ["finally", this.maybeBlock(stmt.finalizer, S_TFFF)]);
          }
          return result;
        },
        SwitchStatement: function(stmt, flags) {
          var result, fragment, i, iz, bodyFlags, that = this;
          withIndent(function() {
            result = [
              "switch" + space + "(",
              that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),
              ")" + space + "{" + newline
            ];
          });
          if (stmt.cases) {
            bodyFlags = S_TFFF;
            for (i = 0, iz = stmt.cases.length; i < iz; ++i) {
              if (i === iz - 1) {
                bodyFlags |= F_SEMICOLON_OPT;
              }
              fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));
              result.push(fragment);
              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                result.push(newline);
              }
            }
          }
          result.push(addIndent("}"));
          return result;
        },
        SwitchCase: function(stmt, flags) {
          var result, fragment, i, iz, bodyFlags, that = this;
          withIndent(function() {
            if (stmt.test) {
              result = [
                join("case", that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),
                ":"
              ];
            } else {
              result = ["default:"];
            }
            i = 0;
            iz = stmt.consequent.length;
            if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {
              fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);
              result.push(fragment);
              i = 1;
            }
            if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
              result.push(newline);
            }
            bodyFlags = S_TFFF;
            for (; i < iz; ++i) {
              if (i === iz - 1 && flags & F_SEMICOLON_OPT) {
                bodyFlags |= F_SEMICOLON_OPT;
              }
              fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));
              result.push(fragment);
              if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
                result.push(newline);
              }
            }
          });
          return result;
        },
        IfStatement: function(stmt, flags) {
          var result, bodyFlags, semicolonOptional, that = this;
          withIndent(function() {
            result = [
              "if" + space + "(",
              that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
              ")"
            ];
          });
          semicolonOptional = flags & F_SEMICOLON_OPT;
          bodyFlags = S_TFFF;
          if (semicolonOptional) {
            bodyFlags |= F_SEMICOLON_OPT;
          }
          if (stmt.alternate) {
            result.push(this.maybeBlock(stmt.consequent, S_TFFF));
            result = this.maybeBlockSuffix(stmt.consequent, result);
            if (stmt.alternate.type === Syntax.IfStatement) {
              result = join(result, ["else ", this.generateStatement(stmt.alternate, bodyFlags)]);
            } else {
              result = join(result, join("else", this.maybeBlock(stmt.alternate, bodyFlags)));
            }
          } else {
            result.push(this.maybeBlock(stmt.consequent, bodyFlags));
          }
          return result;
        },
        ForStatement: function(stmt, flags) {
          var result, that = this;
          withIndent(function() {
            result = ["for" + space + "("];
            if (stmt.init) {
              if (stmt.init.type === Syntax.VariableDeclaration) {
                result.push(that.generateStatement(stmt.init, S_FFFF));
              } else {
                result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));
                result.push(";");
              }
            } else {
              result.push(";");
            }
            if (stmt.test) {
              result.push(space);
              result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));
              result.push(";");
            } else {
              result.push(";");
            }
            if (stmt.update) {
              result.push(space);
              result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));
              result.push(")");
            } else {
              result.push(")");
            }
          });
          result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
          return result;
        },
        ForInStatement: function(stmt, flags) {
          return this.generateIterationForStatement("in", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
        },
        ForOfStatement: function(stmt, flags) {
          return this.generateIterationForStatement("of", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
        },
        LabeledStatement: function(stmt, flags) {
          return [stmt.label.name + ":", this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];
        },
        Program: function(stmt, flags) {
          var result, fragment, i, iz, bodyFlags;
          iz = stmt.body.length;
          result = [safeConcatenation && iz > 0 ? "\n" : ""];
          bodyFlags = S_TFTF;
          for (i = 0; i < iz; ++i) {
            if (!safeConcatenation && i === iz - 1) {
              bodyFlags |= F_SEMICOLON_OPT;
            }
            if (preserveBlankLines) {
              if (i === 0) {
                if (!stmt.body[0].leadingComments) {
                  generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);
                }
              }
              if (i > 0) {
                if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
                  generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                }
              }
            }
            fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));
            result.push(fragment);
            if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
              if (preserveBlankLines) {
                if (!stmt.body[i + 1].leadingComments) {
                  result.push(newline);
                }
              } else {
                result.push(newline);
              }
            }
            if (preserveBlankLines) {
              if (i === iz - 1) {
                if (!stmt.body[i].trailingComments) {
                  generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                }
              }
            }
          }
          return result;
        },
        FunctionDeclaration: function(stmt, flags) {
          return [
            generateAsyncPrefix(stmt, true),
            "function",
            generateStarSuffix(stmt) || noEmptySpace(),
            stmt.id ? generateIdentifier(stmt.id) : "",
            this.generateFunctionBody(stmt)
          ];
        },
        ReturnStatement: function(stmt, flags) {
          if (stmt.argument) {
            return [join(
              "return",
              this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
            ), this.semicolon(flags)];
          }
          return ["return" + this.semicolon(flags)];
        },
        WhileStatement: function(stmt, flags) {
          var result, that = this;
          withIndent(function() {
            result = [
              "while" + space + "(",
              that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
              ")"
            ];
          });
          result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
          return result;
        },
        WithStatement: function(stmt, flags) {
          var result, that = this;
          withIndent(function() {
            result = [
              "with" + space + "(",
              that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),
              ")"
            ];
          });
          result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
          return result;
        }
      };
      merge2(CodeGenerator.prototype, CodeGenerator.Statement);
      CodeGenerator.Expression = {
        SequenceExpression: function(expr, precedence, flags) {
          var result, i, iz;
          if (Precedence.Sequence < precedence) {
            flags |= F_ALLOW_IN;
          }
          result = [];
          for (i = 0, iz = expr.expressions.length; i < iz; ++i) {
            result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));
            if (i + 1 < iz) {
              result.push("," + space);
            }
          }
          return parenthesize(result, Precedence.Sequence, precedence);
        },
        AssignmentExpression: function(expr, precedence, flags) {
          return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);
        },
        ArrowFunctionExpression: function(expr, precedence, flags) {
          return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
        },
        ConditionalExpression: function(expr, precedence, flags) {
          if (Precedence.Conditional < precedence) {
            flags |= F_ALLOW_IN;
          }
          return parenthesize(
            [
              this.generateExpression(expr.test, Precedence.Coalesce, flags),
              space + "?" + space,
              this.generateExpression(expr.consequent, Precedence.Assignment, flags),
              space + ":" + space,
              this.generateExpression(expr.alternate, Precedence.Assignment, flags)
            ],
            Precedence.Conditional,
            precedence
          );
        },
        LogicalExpression: function(expr, precedence, flags) {
          if (expr.operator === "??") {
            flags |= F_FOUND_COALESCE;
          }
          return this.BinaryExpression(expr, precedence, flags);
        },
        BinaryExpression: function(expr, precedence, flags) {
          var result, leftPrecedence, rightPrecedence, currentPrecedence, fragment, leftSource;
          currentPrecedence = BinaryPrecedence[expr.operator];
          leftPrecedence = expr.operator === "**" ? Precedence.Postfix : currentPrecedence;
          rightPrecedence = expr.operator === "**" ? currentPrecedence : currentPrecedence + 1;
          if (currentPrecedence < precedence) {
            flags |= F_ALLOW_IN;
          }
          fragment = this.generateExpression(expr.left, leftPrecedence, flags);
          leftSource = fragment.toString();
          if (leftSource.charCodeAt(leftSource.length - 1) === 47 && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {
            result = [fragment, noEmptySpace(), expr.operator];
          } else {
            result = join(fragment, expr.operator);
          }
          fragment = this.generateExpression(expr.right, rightPrecedence, flags);
          if (expr.operator === "/" && fragment.toString().charAt(0) === "/" || expr.operator.slice(-1) === "<" && fragment.toString().slice(0, 3) === "!--") {
            result.push(noEmptySpace());
            result.push(fragment);
          } else {
            result = join(result, fragment);
          }
          if (expr.operator === "in" && !(flags & F_ALLOW_IN)) {
            return ["(", result, ")"];
          }
          if ((expr.operator === "||" || expr.operator === "&&") && flags & F_FOUND_COALESCE) {
            return ["(", result, ")"];
          }
          return parenthesize(result, currentPrecedence, precedence);
        },
        CallExpression: function(expr, precedence, flags) {
          var result, i, iz;
          result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];
          if (expr.optional) {
            result.push("?.");
          }
          result.push("(");
          for (i = 0, iz = expr["arguments"].length; i < iz; ++i) {
            result.push(this.generateExpression(expr["arguments"][i], Precedence.Assignment, E_TTT));
            if (i + 1 < iz) {
              result.push("," + space);
            }
          }
          result.push(")");
          if (!(flags & F_ALLOW_CALL)) {
            return ["(", result, ")"];
          }
          return parenthesize(result, Precedence.Call, precedence);
        },
        ChainExpression: function(expr, precedence, flags) {
          if (Precedence.OptionalChaining < precedence) {
            flags |= F_ALLOW_CALL;
          }
          var result = this.generateExpression(expr.expression, Precedence.OptionalChaining, flags);
          return parenthesize(result, Precedence.OptionalChaining, precedence);
        },
        NewExpression: function(expr, precedence, flags) {
          var result, length, i, iz, itemFlags;
          length = expr["arguments"].length;
          itemFlags = flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0 ? E_TFT : E_TFF;
          result = join(
            "new",
            this.generateExpression(expr.callee, Precedence.New, itemFlags)
          );
          if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {
            result.push("(");
            for (i = 0, iz = length; i < iz; ++i) {
              result.push(this.generateExpression(expr["arguments"][i], Precedence.Assignment, E_TTT));
              if (i + 1 < iz) {
                result.push("," + space);
              }
            }
            result.push(")");
          }
          return parenthesize(result, Precedence.New, precedence);
        },
        MemberExpression: function(expr, precedence, flags) {
          var result, fragment;
          result = [this.generateExpression(expr.object, Precedence.Call, flags & F_ALLOW_CALL ? E_TTF : E_TFF)];
          if (expr.computed) {
            if (expr.optional) {
              result.push("?.");
            }
            result.push("[");
            result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));
            result.push("]");
          } else {
            if (!expr.optional && expr.object.type === Syntax.Literal && typeof expr.object.value === "number") {
              fragment = toSourceNodeWhenNeeded(result).toString();
              if (fragment.indexOf(".") < 0 && !/[eExX]/.test(fragment) && esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) && !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)) {
                result.push(" ");
              }
            }
            result.push(expr.optional ? "?." : ".");
            result.push(generateIdentifier(expr.property));
          }
          return parenthesize(result, Precedence.Member, precedence);
        },
        MetaProperty: function(expr, precedence, flags) {
          var result;
          result = [];
          result.push(typeof expr.meta === "string" ? expr.meta : generateIdentifier(expr.meta));
          result.push(".");
          result.push(typeof expr.property === "string" ? expr.property : generateIdentifier(expr.property));
          return parenthesize(result, Precedence.Member, precedence);
        },
        UnaryExpression: function(expr, precedence, flags) {
          var result, fragment, rightCharCode, leftSource, leftCharCode;
          fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);
          if (space === "") {
            result = join(expr.operator, fragment);
          } else {
            result = [expr.operator];
            if (expr.operator.length > 2) {
              result = join(result, fragment);
            } else {
              leftSource = toSourceNodeWhenNeeded(result).toString();
              leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
              rightCharCode = fragment.toString().charCodeAt(0);
              if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode)) {
                result.push(noEmptySpace());
                result.push(fragment);
              } else {
                result.push(fragment);
              }
            }
          }
          return parenthesize(result, Precedence.Unary, precedence);
        },
        YieldExpression: function(expr, precedence, flags) {
          var result;
          if (expr.delegate) {
            result = "yield*";
          } else {
            result = "yield";
          }
          if (expr.argument) {
            result = join(
              result,
              this.generateExpression(expr.argument, Precedence.Yield, E_TTT)
            );
          }
          return parenthesize(result, Precedence.Yield, precedence);
        },
        AwaitExpression: function(expr, precedence, flags) {
          var result = join(
            expr.all ? "await*" : "await",
            this.generateExpression(expr.argument, Precedence.Await, E_TTT)
          );
          return parenthesize(result, Precedence.Await, precedence);
        },
        UpdateExpression: function(expr, precedence, flags) {
          if (expr.prefix) {
            return parenthesize(
              [
                expr.operator,
                this.generateExpression(expr.argument, Precedence.Unary, E_TTT)
              ],
              Precedence.Unary,
              precedence
            );
          }
          return parenthesize(
            [
              this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),
              expr.operator
            ],
            Precedence.Postfix,
            precedence
          );
        },
        FunctionExpression: function(expr, precedence, flags) {
          var result = [
            generateAsyncPrefix(expr, true),
            "function"
          ];
          if (expr.id) {
            result.push(generateStarSuffix(expr) || noEmptySpace());
            result.push(generateIdentifier(expr.id));
          } else {
            result.push(generateStarSuffix(expr) || space);
          }
          result.push(this.generateFunctionBody(expr));
          return result;
        },
        ArrayPattern: function(expr, precedence, flags) {
          return this.ArrayExpression(expr, precedence, flags, true);
        },
        ArrayExpression: function(expr, precedence, flags, isPattern) {
          var result, multiline, that = this;
          if (!expr.elements.length) {
            return "[]";
          }
          multiline = isPattern ? false : expr.elements.length > 1;
          result = ["[", multiline ? newline : ""];
          withIndent(function(indent2) {
            var i, iz;
            for (i = 0, iz = expr.elements.length; i < iz; ++i) {
              if (!expr.elements[i]) {
                if (multiline) {
                  result.push(indent2);
                }
                if (i + 1 === iz) {
                  result.push(",");
                }
              } else {
                result.push(multiline ? indent2 : "");
                result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));
              }
              if (i + 1 < iz) {
                result.push("," + (multiline ? newline : space));
              }
            }
          });
          if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(newline);
          }
          result.push(multiline ? base2 : "");
          result.push("]");
          return result;
        },
        RestElement: function(expr, precedence, flags) {
          return "..." + this.generatePattern(expr.argument);
        },
        ClassExpression: function(expr, precedence, flags) {
          var result, fragment;
          result = ["class"];
          if (expr.id) {
            result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));
          }
          if (expr.superClass) {
            fragment = join("extends", this.generateExpression(expr.superClass, Precedence.Unary, E_TTT));
            result = join(result, fragment);
          }
          result.push(space);
          result.push(this.generateStatement(expr.body, S_TFFT));
          return result;
        },
        MethodDefinition: function(expr, precedence, flags) {
          var result, fragment;
          if (expr["static"]) {
            result = ["static" + space];
          } else {
            result = [];
          }
          if (expr.kind === "get" || expr.kind === "set") {
            fragment = [
              join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),
              this.generateFunctionBody(expr.value)
            ];
          } else {
            fragment = [
              generateMethodPrefix(expr),
              this.generatePropertyKey(expr.key, expr.computed),
              this.generateFunctionBody(expr.value)
            ];
          }
          return join(result, fragment);
        },
        Property: function(expr, precedence, flags) {
          if (expr.kind === "get" || expr.kind === "set") {
            return [
              expr.kind,
              noEmptySpace(),
              this.generatePropertyKey(expr.key, expr.computed),
              this.generateFunctionBody(expr.value)
            ];
          }
          if (expr.shorthand) {
            if (expr.value.type === "AssignmentPattern") {
              return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);
            }
            return this.generatePropertyKey(expr.key, expr.computed);
          }
          if (expr.method) {
            return [
              generateMethodPrefix(expr),
              this.generatePropertyKey(expr.key, expr.computed),
              this.generateFunctionBody(expr.value)
            ];
          }
          return [
            this.generatePropertyKey(expr.key, expr.computed),
            ":" + space,
            this.generateExpression(expr.value, Precedence.Assignment, E_TTT)
          ];
        },
        ObjectExpression: function(expr, precedence, flags) {
          var multiline, result, fragment, that = this;
          if (!expr.properties.length) {
            return "{}";
          }
          multiline = expr.properties.length > 1;
          withIndent(function() {
            fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);
          });
          if (!multiline) {
            if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
              return ["{", space, fragment, space, "}"];
            }
          }
          withIndent(function(indent2) {
            var i, iz;
            result = ["{", newline, indent2, fragment];
            if (multiline) {
              result.push("," + newline);
              for (i = 1, iz = expr.properties.length; i < iz; ++i) {
                result.push(indent2);
                result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
                if (i + 1 < iz) {
                  result.push("," + newline);
                }
              }
            }
          });
          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(newline);
          }
          result.push(base2);
          result.push("}");
          return result;
        },
        AssignmentPattern: function(expr, precedence, flags) {
          return this.generateAssignment(expr.left, expr.right, "=", precedence, flags);
        },
        ObjectPattern: function(expr, precedence, flags) {
          var result, i, iz, multiline, property, that = this;
          if (!expr.properties.length) {
            return "{}";
          }
          multiline = false;
          if (expr.properties.length === 1) {
            property = expr.properties[0];
            if (property.type === Syntax.Property && property.value.type !== Syntax.Identifier) {
              multiline = true;
            }
          } else {
            for (i = 0, iz = expr.properties.length; i < iz; ++i) {
              property = expr.properties[i];
              if (property.type === Syntax.Property && !property.shorthand) {
                multiline = true;
                break;
              }
            }
          }
          result = ["{", multiline ? newline : ""];
          withIndent(function(indent2) {
            var i2, iz2;
            for (i2 = 0, iz2 = expr.properties.length; i2 < iz2; ++i2) {
              result.push(multiline ? indent2 : "");
              result.push(that.generateExpression(expr.properties[i2], Precedence.Sequence, E_TTT));
              if (i2 + 1 < iz2) {
                result.push("," + (multiline ? newline : space));
              }
            }
          });
          if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(newline);
          }
          result.push(multiline ? base2 : "");
          result.push("}");
          return result;
        },
        ThisExpression: function(expr, precedence, flags) {
          return "this";
        },
        Super: function(expr, precedence, flags) {
          return "super";
        },
        Identifier: function(expr, precedence, flags) {
          return generateIdentifier(expr);
        },
        ImportDefaultSpecifier: function(expr, precedence, flags) {
          return generateIdentifier(expr.id || expr.local);
        },
        ImportNamespaceSpecifier: function(expr, precedence, flags) {
          var result = ["*"];
          var id = expr.id || expr.local;
          if (id) {
            result.push(space + "as" + noEmptySpace() + generateIdentifier(id));
          }
          return result;
        },
        ImportSpecifier: function(expr, precedence, flags) {
          var imported = expr.imported;
          var result = [imported.name];
          var local = expr.local;
          if (local && local.name !== imported.name) {
            result.push(noEmptySpace() + "as" + noEmptySpace() + generateIdentifier(local));
          }
          return result;
        },
        ExportSpecifier: function(expr, precedence, flags) {
          var local = expr.local;
          var result = [local.name];
          var exported = expr.exported;
          if (exported && exported.name !== local.name) {
            result.push(noEmptySpace() + "as" + noEmptySpace() + generateIdentifier(exported));
          }
          return result;
        },
        Literal: function(expr, precedence, flags) {
          var raw;
          if (expr.hasOwnProperty("raw") && parse8 && extra.raw) {
            try {
              raw = parse8(expr.raw).body[0].expression;
              if (raw.type === Syntax.Literal) {
                if (raw.value === expr.value) {
                  return expr.raw;
                }
              }
            } catch (e2) {
            }
          }
          if (expr.regex) {
            return "/" + expr.regex.pattern + "/" + expr.regex.flags;
          }
          if (typeof expr.value === "bigint") {
            return expr.value.toString() + "n";
          }
          if (expr.bigint) {
            return expr.bigint + "n";
          }
          if (expr.value === null) {
            return "null";
          }
          if (typeof expr.value === "string") {
            return escapeString(expr.value);
          }
          if (typeof expr.value === "number") {
            return generateNumber(expr.value);
          }
          if (typeof expr.value === "boolean") {
            return expr.value ? "true" : "false";
          }
          return generateRegExp(expr.value);
        },
        GeneratorExpression: function(expr, precedence, flags) {
          return this.ComprehensionExpression(expr, precedence, flags);
        },
        ComprehensionExpression: function(expr, precedence, flags) {
          var result, i, iz, fragment, that = this;
          result = expr.type === Syntax.GeneratorExpression ? ["("] : ["["];
          if (extra.moz.comprehensionExpressionStartsWithAssignment) {
            fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
            result.push(fragment);
          }
          if (expr.blocks) {
            withIndent(function() {
              for (i = 0, iz = expr.blocks.length; i < iz; ++i) {
                fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);
                if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
                  result = join(result, fragment);
                } else {
                  result.push(fragment);
                }
              }
            });
          }
          if (expr.filter) {
            result = join(result, "if" + space);
            fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);
            result = join(result, ["(", fragment, ")"]);
          }
          if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
            fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
            result = join(result, fragment);
          }
          result.push(expr.type === Syntax.GeneratorExpression ? ")" : "]");
          return result;
        },
        ComprehensionBlock: function(expr, precedence, flags) {
          var fragment;
          if (expr.left.type === Syntax.VariableDeclaration) {
            fragment = [
              expr.left.kind,
              noEmptySpace(),
              this.generateStatement(expr.left.declarations[0], S_FFFF)
            ];
          } else {
            fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);
          }
          fragment = join(fragment, expr.of ? "of" : "in");
          fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));
          return ["for" + space + "(", fragment, ")"];
        },
        SpreadElement: function(expr, precedence, flags) {
          return [
            "...",
            this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)
          ];
        },
        TaggedTemplateExpression: function(expr, precedence, flags) {
          var itemFlags = E_TTF;
          if (!(flags & F_ALLOW_CALL)) {
            itemFlags = E_TFF;
          }
          var result = [
            this.generateExpression(expr.tag, Precedence.Call, itemFlags),
            this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)
          ];
          return parenthesize(result, Precedence.TaggedTemplate, precedence);
        },
        TemplateElement: function(expr, precedence, flags) {
          return expr.value.raw;
        },
        TemplateLiteral: function(expr, precedence, flags) {
          var result, i, iz;
          result = ["`"];
          for (i = 0, iz = expr.quasis.length; i < iz; ++i) {
            result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));
            if (i + 1 < iz) {
              result.push("${" + space);
              result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));
              result.push(space + "}");
            }
          }
          result.push("`");
          return result;
        },
        ModuleSpecifier: function(expr, precedence, flags) {
          return this.Literal(expr, precedence, flags);
        },
        ImportExpression: function(expr, precedence, flag) {
          return parenthesize([
            "import(",
            this.generateExpression(expr.source, Precedence.Assignment, E_TTT),
            ")"
          ], Precedence.Call, precedence);
        }
      };
      merge2(CodeGenerator.prototype, CodeGenerator.Expression);
      CodeGenerator.prototype.generateExpression = function(expr, precedence, flags) {
        var result, type3;
        type3 = expr.type || Syntax.Property;
        if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
          return generateVerbatim(expr, precedence);
        }
        result = this[type3](expr, precedence, flags);
        if (extra.comment) {
          result = addComments(expr, result);
        }
        return toSourceNodeWhenNeeded(result, expr);
      };
      CodeGenerator.prototype.generateStatement = function(stmt, flags) {
        var result, fragment;
        result = this[stmt.type](stmt, flags);
        if (extra.comment) {
          result = addComments(stmt, result);
        }
        fragment = toSourceNodeWhenNeeded(result).toString();
        if (stmt.type === Syntax.Program && !safeConcatenation && newline === "" && fragment.charAt(fragment.length - 1) === "\n") {
          result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, "") : fragment.replace(/\s+$/, "");
        }
        return toSourceNodeWhenNeeded(result, stmt);
      };
      function generateInternal(node) {
        var codegen;
        codegen = new CodeGenerator();
        if (isStatement(node)) {
          return codegen.generateStatement(node, S_TFFF);
        }
        if (isExpression(node)) {
          return codegen.generateExpression(node, Precedence.Sequence, E_TTT);
        }
        throw new Error("Unknown node type: " + node.type);
      }
      function generate(node, options2) {
        var defaultOptions2 = getDefaultOptions(), result, pair;
        if (options2 != null) {
          if (typeof options2.indent === "string") {
            defaultOptions2.format.indent.style = options2.indent;
          }
          if (typeof options2.base === "number") {
            defaultOptions2.format.indent.base = options2.base;
          }
          options2 = updateDeeply(defaultOptions2, options2);
          indent = options2.format.indent.style;
          if (typeof options2.base === "string") {
            base2 = options2.base;
          } else {
            base2 = stringRepeat(indent, options2.format.indent.base);
          }
        } else {
          options2 = defaultOptions2;
          indent = options2.format.indent.style;
          base2 = stringRepeat(indent, options2.format.indent.base);
        }
        json2 = options2.format.json;
        renumber = options2.format.renumber;
        hexadecimal = json2 ? false : options2.format.hexadecimal;
        quotes = json2 ? "double" : options2.format.quotes;
        escapeless = options2.format.escapeless;
        newline = options2.format.newline;
        space = options2.format.space;
        if (options2.format.compact) {
          newline = space = indent = base2 = "";
        }
        parentheses = options2.format.parentheses;
        semicolons = options2.format.semicolons;
        safeConcatenation = options2.format.safeConcatenation;
        directive = options2.directive;
        parse8 = json2 ? null : options2.parse;
        sourceMap = options2.sourceMap;
        sourceCode = options2.sourceCode;
        preserveBlankLines = options2.format.preserveBlankLines && sourceCode !== null;
        extra = options2;
        if (sourceMap) {
          if (!exports.browser) {
            SourceNode = require_source_map().SourceNode;
          } else {
            SourceNode = global.sourceMap.SourceNode;
          }
        }
        result = generateInternal(node);
        if (!sourceMap) {
          pair = { code: result.toString(), map: null };
          return options2.sourceMapWithCode ? pair : pair.code;
        }
        pair = result.toStringWithSourceMap({
          file: options2.file,
          sourceRoot: options2.sourceMapRoot
        });
        if (options2.sourceContent) {
          pair.map.setSourceContent(
            options2.sourceMap,
            options2.sourceContent
          );
        }
        if (options2.sourceMapWithCode) {
          return pair;
        }
        return pair.map.toString();
      }
      FORMAT_MINIFY = {
        indent: {
          style: "",
          base: 0
        },
        renumber: true,
        hexadecimal: true,
        quotes: "auto",
        escapeless: true,
        compact: true,
        parentheses: false,
        semicolons: false
      };
      FORMAT_DEFAULTS = getDefaultOptions().format;
      exports.version = require_package().version;
      exports.generate = generate;
      exports.attachComments = estraverse.attachComments;
      exports.Precedence = updateDeeply({}, Precedence);
      exports.browser = false;
      exports.FORMAT_MINIFY = FORMAT_MINIFY;
      exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
    })();
  }
});

// node_modules/p5/dist/constants-8IpwyBct.js
var _PI = Math.PI;
var VERSION = "2.0.5";
var P2D = "p2d";
var P2DHDR = "p2d-hdr";
var WEBGL = "webgl";
var WEBGL2 = "webgl2";
var ARROW = "default";
var SIMPLE = "simple";
var FULL = "full";
var CROSS = "crosshair";
var HAND = "pointer";
var MOVE = "move";
var TEXT = "text";
var WAIT = "wait";
var HALF_PI = _PI / 2;
var PI = _PI;
var QUARTER_PI = _PI / 4;
var TAU = _PI * 2;
var TWO_PI = _PI * 2;
var DEG_TO_RAD = _PI / 180;
var RAD_TO_DEG = 180 / _PI;
var CORNER = "corner";
var CORNERS = "corners";
var RADIUS = "radius";
var RIGHT = "right";
var LEFT = "left";
var CENTER = "center";
var TOP = "top";
var BOTTOM = "bottom";
var BASELINE = "alphabetic";
var POINTS = 0;
var LINES = 1;
var LINE_STRIP = 3;
var LINE_LOOP = 2;
var TRIANGLES = 4;
var TRIANGLE_FAN = 6;
var TRIANGLE_STRIP = 5;
var QUADS = "quads";
var QUAD_STRIP = "quad_strip";
var TESS = "tess";
var EMPTY_PATH = 7;
var PATH = 8;
var CLOSE = "close";
var OPEN = "open";
var CHORD = "chord";
var PIE = "pie";
var PROJECT = "square";
var SQUARE = "butt";
var ROUND = "round";
var BEVEL = "bevel";
var MITER = "miter";
var AUTO = "auto";
var ALT = "Alt";
var BACKSPACE = "Backspace";
var CONTROL = "Control";
var DELETE = "Delete";
var DOWN_ARROW = "ArrowDown";
var ENTER = "Enter";
var ESCAPE = "Escape";
var LEFT_ARROW = "ArrowLeft";
var OPTION = "Alt";
var RETURN = "Enter";
var RIGHT_ARROW = "ArrowRight";
var SHIFT = "Shift";
var TAB = "Tab";
var UP_ARROW = "ArrowUp";
var BLEND = "source-over";
var REMOVE = "destination-out";
var ADD = "lighter";
var DARKEST = "darken";
var LIGHTEST = "lighten";
var DIFFERENCE = "difference";
var SUBTRACT = "subtract";
var EXCLUSION = "exclusion";
var MULTIPLY = "multiply";
var SCREEN = "screen";
var REPLACE = "copy";
var OVERLAY = "overlay";
var HARD_LIGHT = "hard-light";
var SOFT_LIGHT = "soft-light";
var DODGE = "color-dodge";
var BURN = "color-burn";
var THRESHOLD = "threshold";
var GRAY = "gray";
var OPAQUE = "opaque";
var INVERT = "invert";
var POSTERIZE = "posterize";
var DILATE = "dilate";
var ERODE = "erode";
var BLUR = "blur";
var NORMAL = "normal";
var ITALIC = "italic";
var BOLD = "bold";
var BOLDITALIC = "bold italic";
var CHAR = "CHAR";
var WORD = "WORD";
var _DEFAULT_TEXT_FILL = "#000000";
var _DEFAULT_LEADMULT = 1.25;
var _CTX_MIDDLE = "middle";
var LINEAR = "linear";
var QUADRATIC = "quadratic";
var BEZIER = "bezier";
var CURVE = "curve";
var STROKE = "stroke";
var FILL = "fill";
var TEXTURE = "texture";
var IMMEDIATE = "immediate";
var IMAGE = "image";
var NEAREST = "nearest";
var REPEAT = "repeat";
var CLAMP = "clamp";
var MIRROR = "mirror";
var FLAT = "flat";
var SMOOTH = "smooth";
var LANDSCAPE = "landscape";
var PORTRAIT = "portrait";
var _DEFAULT_STROKE = "#000000";
var _DEFAULT_FILL = "#FFFFFF";
var GRID = "grid";
var AXES = "axes";
var LABEL = "label";
var FALLBACK = "fallback";
var CONTAIN = "contain";
var COVER = "cover";
var UNSIGNED_BYTE = "unsigned-byte";
var UNSIGNED_INT = "unsigned-int";
var FLOAT = "float";
var HALF_FLOAT = "half-float";
var INCLUDE = Symbol("include");
var EXCLUDE = Symbol("exclude");
var JOIN = Symbol("join");
var constants = Object.freeze({
  __proto__: null,
  ADD,
  ALT,
  ARROW,
  AUTO,
  AXES,
  BACKSPACE,
  BASELINE,
  BEVEL,
  BEZIER,
  BLEND,
  BLUR,
  BOLD,
  BOLDITALIC,
  BOTTOM,
  BURN,
  CENTER,
  CHAR,
  CHORD,
  CLAMP,
  CLOSE,
  CONTAIN,
  CONTROL,
  CORNER,
  CORNERS,
  COVER,
  CROSS,
  CURVE,
  DARKEST,
  DEG_TO_RAD,
  DELETE,
  DIFFERENCE,
  DILATE,
  DODGE,
  DOWN_ARROW,
  EMPTY_PATH,
  ENTER,
  ERODE,
  ESCAPE,
  EXCLUDE,
  EXCLUSION,
  FALLBACK,
  FILL,
  FLAT,
  FLOAT,
  FULL,
  GRAY,
  GRID,
  HALF_FLOAT,
  HALF_PI,
  HAND,
  HARD_LIGHT,
  IMAGE,
  IMMEDIATE,
  INCLUDE,
  INVERT,
  ITALIC,
  JOIN,
  LABEL,
  LANDSCAPE,
  LEFT,
  LEFT_ARROW,
  LIGHTEST,
  LINEAR,
  LINES,
  LINE_LOOP,
  LINE_STRIP,
  MIRROR,
  MITER,
  MOVE,
  MULTIPLY,
  NEAREST,
  NORMAL,
  OPAQUE,
  OPEN,
  OPTION,
  OVERLAY,
  P2D,
  P2DHDR,
  PATH,
  PI,
  PIE,
  POINTS,
  PORTRAIT,
  POSTERIZE,
  PROJECT,
  QUADRATIC,
  QUADS,
  QUAD_STRIP,
  QUARTER_PI,
  RADIUS,
  RAD_TO_DEG,
  REMOVE,
  REPEAT,
  REPLACE,
  RETURN,
  RIGHT,
  RIGHT_ARROW,
  ROUND,
  SCREEN,
  SHIFT,
  SIMPLE,
  SMOOTH,
  SOFT_LIGHT,
  SQUARE,
  STROKE,
  SUBTRACT,
  TAB,
  TAU,
  TESS,
  TEXT,
  TEXTURE,
  THRESHOLD,
  TOP,
  TRIANGLES,
  TRIANGLE_FAN,
  TRIANGLE_STRIP,
  TWO_PI,
  UNSIGNED_BYTE,
  UNSIGNED_INT,
  UP_ARROW,
  VERSION,
  WAIT,
  WEBGL,
  WEBGL2,
  WORD,
  _CTX_MIDDLE,
  _DEFAULT_FILL,
  _DEFAULT_LEADMULT,
  _DEFAULT_STROKE,
  _DEFAULT_TEXT_FILL
});

// node_modules/p5/dist/core/transform.js
function transform(p53, fn2) {
  fn2.applyMatrix = function(...args) {
    let isTypedArray = args[0] instanceof Object.getPrototypeOf(Uint8Array);
    if (Array.isArray(args[0]) || isTypedArray) {
      this._renderer.applyMatrix(...args[0]);
    } else {
      this._renderer.applyMatrix(...args);
    }
    return this;
  };
  fn2.resetMatrix = function() {
    this._renderer.resetMatrix();
    return this;
  };
  fn2.rotate = function(angle, axis) {
    this._renderer.rotate(this._toRadians(angle), axis);
    return this;
  };
  fn2.rotateX = function(angle) {
    this._assert3d("rotateX");
    this._renderer.rotateX(this._toRadians(angle));
    return this;
  };
  fn2.rotateY = function(angle) {
    this._assert3d("rotateY");
    this._renderer.rotateY(this._toRadians(angle));
    return this;
  };
  fn2.rotateZ = function(angle) {
    this._assert3d("rotateZ");
    this._renderer.rotateZ(this._toRadians(angle));
    return this;
  };
  fn2.scale = function(x, y, z) {
    if (x instanceof p53.Vector) {
      const v = x;
      x = v.x;
      y = v.y;
      z = v.z;
    } else if (Array.isArray(x)) {
      const rg = x;
      x = rg[0];
      y = rg[1];
      z = rg[2] || 1;
    }
    if (isNaN(y)) {
      y = z = x;
    } else if (isNaN(z)) {
      z = 1;
    }
    this._renderer.scale(x, y, z);
    return this;
  };
  fn2.shearX = function(angle) {
    const rad = this._toRadians(angle);
    this._renderer.applyMatrix(1, 0, Math.tan(rad), 1, 0, 0);
    return this;
  };
  fn2.shearY = function(angle) {
    const rad = this._toRadians(angle);
    this._renderer.applyMatrix(1, Math.tan(rad), 0, 1, 0, 0);
    return this;
  };
  fn2.translate = function(x, y, z) {
    if (this._renderer.isP3D) {
      this._renderer.translate(x, y, z);
    } else {
      this._renderer.translate(x, y);
    }
    return this;
  };
  fn2.push = function() {
    this._renderer.push();
  };
  fn2.pop = function() {
    this._renderer.pop();
  };
}
if (typeof p5 !== "undefined") {
  transform(p5, p5.prototype);
}

// node_modules/p5/dist/core/structure.js
function structure(p53, fn2) {
  fn2.noLoop = function() {
    this._loop = false;
  };
  fn2.loop = function() {
    if (!this._loop) {
      this._loop = true;
      if (this._setupDone) {
        this._draw();
      }
    }
  };
  fn2.isLooping = function() {
    return this._loop;
  };
  fn2.redraw = async function(n3) {
    if (this._inUserDraw || !this._setupDone) {
      return;
    }
    let numberOfRedraws = parseInt(n3);
    if (isNaN(numberOfRedraws) || numberOfRedraws < 1) {
      numberOfRedraws = 1;
    }
    const context = this._isGlobal ? window : this;
    if (typeof context.draw === "function") {
      if (typeof context.setup === "undefined") {
        context.scale(context._pixelDensity, context._pixelDensity);
      }
      for (let idxRedraw = 0; idxRedraw < numberOfRedraws; idxRedraw++) {
        context.resetMatrix();
        if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
          this._updateAccsOutput();
        }
        if (this._renderer.isP3D) {
          this._renderer._update();
        }
        this.frameCount = context.frameCount + 1;
        await this._runLifecycleHook("predraw");
        this._inUserDraw = true;
        try {
          await context.draw();
        } finally {
          this._inUserDraw = false;
        }
        await this._runLifecycleHook("postdraw");
      }
    }
  };
}
if (typeof p5 !== "undefined") {
  structure(p5, p5.prototype);
}

// node_modules/p5/dist/math/p5.Vector.js
var calculateRemainder2D = function(xComponent, yComponent) {
  if (xComponent !== 0) {
    this.x = this.x % xComponent;
  }
  if (yComponent !== 0) {
    this.y = this.y % yComponent;
  }
  return this;
};
var calculateRemainder3D = function(xComponent, yComponent, zComponent) {
  if (xComponent !== 0) {
    this.x = this.x % xComponent;
  }
  if (yComponent !== 0) {
    this.y = this.y % yComponent;
  }
  if (zComponent !== 0) {
    this.z = this.z % zComponent;
  }
  return this;
};
var Vector = class _Vector {
  // This is how it comes in with createVector()
  // This check if the first argument is a function
  constructor(...args) {
    let values = args.map((arg) => arg || 0);
    if (typeof args[0] === "function") {
      this.isPInst = true;
      this._fromRadians = args[0];
      this._toRadians = args[1];
      values = args.slice(2).map((arg) => arg || 0);
    }
    let dimensions = values.length;
    if (dimensions === 0) {
      this.dimensions = 2;
      this._values = [0, 0, 0];
    } else {
      this.dimensions = dimensions;
      this._values = values;
    }
  }
  /**
   * Gets the values of the N-dimensional vector.
   *
   * This method returns an array of numbers that represent the vector.
   * Each number in the array corresponds to a different component of the vector,
   * like its position in different directions (e.g., x, y, z).
   *
   * @returns {Array<number>} The array of values representing the vector.
   */
  get values() {
    return this._values;
  }
  /**
   * Sets the values of the vector.
   *
   * This method allows you to update the entire vector with a new set of values.
   * You need to provide an array of numbers, where each number represents a component
   * of the vector (e.g., x, y, z). The length of the array should match the number of
   * dimensions of the vector. If the array is shorter, the missing components will be
   * set to 0. If the array is longer, the extra values will be ignored.
   *
   * @param {Array<number>} newValues - An array of numbers representing the new values for the vector.
   *
   */
  set values(newValues) {
    let dimensions = newValues.length;
    if (dimensions === 0) {
      this.dimensions = 2;
      this._values = [0, 0, 0];
    } else {
      this.dimensions = dimensions;
      this._values = newValues.slice();
    }
  }
  /**
   * Gets the x component of the vector.
   *
   * This method returns the value of the x component of the vector.
   * Think of the x component as the horizontal position or the first number in the vector.
   * If the x component is not defined, it will return 0.
   *
   * @returns {Number} The x component of the vector. Returns 0 if the value is not defined.
   */
  get x() {
    return this._values[0] || 0;
  }
  /**
   * Retrieves the value at the specified index from the vector.
   *
   * This method allows you to get the value of a specific component of the vector
   * by providing its index. Think of the vector as a list of numbers, where each
   * number represents a different direction (like x, y, or z). The index is just
   * the position of the number in that list.
   *
   * For example, if you have a vector with values 10, 20, 30 the index 0 would
   * give you the first value 10, index 1 would give you the second value 20,
   * and so on.
   *
   * @param {Number} index - The position of the value you want to get from the vector.
   * @returns {Number} The value at the specified position in the vector.
   * @throws Will throw an error if the index is out of bounds, meaning if you try to
   *          get a value from a position that doesn't exist in the vector.
   */
  getValue(index) {
    if (index < this._values.length) {
      return this._values[index];
    } else {
      p5._friendlyError(
        "The index parameter is trying to set a value outside the bounds of the vector",
        "p5.Vector.setValue"
      );
    }
  }
  /**
   * Sets the value at the specified index of the vector.
   *
   * This method allows you to change a specific component of the vector by providing its index and the new value you want to set.
   * Think of the vector as a list of numbers, where each number represents a different direction (like x, y, or z).
   * The index is just the position of the number in that list.
   *
   * For example, if you have a vector with values [0, 20, 30], and you want to change the second value (20) to 50,
   * you would use this method with index 1 (since indexes start at 0) and value 50.
   *
   * @param {Number} index - The position in the vector where you want to set the new value.
   * @param {Number} value - The new value you want to set at the specified position.
   * @throws Will throw an error if the index is outside the bounds of the vector, meaning if you try to set a value at a position that doesn't exist in the vector.
   */
  setValue(index, value) {
    if (index < this._values.length) {
      this._values[index] = value;
    } else {
      p5._friendlyError(
        "The index parameter is trying to set a value outside the bounds of the vector",
        "p5.Vector.setValue"
      );
    }
  }
  /**
   * Gets the y component of the vector.
   *
   * This method returns the value of the y component of the vector.
   * Think of the y component as the vertical position or the second number in the vector.
   * If the y component is not defined, it will return 0.
   *
   * @returns {Number} The y component of the vector. Returns 0 if the value is not defined.
   */
  get y() {
    return this._values[1] || 0;
  }
  /**
   * Gets the z component of the vector.
   *
   * This method returns the value of the z component of the vector.
   * Think of the z component as the depth or the third number in the vector.
   * If the z component is not defined, it will return 0.
   *
   * @returns {Number} The z component of the vector. Returns 0 if the value is not defined.
   */
  get z() {
    return this._values[2] || 0;
  }
  /**
   * Gets the w component of the vector.
   *
   * This method returns the value of the w component of the vector.
   * Think of the w component as the fourth number in the vector.
   * If the w component is not defined, it will return 0.
   *
   * @returns {Number} The w component of the vector. Returns 0 if the value is not defined.
   */
  get w() {
    return this._values[3] || 0;
  }
  /**
   * Sets the x component of the vector.
   *
   * This method allows you to change the x value of the vector.
   * The x value is the first number in the vector, representing the horizontal position.
   * By calling this method, you can update the x value to a new number.
   *
   * @param {Number} xVal - The new value for the x component.
   */
  set x(xVal) {
    if (this._values.length > 1) {
      this._values[0] = xVal;
    }
  }
  /**
   * Sets the y component of the vector.
   *
   * This method allows you to change the y value of the vector.
   * The y value is the second number in the vector, representing the vertical position.
   * By calling this method, you can update the y value to a new number.
   *
   * @param {Number} yVal - The new value for the y component.
   */
  set y(yVal) {
    if (this._values.length > 1) {
      this._values[1] = yVal;
    }
  }
  /**
   * Sets the z component of the vector.
   *
   * This method allows you to change the z value of the vector.
   * The z value is the third number in the vector, representing the depth or the third dimension.
   * By calling this method, you can update the z value to a new number.
   *
   * @param {Number} zVal - The new value for the z component.
   */
  set z(zVal) {
    if (this._values.length > 2) {
      this._values[2] = zVal;
    }
  }
  /**
   * Sets the w component of the vector.
   *
   * This method allows you to change the w value of the vector.
   * The w value is the fourth number in the vector, representing the fourth dimension.
   * By calling this method, you can update the w value to a new number.
   *
   * @param {Number} wVal - The new value for the w component.
   */
  set w(wVal) {
    if (this._values.length > 3) {
      this._values[3] = wVal;
    }
  }
  /**
   * Returns a string representation of a vector.
   *
   * Calling `toString()` is useful for printing vectors to the console while
   * debugging.
   *
   * @return {String} string representation of the vector.
   *
   * @example
   * <div class = "norender">
   * <code>
   * function setup() {
   *   let v = createVector(20, 30);
   *
   *   // Prints 'p5.Vector Object : [20, 30, 0]'.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   */
  toString() {
    return `[${this.values.join(", ")}]`;
  }
  /**
   * Sets the vector's `x`, `y`, and `z` components.
   *
   * `set()` can use separate numbers, as in `v.set(1, 2, 3)`, a
   * <a href="#/p5.Vector">p5.Vector</a> object, as in `v.set(v2)`, or an
   * array of numbers, as in `v.set([1, 2, 3])`.
   *
   * If a value isn't provided for a component, it will be set to 0. For
   * example, `v.set(4, 5)` sets `v.x` to 4, `v.y` to 5, and `v.z` to 0.
   * Calling `set()` with no arguments, as in `v.set()`, sets all the vector's
   * components to 0.
   *
   * @param {Number} [x] x component of the vector.
   * @param {Number} [y] y component of the vector.
   * @param {Number} [z] z component of the vector.
   * @chainable
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Top left.
   *   let pos = createVector(25, 25);
   *   point(pos);
   *
   *   // Top right.
   *   // set() with numbers.
   *   pos.set(75, 25);
   *   point(pos);
   *
   *   // Bottom right.
   *   // set() with a p5.Vector.
   *   let p2 = createVector(75, 75);
   *   pos.set(p2);
   *   point(pos);
   *
   *   // Bottom left.
   *   // set() with an array.
   *   let arr = [25, 75];
   *   pos.set(arr);
   *   point(pos);
   *
   *   describe('Four black dots arranged in a square on a gray background.');
   * }
   * </code>
   * </div>
   */
  /**
   * @param {p5.Vector|Number[]} value vector to set.
   * @chainable
   */
  set(...args) {
    if (args[0] instanceof _Vector) {
      this.values = args[0].values.slice();
    } else if (Array.isArray(args[0])) {
      this.values = args[0].map((arg) => arg || 0);
    } else {
      this.values = args.map((arg) => arg || 0);
    }
    this.dimensions = this.values.length;
    return this;
  }
  /**
   * Returns a copy of the <a href="#/p5.Vector">p5.Vector</a> object.
   *
   * @return {p5.Vector} copy of the <a href="#/p5.Vector">p5.Vector</a> object.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100 ,100);
   *
   *   background(200);
   *
   *   // Create a p5.Vector object.
   *   let pos = createVector(50, 50);
   *
   *   // Make a copy.
   *   let pc = pos.copy();
   *
   *   // Draw the point.
   *   strokeWeight(5);
   *   point(pc);
   *
   *   describe('A black point drawn in the middle of a gray square.');
   * }
   * </code>
   * </div>
   */
  copy() {
    if (this.isPInst) {
      return new _Vector(this._fromRadians, this._toRadians, ...this.values);
    } else {
      return new _Vector(...this.values);
    }
  }
  /**
   * Adds to a vector's components.
   *
   * `add()` can use separate numbers, as in `v.add(1, 2, 3)`,
   * another <a href="#/p5.Vector">p5.Vector</a> object, as in `v.add(v2)`, or
   * an array of numbers, as in `v.add([1, 2, 3])`.
   *
   * If a value isn't provided for a component, it won't change. For
   * example, `v.add(4, 5)` adds 4 to `v.x`, 5 to `v.y`, and 0 to `v.z`.
   * Calling `add()` with no arguments, as in `v.add()`, has no effect.
   *
   * This method supports N-dimensional vectors.
   *
   * The static version of `add()`, as in `p5.Vector.add(v2, v1)`, returns a new
   * <a href="#/p5.Vector">p5.Vector</a> object and doesn't change the
   * originals.
   *
   * @param  {Number|Array} x   x component of the vector to be added or an array of components.
   * @param  {Number} [y] y component of the vector to be added.
   * @param  {Number} [z] z component of the vector to be added.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Top left.
   *   let pos = createVector(25, 25);
   *   point(pos);
   *
   *   // Top right.
   *   // Add numbers.
   *   pos.add(50, 0);
   *   point(pos);
   *
   *   // Bottom right.
   *   // Add a p5.Vector.
   *   let p2 = createVector(0, 50);
   *   pos.add(p2);
   *   point(pos);
   *
   *   // Bottom left.
   *   // Add an array.
   *   let arr = [-50, 0];
   *   pos.add(arr);
   *   point(pos);
   *
   *   describe('Four black dots arranged in a square on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Top left.
   *   let p1 = createVector(25, 25);
   *
   *   // Center.
   *   let p2 = createVector(50, 50);
   *
   *   // Bottom right.
   *   // Add p1 and p2.
   *   let p3 = p5.Vector.add(p1, p2);
   *
   *   // Draw the points.
   *   strokeWeight(5);
   *   point(p1);
   *   point(p2);
   *   point(p3);
   *
   *   describe('Three black dots in a diagonal line from top left to bottom right.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Three arrows drawn on a gray square. A red arrow extends from the top left corner to the center. A blue arrow extends from the tip of the red arrow. A purple arrow extends from the origin to the tip of the blue arrow.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   let origin = createVector(0, 0);
   *
   *   // Draw the red arrow.
   *   let v1 = createVector(50, 50);
   *   drawArrow(origin, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   let v2 = createVector(-30, 20);
   *   drawArrow(v1, v2, 'blue');
   *
   *   // Purple arrow.
   *   let v3 = p5.Vector.add(v1, v2);
   *   drawArrow(origin, v3, 'purple');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {p5.Vector|Number[]} value The vector to add
   * @chainable
   */
  add(...args) {
    if (args[0] instanceof _Vector) {
      args = args[0].values;
    } else if (Array.isArray(args[0])) {
      args = args[0];
    }
    args.forEach((value, index) => {
      this.values[index] = (this.values[index] || 0) + (value || 0);
    });
    return this;
  }
  /**
   * Performs modulo (remainder) division with a vector's `x`, `y`, and `z`
   * components.
   *
   * `rem()` can use separate numbers, as in `v.rem(1, 2, 3)`,
   * another <a href="#/p5.Vector">p5.Vector</a> object, as in `v.rem(v2)`, or
   * an array of numbers, as in `v.rem([1, 2, 3])`.
   *
   * If only one value is provided, as in `v.rem(2)`, then all the components
   * will be set to their values modulo 2. If two values are provided, as in
   * `v.rem(2, 3)`, then `v.z` won't change. Calling `rem()` with no
   * arguments, as in `v.rem()`, has no effect.
   *
   * The static version of `rem()`, as in `p5.Vector.rem(v2, v1)`, returns a
   * new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change the
   * originals.
   *
   * @param {Number} x x component of divisor vector.
   * @param {Number} y y component of divisor vector.
   * @param {Number} z z component of divisor vector.
   * @chainable
   *
   * @example
   * <div class='norender'>
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(3, 4, 5);
   *
   *   // Divide numbers.
   *   v.rem(2);
   *
   *   // Prints 'p5.Vector Object : [1, 0, 1]'.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class='norender'>
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(3, 4, 5);
   *
   *   // Divide numbers.
   *   v.rem(2, 3);
   *
   *   // Prints 'p5.Vector Object : [1, 1, 5]'.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class='norender'>
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(3, 4, 5);
   *
   *   // Divide numbers.
   *   v.rem(2, 3, 4);
   *
   *   // Prints 'p5.Vector Object : [1, 1, 1]'.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class='norender'>
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v1 = createVector(3, 4, 5);
   *   let v2 = createVector(2, 3, 4);
   *
   *   // Divide a p5.Vector.
   *   v1.rem(v2);
   *
   *   // Prints 'p5.Vector Object : [1, 1, 1]'.
   *   print(v1.toString());
   * }
   * </code>
   * </div>
   *
   * <div class='norender'>
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(3, 4, 5);
   *
   *   // Divide an array.
   *   let arr = [2, 3, 4];
   *   v.rem(arr);
   *
   *   // Prints 'p5.Vector Object : [1, 1, 1]'.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v1 = createVector(3, 4, 5);
   *   let v2 = createVector(2, 3, 4);
   *
   *   // Divide without modifying the original vectors.
   *   let v3 = p5.Vector.rem(v1, v2);
   *
   *   // Prints 'p5.Vector Object : [1, 1, 1]'.
   *   print(v3.toString());
   * }
   * </code>
   * </div>
   */
  /**
   * @param {p5.Vector | Number[]}  value  divisor vector.
   * @chainable
   */
  rem(x, y, z) {
    if (x instanceof _Vector) {
      if ([x.x, x.y, x.z].every(Number.isFinite)) {
        const xComponent = parseFloat(x.x);
        const yComponent = parseFloat(x.y);
        const zComponent = parseFloat(x.z);
        return calculateRemainder3D.call(
          this,
          xComponent,
          yComponent,
          zComponent
        );
      }
    } else if (Array.isArray(x)) {
      if (x.every((element2) => Number.isFinite(element2))) {
        if (x.length === 2) {
          return calculateRemainder2D.call(this, x[0], x[1]);
        }
        if (x.length === 3) {
          return calculateRemainder3D.call(this, x[0], x[1], x[2]);
        }
      }
    } else if (arguments.length === 1) {
      if (Number.isFinite(arguments[0]) && arguments[0] !== 0) {
        this.x = this.x % arguments[0];
        this.y = this.y % arguments[0];
        this.z = this.z % arguments[0];
        return this;
      }
    } else if (arguments.length === 2) {
      const vectorComponents = [...arguments];
      if (vectorComponents.every((element2) => Number.isFinite(element2))) {
        if (vectorComponents.length === 2) {
          return calculateRemainder2D.call(
            this,
            vectorComponents[0],
            vectorComponents[1]
          );
        }
      }
    } else if (arguments.length === 3) {
      const vectorComponents = [...arguments];
      if (vectorComponents.every((element2) => Number.isFinite(element2))) {
        if (vectorComponents.length === 3) {
          return calculateRemainder3D.call(
            this,
            vectorComponents[0],
            vectorComponents[1],
            vectorComponents[2]
          );
        }
      }
    }
  }
  /**
   * Subtracts from a vector's `x`, `y`, and `z` components.
   *
   * `sub()` can use separate numbers, as in `v.sub(1, 2, 3)`, another
   * <a href="#/p5.Vector">p5.Vector</a> object, as in `v.sub(v2)`, or an array
   * of numbers, as in `v.sub([1, 2, 3])`.
   *
   * If a value isn't provided for a component, it won't change. For
   * example, `v.sub(4, 5)` subtracts 4 from `v.x`, 5 from `v.y`, and 0 from `v.z`.
   * Calling `sub()` with no arguments, as in `v.sub()`, has no effect.
   *
   * The static version of `sub()`, as in `p5.Vector.sub(v2, v1)`, returns a new
   * <a href="#/p5.Vector">p5.Vector</a> object and doesn't change the
   * originals.
   *
   * @param  {Number} x   x component of the vector to subtract.
   * @param  {Number} [y] y component of the vector to subtract.
   * @param  {Number} [z] z component of the vector to subtract.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Bottom right.
   *   let pos = createVector(75, 75);
   *   point(pos);
   *
   *   // Top right.
   *   // Subtract numbers.
   *   pos.sub(0, 50);
   *   point(pos);
   *
   *   // Top left.
   *   // Subtract a p5.Vector.
   *   let p2 = createVector(50, 0);
   *   pos.sub(p2);
   *   point(pos);
   *
   *   // Bottom left.
   *   // Subtract an array.
   *   let arr = [0, -50];
   *   pos.sub(arr);
   *   point(pos);
   *
   *   describe('Four black dots arranged in a square on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create p5.Vector objects.
   *   let p1 = createVector(75, 75);
   *   let p2 = createVector(50, 50);
   *
   *   // Subtract with modifying the original vectors.
   *   let p3 = p5.Vector.sub(p1, p2);
   *
   *   // Draw the points.
   *   strokeWeight(5);
   *   point(p1);
   *   point(p2);
   *   point(p3);
   *
   *   describe('Three black dots in a diagonal line from top left to bottom right.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Three arrows drawn on a gray square. A red and a blue arrow extend from the top left. A purple arrow extends from the tip of the red arrow to the tip of the blue arrow.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   let origin = createVector(0, 0);
   *
   *   // Draw the red arrow.
   *   let v1 = createVector(50, 50);
   *   drawArrow(origin, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   let v2 = createVector(20, 70);
   *   drawArrow(origin, v2, 'blue');
   *
   *   // Purple arrow.
   *   let v3 = p5.Vector.sub(v2, v1);
   *   drawArrow(v1, v3, 'purple');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {p5.Vector|Number[]} value the vector to subtract
   * @chainable
   */
  sub(...args) {
    if (args[0] instanceof _Vector) {
      args[0].values.forEach((value, index) => {
        this.values[index] -= value || 0;
      });
    } else if (Array.isArray(args[0])) {
      args[0].forEach((value, index) => {
        this.values[index] -= value || 0;
      });
    } else {
      args.forEach((value, index) => {
        this.values[index] -= value || 0;
      });
    }
    return this;
  }
  /**
   * Multiplies a vector's `x`, `y`, and `z` components.
   *
   * `mult()` can use separate numbers, as in `v.mult(1, 2, 3)`, another
   * <a href="#/p5.Vector">p5.Vector</a> object, as in `v.mult(v2)`, or an array
   * of numbers, as in `v.mult([1, 2, 3])`.
   *
   * If only one value is provided, as in `v.mult(2)`, then all the components
   * will be multiplied by 2. If a value isn't provided for a component, it
   * won't change. For example, `v.mult(4, 5)` multiplies `v.x` by, `v.y` by 5,
   * and `v.z` by 1. Calling `mult()` with no arguments, as in `v.mult()`, has
   * no effect.
   *
   * The static version of `mult()`, as in `p5.Vector.mult(v, 2)`, returns a new
   * <a href="#/p5.Vector">p5.Vector</a> object and doesn't change the
   * originals.
   *
   * @method mult
   * @param  {Number} n The number to multiply with the vector
   * @chainable
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Top-left.
   *   let p = createVector(25, 25);
   *   point(p);
   *
   *   // Center.
   *   // Multiply all components by 2.
   *   p.mult(2);
   *   point(p);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   strokeWeight(5);
   *
   *   // Top-left.
   *   let p = createVector(25, 25);
   *   point(p);
   *
   *   // Bottom-right.
   *   // Multiply p.x * 2 and p.y * 3
   *   p.mult(2, 3);
   *   point(p);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the bottom center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Top-left.
   *   let p = createVector(25, 25);
   *   point(p);
   *
   *   // Bottom-right.
   *   // Multiply p.x * 2 and p.y * 3
   *   let arr = [2, 3];
   *   p.mult(arr);
   *   point(p);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the bottom center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Top-left.
   *   let p = createVector(25, 25);
   *   point(p);
   *
   *   // Bottom-right.
   *   // Multiply p.x * p2.x and p.y * p2.y
   *   let p2 = createVector(2, 3);
   *   p.mult(p2);
   *   point(p);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the bottom center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Top-left.
   *   let p = createVector(25, 25);
   *   point(p);
   *
   *   // Bottom-right.
   *   // Create a new p5.Vector with
   *   // p3.x = p.x * p2.x
   *   // p3.y = p.y * p2.y
   *   let p2 = createVector(2, 3);
   *   let p3 = p5.Vector.mult(p, p2);
   *   point(p3);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the bottom center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Two arrows extending from the top left corner. The blue arrow is twice the length of the red arrow.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   let origin = createVector(0, 0);
   *
   *   // Draw the red arrow.
   *   let v1 = createVector(25, 25);
   *   drawArrow(origin, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   let v2 = p5.Vector.mult(v1, 2);
   *   drawArrow(origin, v2, 'blue');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {Number} x number to multiply with the x component of the vector.
   * @param  {Number} y number to multiply with the y component of the vector.
   * @param  {Number} [z] number to multiply with the z component of the vector.
   * @chainable
   */
  /**
   * @param  {Number[]} arr array to multiply with the components of the vector.
   * @chainable
   */
  /**
   * @param  {p5.Vector} v vector to multiply with the components of the original vector.
   * @chainable
   */
  mult(...args) {
    if (args.length === 1 && args[0] instanceof _Vector) {
      const v = args[0];
      const maxLen = Math.min(this.values.length, v.values.length);
      for (let i = 0; i < maxLen; i++) {
        if (Number.isFinite(v.values[i]) && typeof v.values[i] === "number") {
          this._values[i] *= v.values[i];
        } else {
          console.warn(
            "p5.Vector.prototype.mult:",
            "v contains components that are either undefined or not finite numbers"
          );
          return this;
        }
      }
    } else if (args.length === 1 && Array.isArray(args[0])) {
      const arr2 = args[0];
      const maxLen = Math.min(this.values.length, arr2.length);
      for (let i = 0; i < maxLen; i++) {
        if (Number.isFinite(arr2[i]) && typeof arr2[i] === "number") {
          this._values[i] *= arr2[i];
        } else {
          console.warn(
            "p5.Vector.prototype.mult:",
            "arr contains elements that are either undefined or not finite numbers"
          );
          return this;
        }
      }
    } else if (args.length === 1 && typeof args[0] === "number" && Number.isFinite(args[0])) {
      for (let i = 0; i < this._values.length; i++) {
        this._values[i] *= args[0];
      }
    }
    return this;
  }
  /**
   * Divides a vector's `x`, `y`, and `z` components.
   *
   * `div()` can use separate numbers, as in `v.div(1, 2, 3)`, another
   * <a href="#/p5.Vector">p5.Vector</a> object, as in `v.div(v2)`, or an array
   * of numbers, as in `v.div([1, 2, 3])`.
   *
   * If only one value is provided, as in `v.div(2)`, then all the components
   * will be divided by 2. If a value isn't provided for a component, it
   * won't change. For example, `v.div(4, 5)` divides `v.x` by, `v.y` by 5,
   * and `v.z` by 1. Calling `div()` with no arguments, as in `v.div()`, has
   * no effect.
   *
   * The static version of `div()`, as in `p5.Vector.div(v, 2)`, returns a new
   * <a href="#/p5.Vector">p5.Vector</a> object and doesn't change the
   * originals.
   *
   * @param  {Number}    n The number to divide the vector by
   * @chainable
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Center.
   *   let p = createVector(50, 50);
   *   point(p);
   *
   *   // Top-left.
   *   // Divide p.x / 2 and p.y / 2
   *   p.div(2);
   *   point(p);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Bottom-right.
   *   let p = createVector(50, 75);
   *   point(p);
   *
   *   // Top-left.
   *   // Divide p.x / 2 and p.y / 3
   *   p.div(2, 3);
   *   point(p);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the bottom center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Bottom-right.
   *   let p = createVector(50, 75);
   *   point(p);
   *
   *   // Top-left.
   *   // Divide p.x / 2 and p.y / 3
   *   let arr = [2, 3];
   *   p.div(arr);
   *   point(p);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the bottom center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Bottom-right.
   *   let p = createVector(50, 75);
   *   point(p);
   *
   *   // Top-left.
   *   // Divide p.x / 2 and p.y / 3
   *   let p2 = createVector(2, 3);
   *   p.div(p2);
   *   point(p);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the bottom center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the points.
   *   strokeWeight(5);
   *
   *   // Bottom-right.
   *   let p = createVector(50, 75);
   *   point(p);
   *
   *   // Top-left.
   *   // Create a new p5.Vector with
   *   // p3.x = p.x / p2.x
   *   // p3.y = p.y / p2.y
   *   let p2 = createVector(2, 3);
   *   let p3 = p5.Vector.div(p, p2);
   *   point(p3);
   *
   *   describe('Two black dots drawn on a gray square. One dot is in the top left corner and the other is in the bottom center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function draw() {
   *   background(200);
   *
   *   let origin = createVector(0, 0);
   *
   *   // Draw the red arrow.
   *   let v1 = createVector(50, 50);
   *   drawArrow(origin, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   let v2 = p5.Vector.div(v1, 2);
   *   drawArrow(origin, v2, 'blue');
   *
   *   describe('Two arrows extending from the top left corner. The blue arrow is half the length of the red arrow.');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {Number} x number to divide with the x component of the vector.
   * @param  {Number} y number to divide with the y component of the vector.
   * @param  {Number} [z] number to divide with the z component of the vector.
   * @chainable
   */
  /**
   * @param  {Number[]} arr array to divide the components of the vector by.
   * @chainable
   */
  /**
   * @param  {p5.Vector} v vector to divide the components of the original vector by.
   * @chainable
   */
  div(...args) {
    if (args.length === 0) return this;
    if (args.length === 1 && args[0] instanceof _Vector) {
      const v = args[0];
      if (v._values.every(
        (val2) => Number.isFinite(val2) && typeof val2 === "number"
      )) {
        if (v._values.some((val2) => val2 === 0)) {
          console.warn("p5.Vector.prototype.div:", "divide by 0");
          return this;
        }
        this._values = this._values.map((val2, i) => val2 / v._values[i]);
      } else {
        console.warn(
          "p5.Vector.prototype.div:",
          "vector contains components that are either undefined or not finite numbers"
        );
      }
      return this;
    }
    if (args.length === 1 && Array.isArray(args[0])) {
      const arr2 = args[0];
      if (arr2.every((val2) => Number.isFinite(val2) && typeof val2 === "number")) {
        if (arr2.some((val2) => val2 === 0)) {
          console.warn("p5.Vector.prototype.div:", "divide by 0");
          return this;
        }
        this._values = this._values.map((val2, i) => val2 / arr2[i]);
      } else {
        console.warn(
          "p5.Vector.prototype.div:",
          "array contains components that are either undefined or not finite numbers"
        );
      }
      return this;
    }
    if (args.every((val2) => Number.isFinite(val2) && typeof val2 === "number")) {
      if (args.some((val2) => val2 === 0)) {
        console.warn("p5.Vector.prototype.div:", "divide by 0");
        return this;
      }
      this._values = this._values.map((val2, i) => val2 / args[0]);
    } else {
      console.warn(
        "p5.Vector.prototype.div:",
        "arguments contain components that are either undefined or not finite numbers"
      );
    }
    return this;
  }
  /**
   * Calculates the magnitude (length) of the vector.
   *
   * Use <a href="#/p5/mag">mag()</a> to calculate the magnitude of a 2D vector
   * using components as in `mag(x, y)`.
   *
   * @return {Number} magnitude of the vector.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Vector object.
   *   let p = createVector(30, 40);
   *
   *   // Draw a line from the origin.
   *   line(0, 0, p.x, p.y);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the vector's magnitude.
   *   let m = p.mag();
   *   text(m, p.x, p.y);
   *
   *   describe('A diagonal black line extends from the top left corner of a gray square. The number 50 is written at the end of the line.');
   * }
   * </code>
   * </div>
   */
  mag() {
    return Math.sqrt(this.magSq());
  }
  /**
   * Calculates the magnitude (length) of the vector squared.
   *
   * @return {Number} squared magnitude of the vector.
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Vector object.
   *   let p = createVector(30, 40);
   *
   *   // Draw a line from the origin.
   *   line(0, 0, p.x, p.y);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the vector's magnitude squared.
   *   let m = p.magSq();
   *   text(m, p.x, p.y);
   *
   *   describe('A diagonal black line extends from the top left corner of a gray square. The number 2500 is written at the end of the line.');
   * }
   * </code>
   * </div>
   */
  magSq() {
    return this._values.reduce(
      (sum, component) => sum + component * component,
      0
    );
  }
  /**
   * Calculates the dot product of two vectors.
   *
   * The dot product is a number that describes the overlap between two vectors.
   * Visually, the dot product can be thought of as the "shadow" one vector
   * casts on another. The dot product's magnitude is largest when two vectors
   * point in the same or opposite directions. Its magnitude is 0 when two
   * vectors form a right angle.
   *
   * The version of `dot()` with one parameter interprets it as another
   * <a href="#/p5.Vector">p5.Vector</a> object.
   *
   * The version of `dot()` with multiple parameters interprets them as the
   * `x`, `y`, and `z` components of another vector.
   *
   * The static version of `dot()`, as in `p5.Vector.dot(v1, v2)`, is the same
   * as calling `v1.dot(v2)`.
   *
   * @param  {Number} x   x component of the vector.
   * @param  {Number} [y] y component of the vector.
   * @param  {Number} [z] z component of the vector.
   * @return {Number}     dot product.
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v1 = createVector(3, 4);
   *   let v2 = createVector(3, 0);
   *
   *   // Calculate the dot product.
   *   let dp = v1.dot(v2);
   *
   *   // Prints "9" to the console.
   *   print(dp);
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v1 = createVector(1, 0);
   *   let v2 = createVector(0, 1);
   *
   *   // Calculate the dot product.
   *   let dp = p5.Vector.dot(v1, v2);
   *
   *   // Prints "0" to the console.
   *   print(dp);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Two arrows drawn on a gray square. A black arrow points to the right and a red arrow follows the mouse. The text "v1 • v2 = something" changes as the mouse moves.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Center.
   *   let v0 = createVector(50, 50);
   *
   *   // Draw the black arrow.
   *   let v1 = createVector(30, 0);
   *   drawArrow(v0, v1, 'black');
   *
   *   // Draw the red arrow.
   *   let v2 = createVector(mouseX - 50, mouseY - 50);
   *   drawArrow(v0, v2, 'red');
   *
   *   // Display the dot product.
   *   let dp = v2.dot(v1);
   *   text(`v2 • v1 = ${dp}`, 10, 20);
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {p5.Vector} v <a href="#/p5.Vector">p5.Vector</a> to be dotted.
   * @return {Number}
   */
  dot(...args) {
    if (args[0] instanceof _Vector) {
      return this.dot(...args[0]._values);
    }
    return this._values.reduce((sum, component, index) => {
      return sum + component * (args[index] || 0);
    }, 0);
  }
  /**
   * Calculates the cross product of two vectors.
   *
   * The cross product is a vector that points straight out of the plane created
   * by two vectors. The cross product's magnitude is the area of the parallelogram
   * formed by the original two vectors.
   *
   * The static version of `cross()`, as in `p5.Vector.cross(v1, v2)`, is the same
   * as calling `v1.cross(v2)`.
   *
   * @param  {p5.Vector} v <a href="#/p5.Vector">p5.Vector</a> to be crossed.
   * @return {p5.Vector}   cross product as a <a href="#/p5.Vector">p5.Vector</a>.
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v1 = createVector(1, 0);
   *   let v2 = createVector(3, 4);
   *
   *   // Calculate the cross product.
   *   let cp = v1.cross(v2);
   *
   *   // Prints "p5.Vector Object : [0, 0, 4]" to the console.
   *   print(cp.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v1 = createVector(1, 0);
   *   let v2 = createVector(3, 4);
   *
   *   // Calculate the cross product.
   *   let cp = p5.Vector.cross(v1, v2);
   *
   *   // Prints "p5.Vector Object : [0, 0, 4]" to the console.
   *   print(cp.toString());
   * }
   * </code>
   * </div>
   */
  cross(v) {
    const x = this.y * v.z - this.z * v.y;
    const y = this.z * v.x - this.x * v.z;
    const z = this.x * v.y - this.y * v.x;
    if (this.isPInst) {
      return new _Vector(this._fromRadians, this._toRadians, x, y, z);
    } else {
      return new _Vector(x, y, z);
    }
  }
  /**
   * Calculates the distance between two points represented by vectors.
   *
   * A point's coordinates can be represented by the components of a vector
   * that extends from the origin to the point.
   *
   * The static version of `dist()`, as in `p5.Vector.dist(v1, v2)`, is the same
   * as calling `v1.dist(v2)`.
   *
   * Use <a href="#/p5/dist">dist()</a> to calculate the distance between points
   * using coordinates as in `dist(x1, y1, x2, y2)`.
   *
   * @method dist
   * @submodule p5.Vector
   * @param  {p5.Vector} v x, y, and z coordinates of a <a href="#/p5.Vector">p5.Vector</a>.
   * @return {Number}      distance.
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create p5.Vector objects.
   *   let v1 = createVector(1, 0);
   *   let v2 = createVector(0, 1);
   *
   *   // Calculate the distance between them.
   *   let d = v1.dist(v2);
   *
   *   // Prints "1.414..." to the console.
   *   print(d);
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create p5.Vector objects.
   *   let v1 = createVector(1, 0);
   *   let v2 = createVector(0, 1);
   *
   *   // Calculate the distance between them.
   *   let d = p5.Vector.dist(v1, v2);
   *
   *   // Prints "1.414..." to the console.
   *   print(d);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Three arrows drawn on a gray square. A red and a blue arrow extend from the top left. A purple arrow extends from the tip of the red arrow to the tip of the blue arrow. The number 36 is written in black near the purple arrow.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   let origin = createVector(0, 0);
   *
   *   // Draw the red arrow.
   *   let v1 = createVector(50, 50);
   *   drawArrow(origin, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   let v2 = createVector(20, 70);
   *   drawArrow(origin, v2, 'blue');
   *
   *   // Purple arrow.
   *   let v3 = p5.Vector.sub(v2, v1);
   *   drawArrow(v1, v3, 'purple');
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *
   *   // Display the magnitude. The same as floor(v3.mag());
   *   let m = floor(p5.Vector.dist(v1, v2));
   *   text(m, 50, 75);
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  dist(v) {
    return v.copy().sub(this).mag();
  }
  /**
   * Scales the components of a <a href="#/p5.Vector">p5.Vector</a> object so
   * that its magnitude is 1.
   *
   * The static version of `normalize()`,  as in `p5.Vector.normalize(v)`,
   * returns a new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change
   * the original.
   *
   * @return {p5.Vector} normalized <a href="#/p5.Vector">p5.Vector</a>.
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Vector.
   *   let v = createVector(10, 20, 2);
   *
   *   // Normalize.
   *   v.normalize();
   *
   *   // Prints "p5.Vector Object : [0.445..., 0.890..., 0.089...]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Vector.
   *   let v0 = createVector(10, 20, 2);
   *
   *   // Create a normalized copy.
   *   let v1 = p5.Vector.normalize(v0);
   *
   *   // Prints "p5.Vector Object : [10, 20, 2]" to the console.
   *   print(v0.toString());
   *   // Prints "p5.Vector Object : [0.445..., 0.890..., 0.089...]" to the console.
   *   print(v1.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe("A red and blue arrow extend from the center of a circle. Both arrows follow the mouse, but the blue arrow's length is fixed to the circle's radius.");
   * }
   *
   * function draw() {
   *   background(240);
   *
   *   // Vector to the center.
   *   let v0 = createVector(50, 50);
   *
   *   // Vector from the center to the mouse.
   *   let v1 = createVector(mouseX - 50, mouseY - 50);
   *
   *   // Circle's radius.
   *   let r = 25;
   *
   *   // Draw the red arrow.
   *   drawArrow(v0, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   v1.normalize();
   *   drawArrow(v0, v1.mult(r), 'blue');
   *
   *   // Draw the circle.
   *   noFill();
   *   circle(50, 50, r * 2);
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  normalize() {
    const len = this.mag();
    if (len !== 0) this.mult(1 / len);
    return this;
  }
  /**
   * Limits a vector's magnitude to a maximum value.
   *
   * The static version of `limit()`, as in `p5.Vector.limit(v, 5)`, returns a
   * new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change the
   * original.
   *
   * @param  {Number}    max maximum magnitude for the vector.
   * @chainable
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(10, 20, 2);
   *
   *   // Limit its magnitude.
   *   v.limit(5);
   *
   *   // Prints "p5.Vector Object : [2.227..., 4.454..., 0.445...]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v0 = createVector(10, 20, 2);
   *
   *   // Create a copy an limit its magintude.
   *   let v1 = p5.Vector.limit(v0, 5);
   *
   *   // Prints "p5.Vector Object : [2.227..., 4.454..., 0.445...]" to the console.
   *   print(v1.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe("A red and blue arrow extend from the center of a circle. Both arrows follow the mouse, but the blue arrow never crosses the circle's edge.");
   * }
   * function draw() {
   *   background(240);
   *
   *   // Vector to the center.
   *   let v0 = createVector(50, 50);
   *
   *   // Vector from the center to the mouse.
   *   let v1 = createVector(mouseX - 50, mouseY - 50);
   *
   *   // Circle's radius.
   *   let r = 25;
   *
   *   // Draw the red arrow.
   *   drawArrow(v0, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   drawArrow(v0, v1.limit(r), 'blue');
   *
   *   // Draw the circle.
   *   noFill();
   *   circle(50, 50, r * 2);
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  limit(max) {
    const mSq = this.magSq();
    if (mSq > max * max) {
      this.div(Math.sqrt(mSq)).mult(max);
    }
    return this;
  }
  /**
   * Sets a vector's magnitude to a given value.
   *
   * The static version of `setMag()`, as in `p5.Vector.setMag(v, 10)`, returns
   * a new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change the
   * original.
   *
   * @param  {Number}    len new length for this vector.
   * @chainable
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(3, 4, 0);
   *
   *   // Prints "5" to the console.
   *   print(v.mag());
   *
   *   // Set its magnitude to 10.
   *   v.setMag(10);
   *
   *   // Prints "p5.Vector Object : [6, 8, 0]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v0 = createVector(3, 4, 0);
   *
   *   // Create a copy with a magnitude of 10.
   *   let v1 = p5.Vector.setMag(v0, 10);
   *
   *   // Prints "5" to the console.
   *   print(v0.mag());
   *
   *   // Prints "p5.Vector Object : [6, 8, 0]" to the console.
   *   print(v1.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Two arrows extend from the top left corner of a square toward its center. The red arrow reaches the center and the blue arrow only extends part of the way.');
   * }
   *
   * function draw() {
   *   background(240);
   *
   *   let origin = createVector(0, 0);
   *   let v = createVector(50, 50);
   *
   *   // Draw the red arrow.
   *   drawArrow(origin, v, 'red');
   *
   *   // Set v's magnitude to 30.
   *   v.setMag(30);
   *
   *   // Draw the blue arrow.
   *   drawArrow(origin, v, 'blue');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  setMag(n3) {
    return this.normalize().mult(n3);
  }
  /**
   * Calculates the angle a 2D vector makes with the positive x-axis.
   *
   * By convention, the positive x-axis has an angle of 0. Angles increase in
   * the clockwise direction.
   *
   * If the vector was created with
   * <a href="#/p5/createVector">createVector()</a>, `heading()` returns angles
   * in the units of the current <a href="#/p5/angleMode">angleMode()</a>.
   *
   * The static version of `heading()`, as in `p5.Vector.heading(v)`, works the
   * same way.
   *
   * @return {Number} angle of rotation.
   *
   * @example
   * <div class = "norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(1, 1);
   *
   *   // Prints "0.785..." to the console.
   *   print(v.heading());
   *
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Prints "45" to the console.
   *   print(v.heading());
   * }
   * </code>
   * </div>
   *
   * <div class = "norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(1, 1);
   *
   *   // Prints "0.785..." to the console.
   *   print(p5.Vector.heading(v));
   *
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Prints "45" to the console.
   *   print(p5.Vector.heading(v));
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('A black arrow extends from the top left of a square to its center. The text "Radians: 0.79" and "Degrees: 45" is written near the tip of the arrow.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   let origin = createVector(0, 0);
   *   let v = createVector(50, 50);
   *
   *   // Draw the black arrow.
   *   drawArrow(origin, v, 'black');
   *
   *   // Use radians.
   *   angleMode(RADIANS);
   *
   *   // Display the heading in radians.
   *   let h = round(v.heading(), 2);
   *   text(`Radians: ${h}`, 20, 70);
   *
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Display the heading in degrees.
   *   h = v.heading();
   *   text(`Degrees: ${h}`, 20, 85);
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  heading() {
    const h = Math.atan2(this.y, this.x);
    if (this.isPInst) return this._fromRadians(h);
    return h;
  }
  /**
   * Rotates a 2D vector to a specific angle without changing its magnitude.
   *
   * By convention, the positive x-axis has an angle of 0. Angles increase in
   * the clockwise direction.
   *
   * If the vector was created with
   * <a href="#/p5/createVector">createVector()</a>, `setHeading()` uses
   * the units of the current <a href="#/p5/angleMode">angleMode()</a>.
   *
   * @param  {Number}    angle angle of rotation.
   * @chainable
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(0, 1);
   *
   *   // Prints "1.570..." to the console.
   *   print(v.heading());
   *
   *   // Point to the left.
   *   v.setHeading(PI);
   *
   *   // Prints "3.141..." to the console.
   *   print(v.heading());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Create a p5.Vector object.
   *   let v = createVector(0, 1);
   *
   *   // Prints "90" to the console.
   *   print(v.heading());
   *
   *   // Point to the left.
   *   v.setHeading(180);
   *
   *   // Prints "180" to the console.
   *   print(v.heading());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Two arrows extend from the center of a gray square. The red arrow points to the right and the blue arrow points down.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Create p5.Vector objects.
   *   let v0 = createVector(50, 50);
   *   let v1 = createVector(30, 0);
   *
   *   // Draw the red arrow.
   *   drawArrow(v0, v1, 'red');
   *
   *   // Point down.
   *   v1.setHeading(HALF_PI);
   *
   *   // Draw the blue arrow.
   *   drawArrow(v0, v1, 'blue');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  setHeading(a2) {
    if (this.isPInst) a2 = this._toRadians(a2);
    let m3 = this.mag();
    this.x = m3 * Math.cos(a2);
    this.y = m3 * Math.sin(a2);
    return this;
  }
  /**
   * Rotates a 2D vector by an angle without changing its magnitude.
   *
   * By convention, the positive x-axis has an angle of 0. Angles increase in
   * the clockwise direction.
   *
   * If the vector was created with
   * <a href="#/p5/createVector">createVector()</a>, `rotate()` uses
   * the units of the current <a href="#/p5/angleMode">angleMode()</a>.
   *
   * The static version of `rotate()`, as in `p5.Vector.rotate(v, PI)`,
   * returns a new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change
   * the original.
   *
   * @param  {Number}    angle angle of rotation.
   * @chainable
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(1, 0);
   *
   *   // Prints "p5.Vector Object : [1, 0, 0]" to the console.
   *   print(v.toString());
   *
   *   // Rotate a quarter turn.
   *   v.rotate(HALF_PI);
   *
   *   // Prints "p5.Vector Object : [0, 1, 0]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Create a p5.Vector object.
   *   let v = createVector(1, 0);
   *
   *   // Prints "p5.Vector Object : [1, 0, 0]" to the console.
   *   print(v.toString());
   *
   *   // Rotate a quarter turn.
   *   v.rotate(90);
   *
   *   // Prints "p5.Vector Object : [0, 1, 0]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v0 = createVector(1, 0);
   *
   *   // Create a rotated copy.
   *   let v1 = p5.Vector.rotate(v0, HALF_PI);
   *
   *   // Prints "p5.Vector Object : [1, 0, 0]" to the console.
   *   print(v0.toString());
   *   // Prints "p5.Vector Object : [0, 1, 0]" to the console.
   *   print(v1.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Create a p5.Vector object.
   *   let v0 = createVector(1, 0);
   *
   *   // Create a rotated copy.
   *   let v1 = p5.Vector.rotate(v0, 90);
   *
   *   // Prints "p5.Vector Object : [1, 0, 0]" to the console.
   *   print(v0.toString());
   *
   *   // Prints "p5.Vector Object : [0, 1, 0]" to the console.
   *   print(v1.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let v0;
   * let v1;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create p5.Vector objects.
   *   v0 = createVector(50, 50);
   *   v1 = createVector(30, 0);
   *
   *   describe('A black arrow extends from the center of a gray square. The arrow rotates clockwise.');
   * }
   *
   * function draw() {
   *   background(240);
   *
   *   // Rotate v1.
   *   v1.rotate(0.01);
   *
   *   // Draw the black arrow.
   *   drawArrow(v0, v1, 'black');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  rotate(a2) {
    let newHeading = this.heading() + a2;
    if (this.isPInst) newHeading = this._toRadians(newHeading);
    const mag = this.mag();
    this.x = Math.cos(newHeading) * mag;
    this.y = Math.sin(newHeading) * mag;
    return this;
  }
  /**
   * Calculates the angle between two vectors.
   *
   * The angles returned are signed, which means that
   * `v1.angleBetween(v2) === -v2.angleBetween(v1)`.
   *
   * If the vector was created with
   * <a href="#/p5/createVector">createVector()</a>, `angleBetween()` returns
   * angles in the units of the current
   * <a href="#/p5/angleMode">angleMode()</a>.
   *
   * @param  {p5.Vector}    value x, y, and z components of a <a href="#/p5.Vector">p5.Vector</a>.
   * @return {Number}       angle between the vectors.
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v0 = createVector(1, 0);
   *   let v1 = createVector(0, 1);
   *
   *   // Prints "1.570..." to the console.
   *   print(v0.angleBetween(v1));
   *
   *   // Prints "-1.570..." to the console.
   *   print(v1.angleBetween(v0));
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Use degrees.
   *   angleMode(DEGREES);
   *   // Create p5.Vector objects.
   *   let v0 = createVector(1, 0);
   *   let v1 = createVector(0, 1);
   *
   *   // Prints "90" to the console.
   *   print(v0.angleBetween(v1));
   *
   *   // Prints "-90" to the console.
   *   print(v1.angleBetween(v0));
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v0 = createVector(1, 0);
   *   let v1 = createVector(0, 1);
   *
   *   // Prints "1.570..." to the console.
   *   print(p5.Vector.angleBetween(v0, v1));
   *
   *   // Prints "-1.570..." to the console.
   *   print(p5.Vector.angleBetween(v1, v0));
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Create p5.Vector objects.
   *   let v0 = createVector(1, 0);
   *   let v1 = createVector(0, 1);
   *
   *   // Prints "90" to the console.
   *   print(p5.Vector.angleBetween(v0, v1));
   *
   *   // Prints "-90" to the console.
   *   print(p5.Vector.angleBetween(v1, v0));
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Two arrows extend from the center of a gray square. A red arrow points to the right and a blue arrow points down. The text "Radians: 1.57" and "Degrees: 90" is written above the arrows.');
   * }
   * function draw() {
   *   background(200);
   *
   *   // Create p5.Vector objects.
   *   let v0 = createVector(50, 50);
   *   let v1 = createVector(30, 0);
   *   let v2 = createVector(0, 30);
   *
   *   // Draw the red arrow.
   *   drawArrow(v0, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   drawArrow(v0, v2, 'blue');
   *
   *   // Use radians.
   *   angleMode(RADIANS);
   *
   *   // Display the angle in radians.
   *   let angle = round(v1.angleBetween(v2), 2);
   *   text(`Radians: ${angle}`, 20, 20);
   *
   *   // Use degrees.
   *   angleMode(DEGREES);
   *
   *   // Display the angle in degrees.
   *   angle = round(v1.angleBetween(v2), 2);
   *   text(`Degrees: ${angle}`, 20, 35);
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  angleBetween(v) {
    const magSqMult = this.magSq() * v.magSq();
    if (magSqMult === 0) {
      return NaN;
    }
    const u = this.cross(v);
    let angle = Math.atan2(u.mag(), this.dot(v)) * Math.sign(u.z || 1);
    if (this.isPInst) {
      angle = this._fromRadians(angle);
    }
    return angle;
  }
  /**
   * Calculates new `x`, `y`, and `z` components that are proportionally the
   * same distance between two vectors.
   *
   * The `amt` parameter is the amount to interpolate between the old vector and
   * the new vector. 0.0 keeps all components equal to the old vector's, 0.5 is
   * halfway between, and 1.0 sets all components equal to the new vector's.
   *
   * The static version of `lerp()`, as in `p5.Vector.lerp(v0, v1, 0.5)`,
   * returns a new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change
   * the original.
   *
   * @param  {Number}    x   x component.
   * @param  {Number}    y   y component.
   * @param  {Number}    z   z component.
   * @param  {Number}    amt amount of interpolation between 0.0 (old vector)
   *                         and 1.0 (new vector). 0.5 is halfway between.
   * @chainable
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v0 = createVector(1, 1, 1);
   *   let v1 = createVector(3, 3, 3);
   *
   *   // Interpolate.
   *   v0.lerp(v1, 0.5);
   *
   *   // Prints "p5.Vector Object : [2, 2, 2]" to the console.
   *   print(v0.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(1, 1, 1);
   *
   *   // Interpolate.
   *   v.lerp(3, 3, 3, 0.5);
   *
   *   // Prints "p5.Vector Object : [2, 2, 2]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v0 = createVector(1, 1, 1);
   *   let v1 = createVector(3, 3, 3);
   *
   *   // Interpolate.
   *   let v2 = p5.Vector.lerp(v0, v1, 0.5);
   *
   *   // Prints "p5.Vector Object : [2, 2, 2]" to the console.
   *   print(v2.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Three arrows extend from the center of a gray square. A red arrow points to the right, a blue arrow points down, and a purple arrow points to the bottom right.');
   * }
   * function draw() {
   *   background(200);
   *
   *   // Create p5.Vector objects.
   *   let v0 = createVector(50, 50);
   *   let v1 = createVector(30, 0);
   *   let v2 = createVector(0, 30);
   *
   *   // Interpolate.
   *   let v3 = p5.Vector.lerp(v1, v2, 0.5);
   *
   *   // Draw the red arrow.
   *   drawArrow(v0, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   drawArrow(v0, v2, 'blue');
   *
   *   // Draw the purple arrow.
   *   drawArrow(v0, v3, 'purple');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {p5.Vector} v  <a href="#/p5.Vector">p5.Vector</a> to lerp toward.
   * @param  {Number}    amt
   * @chainable
   */
  lerp(x, y, z, amt) {
    if (x instanceof _Vector) {
      return this.lerp(x.x, x.y, x.z, y);
    }
    this.x += (x - this.x) * amt || 0;
    this.y += (y - this.y) * amt || 0;
    this.z += (z - this.z) * amt || 0;
    return this;
  }
  /**
   * Calculates a new heading and magnitude that are between two vectors.
   *
   * The `amt` parameter is the amount to interpolate between the old vector and
   * the new vector. 0.0 keeps the heading and magnitude equal to the old
   * vector's, 0.5 sets them halfway between, and 1.0 sets the heading and
   * magnitude equal to the new vector's.
   *
   * `slerp()` differs from <a href="#/p5.Vector/lerp">lerp()</a> because
   * it interpolates magnitude. Calling `v0.slerp(v1, 0.5)` sets `v0`'s
   * magnitude to a value halfway between its original magnitude and `v1`'s.
   * Calling `v0.lerp(v1, 0.5)` makes no such guarantee.
   *
   * The static version of `slerp()`, as in `p5.Vector.slerp(v0, v1, 0.5)`,
   * returns a new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change
   * the original.
   *
   * @param {p5.Vector} v <a href="#/p5.Vector">p5.Vector</a> to slerp toward.
   * @param {Number} amt  amount of interpolation between 0.0 (old vector)
   *                      and 1.0 (new vector). 0.5 is halfway between.
   * @return {p5.Vector}
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v0 = createVector(3, 0);
   *
   *   // Prints "3" to the console.
   *   print(v0.mag());
   *
   *   // Prints "0" to the console.
   *   print(v0.heading());
   *
   *   // Create a p5.Vector object.
   *   let v1 = createVector(0, 1);
   *
   *   // Prints "1" to the console.
   *   print(v1.mag());
   *
   *   // Prints "1.570..." to the console.
   *   print(v1.heading());
   *
   *   // Interpolate halfway between v0 and v1.
   *   v0.slerp(v1, 0.5);
   *
   *   // Prints "2" to the console.
   *   print(v0.mag());
   *
   *   // Prints "0.785..." to the console.
   *   print(v0.heading());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v0 = createVector(3, 0);
   *
   *   // Prints "3" to the console.
   *   print(v0.mag());
   *
   *   // Prints "0" to the console.
   *   print(v0.heading());
   *
   *   // Create a p5.Vector object.
   *   let v1 = createVector(0, 1);
   *
   *   // Prints "1" to the console.
   *   print(v1.mag());
   *
   *   // Prints "1.570..." to the console.
   *   print(v1.heading());
   *
   *   // Create a p5.Vector that's halfway between v0 and v1.
   *   let v3 = p5.Vector.slerp(v0, v1, 0.5);
   *
   *   // Prints "2" to the console.
   *   print(v3.mag());
   *
   *   // Prints "0.785..." to the console.
   *   print(v3.heading());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Three arrows extend from the center of a gray square. A red arrow points to the right, a blue arrow points to the left, and a purple arrow points down.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Create p5.Vector objects.
   *   let v0 = createVector(50, 50);
   *   let v1 = createVector(20, 0);
   *   let v2 = createVector(-40, 0);
   *
   *   // Create a p5.Vector that's halfway between v1 and v2.
   *   let v3 = p5.Vector.slerp(v1, v2, 0.5);
   *
   *   // Draw the red arrow.
   *   drawArrow(v0, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   drawArrow(v0, v2, 'blue');
   *
   *   // Draw the purple arrow.
   *   drawArrow(v0, v3, 'purple');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  slerp(v, amt) {
    if (amt === 0) {
      return this;
    }
    if (amt === 1) {
      return this.set(v);
    }
    const selfMag = this.mag();
    const vMag = v.mag();
    const magmag = selfMag * vMag;
    if (magmag === 0) {
      this.mult(1 - amt).add(v.x * amt, v.y * amt, v.z * amt);
      return this;
    }
    const axis = this.cross(v);
    const axisMag = axis.mag();
    const theta = Math.atan2(axisMag, this.dot(v));
    if (axisMag > 0) {
      axis.x /= axisMag;
      axis.y /= axisMag;
      axis.z /= axisMag;
    } else if (theta < Math.PI * 0.5) {
      this.mult(1 - amt).add(v.x * amt, v.y * amt, v.z * amt);
      return this;
    } else {
      if (this.z === 0 && v.z === 0) {
        axis.set(0, 0, 1);
      } else if (this.x !== 0) {
        axis.set(this.y, -this.x, 0).normalize();
      } else {
        axis.set(1, 0, 0);
      }
    }
    const ey = axis.cross(this);
    const lerpedMagFactor = 1 - amt + amt * vMag / selfMag;
    const cosMultiplier = lerpedMagFactor * Math.cos(amt * theta);
    const sinMultiplier = lerpedMagFactor * Math.sin(amt * theta);
    this.x = this.x * cosMultiplier + ey.x * sinMultiplier;
    this.y = this.y * cosMultiplier + ey.y * sinMultiplier;
    this.z = this.z * cosMultiplier + ey.z * sinMultiplier;
    return this;
  }
  /**
   * Reflects a vector about a line in 2D or a plane in 3D.
   *
   * The orientation of the line or plane is described by a normal vector that
   * points away from the shape.
   *
   * The static version of `reflect()`, as in `p5.Vector.reflect(v, n)`,
   * returns a new <a href="#/p5.Vector">p5.Vector</a> object and doesn't change
   * the original.
   *
   * @param  {p5.Vector} surfaceNormal  <a href="#/p5.Vector">p5.Vector</a>
   *                                    to reflect about.
   * @chainable
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a normal vector.
   *   let n = createVector(0, 1);
   *   // Create a vector to reflect.
   *   let v = createVector(4, 6);
   *
   *   // Reflect v about n.
   *   v.reflect(n);
   *
   *   // Prints "p5.Vector Object : [4, -6, 0]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a normal vector.
   *   let n = createVector(0, 1);
   *
   *   // Create a vector to reflect.
   *   let v0 = createVector(4, 6);
   *
   *   // Create a reflected vector.
   *   let v1 = p5.Vector.reflect(v0, n);
   *
   *   // Prints "p5.Vector Object : [4, -6, 0]" to the console.
   *   print(v1.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('Three arrows extend from the center of a gray square with a vertical line down its middle. A black arrow points to the right, a blue arrow points to the bottom left, and a red arrow points to the bottom right.');
   * }
   * function draw() {
   *   background(200);
   *
   *   // Draw a vertical line.
   *   line(50, 0, 50, 100);
   *
   *   // Create a normal vector.
   *   let n = createVector(1, 0);
   *
   *   // Center.
   *   let v0 = createVector(50, 50);
   *
   *   // Create a vector to reflect.
   *   let v1 = createVector(30, 40);
   *
   *   // Create a reflected vector.
   *   let v2 = p5.Vector.reflect(v1, n);
   *
   *   // Scale the normal vector for drawing.
   *   n.setMag(30);
   *
   *   // Draw the black arrow.
   *   drawArrow(v0, n, 'black');
   *
   *   // Draw the red arrow.
   *   drawArrow(v0, v1, 'red');
   *
   *   // Draw the blue arrow.
   *   drawArrow(v0, v2, 'blue');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  reflect(surfaceNormal) {
    const surfaceNormalCopy = _Vector.normalize(surfaceNormal);
    return this.sub(surfaceNormalCopy.mult(2 * this.dot(surfaceNormalCopy)));
  }
  /**
   * Returns the vector's components as an array of numbers.
   *
   * @return {Number[]} array with the vector's components.
   * @example
   * <div class = "norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = createVector(20, 30);
   *
   *   // Prints "[20, 30, 0]" to the console.
   *   print(v.array());
   * }
   * </code>
   * </div>
   */
  array() {
    return [this.x || 0, this.y || 0, this.z || 0];
  }
  /**
   * Checks whether all the vector's components are equal to another vector's.
   *
   * `equals()` returns `true` if the vector's components are all the same as another
   * vector's and `false` if not.
   *
   * The version of `equals()` with one parameter interprets it as another
   * <a href="#/p5.Vector">p5.Vector</a> object.
   *
   * The version of `equals()` with multiple parameters interprets them as the
   * components of another vector. Any missing parameters are assigned the value
   * 0.
   *
   * The static version of `equals()`, as in `p5.Vector.equals(v0, v1)`,
   * interprets both parameters as <a href="#/p5.Vector">p5.Vector</a> objects.
   *
   * @param {Number} [x] x component of the vector.
   * @param {Number} [y] y component of the vector.
   * @param {Number} [z] z component of the vector.
   * @return {Boolean} whether the vectors are equal.
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v0 = createVector(10, 20, 30);
   *   let v1 = createVector(10, 20, 30);
   *   let v2 = createVector(0, 0, 0);
   *
   *   // Prints "true" to the console.
   *   print(v0.equals(v1));
   *
   *   // Prints "false" to the console.
   *   print(v0.equals(v2));
   * }
   * </code>
   * </div>
   *
   * <div class = "norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v0 = createVector(5, 10, 20);
   *   let v1 = createVector(5, 10, 20);
   *   let v2 = createVector(13, 10, 19);
   *
   *   // Prints "true" to the console.
   *   print(v0.equals(v1.x, v1.y, v1.z));
   *
   *   // Prints "false" to the console.
   *   print(v0.equals(v2.x, v2.y, v2.z));
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create p5.Vector objects.
   *   let v0 = createVector(10, 20, 30);
   *   let v1 = createVector(10, 20, 30);
   *   let v2 = createVector(0, 0, 0);
   *
   *   // Prints "true" to the console.
   *   print(p5.Vector.equals(v0, v1));
   *
   *   // Prints "false" to the console.
   *   print(p5.Vector.equals(v0, v2));
   * }
   * </code>
   * </div>
   */
  /**
   * @param {p5.Vector|Array} value vector to compare.
   * @return {Boolean}
   */
  equals(...args) {
    let values;
    if (args[0] instanceof _Vector) {
      values = args[0]._values;
    } else if (Array.isArray(args[0])) {
      values = args[0];
    } else {
      values = args;
    }
    for (let i = 0; i < this._values.length; i++) {
      if (this._values[i] !== (values[i] || 0)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Replaces the components of a <a href="#/p5.Vector">p5.Vector</a> that are very close to zero with zero.
   *
   * In computers, handling numbers with decimals can give slightly imprecise answers due to the way those numbers are represented.
   * This can make it hard to check if a number is zero, as it may be close but not exactly zero.
   * This method rounds very close numbers to zero to make those checks easier
   *
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/EPSILON
   *
   * @method clampToZero
   * @return {p5.Vector} with components very close to zero replaced with zero.
   * @chainable
   */
  clampToZero() {
    for (let i = 0; i < this._values.length; i++) {
      this._values[i] = this._clampToZero(this._values[i]);
    }
    return this;
  }
  /**
   * Helper function for clampToZero
   * @private
   */
  _clampToZero(val2) {
    return Math.abs((val2 || 0) - 0) <= Number.EPSILON ? 0 : val2;
  }
  // Static Methods
  /**
   * Creates a new 2D vector from an angle.
   *
   * @static
   * @param {Number}     angle desired angle, in radians. Unaffected by <a href="#/p5/angleMode">angleMode()</a>.
   * @param {Number}     [length] length of the new vector (defaults to 1).
   * @return {p5.Vector}       new <a href="#/p5.Vector">p5.Vector</a> object.
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = p5.Vector.fromAngle(0);
   *
   *   // Prints "p5.Vector Object : [1, 0, 0]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = p5.Vector.fromAngle(0, 30);
   *
   *   // Prints "p5.Vector Object : [30, 0, 0]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe('A black arrow extends from the center of a gray square. It points to the right.');
   * }
   * function draw() {
   *   background(200);
   *
   *   // Create a p5.Vector to the center.
   *   let v0 = createVector(50, 50);
   *
   *   // Create a p5.Vector with an angle 0 and magnitude 30.
   *   let v1 = p5.Vector.fromAngle(0, 30);
   *
   *   // Draw the black arrow.
   *   drawArrow(v0, v1, 'black');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  static fromAngle(angle, length) {
    if (typeof length === "undefined") {
      length = 1;
    }
    return new _Vector(length * Math.cos(angle), length * Math.sin(angle), 0);
  }
  /**
   * Creates a new 3D vector from a pair of ISO spherical angles.
   *
   * @static
   * @param {Number}     theta    polar angle in radians (zero is up).
   * @param {Number}     phi      azimuthal angle in radians
   *                               (zero is out of the screen).
   * @param {Number}     [length] length of the new vector (defaults to 1).
   * @return {p5.Vector}          new <a href="#/p5.Vector">p5.Vector</a> object.
   *
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = p5.Vector.fromAngles(0, 0);
   *
   *   // Prints "p5.Vector Object : [0, -1, 0]" to the console.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   describe('A light shines on a pink sphere as it orbits.');
   * }
   *
   * function draw() {
   *   background(0);
   *
   *   // Calculate the ISO angles.
   *   let theta = frameCount *  0.05;
   *   let phi = 0;
   *
   *   // Create a p5.Vector object.
   *   let v = p5.Vector.fromAngles(theta, phi, 100);
   *
   *   // Create a point light using the p5.Vector.
   *   let c = color('deeppink');
   *   pointLight(c, v);
   *
   *   // Style the sphere.
   *   fill(255);
   *   noStroke();
   *
   *   // Draw the sphere.
   *   sphere(35);
   * }
   * </code>
   * </div>
   */
  static fromAngles(theta, phi2, length) {
    if (typeof length === "undefined") {
      length = 1;
    }
    const cosPhi = Math.cos(phi2);
    const sinPhi = Math.sin(phi2);
    const cosTheta = Math.cos(theta);
    const sinTheta = Math.sin(theta);
    return new _Vector(
      length * sinTheta * sinPhi,
      -length * cosTheta,
      length * sinTheta * cosPhi
    );
  }
  /**
   * Creates a new 2D unit vector with a random heading.
   *
   * @static
   * @return {p5.Vector} new <a href="#/p5.Vector">p5.Vector</a> object.
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = p5.Vector.random2D();
   *
   *   // Prints "p5.Vector Object : [x, y, 0]" to the console
   *   // where x and y are small random numbers.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Slow the frame rate.
   *   frameRate(1);
   *
   *   describe('A black arrow in extends from the center of a gray square. It changes direction once per second.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Create a p5.Vector to the center.
   *   let v0 = createVector(50, 50);
   *
   *   // Create a random p5.Vector.
   *   let v1 = p5.Vector.random2D();
   *
   *   // Scale v1 for drawing.
   *   v1.mult(30);
   *
   *   // Draw the black arrow.
   *   drawArrow(v0, v1, 'black');
   * }
   *
   * // Draws an arrow between two vectors.
   * function drawArrow(base, vec, myColor) {
   *   push();
   *   stroke(myColor);
   *   strokeWeight(3);
   *   fill(myColor);
   *   translate(base.x, base.y);
   *   line(0, 0, vec.x, vec.y);
   *   rotate(vec.heading());
   *   let arrowSize = 7;
   *   translate(vec.mag() - arrowSize, 0);
   *   triangle(0, arrowSize / 2, 0, -arrowSize / 2, arrowSize, 0);
   *   pop();
   * }
   * </code>
   * </div>
   */
  static random2D() {
    return this.fromAngle(Math.random() * TWO_PI);
  }
  /**
   * Creates a new 3D unit vector with a random heading.
   *
   * @static
   * @return {p5.Vector} new <a href="#/p5.Vector">p5.Vector</a> object.
   * @example
   * <div class="norender">
   * <code>
   * function setup() {
   *   // Create a p5.Vector object.
   *   let v = p5.Vector.random3D();
   *
   *   // Prints "p5.Vector Object : [x, y, z]" to the console
   *   // where x, y, and z are small random numbers.
   *   print(v.toString());
   * }
   * </code>
   * </div>
   */
  static random3D() {
    const angle = Math.random() * TWO_PI;
    const vz = Math.random() * 2 - 1;
    const vzBase = Math.sqrt(1 - vz * vz);
    const vx = vzBase * Math.cos(angle);
    const vy = vzBase * Math.sin(angle);
    return new _Vector(vx, vy, vz);
  }
  // Returns a copy of a vector.
  /**
   * @static
   * @param  {p5.Vector} v the <a href="#/p5.Vector">p5.Vector</a> to create a copy of
   * @return {p5.Vector} the copy of the <a href="#/p5.Vector">p5.Vector</a> object
   */
  static copy(v) {
    return v.copy(v);
  }
  // Adds two vectors together and returns a new one.
  /**
   * @static
   * @param  {p5.Vector} v1 A <a href="#/p5.Vector">p5.Vector</a> to add
   * @param  {p5.Vector} v2 A <a href="#/p5.Vector">p5.Vector</a> to add
   * @param  {p5.Vector} [target] vector to receive the result.
   * @return {p5.Vector} resulting <a href="#/p5.Vector">p5.Vector</a>.
   */
  static add(v1, v2, target) {
    if (!target) {
      target = v1.copy();
      if (arguments.length === 3) {
        p5._friendlyError(
          "The target parameter is undefined, it should be of type p5.Vector",
          "p5.Vector.add"
        );
      }
    } else {
      target.set(v1);
    }
    target.add(v2);
    return target;
  }
  // Returns a vector remainder when it is divided by another vector
  /**
   * @static
   * @param  {p5.Vector} v1 The dividend <a href="#/p5.Vector">p5.Vector</a>
   * @param  {p5.Vector} v2 The divisor <a href="#/p5.Vector">p5.Vector</a>
   */
  /**
   * @static
   * @param  {p5.Vector} v1
   * @param  {p5.Vector} v2
   * @return {p5.Vector} The resulting <a href="#/p5.Vector">p5.Vector</a>
   */
  static rem(v1, v2) {
    if (v1 instanceof _Vector && v2 instanceof _Vector) {
      let target = v1.copy();
      target.rem(v2);
      return target;
    }
  }
  /*
   * Subtracts one <a href="#/p5.Vector">p5.Vector</a> from another and returns a new one.  The second
   * vector (`v2`) is subtracted from the first (`v1`), resulting in `v1-v2`.
   */
  /**
   * @static
   * @param  {p5.Vector} v1 A <a href="#/p5.Vector">p5.Vector</a> to subtract from
   * @param  {p5.Vector} v2 A <a href="#/p5.Vector">p5.Vector</a> to subtract
   * @param  {p5.Vector} [target] vector to receive the result.
   * @return {p5.Vector} The resulting <a href="#/p5.Vector">p5.Vector</a>
   */
  static sub(v1, v2, target) {
    if (!target) {
      target = v1.copy();
      if (arguments.length === 3) {
        p5._friendlyError(
          "The target parameter is undefined, it should be of type p5.Vector",
          "p5.Vector.sub"
        );
      }
    } else {
      target.set(v1);
    }
    target.sub(v2);
    return target;
  }
  /**
   * Multiplies a vector by a scalar and returns a new vector.
   */
  /**
   * @static
   * @param  {Number} x
   * @param  {Number} y
   * @param  {Number} [z]
   * @return {p5.Vector} resulting new <a href="#/p5.Vector">p5.Vector</a>.
   */
  /**
   * @static
   * @param  {p5.Vector} v
   * @param  {Number}  n
   * @param  {p5.Vector} [target] vector to receive the result.
   */
  /**
   * @static
   * @param  {p5.Vector} v0
   * @param  {p5.Vector} v1
   * @param  {p5.Vector} [target]
   */
  /**
   * @static
   * @param  {p5.Vector} v0
   * @param  {Number[]} arr
   * @param  {p5.Vector} [target]
   */
  static mult(v, n3, target) {
    if (!target) {
      target = v.copy();
      if (arguments.length === 3) {
        p5._friendlyError(
          "The target parameter is undefined, it should be of type p5.Vector",
          "p5.Vector.mult"
        );
      }
    } else {
      target.set(v);
    }
    target.mult(n3);
    return target;
  }
  /**
   * Rotates the vector (only 2D vectors) by the given angle; magnitude remains the same. Returns a new vector.
   */
  /**
   * @static
   * @param  {p5.Vector} v
   * @param  {Number} angle
   * @param  {p5.Vector} [target] The vector to receive the result
   */
  static rotate(v, a2, target) {
    if (arguments.length === 2) {
      target = v.copy();
    } else {
      if (!(target instanceof _Vector)) {
        p5._friendlyError(
          "The target parameter should be of type p5.Vector",
          "p5.Vector.rotate"
        );
      }
      target.set(v);
    }
    target.rotate(a2);
    return target;
  }
  /**
   * Divides a vector by a scalar and returns a new vector.
   */
  /**
   * @static
   * @param  {Number} x
   * @param  {Number} y
   * @param  {Number} [z]
   * @return {p5.Vector} The resulting new <a href="#/p5.Vector">p5.Vector</a>
   */
  /**
   * @static
   * @param  {p5.Vector} v
   * @param  {Number}  n
   * @param  {p5.Vector} [target] The vector to receive the result
   */
  /**
   * @static
   * @param  {p5.Vector} v0
   * @param  {p5.Vector} v1
   * @param  {p5.Vector} [target]
   */
  /**
   * @static
   * @param  {p5.Vector} v0
   * @param  {Number[]} arr
   * @param  {p5.Vector} [target]
   */
  static div(v, n3, target) {
    if (!target) {
      target = v.copy();
      if (arguments.length === 3) {
        p5._friendlyError(
          "The target parameter is undefined, it should be of type p5.Vector",
          "p5.Vector.div"
        );
      }
    } else {
      target.set(v);
    }
    target.div(n3);
    return target;
  }
  /**
   * Calculates the dot product of two vectors.
   */
  /**
   * @static
   * @param  {p5.Vector} v1 first <a href="#/p5.Vector">p5.Vector</a>.
   * @param  {p5.Vector} v2 second <a href="#/p5.Vector">p5.Vector</a>.
   * @return {Number}     dot product.
   */
  static dot(v1, v2) {
    return v1.dot(v2);
  }
  /**
   * Calculates the cross product of two vectors.
   */
  /**
   * @static
   * @param  {p5.Vector} v1 first <a href="#/p5.Vector">p5.Vector</a>.
   * @param  {p5.Vector} v2 second <a href="#/p5.Vector">p5.Vector</a>.
   * @return {Number}     cross product.
   */
  static cross(v1, v2) {
    return v1.cross(v2);
  }
  /**
   * Calculates the Euclidean distance between two points (considering a
   * point as a vector object).
   */
  /**
   * @static
   * @param  {p5.Vector} v1 The first <a href="#/p5.Vector">p5.Vector</a>
   * @param  {p5.Vector} v2 The second <a href="#/p5.Vector">p5.Vector</a>
   * @return {Number}     The distance
   */
  static dist(v1, v2) {
    return v1.dist(v2);
  }
  /**
   * Linear interpolate a vector to another vector and return the result as a
   * new vector.
   */
  /**
   * @static
   * @param {p5.Vector} v1
   * @param {p5.Vector} v2
   * @param {Number} amt
   * @param {p5.Vector} [target] The vector to receive the result
   * @return {p5.Vector}      The lerped value
   */
  static lerp(v1, v2, amt, target) {
    if (!target) {
      target = v1.copy();
      if (arguments.length === 4) {
        p5._friendlyError(
          "The target parameter is undefined, it should be of type p5.Vector",
          "p5.Vector.lerp"
        );
      }
    } else {
      target.set(v1);
    }
    target.lerp(v2, amt);
    return target;
  }
  /**
   * Performs spherical linear interpolation with the other vector
   * and returns the resulting vector.
   * This works in both 3D and 2D. As for 2D, the result of slerping
   * between 2D vectors is always a 2D vector.
   */
  /**
   * @static
   * @param {p5.Vector} v1 old vector.
   * @param {p5.Vector} v2 new vector.
   * @param {Number} amt
   * @param {p5.Vector} [target] vector to receive the result.
   * @return {p5.Vector} slerped vector between v1 and v2
   */
  static slerp(v1, v2, amt, target) {
    if (!target) {
      target = v1.copy();
      if (arguments.length === 4) {
        p5._friendlyError(
          "The target parameter is undefined, it should be of type p5.Vector",
          "p5.Vector.slerp"
        );
      }
    } else {
      target.set(v1);
    }
    target.slerp(v2, amt);
    return target;
  }
  /**
   * Calculates the magnitude (length) of the vector and returns the result as
   * a float (this is simply the equation `sqrt(x*x + y*y + z*z)`.)
   */
  /**
   * @static
   * @param {p5.Vector} vecT The vector to return the magnitude of
   * @return {Number}        The magnitude of vecT
   */
  static mag(vecT) {
    return vecT.mag();
  }
  /**
   * Calculates the squared magnitude of the vector and returns the result
   * as a float (this is simply the equation <em>(x\*x + y\*y + z\*z)</em>.)
   * Faster if the real length is not required in the
   * case of comparing vectors, etc.
   */
  /**
   * @static
   * @param {p5.Vector} vecT the vector to return the squared magnitude of
   * @return {Number}        the squared magnitude of vecT
   */
  static magSq(vecT) {
    return vecT.magSq();
  }
  /**
   * Normalize the vector to length 1 (make it a unit vector).
   */
  /**
   * @static
   * @param {p5.Vector} v  The vector to normalize
   * @param {p5.Vector} [target] The vector to receive the result
   * @return {p5.Vector}   The vector v, normalized to a length of 1
   */
  static normalize(v, target) {
    if (arguments.length < 2) {
      target = v.copy();
    } else {
      if (!(target instanceof _Vector)) {
        p5._friendlyError(
          "The target parameter should be of type p5.Vector",
          "p5.Vector.normalize"
        );
      }
      target.set(v);
    }
    return target.normalize();
  }
  /**
   * Limit the magnitude of the vector to the value used for the <b>max</b>
   * parameter.
   */
  /**
   * @static
   * @param {p5.Vector} v  the vector to limit
   * @param {Number}    max
   * @param {p5.Vector} [target] the vector to receive the result (Optional)
   * @return {p5.Vector} v with a magnitude limited to max
   */
  static limit(v, max, target) {
    if (arguments.length < 3) {
      target = v.copy();
    } else {
      if (!(target instanceof _Vector)) {
        p5._friendlyError(
          "The target parameter should be of type p5.Vector",
          "p5.Vector.limit"
        );
      }
      target.set(v);
    }
    return target.limit(max);
  }
  /**
   * Set the magnitude of the vector to the value used for the <b>len</b>
   * parameter.
   */
  /**
   * @static
   * @param {p5.Vector} v  the vector to set the magnitude of
   * @param {Number}    len
   * @param {p5.Vector} [target] the vector to receive the result (Optional)
   * @return {p5.Vector} v with a magnitude set to len
   */
  static setMag(v, len, target) {
    if (arguments.length < 3) {
      target = v.copy();
    } else {
      if (!(target instanceof _Vector)) {
        p5._friendlyError(
          "The target parameter should be of type p5.Vector",
          "p5.Vector.setMag"
        );
      }
      target.set(v);
    }
    return target.setMag(len);
  }
  /**
   * Calculate the angle of rotation for this vector (only 2D vectors).
   * p5.Vectors created using <a href="#/p5/createVector">createVector()</a>
   * will take the current <a href="#/p5/angleMode">angleMode</a> into
   * consideration, and give the angle in radians or degrees accordingly.
   */
  /**
   * @static
   * @param {p5.Vector} v the vector to find the angle of
   * @return {Number} the angle of rotation
   */
  static heading(v) {
    return v.heading();
  }
  /**
   * Calculates and returns the angle between two vectors. This function will take
   * the <a href="#/p5/angleMode">angleMode</a> on v1 into consideration, and
   * give the angle in radians or degrees accordingly.
   */
  /**
   * @static
   * @param  {p5.Vector}    v1 the first vector.
   * @param  {p5.Vector}    v2 the second vector.
   * @return {Number}       angle between the two vectors.
   */
  static angleBetween(v1, v2) {
    return v1.angleBetween(v2);
  }
  /**
   * Reflect a vector about a normal to a line in 2D, or about a normal to a
   * plane in 3D.
   */
  /**
   * @static
   * @param  {p5.Vector} incidentVector vector to be reflected.
   * @param  {p5.Vector} surfaceNormal
   * @param  {p5.Vector} [target] vector to receive the result.
   * @return {p5.Vector} the reflected vector
   */
  static reflect(incidentVector, surfaceNormal, target) {
    if (arguments.length < 3) {
      target = incidentVector.copy();
    } else {
      if (!(target instanceof _Vector)) {
        p5._friendlyError(
          "The target parameter should be of type p5.Vector",
          "p5.Vector.reflect"
        );
      }
      target.set(incidentVector);
    }
    return target.reflect(surfaceNormal);
  }
  /**
   * Return a representation of this vector as a float array. This is only
   * for temporary use. If used in any other fashion, the contents should be
   * copied by using the <b>p5.Vector.<a href="#/p5.Vector/copy">copy()</a></b>
   * method to copy into your own vector.
   */
  /**
   * @static
   * @param  {p5.Vector} v the vector to convert to an array
   * @return {Number[]} an Array with the 3 values
   */
  static array(v) {
    return v.array();
  }
  /**
   * Equality check against a <a href="#/p5.Vector">p5.Vector</a>
   */
  /**
   * @static
   * @param {p5.Vector|Array} v1 the first vector to compare
   * @param {p5.Vector|Array} v2 the second vector to compare
   * @return {Boolean}
   */
  static equals(v1, v2) {
    let v;
    if (v1 instanceof _Vector) {
      v = v1;
    } else if (v1 instanceof Array) {
      v = new _Vector().set(v1);
    } else {
      p5._friendlyError(
        "The v1 parameter should be of type Array or p5.Vector",
        "p5.Vector.equals"
      );
    }
    return v.equals(v2);
  }
};
function vector(p53, fn2) {
  p53.Vector = Vector;
}
if (typeof p5 !== "undefined") {
  vector(p5, p5.prototype);
}

// node_modules/p5/dist/core/environment.js
function environment(p53, fn2) {
  const standardCursors = [ARROW, CROSS, HAND, MOVE, TEXT, WAIT];
  fn2._frameRate = 0;
  fn2._lastFrameTime = window.performance.now();
  fn2._targetFrameRate = 60;
  const _windowPrint = window.print;
  let windowPrintDisabled = false;
  fn2.print = function(...args) {
    if (!args.length) {
      if (!windowPrintDisabled) {
        _windowPrint();
        if (window.confirm(
          "You just tried to print the webpage. Do you want to prevent this from running again?"
        )) {
          windowPrintDisabled = true;
        }
      }
    } else {
      console.log(...args);
    }
  };
  fn2.frameCount = 0;
  fn2.deltaTime = 0;
  fn2.focused = document.hasFocus();
  fn2.cursor = function(type3, x, y) {
    let cursor = "auto";
    const canvas2 = this._curElement.elt;
    if (standardCursors.includes(type3)) {
      cursor = type3;
    } else if (typeof type3 === "string") {
      let coords = "";
      if (x && y && (typeof x === "number" && typeof y === "number")) {
        coords = `${x} ${y}`;
      }
      if (type3.substring(0, 7) === "http://" || type3.substring(0, 8) === "https://") {
        cursor = `url(${type3}) ${coords}, auto`;
      } else if (/\.(cur|jpg|jpeg|gif|png|CUR|JPG|JPEG|GIF|PNG)$/.test(type3)) {
        cursor = `url(${type3}) ${coords}, auto`;
      } else {
        cursor = type3;
      }
    }
    canvas2.style.cursor = cursor;
  };
  fn2.frameRate = function(fps) {
    if (typeof fps !== "number" || fps < 0) {
      return this._frameRate;
    } else {
      this._targetFrameRate = fps;
      if (fps === 0) {
        this._frameRate = fps;
      }
      return this;
    }
  };
  fn2.getFrameRate = function() {
    return this.frameRate();
  };
  fn2.setFrameRate = function(fps) {
    return this.frameRate(fps);
  };
  fn2.getTargetFrameRate = function() {
    return this._targetFrameRate;
  };
  fn2.noCursor = function() {
    this._curElement.elt.style.cursor = "none";
  };
  fn2.webglVersion = P2D;
  fn2.displayWidth = screen.width;
  fn2.displayHeight = screen.height;
  fn2.windowWidth = 0;
  fn2.windowHeight = 0;
  fn2._onresize = function(e2) {
    this.windowWidth = getWindowWidth();
    this.windowHeight = getWindowHeight();
    const context = this._isGlobal ? window : this;
    let executeDefault;
    if (typeof context.windowResized === "function") {
      executeDefault = context.windowResized(e2);
      if (executeDefault !== void 0 && !executeDefault) {
        e2.preventDefault();
      }
    }
  };
  function getWindowWidth() {
    return window.innerWidth || document.documentElement && document.documentElement.clientWidth || document.body && document.body.clientWidth || 0;
  }
  function getWindowHeight() {
    return window.innerHeight || document.documentElement && document.documentElement.clientHeight || document.body && document.body.clientHeight || 0;
  }
  fn2._updateWindowSize = function() {
    this.windowWidth = getWindowWidth();
    this.windowHeight = getWindowHeight();
  };
  Object.defineProperty(fn2, "width", {
    get() {
      return this._renderer.width;
    }
  });
  Object.defineProperty(fn2, "height", {
    get() {
      return this._renderer.height;
    }
  });
  fn2.fullscreen = function(val2) {
    if (typeof val2 === "undefined") {
      return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement;
    } else {
      if (val2) {
        launchFullscreen(document.documentElement);
      } else {
        exitFullscreen();
      }
    }
  };
  fn2.pixelDensity = function(val2) {
    let returnValue;
    if (typeof val2 === "number") {
      if (val2 !== this._renderer._pixelDensity) {
        this._renderer._pixelDensity = val2;
      }
      returnValue = this;
      this.resizeCanvas(this.width, this.height, true);
    } else {
      returnValue = this._renderer._pixelDensity;
    }
    return returnValue;
  };
  fn2.displayDensity = () => window.devicePixelRatio;
  function launchFullscreen(element2) {
    const enabled = document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled;
    if (!enabled) {
      throw new Error("Fullscreen not enabled in this browser.");
    }
    if (element2.requestFullscreen) {
      element2.requestFullscreen();
    } else if (element2.mozRequestFullScreen) {
      element2.mozRequestFullScreen();
    } else if (element2.webkitRequestFullscreen) {
      element2.webkitRequestFullscreen();
    } else if (element2.msRequestFullscreen) {
      element2.msRequestFullscreen();
    }
  }
  function exitFullscreen() {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    }
  }
  fn2.getURL = () => location.href;
  fn2.getURLPath = () => location.pathname.split("/").filter((v) => v !== "");
  fn2.getURLParams = function() {
    const re = /[?&]([^&=]+)(?:[&=])([^&=]+)/gim;
    let m3;
    const v = {};
    while ((m3 = re.exec(location.search)) != null) {
      if (m3.index === re.lastIndex) {
        re.lastIndex++;
      }
      v[m3[1]] = m3[2];
    }
    return v;
  };
  fn2.worldToScreen = function(worldPosition) {
    if (typeof worldPosition === "number") {
      worldPosition = this.createVector(...arguments);
    }
    const matrix2 = this._renderer.getWorldToScreenMatrix();
    const screenPosition = matrix2.multiplyAndNormalizePoint(worldPosition);
    return screenPosition;
  };
  fn2.screenToWorld = function(screenPosition) {
    if (typeof screenPosition === "number") {
      screenPosition = this.createVector(...arguments);
    }
    const matrix2 = this._renderer.getWorldToScreenMatrix();
    if (screenPosition.dimensions == 2) {
      let z = matrix2.mat4[14] / matrix2.mat4[15];
      screenPosition = this.createVector(screenPosition.x, screenPosition.y, z);
    }
    const matrixInverse = matrix2.invert(matrix2);
    const worldPosition = matrixInverse.multiplyAndNormalizePoint(screenPosition);
    return worldPosition;
  };
}
if (typeof p5 !== "undefined") {
  environment(p5, p5.prototype);
}

// node_modules/colorjs.io/src/multiply-matrices.js
function multiplyMatrices(A, B) {
  let m3 = A.length;
  if (!Array.isArray(A[0])) {
    A = [A];
  }
  if (!Array.isArray(B[0])) {
    B = B.map((x) => [x]);
  }
  let p2 = B[0].length;
  let B_cols = B[0].map((_23, i) => B.map((x) => x[i]));
  let product = A.map((row) => B_cols.map((col) => {
    let ret = 0;
    if (!Array.isArray(row)) {
      for (let c4 of col) {
        ret += row * c4;
      }
      return ret;
    }
    for (let i = 0; i < row.length; i++) {
      ret += row[i] * (col[i] || 0);
    }
    return ret;
  }));
  if (m3 === 1) {
    product = product[0];
  }
  if (p2 === 1) {
    return product.map((x) => x[0]);
  }
  return product;
}

// node_modules/colorjs.io/src/util.js
function isString(str) {
  return type(str) === "string";
}
function type(o) {
  let str = Object.prototype.toString.call(o);
  return (str.match(/^\[object\s+(.*?)\]$/)[1] || "").toLowerCase();
}
function serializeNumber(n3, { precision, unit }) {
  if (isNone(n3)) {
    return "none";
  }
  return toPrecision(n3, precision) + (unit ?? "");
}
function isNone(n3) {
  return Number.isNaN(n3) || n3 instanceof Number && (n3 == null ? void 0 : n3.none);
}
function skipNone(n3) {
  return isNone(n3) ? 0 : n3;
}
function toPrecision(n3, precision) {
  if (n3 === 0) {
    return 0;
  }
  let integer2 = ~~n3;
  let digits = 0;
  if (integer2 && precision) {
    digits = ~~Math.log10(Math.abs(integer2)) + 1;
  }
  const multiplier = 10 ** (precision - digits);
  return Math.floor(n3 * multiplier + 0.5) / multiplier;
}
var angleFactor = {
  deg: 1,
  grad: 0.9,
  rad: 180 / Math.PI,
  turn: 360
};
function parseFunction(str) {
  if (!str) {
    return;
  }
  str = str.trim();
  const isFunctionRegex = /^([a-z]+)\((.+?)\)$/i;
  const isNumberRegex = /^-?[\d.]+$/;
  const unitValueRegex = /%|deg|g?rad|turn$/;
  const singleArgument = /\/?\s*(none|[-\w.]+(?:%|deg|g?rad|turn)?)/g;
  let parts = str.match(isFunctionRegex);
  if (parts) {
    let args = [];
    parts[2].replace(singleArgument, ($0, rawArg) => {
      let match = rawArg.match(unitValueRegex);
      let arg = rawArg;
      if (match) {
        let unit = match[0];
        let unitlessArg = arg.slice(0, -unit.length);
        if (unit === "%") {
          arg = new Number(unitlessArg / 100);
          arg.type = "<percentage>";
        } else {
          arg = new Number(unitlessArg * angleFactor[unit]);
          arg.type = "<angle>";
          arg.unit = unit;
        }
      } else if (isNumberRegex.test(arg)) {
        arg = new Number(arg);
        arg.type = "<number>";
      } else if (arg === "none") {
        arg = new Number(NaN);
        arg.none = true;
      }
      if ($0.startsWith("/")) {
        arg = arg instanceof Number ? arg : new Number(arg);
        arg.alpha = true;
      }
      if (typeof arg === "object" && arg instanceof Number) {
        arg.raw = rawArg;
      }
      args.push(arg);
    });
    return {
      name: parts[1].toLowerCase(),
      rawName: parts[1],
      rawArgs: parts[2],
      // An argument could be (as of css-color-4):
      // a number, percentage, degrees (hue), ident (in color())
      args
    };
  }
}
function last(arr2) {
  return arr2[arr2.length - 1];
}
function interpolate(start, end, p2) {
  if (isNaN(start)) {
    return end;
  }
  if (isNaN(end)) {
    return start;
  }
  return start + (end - start) * p2;
}
function interpolateInv(start, end, value) {
  return (value - start) / (end - start);
}
function mapRange(from, to2, value) {
  return interpolate(to2[0], to2[1], interpolateInv(from[0], from[1], value));
}
function parseCoordGrammar(coordGrammars) {
  return coordGrammars.map((coordGrammar2) => {
    return coordGrammar2.split("|").map((type3) => {
      type3 = type3.trim();
      let range2 = type3.match(/^(<[a-z]+>)\[(-?[.\d]+),\s*(-?[.\d]+)\]?$/);
      if (range2) {
        let ret = new String(range2[1]);
        ret.range = [+range2[2], +range2[3]];
        return ret;
      }
      return type3;
    });
  });
}
function clamp(min, val2, max) {
  return Math.max(Math.min(max, val2), min);
}
function copySign(to2, from) {
  return Math.sign(to2) === Math.sign(from) ? to2 : -to2;
}
function spow(base2, exp) {
  return copySign(Math.abs(base2) ** exp, base2);
}
function zdiv(n3, d2) {
  return d2 === 0 ? 0 : n3 / d2;
}
function bisectLeft(arr2, value, lo = 0, hi = arr2.length) {
  while (lo < hi) {
    const mid = lo + hi >> 1;
    if (arr2[mid] < value) {
      lo = mid + 1;
    } else {
      hi = mid;
    }
  }
  return lo;
}

// node_modules/colorjs.io/src/hooks.js
var Hooks = class {
  add(name, callback, first) {
    if (typeof arguments[0] != "string") {
      for (var name in arguments[0]) {
        this.add(name, arguments[0][name], arguments[1]);
      }
      return;
    }
    (Array.isArray(name) ? name : [name]).forEach(function(name2) {
      this[name2] = this[name2] || [];
      if (callback) {
        this[name2][first ? "unshift" : "push"](callback);
      }
    }, this);
  }
  run(name, env) {
    this[name] = this[name] || [];
    this[name].forEach(function(callback) {
      callback.call(env && env.context ? env.context : env, env);
    });
  }
};
var hooks = new Hooks();
var hooks_default = hooks;

// node_modules/colorjs.io/src/adapt.js
var WHITES = {
  // for compatibility, the four-digit chromaticity-derived ones everyone else uses
  D50: [0.3457 / 0.3585, 1, (1 - 0.3457 - 0.3585) / 0.3585],
  D65: [0.3127 / 0.329, 1, (1 - 0.3127 - 0.329) / 0.329]
};
function getWhite(name) {
  if (Array.isArray(name)) {
    return name;
  }
  return WHITES[name];
}
function adapt(W1, W2, XYZ, options2 = {}) {
  W1 = getWhite(W1);
  W2 = getWhite(W2);
  if (!W1 || !W2) {
    throw new TypeError(`Missing white point to convert ${!W1 ? "from" : ""}${!W1 && !W2 ? "/" : ""}${!W2 ? "to" : ""}`);
  }
  if (W1 === W2) {
    return XYZ;
  }
  let env = { W1, W2, XYZ, options: options2 };
  hooks_default.run("chromatic-adaptation-start", env);
  if (!env.M) {
    if (env.W1 === WHITES.D65 && env.W2 === WHITES.D50) {
      env.M = [
        [1.0479297925449969, 0.022946870601609652, -0.05019226628920524],
        [0.02962780877005599, 0.9904344267538799, -0.017073799063418826],
        [-0.009243040646204504, 0.015055191490298152, 0.7518742814281371]
      ];
    } else if (env.W1 === WHITES.D50 && env.W2 === WHITES.D65) {
      env.M = [
        [0.955473421488075, -0.02309845494876471, 0.06325924320057072],
        [-0.0283697093338637, 1.0099953980813041, 0.021041441191917323],
        [0.012314014864481998, -0.020507649298898964, 1.330365926242124]
      ];
    }
  }
  hooks_default.run("chromatic-adaptation-end", env);
  if (env.M) {
    return multiplyMatrices(env.M, env.XYZ);
  } else {
    throw new TypeError("Only Bradford CAT with white points D50 and D65 supported for now.");
  }
}

// node_modules/colorjs.io/src/defaults.js
var _a, _b, _c;
var defaults_default = {
  gamut_mapping: "css",
  precision: 5,
  deltaE: "76",
  // Default deltaE method
  verbose: ((_c = (_b = (_a = globalThis == null ? void 0 : globalThis.process) == null ? void 0 : _a.env) == null ? void 0 : _b.NODE_ENV) == null ? void 0 : _c.toLowerCase()) !== "test",
  warn: function warn(msg) {
    var _a2, _b2;
    if (this.verbose) {
      (_b2 = (_a2 = globalThis == null ? void 0 : globalThis.console) == null ? void 0 : _a2.warn) == null ? void 0 : _b2.call(_a2, msg);
    }
  }
};

// node_modules/colorjs.io/src/parse.js
var noneTypes = /* @__PURE__ */ new Set(["<number>", "<percentage>", "<angle>"]);
function coerceCoords(space, format, name, coords) {
  let types2 = Object.entries(space.coords).map(([id, coordMeta], i) => {
    let coordGrammar2 = format.coordGrammar[i];
    let arg = coords[i];
    let providedType = arg == null ? void 0 : arg.type;
    let type3;
    if (arg.none) {
      type3 = coordGrammar2.find((c4) => noneTypes.has(c4));
    } else {
      type3 = coordGrammar2.find((c4) => c4 == providedType);
    }
    if (!type3) {
      let coordName = coordMeta.name || id;
      throw new TypeError(`${providedType ?? arg.raw} not allowed for ${coordName} in ${name}()`);
    }
    let fromRange = type3.range;
    if (providedType === "<percentage>") {
      fromRange || (fromRange = [0, 1]);
    }
    let toRange = coordMeta.range || coordMeta.refRange;
    if (fromRange && toRange) {
      coords[i] = mapRange(fromRange, toRange, coords[i]);
    }
    return type3;
  });
  return types2;
}
function parse(str, { meta } = {}) {
  var _a2, _b2, _c2, _d;
  let env = { "str": (_a2 = String(str)) == null ? void 0 : _a2.trim() };
  hooks_default.run("parse-start", env);
  if (env.color) {
    return env.color;
  }
  env.parsed = parseFunction(env.str);
  if (env.parsed) {
    let name = env.parsed.name;
    if (name === "color") {
      let id = env.parsed.args.shift();
      let alternateId = id.startsWith("--") ? id.substring(2) : `--${id}`;
      let ids = [id, alternateId];
      let alpha = env.parsed.rawArgs.indexOf("/") > 0 ? env.parsed.args.pop() : 1;
      for (let space of ColorSpace.all) {
        let colorSpec = space.getFormat("color");
        if (colorSpec) {
          if (ids.includes(colorSpec.id) || ((_b2 = colorSpec.ids) == null ? void 0 : _b2.filter((specId) => ids.includes(specId)).length)) {
            const coords = Object.keys(space.coords).map((_23, i) => env.parsed.args[i] || 0);
            let types2;
            if (colorSpec.coordGrammar) {
              types2 = coerceCoords(space, colorSpec, "color", coords);
            }
            if (meta) {
              Object.assign(meta, { formatId: "color", types: types2 });
            }
            if (colorSpec.id.startsWith("--") && !id.startsWith("--")) {
              defaults_default.warn(`${space.name} is a non-standard space and not currently supported in the CSS spec. Use prefixed color(${colorSpec.id}) instead of color(${id}).`);
            }
            if (id.startsWith("--") && !colorSpec.id.startsWith("--")) {
              defaults_default.warn(`${space.name} is a standard space and supported in the CSS spec. Use color(${colorSpec.id}) instead of prefixed color(${id}).`);
            }
            return { spaceId: space.id, coords, alpha };
          }
        }
      }
      let didYouMean = "";
      let registryId = id in ColorSpace.registry ? id : alternateId;
      if (registryId in ColorSpace.registry) {
        let cssId = (_d = (_c2 = ColorSpace.registry[registryId].formats) == null ? void 0 : _c2.color) == null ? void 0 : _d.id;
        if (cssId) {
          didYouMean = `Did you mean color(${cssId})?`;
        }
      }
      throw new TypeError(`Cannot parse color(${id}). ` + (didYouMean || "Missing a plugin?"));
    } else {
      for (let space of ColorSpace.all) {
        let format = space.getFormat(name);
        if (format && format.type === "function") {
          let alpha = 1;
          if (format.lastAlpha || last(env.parsed.args).alpha) {
            alpha = env.parsed.args.pop();
          }
          let coords = env.parsed.args;
          let types2;
          if (format.coordGrammar) {
            types2 = coerceCoords(space, format, name, coords);
          }
          if (meta) {
            Object.assign(meta, { formatId: format.name, types: types2 });
          }
          return {
            spaceId: space.id,
            coords,
            alpha
          };
        }
      }
    }
  } else {
    for (let space of ColorSpace.all) {
      for (let formatId in space.formats) {
        let format = space.formats[formatId];
        if (format.type !== "custom") {
          continue;
        }
        if (format.test && !format.test(env.str)) {
          continue;
        }
        let color3 = format.parse(env.str);
        if (color3) {
          color3.alpha ?? (color3.alpha = 1);
          if (meta) {
            meta.formatId = formatId;
          }
          return color3;
        }
      }
    }
  }
  throw new TypeError(`Could not parse ${str} as a color. Missing a plugin?`);
}

// node_modules/colorjs.io/src/getColor.js
function getColor(color3) {
  if (Array.isArray(color3)) {
    return color3.map(getColor);
  }
  if (!color3) {
    throw new TypeError("Empty color reference");
  }
  if (isString(color3)) {
    color3 = parse(color3);
  }
  let space = color3.space || color3.spaceId;
  if (!(space instanceof ColorSpace)) {
    color3.space = ColorSpace.get(space);
  }
  if (color3.alpha === void 0) {
    color3.alpha = 1;
  }
  return color3;
}

// node_modules/colorjs.io/src/space.js
var ε = 75e-6;
var _ColorSpace = class _ColorSpace {
  constructor(options2) {
    var _a2;
    this.id = options2.id;
    this.name = options2.name;
    this.base = options2.base ? _ColorSpace.get(options2.base) : null;
    this.aliases = options2.aliases;
    if (this.base) {
      this.fromBase = options2.fromBase;
      this.toBase = options2.toBase;
    }
    let coords = options2.coords ?? this.base.coords;
    for (let name in coords) {
      if (!("name" in coords[name])) {
        coords[name].name = name;
      }
    }
    this.coords = coords;
    let white6 = options2.white ?? this.base.white ?? "D65";
    this.white = getWhite(white6);
    this.formats = options2.formats ?? {};
    for (let name in this.formats) {
      let format = this.formats[name];
      format.type || (format.type = "function");
      format.name || (format.name = name);
    }
    if (!((_a2 = this.formats.color) == null ? void 0 : _a2.id)) {
      this.formats.color = {
        ...this.formats.color ?? {},
        id: options2.cssId || this.id
      };
    }
    if (options2.gamutSpace) {
      this.gamutSpace = options2.gamutSpace === "self" ? this : _ColorSpace.get(options2.gamutSpace);
    } else {
      if (this.isPolar) {
        this.gamutSpace = this.base;
      } else {
        this.gamutSpace = this;
      }
    }
    if (this.gamutSpace.isUnbounded) {
      this.inGamut = (coords2, options3) => {
        return true;
      };
    }
    this.referred = options2.referred;
    Object.defineProperty(this, "path", {
      value: getPath(this).reverse(),
      writable: false,
      enumerable: true,
      configurable: true
    });
    hooks_default.run("colorspace-init-end", this);
  }
  inGamut(coords, { epsilon = ε } = {}) {
    if (!this.equals(this.gamutSpace)) {
      coords = this.to(this.gamutSpace, coords);
      return this.gamutSpace.inGamut(coords, { epsilon });
    }
    let coordMeta = Object.values(this.coords);
    return coords.every((c4, i) => {
      let meta = coordMeta[i];
      if (meta.type !== "angle" && meta.range) {
        if (Number.isNaN(c4)) {
          return true;
        }
        let [min, max] = meta.range;
        return (min === void 0 || c4 >= min - epsilon) && (max === void 0 || c4 <= max + epsilon);
      }
      return true;
    });
  }
  get isUnbounded() {
    return Object.values(this.coords).every((coord) => !("range" in coord));
  }
  get cssId() {
    var _a2, _b2;
    return ((_b2 = (_a2 = this.formats) == null ? void 0 : _a2.color) == null ? void 0 : _b2.id) || this.id;
  }
  get isPolar() {
    for (let id in this.coords) {
      if (this.coords[id].type === "angle") {
        return true;
      }
    }
    return false;
  }
  getFormat(format) {
    if (typeof format === "object") {
      format = processFormat(format, this);
      return format;
    }
    let ret;
    if (format === "default") {
      ret = Object.values(this.formats)[0];
    } else {
      ret = this.formats[format];
    }
    if (ret) {
      ret = processFormat(ret, this);
      return ret;
    }
    return null;
  }
  /**
   * Check if this color space is the same as another color space reference.
   * Allows proxying color space objects and comparing color spaces with ids.
   * @param {string | ColorSpace} space ColorSpace object or id to compare to
   * @returns {boolean}
   */
  equals(space) {
    if (!space) {
      return false;
    }
    return this === space || this.id === space || this.id === space.id;
  }
  to(space, coords) {
    if (arguments.length === 1) {
      const color3 = getColor(space);
      [space, coords] = [color3.space, color3.coords];
    }
    space = _ColorSpace.get(space);
    if (this.equals(space)) {
      return coords;
    }
    coords = coords.map((c4) => Number.isNaN(c4) ? 0 : c4);
    let myPath = this.path;
    let otherPath = space.path;
    let connectionSpace, connectionSpaceIndex;
    for (let i = 0; i < myPath.length; i++) {
      if (myPath[i].equals(otherPath[i])) {
        connectionSpace = myPath[i];
        connectionSpaceIndex = i;
      } else {
        break;
      }
    }
    if (!connectionSpace) {
      throw new Error(`Cannot convert between color spaces ${this} and ${space}: no connection space was found`);
    }
    for (let i = myPath.length - 1; i > connectionSpaceIndex; i--) {
      coords = myPath[i].toBase(coords);
    }
    for (let i = connectionSpaceIndex + 1; i < otherPath.length; i++) {
      coords = otherPath[i].fromBase(coords);
    }
    return coords;
  }
  from(space, coords) {
    if (arguments.length === 1) {
      const color3 = getColor(space);
      [space, coords] = [color3.space, color3.coords];
    }
    space = _ColorSpace.get(space);
    return space.to(this, coords);
  }
  toString() {
    return `${this.name} (${this.id})`;
  }
  getMinCoords() {
    let ret = [];
    for (let id in this.coords) {
      let meta = this.coords[id];
      let range2 = meta.range || meta.refRange;
      ret.push((range2 == null ? void 0 : range2.min) ?? 0);
    }
    return ret;
  }
  // Returns array of unique color spaces
  static get all() {
    return [...new Set(Object.values(_ColorSpace.registry))];
  }
  static register(id, space) {
    if (arguments.length === 1) {
      space = arguments[0];
      id = space.id;
    }
    space = this.get(space);
    if (this.registry[id] && this.registry[id] !== space) {
      throw new Error(`Duplicate color space registration: '${id}'`);
    }
    this.registry[id] = space;
    if (arguments.length === 1 && space.aliases) {
      for (let alias of space.aliases) {
        this.register(alias, space);
      }
    }
    return space;
  }
  /**
   * Lookup ColorSpace object by name
   * @param {ColorSpace | string} name
   */
  static get(space, ...alternatives) {
    if (!space || space instanceof _ColorSpace) {
      return space;
    }
    let argType = type(space);
    if (argType === "string") {
      let ret = _ColorSpace.registry[space.toLowerCase()];
      if (!ret) {
        throw new TypeError(`No color space found with id = "${space}"`);
      }
      return ret;
    }
    if (alternatives.length) {
      return _ColorSpace.get(...alternatives);
    }
    throw new TypeError(`${space} is not a valid color space`);
  }
  /**
   * Get metadata about a coordinate of a color space
   *
   * @static
   * @param {Array | string} ref
   * @param {ColorSpace | string} [workingSpace]
   * @return {Object}
   */
  static resolveCoord(ref2, workingSpace) {
    var _a2;
    let coordType = type(ref2);
    let space, coord;
    if (coordType === "string") {
      if (ref2.includes(".")) {
        [space, coord] = ref2.split(".");
      } else {
        [space, coord] = [, ref2];
      }
    } else if (Array.isArray(ref2)) {
      [space, coord] = ref2;
    } else {
      space = ref2.space;
      coord = ref2.coordId;
    }
    space = _ColorSpace.get(space);
    if (!space) {
      space = workingSpace;
    }
    if (!space) {
      throw new TypeError(`Cannot resolve coordinate reference ${ref2}: No color space specified and relative references are not allowed here`);
    }
    coordType = type(coord);
    if (coordType === "number" || coordType === "string" && coord >= 0) {
      let meta = Object.entries(space.coords)[coord];
      if (meta) {
        return { space, id: meta[0], index: coord, ...meta[1] };
      }
    }
    space = _ColorSpace.get(space);
    let normalizedCoord = coord.toLowerCase();
    let i = 0;
    for (let id in space.coords) {
      let meta = space.coords[id];
      if (id.toLowerCase() === normalizedCoord || ((_a2 = meta.name) == null ? void 0 : _a2.toLowerCase()) === normalizedCoord) {
        return { space, id, index: i, ...meta };
      }
      i++;
    }
    throw new TypeError(`No "${coord}" coordinate found in ${space.name}. Its coordinates are: ${Object.keys(space.coords).join(", ")}`);
  }
};
__publicField(_ColorSpace, "registry", {});
__publicField(_ColorSpace, "DEFAULT_FORMAT", {
  type: "functions",
  name: "color"
});
var ColorSpace = _ColorSpace;
function getPath(space) {
  let ret = [space];
  for (let s = space; s = s.base; ) {
    ret.push(s);
  }
  return ret;
}
function processFormat(format, { coords } = {}) {
  if (format.coords && !format.coordGrammar) {
    format.type || (format.type = "function");
    format.name || (format.name = "color");
    format.coordGrammar = parseCoordGrammar(format.coords);
    let coordFormats = Object.entries(coords).map(([id, coordMeta], i) => {
      let outputType = format.coordGrammar[i][0];
      let fromRange = coordMeta.range || coordMeta.refRange;
      let toRange = outputType.range, suffix = "";
      if (outputType == "<percentage>") {
        toRange = [0, 100];
        suffix = "%";
      } else if (outputType == "<angle>") {
        suffix = "deg";
      }
      return { fromRange, toRange, suffix };
    });
    format.serializeCoords = (coords2, precision) => {
      return coords2.map((c4, i) => {
        let { fromRange, toRange, suffix } = coordFormats[i];
        if (fromRange && toRange) {
          c4 = mapRange(fromRange, toRange, c4);
        }
        c4 = serializeNumber(c4, { precision, unit: suffix });
        return c4;
      });
    };
  }
  return format;
}

// node_modules/colorjs.io/src/spaces/xyz-d65.js
var xyz_d65_default = new ColorSpace({
  id: "xyz-d65",
  name: "XYZ D65",
  coords: {
    x: { name: "X" },
    y: { name: "Y" },
    z: { name: "Z" }
  },
  white: "D65",
  formats: {
    color: {
      ids: ["xyz-d65", "xyz"]
    }
  },
  aliases: ["xyz"]
});

// node_modules/colorjs.io/src/rgbspace.js
var RGBColorSpace = class extends ColorSpace {
  /**
   * Creates a new RGB ColorSpace.
   * If coords are not specified, they will use the default RGB coords.
   * Instead of `fromBase()` and `toBase()` functions,
   * you can specify to/from XYZ matrices and have `toBase()` and `fromBase()` automatically generated.
   * @param {*} options - Same options as {@link ColorSpace} plus:
   * @param {number[][]} options.toXYZ_M - Matrix to convert to XYZ
   * @param {number[][]} options.fromXYZ_M - Matrix to convert from XYZ
   */
  constructor(options2) {
    if (!options2.coords) {
      options2.coords = {
        r: {
          range: [0, 1],
          name: "Red"
        },
        g: {
          range: [0, 1],
          name: "Green"
        },
        b: {
          range: [0, 1],
          name: "Blue"
        }
      };
    }
    if (!options2.base) {
      options2.base = xyz_d65_default;
    }
    if (options2.toXYZ_M && options2.fromXYZ_M) {
      options2.toBase ?? (options2.toBase = (rgb) => {
        let xyz = multiplyMatrices(options2.toXYZ_M, rgb);
        if (this.white !== this.base.white) {
          xyz = adapt(this.white, this.base.white, xyz);
        }
        return xyz;
      });
      options2.fromBase ?? (options2.fromBase = (xyz) => {
        xyz = adapt(this.base.white, this.white, xyz);
        return multiplyMatrices(options2.fromXYZ_M, xyz);
      });
    }
    options2.referred ?? (options2.referred = "display");
    super(options2);
  }
};

// node_modules/colorjs.io/src/getAll.js
function getAll(color3, space) {
  color3 = getColor(color3);
  if (!space || color3.space.equals(space)) {
    return color3.coords.slice();
  }
  space = ColorSpace.get(space);
  return space.from(color3);
}

// node_modules/colorjs.io/src/get.js
function get(color3, prop) {
  color3 = getColor(color3);
  let { space, index } = ColorSpace.resolveCoord(prop, color3.space);
  let coords = getAll(color3, space);
  return coords[index];
}

// node_modules/colorjs.io/src/setAll.js
function setAll(color3, space, coords) {
  color3 = getColor(color3);
  space = ColorSpace.get(space);
  color3.coords = space.to(color3.space, coords);
  return color3;
}
setAll.returns = "color";

// node_modules/colorjs.io/src/set.js
function set(color3, prop, value) {
  color3 = getColor(color3);
  if (arguments.length === 2 && type(arguments[1]) === "object") {
    let object2 = arguments[1];
    for (let p2 in object2) {
      set(color3, p2, object2[p2]);
    }
  } else {
    if (typeof value === "function") {
      value = value(get(color3, prop));
    }
    let { space, index } = ColorSpace.resolveCoord(prop, color3.space);
    let coords = getAll(color3, space);
    coords[index] = value;
    setAll(color3, space, coords);
  }
  return color3;
}
set.returns = "color";

// node_modules/colorjs.io/src/spaces/xyz-d50.js
var xyz_d50_default = new ColorSpace({
  id: "xyz-d50",
  name: "XYZ D50",
  white: "D50",
  base: xyz_d65_default,
  fromBase: (coords) => adapt(xyz_d65_default.white, "D50", coords),
  toBase: (coords) => adapt("D50", xyz_d65_default.white, coords)
});

// node_modules/colorjs.io/src/spaces/lab.js
var ε2 = 216 / 24389;
var ε3 = 24 / 116;
var κ = 24389 / 27;
var white = WHITES.D50;
var lab_default = new ColorSpace({
  id: "lab",
  name: "Lab",
  coords: {
    l: {
      refRange: [0, 100],
      name: "Lightness"
    },
    a: {
      refRange: [-125, 125]
    },
    b: {
      refRange: [-125, 125]
    }
  },
  // Assuming XYZ is relative to D50, convert to CIE Lab
  // from CIE standard, which now defines these as a rational fraction
  white,
  base: xyz_d50_default,
  // Convert D50-adapted XYX to Lab
  //  CIE 15.3:2004 section 8.2.1.1
  fromBase(XYZ) {
    let xyz = XYZ.map((value, i) => value / white[i]);
    let f = xyz.map((value) => value > ε2 ? Math.cbrt(value) : (κ * value + 16) / 116);
    return [
      116 * f[1] - 16,
      // L
      500 * (f[0] - f[1]),
      // a
      200 * (f[1] - f[2])
      // b
    ];
  },
  // Convert Lab to D50-adapted XYZ
  // Same result as CIE 15.3:2004 Appendix D although the derivation is different
  // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
  toBase(Lab) {
    let f = [];
    f[1] = (Lab[0] + 16) / 116;
    f[0] = Lab[1] / 500 + f[1];
    f[2] = f[1] - Lab[2] / 200;
    let xyz = [
      f[0] > ε3 ? Math.pow(f[0], 3) : (116 * f[0] - 16) / κ,
      Lab[0] > 8 ? Math.pow((Lab[0] + 16) / 116, 3) : Lab[0] / κ,
      f[2] > ε3 ? Math.pow(f[2], 3) : (116 * f[2] - 16) / κ
    ];
    return xyz.map((value, i) => value * white[i]);
  },
  formats: {
    "lab": {
      coords: ["<number> | <percentage>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
    }
  }
});

// node_modules/colorjs.io/src/angles.js
function constrain(angle) {
  return (angle % 360 + 360) % 360;
}
function adjust(arc, angles) {
  if (arc === "raw") {
    return angles;
  }
  let [a1, a2] = angles.map(constrain);
  let angleDiff = a2 - a1;
  if (arc === "increasing") {
    if (angleDiff < 0) {
      a2 += 360;
    }
  } else if (arc === "decreasing") {
    if (angleDiff > 0) {
      a1 += 360;
    }
  } else if (arc === "longer") {
    if (-180 < angleDiff && angleDiff < 180) {
      if (angleDiff > 0) {
        a1 += 360;
      } else {
        a2 += 360;
      }
    }
  } else if (arc === "shorter") {
    if (angleDiff > 180) {
      a1 += 360;
    } else if (angleDiff < -180) {
      a2 += 360;
    }
  }
  return [a1, a2];
}

// node_modules/colorjs.io/src/spaces/lch.js
var lch_default = new ColorSpace({
  id: "lch",
  name: "LCH",
  coords: {
    l: {
      refRange: [0, 100],
      name: "Lightness"
    },
    c: {
      refRange: [0, 150],
      name: "Chroma"
    },
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    }
  },
  base: lab_default,
  fromBase(Lab) {
    let [L, a2, b3] = Lab;
    let hue;
    const ε11 = 0.02;
    if (Math.abs(a2) < ε11 && Math.abs(b3) < ε11) {
      hue = NaN;
    } else {
      hue = Math.atan2(b3, a2) * 180 / Math.PI;
    }
    return [
      L,
      // L is still L
      Math.sqrt(a2 ** 2 + b3 ** 2),
      // Chroma
      constrain(hue)
      // Hue, in degrees [0 to 360)
    ];
  },
  toBase(LCH2) {
    let [Lightness, Chroma, Hue] = LCH2;
    if (Chroma < 0) {
      Chroma = 0;
    }
    if (isNaN(Hue)) {
      Hue = 0;
    }
    return [
      Lightness,
      // L is still L
      Chroma * Math.cos(Hue * Math.PI / 180),
      // a
      Chroma * Math.sin(Hue * Math.PI / 180)
      // b
    ];
  },
  formats: {
    "lch": {
      coords: ["<number> | <percentage>", "<number> | <percentage>", "<number> | <angle>"]
    }
  }
});

// node_modules/colorjs.io/src/deltaE/deltaE2000.js
var Gfactor = 25 ** 7;
var π = Math.PI;
var r2d = 180 / π;
var d2r = π / 180;
function pow7(x) {
  const x2 = x * x;
  const x7 = x2 * x2 * x2 * x;
  return x7;
}
function deltaE2000_default(color3, sample, { kL = 1, kC = 1, kH = 1 } = {}) {
  [color3, sample] = getColor([color3, sample]);
  let [L1, a1, b1] = lab_default.from(color3);
  let C1 = lch_default.from(lab_default, [L1, a1, b1])[1];
  let [L2, a2, b22] = lab_default.from(sample);
  let C2 = lch_default.from(lab_default, [L2, a2, b22])[1];
  if (C1 < 0) {
    C1 = 0;
  }
  if (C2 < 0) {
    C2 = 0;
  }
  let Cbar = (C1 + C2) / 2;
  let C7 = pow7(Cbar);
  let G2 = 0.5 * (1 - Math.sqrt(C7 / (C7 + Gfactor)));
  let adash1 = (1 + G2) * a1;
  let adash2 = (1 + G2) * a2;
  let Cdash1 = Math.sqrt(adash1 ** 2 + b1 ** 2);
  let Cdash2 = Math.sqrt(adash2 ** 2 + b22 ** 2);
  let h1 = adash1 === 0 && b1 === 0 ? 0 : Math.atan2(b1, adash1);
  let h2 = adash2 === 0 && b22 === 0 ? 0 : Math.atan2(b22, adash2);
  if (h1 < 0) {
    h1 += 2 * π;
  }
  if (h2 < 0) {
    h2 += 2 * π;
  }
  h1 *= r2d;
  h2 *= r2d;
  let ΔL = L2 - L1;
  let ΔC = Cdash2 - Cdash1;
  let hdiff = h2 - h1;
  let hsum = h1 + h2;
  let habs = Math.abs(hdiff);
  let Δh;
  if (Cdash1 * Cdash2 === 0) {
    Δh = 0;
  } else if (habs <= 180) {
    Δh = hdiff;
  } else if (hdiff > 180) {
    Δh = hdiff - 360;
  } else if (hdiff < -180) {
    Δh = hdiff + 360;
  } else {
    defaults_default.warn("the unthinkable has happened");
  }
  let ΔH = 2 * Math.sqrt(Cdash2 * Cdash1) * Math.sin(Δh * d2r / 2);
  let Ldash = (L1 + L2) / 2;
  let Cdash = (Cdash1 + Cdash2) / 2;
  let Cdash7 = pow7(Cdash);
  let hdash;
  if (Cdash1 * Cdash2 === 0) {
    hdash = hsum;
  } else if (habs <= 180) {
    hdash = hsum / 2;
  } else if (hsum < 360) {
    hdash = (hsum + 360) / 2;
  } else {
    hdash = (hsum - 360) / 2;
  }
  let lsq = (Ldash - 50) ** 2;
  let SL = 1 + 0.015 * lsq / Math.sqrt(20 + lsq);
  let SC = 1 + 0.045 * Cdash;
  let T2 = 1;
  T2 -= 0.17 * Math.cos((hdash - 30) * d2r);
  T2 += 0.24 * Math.cos(2 * hdash * d2r);
  T2 += 0.32 * Math.cos((3 * hdash + 6) * d2r);
  T2 -= 0.2 * Math.cos((4 * hdash - 63) * d2r);
  let SH = 1 + 0.015 * Cdash * T2;
  let Δθ = 30 * Math.exp(-1 * ((hdash - 275) / 25) ** 2);
  let RC = 2 * Math.sqrt(Cdash7 / (Cdash7 + Gfactor));
  let RT = -1 * Math.sin(2 * Δθ * d2r) * RC;
  let dE = (ΔL / (kL * SL)) ** 2;
  dE += (ΔC / (kC * SC)) ** 2;
  dE += (ΔH / (kH * SH)) ** 2;
  dE += RT * (ΔC / (kC * SC)) * (ΔH / (kH * SH));
  return Math.sqrt(dE);
}

// node_modules/colorjs.io/src/spaces/oklab.js
var XYZtoLMS_M = [
  [0.819022437996703, 0.3619062600528904, -0.1288737815209879],
  [0.0329836539323885, 0.9292868615863434, 0.0361446663506424],
  [0.0481771893596242, 0.2642395317527308, 0.6335478284694309]
];
var LMStoXYZ_M = [
  [1.2268798758459243, -0.5578149944602171, 0.2813910456659647],
  [-0.0405757452148008, 1.112286803280317, -0.0717110580655164],
  [-0.0763729366746601, -0.4214933324022432, 1.5869240198367816]
];
var LMStoLab_M = [
  [0.210454268309314, 0.7936177747023054, -0.0040720430116193],
  [1.9779985324311684, -2.42859224204858, 0.450593709617411],
  [0.0259040424655478, 0.7827717124575296, -0.8086757549230774]
];
var LabtoLMS_M = [
  [1, 0.3963377773761749, 0.2158037573099136],
  [1, -0.1055613458156586, -0.0638541728258133],
  [1, -0.0894841775298119, -1.2914855480194092]
];
var oklab_default = new ColorSpace({
  id: "oklab",
  name: "Oklab",
  coords: {
    l: {
      refRange: [0, 1],
      name: "Lightness"
    },
    a: {
      refRange: [-0.4, 0.4]
    },
    b: {
      refRange: [-0.4, 0.4]
    }
  },
  // Note that XYZ is relative to D65
  white: "D65",
  base: xyz_d65_default,
  fromBase(XYZ) {
    let LMS = multiplyMatrices(XYZtoLMS_M, XYZ);
    let LMSg = LMS.map((val2) => Math.cbrt(val2));
    return multiplyMatrices(LMStoLab_M, LMSg);
  },
  toBase(OKLab) {
    let LMSg = multiplyMatrices(LabtoLMS_M, OKLab);
    let LMS = LMSg.map((val2) => val2 ** 3);
    return multiplyMatrices(LMStoXYZ_M, LMS);
  },
  formats: {
    "oklab": {
      coords: ["<percentage> | <number>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
    }
  }
});

// node_modules/colorjs.io/src/deltaE/deltaEOK.js
function deltaEOK_default(color3, sample) {
  [color3, sample] = getColor([color3, sample]);
  let [L1, a1, b1] = oklab_default.from(color3);
  let [L2, a2, b22] = oklab_default.from(sample);
  let ΔL = L1 - L2;
  let Δa = a1 - a2;
  let Δb = b1 - b22;
  return Math.sqrt(ΔL ** 2 + Δa ** 2 + Δb ** 2);
}

// node_modules/colorjs.io/src/inGamut.js
var ε4 = 75e-6;
function inGamut(color3, space, { epsilon = ε4 } = {}) {
  color3 = getColor(color3);
  if (!space) {
    space = color3.space;
  }
  space = ColorSpace.get(space);
  let coords = color3.coords;
  if (space !== color3.space) {
    coords = space.from(color3);
  }
  return space.inGamut(coords, { epsilon });
}

// node_modules/colorjs.io/src/clone.js
function clone(color3) {
  return {
    space: color3.space,
    coords: color3.coords.slice(),
    alpha: color3.alpha
  };
}

// node_modules/colorjs.io/src/distance.js
function distance(color1, color22, space = "lab") {
  space = ColorSpace.get(space);
  let coords1 = space.from(color1);
  let coords2 = space.from(color22);
  return Math.sqrt(coords1.reduce((acc, c14, i) => {
    let c24 = coords2[i];
    if (isNaN(c14) || isNaN(c24)) {
      return acc;
    }
    return acc + (c24 - c14) ** 2;
  }, 0));
}

// node_modules/colorjs.io/src/deltaE/deltaE76.js
function deltaE76(color3, sample) {
  return distance(color3, sample, "lab");
}

// node_modules/colorjs.io/src/deltaE/deltaECMC.js
var π2 = Math.PI;
var d2r2 = π2 / 180;
function deltaECMC_default(color3, sample, { l = 2, c: c4 = 1 } = {}) {
  [color3, sample] = getColor([color3, sample]);
  let [L1, a1, b1] = lab_default.from(color3);
  let [, C1, H1] = lch_default.from(lab_default, [L1, a1, b1]);
  let [L2, a2, b22] = lab_default.from(sample);
  let C2 = lch_default.from(lab_default, [L2, a2, b22])[1];
  if (C1 < 0) {
    C1 = 0;
  }
  if (C2 < 0) {
    C2 = 0;
  }
  let ΔL = L1 - L2;
  let ΔC = C1 - C2;
  let Δa = a1 - a2;
  let Δb = b1 - b22;
  let H2 = Δa ** 2 + Δb ** 2 - ΔC ** 2;
  let SL = 0.511;
  if (L1 >= 16) {
    SL = 0.040975 * L1 / (1 + 0.01765 * L1);
  }
  let SC = 0.0638 * C1 / (1 + 0.0131 * C1) + 0.638;
  let T2;
  if (Number.isNaN(H1)) {
    H1 = 0;
  }
  if (H1 >= 164 && H1 <= 345) {
    T2 = 0.56 + Math.abs(0.2 * Math.cos((H1 + 168) * d2r2));
  } else {
    T2 = 0.36 + Math.abs(0.4 * Math.cos((H1 + 35) * d2r2));
  }
  let C4 = Math.pow(C1, 4);
  let F2 = Math.sqrt(C4 / (C4 + 1900));
  let SH = SC * (F2 * T2 + 1 - F2);
  let dE = (ΔL / (l * SL)) ** 2;
  dE += (ΔC / (c4 * SC)) ** 2;
  dE += H2 / SH ** 2;
  return Math.sqrt(dE);
}

// node_modules/colorjs.io/src/spaces/xyz-abs-d65.js
var Yw = 203;
var xyz_abs_d65_default = new ColorSpace({
  // Absolute CIE XYZ, with a D65 whitepoint,
  // as used in most HDR colorspaces as a starting point.
  // SDR spaces are converted per BT.2048
  // so that diffuse, media white is 203 cd/m²
  id: "xyz-abs-d65",
  cssId: "--xyz-abs-d65",
  name: "Absolute XYZ D65",
  coords: {
    x: {
      refRange: [0, 9504.7],
      name: "Xa"
    },
    y: {
      refRange: [0, 1e4],
      name: "Ya"
    },
    z: {
      refRange: [0, 10888.3],
      name: "Za"
    }
  },
  base: xyz_d65_default,
  fromBase(XYZ) {
    return XYZ.map((v) => Math.max(v * Yw, 0));
  },
  toBase(AbsXYZ) {
    return AbsXYZ.map((v) => Math.max(v / Yw, 0));
  }
});

// node_modules/colorjs.io/src/spaces/jzazbz.js
var b = 1.15;
var g = 0.66;
var n = 2610 / 2 ** 14;
var ninv = 2 ** 14 / 2610;
var c1 = 3424 / 2 ** 12;
var c2 = 2413 / 2 ** 7;
var c3 = 2392 / 2 ** 7;
var p = 1.7 * 2523 / 2 ** 5;
var pinv = 2 ** 5 / (1.7 * 2523);
var d = -0.56;
var d0 = 16295499532821565e-27;
var XYZtoCone_M = [
  [0.41478972, 0.579999, 0.014648],
  [-0.20151, 1.120649, 0.0531008],
  [-0.0166008, 0.2648, 0.6684799]
];
var ConetoXYZ_M = [
  [1.9242264357876067, -1.0047923125953657, 0.037651404030618],
  [0.35031676209499907, 0.7264811939316552, -0.06538442294808501],
  [-0.09098281098284752, -0.3127282905230739, 1.5227665613052603]
];
var ConetoIab_M = [
  [0.5, 0.5, 0],
  [3.524, -4.066708, 0.542708],
  [0.199076, 1.096799, -1.295875]
];
var IabtoCone_M = [
  [1, 0.1386050432715393, 0.05804731615611886],
  [0.9999999999999999, -0.1386050432715393, -0.05804731615611886],
  [0.9999999999999998, -0.09601924202631895, -0.8118918960560388]
];
var jzazbz_default = new ColorSpace({
  id: "jzazbz",
  name: "Jzazbz",
  coords: {
    jz: {
      refRange: [0, 1],
      name: "Jz"
    },
    az: {
      refRange: [-0.5, 0.5]
    },
    bz: {
      refRange: [-0.5, 0.5]
    }
  },
  base: xyz_abs_d65_default,
  fromBase(XYZ) {
    let [Xa, Ya, Za] = XYZ;
    let Xm = b * Xa - (b - 1) * Za;
    let Ym = g * Ya - (g - 1) * Xa;
    let LMS = multiplyMatrices(XYZtoCone_M, [Xm, Ym, Za]);
    let PQLMS = LMS.map(function(val2) {
      let num = c1 + c2 * (val2 / 1e4) ** n;
      let denom = 1 + c3 * (val2 / 1e4) ** n;
      return (num / denom) ** p;
    });
    let [Iz, az, bz] = multiplyMatrices(ConetoIab_M, PQLMS);
    let Jz = (1 + d) * Iz / (1 + d * Iz) - d0;
    return [Jz, az, bz];
  },
  toBase(Jzazbz) {
    let [Jz, az, bz] = Jzazbz;
    let Iz = (Jz + d0) / (1 + d - d * (Jz + d0));
    let PQLMS = multiplyMatrices(IabtoCone_M, [Iz, az, bz]);
    let LMS = PQLMS.map(function(val2) {
      let num = c1 - val2 ** pinv;
      let denom = c3 * val2 ** pinv - c2;
      let x = 1e4 * (num / denom) ** ninv;
      return x;
    });
    let [Xm, Ym, Za] = multiplyMatrices(ConetoXYZ_M, LMS);
    let Xa = (Xm + (b - 1) * Za) / b;
    let Ya = (Ym + (g - 1) * Xa) / g;
    return [Xa, Ya, Za];
  },
  formats: {
    // https://drafts.csswg.org/css-color-hdr/#Jzazbz
    "color": {
      coords: ["<number> | <percentage>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
    }
  }
});

// node_modules/colorjs.io/src/spaces/jzczhz.js
var jzczhz_default = new ColorSpace({
  id: "jzczhz",
  name: "JzCzHz",
  coords: {
    jz: {
      refRange: [0, 1],
      name: "Jz"
    },
    cz: {
      refRange: [0, 1],
      name: "Chroma"
    },
    hz: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    }
  },
  base: jzazbz_default,
  fromBase(jzazbz) {
    let [Jz, az, bz] = jzazbz;
    let hue;
    const ε11 = 2e-4;
    if (Math.abs(az) < ε11 && Math.abs(bz) < ε11) {
      hue = NaN;
    } else {
      hue = Math.atan2(bz, az) * 180 / Math.PI;
    }
    return [
      Jz,
      // Jz is still Jz
      Math.sqrt(az ** 2 + bz ** 2),
      // Chroma
      constrain(hue)
      // Hue, in degrees [0 to 360)
    ];
  },
  toBase(jzczhz) {
    return [
      jzczhz[0],
      // Jz is still Jz
      jzczhz[1] * Math.cos(jzczhz[2] * Math.PI / 180),
      // az
      jzczhz[1] * Math.sin(jzczhz[2] * Math.PI / 180)
      // bz
    ];
  }
});

// node_modules/colorjs.io/src/deltaE/deltaEJz.js
function deltaEJz_default(color3, sample) {
  [color3, sample] = getColor([color3, sample]);
  let [Jz1, Cz1, Hz1] = jzczhz_default.from(color3);
  let [Jz2, Cz2, Hz2] = jzczhz_default.from(sample);
  let ΔJ = Jz1 - Jz2;
  let ΔC = Cz1 - Cz2;
  if (Number.isNaN(Hz1) && Number.isNaN(Hz2)) {
    Hz1 = 0;
    Hz2 = 0;
  } else if (Number.isNaN(Hz1)) {
    Hz1 = Hz2;
  } else if (Number.isNaN(Hz2)) {
    Hz2 = Hz1;
  }
  let Δh = Hz1 - Hz2;
  let ΔH = 2 * Math.sqrt(Cz1 * Cz2) * Math.sin(Δh / 2 * (Math.PI / 180));
  return Math.sqrt(ΔJ ** 2 + ΔC ** 2 + ΔH ** 2);
}

// node_modules/colorjs.io/src/spaces/ictcp.js
var c12 = 3424 / 4096;
var c22 = 2413 / 128;
var c32 = 2392 / 128;
var m1 = 2610 / 16384;
var m2 = 2523 / 32;
var im1 = 16384 / 2610;
var im2 = 32 / 2523;
var XYZtoLMS_M2 = [
  [0.3592832590121217, 0.6976051147779502, -0.035891593232029],
  [-0.1920808463704993, 1.100476797037432, 0.0753748658519118],
  [0.0070797844607479, 0.0748396662186362, 0.8433265453898765]
];
var LMStoIPT_M = [
  [2048 / 4096, 2048 / 4096, 0],
  [6610 / 4096, -13613 / 4096, 7003 / 4096],
  [17933 / 4096, -17390 / 4096, -543 / 4096]
];
var IPTtoLMS_M = [
  [0.9999999999999998, 0.0086090370379328, 0.111029625003026],
  [0.9999999999999998, -0.0086090370379328, -0.1110296250030259],
  [0.9999999999999998, 0.5600313357106791, -0.3206271749873188]
];
var LMStoXYZ_M2 = [
  [2.0701522183894223, -1.3263473389671563, 0.2066510476294053],
  [0.3647385209748072, 0.6805660249472273, -0.0453045459220347],
  [-0.0497472075358123, -0.0492609666966131, 1.1880659249923042]
];
var ictcp_default = new ColorSpace({
  id: "ictcp",
  name: "ICTCP",
  // From BT.2100-2 page 7:
  // During production, signal values are expected to exceed the
  // range E′ = [0.0 : 1.0]. This provides processing headroom and avoids
  // signal degradation during cascaded processing. Such values of E′,
  // below 0.0 or exceeding 1.0, should not be clipped during production
  // and exchange.
  // Values below 0.0 should not be clipped in reference displays (even
  // though they represent “negative” light) to allow the black level of
  // the signal (LB) to be properly set using test signals known as “PLUGE”
  coords: {
    i: {
      refRange: [0, 1],
      // Constant luminance,
      name: "I"
    },
    ct: {
      refRange: [-0.5, 0.5],
      // Full BT.2020 gamut in range [-0.5, 0.5]
      name: "CT"
    },
    cp: {
      refRange: [-0.5, 0.5],
      name: "CP"
    }
  },
  base: xyz_abs_d65_default,
  fromBase(XYZ) {
    let LMS = multiplyMatrices(XYZtoLMS_M2, XYZ);
    return LMStoICtCp(LMS);
  },
  toBase(ICtCp) {
    let LMS = ICtCptoLMS(ICtCp);
    return multiplyMatrices(LMStoXYZ_M2, LMS);
  }
});
function LMStoICtCp(LMS) {
  let PQLMS = LMS.map(function(val2) {
    let num = c12 + c22 * (val2 / 1e4) ** m1;
    let denom = 1 + c32 * (val2 / 1e4) ** m1;
    return (num / denom) ** m2;
  });
  return multiplyMatrices(LMStoIPT_M, PQLMS);
}
function ICtCptoLMS(ICtCp) {
  let PQLMS = multiplyMatrices(IPTtoLMS_M, ICtCp);
  let LMS = PQLMS.map(function(val2) {
    let num = Math.max(val2 ** im2 - c12, 0);
    let denom = c22 - c32 * val2 ** im2;
    return 1e4 * (num / denom) ** im1;
  });
  return LMS;
}

// node_modules/colorjs.io/src/deltaE/deltaEITP.js
function deltaEITP_default(color3, sample) {
  [color3, sample] = getColor([color3, sample]);
  let [I1, T1, P1] = ictcp_default.from(color3);
  let [I2, T2, P2] = ictcp_default.from(sample);
  return 720 * Math.sqrt((I1 - I2) ** 2 + 0.25 * (T1 - T2) ** 2 + (P1 - P2) ** 2);
}

// node_modules/colorjs.io/src/spaces/cam16.js
var white2 = WHITES.D65;
var adaptedCoef = 0.42;
var adaptedCoefInv = 1 / adaptedCoef;
var tau = 2 * Math.PI;
var cat16 = [
  [0.401288, 0.650173, -0.051461],
  [-0.250268, 1.204414, 0.045854],
  [-2079e-6, 0.048952, 0.953127]
];
var cat16Inv = [
  [1.8620678550872327, -1.0112546305316843, 0.14918677544445175],
  [0.38752654323613717, 0.6214474419314753, -0.008973985167612518],
  [-0.015841498849333856, -0.03412293802851557, 1.0499644368778496]
];
var m12 = [
  [460, 451, 288],
  [460, -891, -261],
  [460, -220, -6300]
];
var surroundMap = {
  dark: [0.8, 0.525, 0.8],
  dim: [0.9, 0.59, 0.9],
  average: [1, 0.69, 1]
};
var hueQuadMap = {
  // Red, Yellow, Green, Blue, Red
  h: [20.14, 90, 164.25, 237.53, 380.14],
  e: [0.8, 0.7, 1, 1.2, 0.8],
  H: [0, 100, 200, 300, 400]
};
var rad2deg = 180 / Math.PI;
var deg2rad = Math.PI / 180;
function adapt2(coords, fl) {
  const temp = coords.map((c4) => {
    const x = spow(fl * Math.abs(c4) * 0.01, adaptedCoef);
    return 400 * copySign(x, c4) / (x + 27.13);
  });
  return temp;
}
function unadapt(adapted, fl) {
  const constant = 100 / fl * 27.13 ** adaptedCoefInv;
  return adapted.map((c4) => {
    const cabs = Math.abs(c4);
    return copySign(constant * spow(cabs / (400 - cabs), adaptedCoefInv), c4);
  });
}
function hueQuadrature(h) {
  let hp = constrain(h);
  if (hp <= hueQuadMap.h[0]) {
    hp += 360;
  }
  const i = bisectLeft(hueQuadMap.h, hp) - 1;
  const [hi, hii] = hueQuadMap.h.slice(i, i + 2);
  const [ei, eii] = hueQuadMap.e.slice(i, i + 2);
  const Hi = hueQuadMap.H[i];
  const t = (hp - hi) / ei;
  return Hi + 100 * t / (t + (hii - hp) / eii);
}
function invHueQuadrature(H2) {
  let Hp = (H2 % 400 + 400) % 400;
  const i = Math.floor(0.01 * Hp);
  Hp = Hp % 100;
  const [hi, hii] = hueQuadMap.h.slice(i, i + 2);
  const [ei, eii] = hueQuadMap.e.slice(i, i + 2);
  return constrain(
    (Hp * (eii * hi - ei * hii) - 100 * hi * eii) / (Hp * (eii - ei) - 100 * eii)
  );
}
function environment2(refWhite, adaptingLuminance, backgroundLuminance, surround, discounting) {
  const env = {};
  env.discounting = discounting;
  env.refWhite = refWhite;
  env.surround = surround;
  const xyzW = refWhite.map((c4) => {
    return c4 * 100;
  });
  env.la = adaptingLuminance;
  env.yb = backgroundLuminance;
  const yw = xyzW[1];
  const rgbW = multiplyMatrices(cat16, xyzW);
  surround = surroundMap[env.surround];
  const f = surround[0];
  env.c = surround[1];
  env.nc = surround[2];
  const k = 1 / (5 * env.la + 1);
  const k4 = k ** 4;
  env.fl = k4 * env.la + 0.1 * (1 - k4) * (1 - k4) * Math.cbrt(5 * env.la);
  env.flRoot = env.fl ** 0.25;
  env.n = env.yb / yw;
  env.z = 1.48 + Math.sqrt(env.n);
  env.nbb = 0.725 * env.n ** -0.2;
  env.ncb = env.nbb;
  const d2 = discounting ? 1 : Math.max(
    Math.min(f * (1 - 1 / 3.6 * Math.exp((-env.la - 42) / 92)), 1),
    0
  );
  env.dRgb = rgbW.map((c4) => {
    return interpolate(1, yw / c4, d2);
  });
  env.dRgbInv = env.dRgb.map((c4) => {
    return 1 / c4;
  });
  const rgbCW = rgbW.map((c4, i) => {
    return c4 * env.dRgb[i];
  });
  const rgbAW = adapt2(rgbCW, env.fl);
  env.aW = env.nbb * (2 * rgbAW[0] + rgbAW[1] + 0.05 * rgbAW[2]);
  return env;
}
var viewingConditions = environment2(
  white2,
  64 / Math.PI * 0.2,
  20,
  "average",
  false
);
function fromCam16(cam16, env) {
  if (!(cam16.J !== void 0 ^ cam16.Q !== void 0)) {
    throw new Error("Conversion requires one and only one: 'J' or 'Q'");
  }
  if (!(cam16.C !== void 0 ^ cam16.M !== void 0 ^ cam16.s !== void 0)) {
    throw new Error("Conversion requires one and only one: 'C', 'M' or 's'");
  }
  if (!(cam16.h !== void 0 ^ cam16.H !== void 0)) {
    throw new Error("Conversion requires one and only one: 'h' or 'H'");
  }
  if (cam16.J === 0 || cam16.Q === 0) {
    return [0, 0, 0];
  }
  let hRad = 0;
  if (cam16.h !== void 0) {
    hRad = constrain(cam16.h) * deg2rad;
  } else {
    hRad = invHueQuadrature(cam16.H) * deg2rad;
  }
  const cosh = Math.cos(hRad);
  const sinh = Math.sin(hRad);
  let Jroot = 0;
  if (cam16.J !== void 0) {
    Jroot = spow(cam16.J, 1 / 2) * 0.1;
  } else if (cam16.Q !== void 0) {
    Jroot = 0.25 * env.c * cam16.Q / ((env.aW + 4) * env.flRoot);
  }
  let alpha = 0;
  if (cam16.C !== void 0) {
    alpha = cam16.C / Jroot;
  } else if (cam16.M !== void 0) {
    alpha = cam16.M / env.flRoot / Jroot;
  } else if (cam16.s !== void 0) {
    alpha = 4e-4 * cam16.s ** 2 * (env.aW + 4) / env.c;
  }
  const t = spow(
    alpha * Math.pow(1.64 - Math.pow(0.29, env.n), -0.73),
    10 / 9
  );
  const et = 0.25 * (Math.cos(hRad + 2) + 3.8);
  const A = env.aW * spow(Jroot, 2 / env.c / env.z);
  const p1 = 5e4 / 13 * env.nc * env.ncb * et;
  const p2 = A / env.nbb;
  const r = 23 * (p2 + 0.305) * zdiv(t, 23 * p1 + t * (11 * cosh + 108 * sinh));
  const a2 = r * cosh;
  const b3 = r * sinh;
  const rgb_c = unadapt(
    multiplyMatrices(m12, [p2, a2, b3]).map((c4) => {
      return c4 * 1 / 1403;
    }),
    env.fl
  );
  return multiplyMatrices(
    cat16Inv,
    rgb_c.map((c4, i) => {
      return c4 * env.dRgbInv[i];
    })
  ).map((c4) => {
    return c4 / 100;
  });
}
function toCam16(xyzd65, env) {
  const xyz100 = xyzd65.map((c4) => {
    return c4 * 100;
  });
  const rgbA = adapt2(
    multiplyMatrices(cat16, xyz100).map((c4, i) => {
      return c4 * env.dRgb[i];
    }),
    env.fl
  );
  const a2 = rgbA[0] + (-12 * rgbA[1] + rgbA[2]) / 11;
  const b3 = (rgbA[0] + rgbA[1] - 2 * rgbA[2]) / 9;
  const hRad = (Math.atan2(b3, a2) % tau + tau) % tau;
  const et = 0.25 * (Math.cos(hRad + 2) + 3.8);
  const t = 5e4 / 13 * env.nc * env.ncb * zdiv(
    et * Math.sqrt(a2 ** 2 + b3 ** 2),
    rgbA[0] + rgbA[1] + 1.05 * rgbA[2] + 0.305
  );
  const alpha = spow(t, 0.9) * Math.pow(1.64 - Math.pow(0.29, env.n), 0.73);
  const A = env.nbb * (2 * rgbA[0] + rgbA[1] + 0.05 * rgbA[2]);
  const Jroot = spow(A / env.aW, 0.5 * env.c * env.z);
  const J2 = 100 * spow(Jroot, 2);
  const Q2 = 4 / env.c * Jroot * (env.aW + 4) * env.flRoot;
  const C = alpha * Jroot;
  const M = C * env.flRoot;
  const h = constrain(hRad * rad2deg);
  const H2 = hueQuadrature(h);
  const s = 50 * spow(env.c * alpha / (env.aW + 4), 1 / 2);
  return { J: J2, C, h, s, Q: Q2, M, H: H2 };
}
var cam16_default = new ColorSpace({
  id: "cam16-jmh",
  cssId: "--cam16-jmh",
  name: "CAM16-JMh",
  coords: {
    j: {
      refRange: [0, 100],
      name: "J"
    },
    m: {
      refRange: [0, 105],
      name: "Colorfulness"
    },
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    }
  },
  base: xyz_d65_default,
  fromBase(xyz) {
    const cam16 = toCam16(xyz, viewingConditions);
    return [cam16.J, cam16.M, cam16.h];
  },
  toBase(cam16) {
    return fromCam16(
      { J: cam16[0], M: cam16[1], h: cam16[2] },
      viewingConditions
    );
  }
});

// node_modules/colorjs.io/src/spaces/hct.js
var white3 = WHITES.D65;
var ε5 = 216 / 24389;
var κ2 = 24389 / 27;
function toLstar(y) {
  const fy = y > ε5 ? Math.cbrt(y) : (κ2 * y + 16) / 116;
  return 116 * fy - 16;
}
function fromLstar(lstar) {
  return lstar > 8 ? Math.pow((lstar + 16) / 116, 3) : lstar / κ2;
}
function fromHct(coords, env) {
  let [h, c4, t] = coords;
  let xyz = [];
  let j2 = 0;
  if (t === 0) {
    return [0, 0, 0];
  }
  let y = fromLstar(t);
  if (t > 0) {
    j2 = 0.00379058511492914 * t ** 2 + 0.608983189401032 * t + 0.9155088574762233;
  } else {
    j2 = 9514440756550361e-21 * t ** 2 + 0.08693057439788597 * t - 21.928975842194614;
  }
  const threshold = 2e-12;
  const max_attempts = 15;
  let attempt = 0;
  let last2 = Infinity;
  let best = j2;
  while (attempt <= max_attempts) {
    xyz = fromCam16({ J: j2, C: c4, h }, env);
    const delta = Math.abs(xyz[1] - y);
    if (delta < last2) {
      if (delta <= threshold) {
        return xyz;
      }
      best = j2;
      last2 = delta;
    }
    j2 = j2 - (xyz[1] - y) * j2 / (2 * xyz[1]);
    attempt += 1;
  }
  return fromCam16({ J: j2, C: c4, h }, env);
}
function toHct(xyz, env) {
  const t = toLstar(xyz[1]);
  if (t === 0) {
    return [0, 0, 0];
  }
  const cam16 = toCam16(xyz, viewingConditions2);
  return [constrain(cam16.h), cam16.C, t];
}
var viewingConditions2 = environment2(
  white3,
  200 / Math.PI * fromLstar(50),
  fromLstar(50) * 100,
  "average",
  false
);
var hct_default = new ColorSpace({
  id: "hct",
  name: "HCT",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    c: {
      refRange: [0, 145],
      name: "Colorfulness"
    },
    t: {
      refRange: [0, 100],
      name: "Tone"
    }
  },
  base: xyz_d65_default,
  fromBase(xyz) {
    return toHct(xyz, viewingConditions2);
  },
  toBase(hct) {
    return fromHct(hct, viewingConditions2);
  },
  formats: {
    color: {
      id: "--hct",
      coords: ["<number> | <angle>", "<percentage> | <number>", "<percentage> | <number>"]
    }
  }
});

// node_modules/colorjs.io/src/deltaE/deltaEHCT.js
var rad2deg2 = 180 / Math.PI;
var deg2rad2 = Math.PI / 180;
var ucsCoeff = [1, 7e-3, 0.0228];
function convertUcsAb(coords) {
  if (coords[1] < 0) {
    coords = hct_default.fromBase(hct_default.toBase(coords));
  }
  const M = Math.log(Math.max(1 + ucsCoeff[2] * coords[1] * viewingConditions2.flRoot, 1)) / ucsCoeff[2];
  const hrad = coords[0] * deg2rad2;
  const a2 = M * Math.cos(hrad);
  const b3 = M * Math.sin(hrad);
  return [coords[2], a2, b3];
}
function deltaEHCT_default(color3, sample) {
  [color3, sample] = getColor([color3, sample]);
  let [t1, a1, b1] = convertUcsAb(hct_default.from(color3));
  let [t2, a2, b22] = convertUcsAb(hct_default.from(sample));
  return Math.sqrt((t1 - t2) ** 2 + (a1 - a2) ** 2 + (b1 - b22) ** 2);
}

// node_modules/colorjs.io/src/deltaE/index.js
var deltaE_default = {
  deltaE76,
  deltaECMC: deltaECMC_default,
  deltaE2000: deltaE2000_default,
  deltaEJz: deltaEJz_default,
  deltaEITP: deltaEITP_default,
  deltaEOK: deltaEOK_default,
  deltaEHCT: deltaEHCT_default
};

// node_modules/colorjs.io/src/toGamut.js
function calcEpsilon(jnd) {
  const order = !jnd ? 0 : Math.floor(Math.log10(Math.abs(jnd)));
  return Math.max(parseFloat(`1e${order - 2}`), 1e-6);
}
var GMAPPRESET = {
  "hct": {
    method: "hct.c",
    jnd: 2,
    deltaEMethod: "hct",
    blackWhiteClamp: {}
  },
  "hct-tonal": {
    method: "hct.c",
    jnd: 0,
    deltaEMethod: "hct",
    blackWhiteClamp: { channel: "hct.t", min: 0, max: 100 }
  }
};
function toGamut(color3, {
  method = defaults_default.gamut_mapping,
  space = void 0,
  deltaEMethod = "",
  jnd = 2,
  blackWhiteClamp = {}
} = {}) {
  color3 = getColor(color3);
  if (isString(arguments[1])) {
    space = arguments[1];
  } else if (!space) {
    space = color3.space;
  }
  space = ColorSpace.get(space);
  if (inGamut(color3, space, { epsilon: 0 })) {
    return color3;
  }
  let spaceColor;
  if (method === "css") {
    spaceColor = toGamutCSS(color3, { space });
  } else {
    if (method !== "clip" && !inGamut(color3, space)) {
      if (Object.prototype.hasOwnProperty.call(GMAPPRESET, method)) {
        ({ method, jnd, deltaEMethod, blackWhiteClamp } = GMAPPRESET[method]);
      }
      let de = deltaE2000_default;
      if (deltaEMethod !== "") {
        for (let m3 in deltaE_default) {
          if ("deltae" + deltaEMethod.toLowerCase() === m3.toLowerCase()) {
            de = deltaE_default[m3];
            break;
          }
        }
      }
      let clipped = toGamut(to(color3, space), { method: "clip", space });
      if (de(color3, clipped) > jnd) {
        if (Object.keys(blackWhiteClamp).length === 3) {
          let channelMeta = ColorSpace.resolveCoord(blackWhiteClamp.channel);
          let channel = get(to(color3, channelMeta.space), channelMeta.id);
          if (isNone(channel)) {
            channel = 0;
          }
          if (channel >= blackWhiteClamp.max) {
            return to({ space: "xyz-d65", coords: WHITES["D65"] }, color3.space);
          } else if (channel <= blackWhiteClamp.min) {
            return to({ space: "xyz-d65", coords: [0, 0, 0] }, color3.space);
          }
        }
        let coordMeta = ColorSpace.resolveCoord(method);
        let mapSpace = coordMeta.space;
        let coordId = coordMeta.id;
        let mappedColor = to(color3, mapSpace);
        mappedColor.coords.forEach((c4, i) => {
          if (isNone(c4)) {
            mappedColor.coords[i] = 0;
          }
        });
        let bounds = coordMeta.range || coordMeta.refRange;
        let min = bounds[0];
        let ε11 = calcEpsilon(jnd);
        let low = min;
        let high = get(mappedColor, coordId);
        while (high - low > ε11) {
          let clipped2 = clone(mappedColor);
          clipped2 = toGamut(clipped2, { space, method: "clip" });
          let deltaE2 = de(mappedColor, clipped2);
          if (deltaE2 - jnd < ε11) {
            low = get(mappedColor, coordId);
          } else {
            high = get(mappedColor, coordId);
          }
          set(mappedColor, coordId, (low + high) / 2);
        }
        spaceColor = to(mappedColor, space);
      } else {
        spaceColor = clipped;
      }
    } else {
      spaceColor = to(color3, space);
    }
    if (method === "clip" || !inGamut(spaceColor, space, { epsilon: 0 })) {
      let bounds = Object.values(space.coords).map((c4) => c4.range || []);
      spaceColor.coords = spaceColor.coords.map((c4, i) => {
        let [min, max] = bounds[i];
        if (min !== void 0) {
          c4 = Math.max(min, c4);
        }
        if (max !== void 0) {
          c4 = Math.min(c4, max);
        }
        return c4;
      });
    }
  }
  if (space !== color3.space) {
    spaceColor = to(spaceColor, color3.space);
  }
  color3.coords = spaceColor.coords;
  return color3;
}
toGamut.returns = "color";
var COLORS = {
  WHITE: { space: oklab_default, coords: [1, 0, 0] },
  BLACK: { space: oklab_default, coords: [0, 0, 0] }
};
function toGamutCSS(origin, { space } = {}) {
  const JND = 0.02;
  const ε11 = 1e-4;
  origin = getColor(origin);
  if (!space) {
    space = origin.space;
  }
  space = ColorSpace.get(space);
  const oklchSpace = ColorSpace.get("oklch");
  if (space.isUnbounded) {
    return to(origin, space);
  }
  const origin_OKLCH = to(origin, oklchSpace);
  let L = origin_OKLCH.coords[0];
  if (L >= 1) {
    const white6 = to(COLORS.WHITE, space);
    white6.alpha = origin.alpha;
    return to(white6, space);
  }
  if (L <= 0) {
    const black = to(COLORS.BLACK, space);
    black.alpha = origin.alpha;
    return to(black, space);
  }
  if (inGamut(origin_OKLCH, space, { epsilon: 0 })) {
    return to(origin_OKLCH, space);
  }
  function clip(_color) {
    const destColor = to(_color, space);
    const spaceCoords = Object.values(space.coords);
    destColor.coords = destColor.coords.map((coord, index) => {
      if ("range" in spaceCoords[index]) {
        const [min2, max2] = spaceCoords[index].range;
        return clamp(min2, coord, max2);
      }
      return coord;
    });
    return destColor;
  }
  let min = 0;
  let max = origin_OKLCH.coords[1];
  let min_inGamut = true;
  let current2 = clone(origin_OKLCH);
  let clipped = clip(current2);
  let E = deltaEOK_default(clipped, current2);
  if (E < JND) {
    return clipped;
  }
  while (max - min > ε11) {
    const chroma = (min + max) / 2;
    current2.coords[1] = chroma;
    if (min_inGamut && inGamut(current2, space, { epsilon: 0 })) {
      min = chroma;
    } else {
      clipped = clip(current2);
      E = deltaEOK_default(clipped, current2);
      if (E < JND) {
        if (JND - E < ε11) {
          break;
        } else {
          min_inGamut = false;
          min = chroma;
        }
      } else {
        max = chroma;
      }
    }
  }
  return clipped;
}

// node_modules/colorjs.io/src/to.js
function to(color3, space, { inGamut: inGamut2 } = {}) {
  color3 = getColor(color3);
  space = ColorSpace.get(space);
  let coords = space.from(color3);
  let ret = { space, coords, alpha: color3.alpha };
  if (inGamut2) {
    ret = toGamut(ret, inGamut2 === true ? void 0 : inGamut2);
  }
  return ret;
}
to.returns = "color";

// node_modules/colorjs.io/src/serialize.js
function serialize(color3, {
  precision = defaults_default.precision,
  format = "default",
  inGamut: inGamut2 = true,
  ...customOptions
} = {}) {
  var _a2;
  let ret;
  color3 = getColor(color3);
  let formatId = format;
  format = color3.space.getFormat(format) ?? color3.space.getFormat("default") ?? ColorSpace.DEFAULT_FORMAT;
  let coords = color3.coords.slice();
  inGamut2 || (inGamut2 = format.toGamut);
  if (inGamut2 && !inGamut(color3)) {
    coords = toGamut(clone(color3), inGamut2 === true ? void 0 : inGamut2).coords;
  }
  if (format.type === "custom") {
    customOptions.precision = precision;
    if (format.serialize) {
      ret = format.serialize(coords, color3.alpha, customOptions);
    } else {
      throw new TypeError(`format ${formatId} can only be used to parse colors, not for serialization`);
    }
  } else {
    let name = format.name || "color";
    if (format.serializeCoords) {
      coords = format.serializeCoords(coords, precision);
    } else {
      if (precision !== null) {
        coords = coords.map((c4) => {
          return serializeNumber(c4, { precision });
        });
      }
    }
    let args = [...coords];
    if (name === "color") {
      let cssId = format.id || ((_a2 = format.ids) == null ? void 0 : _a2[0]) || color3.space.id;
      args.unshift(cssId);
    }
    let alpha = color3.alpha;
    if (precision !== null) {
      alpha = serializeNumber(alpha, { precision });
    }
    let strAlpha = color3.alpha >= 1 || format.noAlpha ? "" : `${format.commas ? "," : " /"} ${alpha}`;
    ret = `${name}(${args.join(format.commas ? ", " : " ")}${strAlpha})`;
  }
  return ret;
}

// node_modules/colorjs.io/src/spaces/rec2020-linear.js
var toXYZ_M = [
  [0.6369580483012914, 0.14461690358620832, 0.1688809751641721],
  [0.2627002120112671, 0.6779980715188708, 0.05930171646986196],
  [0, 0.028072693049087428, 1.060985057710791]
];
var fromXYZ_M = [
  [1.716651187971268, -0.355670783776392, -0.25336628137366],
  [-0.666684351832489, 1.616481236634939, 0.0157685458139111],
  [0.017639857445311, -0.042770613257809, 0.942103121235474]
];
var rec2020_linear_default = new RGBColorSpace({
  id: "rec2020-linear",
  cssId: "--rec2020-linear",
  name: "Linear REC.2020",
  white: "D65",
  toXYZ_M,
  fromXYZ_M
});

// node_modules/colorjs.io/src/spaces/rec2020.js
var α = 1.09929682680944;
var β = 0.018053968510807;
var rec2020_default = new RGBColorSpace({
  id: "rec2020",
  name: "REC.2020",
  base: rec2020_linear_default,
  // Non-linear transfer function from Rec. ITU-R BT.2020-2 table 4
  toBase(RGB2) {
    return RGB2.map(function(val2) {
      if (val2 < β * 4.5) {
        return val2 / 4.5;
      }
      return Math.pow((val2 + α - 1) / α, 1 / 0.45);
    });
  },
  fromBase(RGB2) {
    return RGB2.map(function(val2) {
      if (val2 >= β) {
        return α * Math.pow(val2, 0.45) - (α - 1);
      }
      return 4.5 * val2;
    });
  }
});

// node_modules/colorjs.io/src/spaces/p3-linear.js
var toXYZ_M2 = [
  [0.4865709486482162, 0.26566769316909306, 0.1982172852343625],
  [0.2289745640697488, 0.6917385218365064, 0.079286914093745],
  [0, 0.04511338185890264, 1.043944368900976]
];
var fromXYZ_M2 = [
  [2.493496911941425, -0.9313836179191239, -0.40271078445071684],
  [-0.8294889695615747, 1.7626640603183463, 0.023624685841943577],
  [0.03584583024378447, -0.07617238926804182, 0.9568845240076872]
];
var p3_linear_default = new RGBColorSpace({
  id: "p3-linear",
  cssId: "--display-p3-linear",
  name: "Linear P3",
  white: "D65",
  toXYZ_M: toXYZ_M2,
  fromXYZ_M: fromXYZ_M2
});

// node_modules/colorjs.io/src/spaces/srgb-linear.js
var toXYZ_M3 = [
  [0.41239079926595934, 0.357584339383878, 0.1804807884018343],
  [0.21263900587151027, 0.715168678767756, 0.07219231536073371],
  [0.01933081871559182, 0.11919477979462598, 0.9505321522496607]
];
var fromXYZ_M3 = [
  [3.2409699419045226, -1.537383177570094, -0.4986107602930034],
  [-0.9692436362808796, 1.8759675015077202, 0.04155505740717559],
  [0.05563007969699366, -0.20397695888897652, 1.0569715142428786]
];
var srgb_linear_default = new RGBColorSpace({
  id: "srgb-linear",
  name: "Linear sRGB",
  white: "D65",
  toXYZ_M: toXYZ_M3,
  fromXYZ_M: fromXYZ_M3
});

// node_modules/colorjs.io/src/keywords.js
var keywords_default = {
  "aliceblue": [240 / 255, 248 / 255, 1],
  "antiquewhite": [250 / 255, 235 / 255, 215 / 255],
  "aqua": [0, 1, 1],
  "aquamarine": [127 / 255, 1, 212 / 255],
  "azure": [240 / 255, 1, 1],
  "beige": [245 / 255, 245 / 255, 220 / 255],
  "bisque": [1, 228 / 255, 196 / 255],
  "black": [0, 0, 0],
  "blanchedalmond": [1, 235 / 255, 205 / 255],
  "blue": [0, 0, 1],
  "blueviolet": [138 / 255, 43 / 255, 226 / 255],
  "brown": [165 / 255, 42 / 255, 42 / 255],
  "burlywood": [222 / 255, 184 / 255, 135 / 255],
  "cadetblue": [95 / 255, 158 / 255, 160 / 255],
  "chartreuse": [127 / 255, 1, 0],
  "chocolate": [210 / 255, 105 / 255, 30 / 255],
  "coral": [1, 127 / 255, 80 / 255],
  "cornflowerblue": [100 / 255, 149 / 255, 237 / 255],
  "cornsilk": [1, 248 / 255, 220 / 255],
  "crimson": [220 / 255, 20 / 255, 60 / 255],
  "cyan": [0, 1, 1],
  "darkblue": [0, 0, 139 / 255],
  "darkcyan": [0, 139 / 255, 139 / 255],
  "darkgoldenrod": [184 / 255, 134 / 255, 11 / 255],
  "darkgray": [169 / 255, 169 / 255, 169 / 255],
  "darkgreen": [0, 100 / 255, 0],
  "darkgrey": [169 / 255, 169 / 255, 169 / 255],
  "darkkhaki": [189 / 255, 183 / 255, 107 / 255],
  "darkmagenta": [139 / 255, 0, 139 / 255],
  "darkolivegreen": [85 / 255, 107 / 255, 47 / 255],
  "darkorange": [1, 140 / 255, 0],
  "darkorchid": [153 / 255, 50 / 255, 204 / 255],
  "darkred": [139 / 255, 0, 0],
  "darksalmon": [233 / 255, 150 / 255, 122 / 255],
  "darkseagreen": [143 / 255, 188 / 255, 143 / 255],
  "darkslateblue": [72 / 255, 61 / 255, 139 / 255],
  "darkslategray": [47 / 255, 79 / 255, 79 / 255],
  "darkslategrey": [47 / 255, 79 / 255, 79 / 255],
  "darkturquoise": [0, 206 / 255, 209 / 255],
  "darkviolet": [148 / 255, 0, 211 / 255],
  "deeppink": [1, 20 / 255, 147 / 255],
  "deepskyblue": [0, 191 / 255, 1],
  "dimgray": [105 / 255, 105 / 255, 105 / 255],
  "dimgrey": [105 / 255, 105 / 255, 105 / 255],
  "dodgerblue": [30 / 255, 144 / 255, 1],
  "firebrick": [178 / 255, 34 / 255, 34 / 255],
  "floralwhite": [1, 250 / 255, 240 / 255],
  "forestgreen": [34 / 255, 139 / 255, 34 / 255],
  "fuchsia": [1, 0, 1],
  "gainsboro": [220 / 255, 220 / 255, 220 / 255],
  "ghostwhite": [248 / 255, 248 / 255, 1],
  "gold": [1, 215 / 255, 0],
  "goldenrod": [218 / 255, 165 / 255, 32 / 255],
  "gray": [128 / 255, 128 / 255, 128 / 255],
  "green": [0, 128 / 255, 0],
  "greenyellow": [173 / 255, 1, 47 / 255],
  "grey": [128 / 255, 128 / 255, 128 / 255],
  "honeydew": [240 / 255, 1, 240 / 255],
  "hotpink": [1, 105 / 255, 180 / 255],
  "indianred": [205 / 255, 92 / 255, 92 / 255],
  "indigo": [75 / 255, 0, 130 / 255],
  "ivory": [1, 1, 240 / 255],
  "khaki": [240 / 255, 230 / 255, 140 / 255],
  "lavender": [230 / 255, 230 / 255, 250 / 255],
  "lavenderblush": [1, 240 / 255, 245 / 255],
  "lawngreen": [124 / 255, 252 / 255, 0],
  "lemonchiffon": [1, 250 / 255, 205 / 255],
  "lightblue": [173 / 255, 216 / 255, 230 / 255],
  "lightcoral": [240 / 255, 128 / 255, 128 / 255],
  "lightcyan": [224 / 255, 1, 1],
  "lightgoldenrodyellow": [250 / 255, 250 / 255, 210 / 255],
  "lightgray": [211 / 255, 211 / 255, 211 / 255],
  "lightgreen": [144 / 255, 238 / 255, 144 / 255],
  "lightgrey": [211 / 255, 211 / 255, 211 / 255],
  "lightpink": [1, 182 / 255, 193 / 255],
  "lightsalmon": [1, 160 / 255, 122 / 255],
  "lightseagreen": [32 / 255, 178 / 255, 170 / 255],
  "lightskyblue": [135 / 255, 206 / 255, 250 / 255],
  "lightslategray": [119 / 255, 136 / 255, 153 / 255],
  "lightslategrey": [119 / 255, 136 / 255, 153 / 255],
  "lightsteelblue": [176 / 255, 196 / 255, 222 / 255],
  "lightyellow": [1, 1, 224 / 255],
  "lime": [0, 1, 0],
  "limegreen": [50 / 255, 205 / 255, 50 / 255],
  "linen": [250 / 255, 240 / 255, 230 / 255],
  "magenta": [1, 0, 1],
  "maroon": [128 / 255, 0, 0],
  "mediumaquamarine": [102 / 255, 205 / 255, 170 / 255],
  "mediumblue": [0, 0, 205 / 255],
  "mediumorchid": [186 / 255, 85 / 255, 211 / 255],
  "mediumpurple": [147 / 255, 112 / 255, 219 / 255],
  "mediumseagreen": [60 / 255, 179 / 255, 113 / 255],
  "mediumslateblue": [123 / 255, 104 / 255, 238 / 255],
  "mediumspringgreen": [0, 250 / 255, 154 / 255],
  "mediumturquoise": [72 / 255, 209 / 255, 204 / 255],
  "mediumvioletred": [199 / 255, 21 / 255, 133 / 255],
  "midnightblue": [25 / 255, 25 / 255, 112 / 255],
  "mintcream": [245 / 255, 1, 250 / 255],
  "mistyrose": [1, 228 / 255, 225 / 255],
  "moccasin": [1, 228 / 255, 181 / 255],
  "navajowhite": [1, 222 / 255, 173 / 255],
  "navy": [0, 0, 128 / 255],
  "oldlace": [253 / 255, 245 / 255, 230 / 255],
  "olive": [128 / 255, 128 / 255, 0],
  "olivedrab": [107 / 255, 142 / 255, 35 / 255],
  "orange": [1, 165 / 255, 0],
  "orangered": [1, 69 / 255, 0],
  "orchid": [218 / 255, 112 / 255, 214 / 255],
  "palegoldenrod": [238 / 255, 232 / 255, 170 / 255],
  "palegreen": [152 / 255, 251 / 255, 152 / 255],
  "paleturquoise": [175 / 255, 238 / 255, 238 / 255],
  "palevioletred": [219 / 255, 112 / 255, 147 / 255],
  "papayawhip": [1, 239 / 255, 213 / 255],
  "peachpuff": [1, 218 / 255, 185 / 255],
  "peru": [205 / 255, 133 / 255, 63 / 255],
  "pink": [1, 192 / 255, 203 / 255],
  "plum": [221 / 255, 160 / 255, 221 / 255],
  "powderblue": [176 / 255, 224 / 255, 230 / 255],
  "purple": [128 / 255, 0, 128 / 255],
  "rebeccapurple": [102 / 255, 51 / 255, 153 / 255],
  "red": [1, 0, 0],
  "rosybrown": [188 / 255, 143 / 255, 143 / 255],
  "royalblue": [65 / 255, 105 / 255, 225 / 255],
  "saddlebrown": [139 / 255, 69 / 255, 19 / 255],
  "salmon": [250 / 255, 128 / 255, 114 / 255],
  "sandybrown": [244 / 255, 164 / 255, 96 / 255],
  "seagreen": [46 / 255, 139 / 255, 87 / 255],
  "seashell": [1, 245 / 255, 238 / 255],
  "sienna": [160 / 255, 82 / 255, 45 / 255],
  "silver": [192 / 255, 192 / 255, 192 / 255],
  "skyblue": [135 / 255, 206 / 255, 235 / 255],
  "slateblue": [106 / 255, 90 / 255, 205 / 255],
  "slategray": [112 / 255, 128 / 255, 144 / 255],
  "slategrey": [112 / 255, 128 / 255, 144 / 255],
  "snow": [1, 250 / 255, 250 / 255],
  "springgreen": [0, 1, 127 / 255],
  "steelblue": [70 / 255, 130 / 255, 180 / 255],
  "tan": [210 / 255, 180 / 255, 140 / 255],
  "teal": [0, 128 / 255, 128 / 255],
  "thistle": [216 / 255, 191 / 255, 216 / 255],
  "tomato": [1, 99 / 255, 71 / 255],
  "turquoise": [64 / 255, 224 / 255, 208 / 255],
  "violet": [238 / 255, 130 / 255, 238 / 255],
  "wheat": [245 / 255, 222 / 255, 179 / 255],
  "white": [1, 1, 1],
  "whitesmoke": [245 / 255, 245 / 255, 245 / 255],
  "yellow": [1, 1, 0],
  "yellowgreen": [154 / 255, 205 / 255, 50 / 255]
};

// node_modules/colorjs.io/src/spaces/srgb.js
var coordGrammar = Array(3).fill("<percentage> | <number>[0, 255]");
var coordGrammarNumber = Array(3).fill("<number>[0, 255]");
var srgb_default = new RGBColorSpace({
  id: "srgb",
  name: "sRGB",
  base: srgb_linear_default,
  fromBase: (rgb) => {
    return rgb.map((val2) => {
      let sign = val2 < 0 ? -1 : 1;
      let abs = val2 * sign;
      if (abs > 31308e-7) {
        return sign * (1.055 * abs ** (1 / 2.4) - 0.055);
      }
      return 12.92 * val2;
    });
  },
  toBase: (rgb) => {
    return rgb.map((val2) => {
      let sign = val2 < 0 ? -1 : 1;
      let abs = val2 * sign;
      if (abs <= 0.04045) {
        return val2 / 12.92;
      }
      return sign * ((abs + 0.055) / 1.055) ** 2.4;
    });
  },
  formats: {
    "rgb": {
      coords: coordGrammar
    },
    "rgb_number": {
      name: "rgb",
      commas: true,
      coords: coordGrammarNumber,
      noAlpha: true
    },
    "color": {
      /* use defaults */
    },
    "rgba": {
      coords: coordGrammar,
      commas: true,
      lastAlpha: true
    },
    "rgba_number": {
      name: "rgba",
      commas: true,
      coords: coordGrammarNumber
    },
    "hex": {
      type: "custom",
      toGamut: true,
      test: (str) => /^#([a-f0-9]{3,4}){1,2}$/i.test(str),
      parse(str) {
        if (str.length <= 5) {
          str = str.replace(/[a-f0-9]/gi, "$&$&");
        }
        let rgba = [];
        str.replace(/[a-f0-9]{2}/gi, (component) => {
          rgba.push(parseInt(component, 16) / 255);
        });
        return {
          spaceId: "srgb",
          coords: rgba.slice(0, 3),
          alpha: rgba.slice(3)[0]
        };
      },
      serialize: (coords, alpha, {
        collapse = true
        // collapse to 3-4 digit hex when possible?
      } = {}) => {
        if (alpha < 1) {
          coords.push(alpha);
        }
        coords = coords.map((c4) => Math.round(c4 * 255));
        let collapsible = collapse && coords.every((c4) => c4 % 17 === 0);
        let hex = coords.map((c4) => {
          if (collapsible) {
            return (c4 / 17).toString(16);
          }
          return c4.toString(16).padStart(2, "0");
        }).join("");
        return "#" + hex;
      }
    },
    "keyword": {
      type: "custom",
      test: (str) => /^[a-z]+$/i.test(str),
      parse(str) {
        str = str.toLowerCase();
        let ret = { spaceId: "srgb", coords: null, alpha: 1 };
        if (str === "transparent") {
          ret.coords = keywords_default.black;
          ret.alpha = 0;
        } else {
          ret.coords = keywords_default[str];
        }
        if (ret.coords) {
          return ret;
        }
      }
    }
  }
});

// node_modules/colorjs.io/src/spaces/p3.js
var p3_default = new RGBColorSpace({
  id: "p3",
  cssId: "display-p3",
  name: "P3",
  base: p3_linear_default,
  // Gamma encoding/decoding is the same as sRGB
  fromBase: srgb_default.fromBase,
  toBase: srgb_default.toBase
});

// node_modules/colorjs.io/src/display.js
defaults_default.display_space = srgb_default;
if (typeof CSS !== "undefined" && CSS.supports) {
  for (let space of [lab_default, rec2020_default, p3_default]) {
    let coords = space.getMinCoords();
    let color3 = { space, coords, alpha: 1 };
    let str = serialize(color3);
    if (CSS.supports("color", str)) {
      defaults_default.display_space = space;
      break;
    }
  }
}

// node_modules/colorjs.io/src/spaces/lab-d65.js
var ε6 = 216 / 24389;
var ε32 = 24 / 116;
var κ3 = 24389 / 27;
var white4 = WHITES.D65;
var lab_d65_default = new ColorSpace({
  id: "lab-d65",
  name: "Lab D65",
  coords: {
    l: {
      refRange: [0, 100],
      name: "Lightness"
    },
    a: {
      refRange: [-125, 125]
    },
    b: {
      refRange: [-125, 125]
    }
  },
  // Assuming XYZ is relative to D65, convert to CIE Lab
  // from CIE standard, which now defines these as a rational fraction
  white: white4,
  base: xyz_d65_default,
  // Convert D65-adapted XYZ to Lab
  //  CIE 15.3:2004 section 8.2.1.1
  fromBase(XYZ) {
    let xyz = XYZ.map((value, i) => value / white4[i]);
    let f = xyz.map((value) => value > ε6 ? Math.cbrt(value) : (κ3 * value + 16) / 116);
    return [
      116 * f[1] - 16,
      // L
      500 * (f[0] - f[1]),
      // a
      200 * (f[1] - f[2])
      // b
    ];
  },
  // Convert Lab to D65-adapted XYZ
  // Same result as CIE 15.3:2004 Appendix D although the derivation is different
  // http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html
  toBase(Lab) {
    let f = [];
    f[1] = (Lab[0] + 16) / 116;
    f[0] = Lab[1] / 500 + f[1];
    f[2] = f[1] - Lab[2] / 200;
    let xyz = [
      f[0] > ε32 ? Math.pow(f[0], 3) : (116 * f[0] - 16) / κ3,
      Lab[0] > 8 ? Math.pow((Lab[0] + 16) / 116, 3) : Lab[0] / κ3,
      f[2] > ε32 ? Math.pow(f[2], 3) : (116 * f[2] - 16) / κ3
    ];
    return xyz.map((value, i) => value * white4[i]);
  },
  formats: {
    "lab-d65": {
      coords: ["<number> | <percentage>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
    }
  }
});

// node_modules/colorjs.io/src/contrast/deltaPhi.js
var phi = Math.pow(5, 0.5) * 0.5 + 0.5;

// node_modules/colorjs.io/src/chromaticity.js
function uv(color3) {
  let [X2, Y, Z2] = getAll(color3, xyz_d65_default);
  let denom = X2 + 15 * Y + 3 * Z2;
  return [4 * X2 / denom, 9 * Y / denom];
}

// node_modules/colorjs.io/src/interpolation.js
function range(color1, color22, options2 = {}) {
  if (isRange(color1)) {
    let [r, options3] = [color1, color22];
    return range(...r.rangeArgs.colors, { ...r.rangeArgs.options, ...options3 });
  }
  let { space, outputSpace, progression, premultiplied } = options2;
  color1 = getColor(color1);
  color22 = getColor(color22);
  color1 = clone(color1);
  color22 = clone(color22);
  let rangeArgs = { colors: [color1, color22], options: options2 };
  if (space) {
    space = ColorSpace.get(space);
  } else {
    space = ColorSpace.registry[defaults_default.interpolationSpace] || color1.space;
  }
  outputSpace = outputSpace ? ColorSpace.get(outputSpace) : space;
  color1 = to(color1, space);
  color22 = to(color22, space);
  color1 = toGamut(color1);
  color22 = toGamut(color22);
  if (space.coords.h && space.coords.h.type === "angle") {
    let arc = options2.hue = options2.hue || "shorter";
    let hue = [space, "h"];
    let [θ1, θ2] = [get(color1, hue), get(color22, hue)];
    if (isNaN(θ1) && !isNaN(θ2)) {
      θ1 = θ2;
    } else if (isNaN(θ2) && !isNaN(θ1)) {
      θ2 = θ1;
    }
    [θ1, θ2] = adjust(arc, [θ1, θ2]);
    set(color1, hue, θ1);
    set(color22, hue, θ2);
  }
  if (premultiplied) {
    color1.coords = color1.coords.map((c4) => c4 * color1.alpha);
    color22.coords = color22.coords.map((c4) => c4 * color22.alpha);
  }
  return Object.assign((p2) => {
    p2 = progression ? progression(p2) : p2;
    let coords = color1.coords.map((start, i) => {
      let end = color22.coords[i];
      return interpolate(start, end, p2);
    });
    let alpha = interpolate(color1.alpha, color22.alpha, p2);
    let ret = { space, coords, alpha };
    if (premultiplied) {
      ret.coords = ret.coords.map((c4) => c4 / alpha);
    }
    if (outputSpace !== space) {
      ret = to(ret, outputSpace);
    }
    return ret;
  }, {
    rangeArgs
  });
}
function isRange(val2) {
  return type(val2) === "function" && !!val2.rangeArgs;
}
defaults_default.interpolationSpace = "lab";

// node_modules/colorjs.io/src/spaces/hsl.js
var hsl_default = new ColorSpace({
  id: "hsl",
  name: "HSL",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    s: {
      range: [0, 100],
      name: "Saturation"
    },
    l: {
      range: [0, 100],
      name: "Lightness"
    }
  },
  base: srgb_default,
  // Adapted from https://drafts.csswg.org/css-color-4/better-rgbToHsl.js
  fromBase: (rgb) => {
    let max = Math.max(...rgb);
    let min = Math.min(...rgb);
    let [r, g2, b3] = rgb;
    let [h, s, l] = [NaN, 0, (min + max) / 2];
    let d2 = max - min;
    if (d2 !== 0) {
      s = l === 0 || l === 1 ? 0 : (max - l) / Math.min(l, 1 - l);
      switch (max) {
        case r:
          h = (g2 - b3) / d2 + (g2 < b3 ? 6 : 0);
          break;
        case g2:
          h = (b3 - r) / d2 + 2;
          break;
        case b3:
          h = (r - g2) / d2 + 4;
      }
      h = h * 60;
    }
    if (s < 0) {
      h += 180;
      s = Math.abs(s);
    }
    if (h >= 360) {
      h -= 360;
    }
    return [h, s * 100, l * 100];
  },
  // Adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative
  toBase: (hsl) => {
    let [h, s, l] = hsl;
    h = h % 360;
    if (h < 0) {
      h += 360;
    }
    s /= 100;
    l /= 100;
    function f(n3) {
      let k = (n3 + h / 30) % 12;
      let a2 = s * Math.min(l, 1 - l);
      return l - a2 * Math.max(-1, Math.min(k - 3, 9 - k, 1));
    }
    return [f(0), f(8), f(4)];
  },
  formats: {
    "hsl": {
      coords: ["<number> | <angle>", "<percentage>", "<percentage>"]
    },
    "hsla": {
      coords: ["<number> | <angle>", "<percentage>", "<percentage>"],
      commas: true,
      lastAlpha: true
    }
  }
});

// node_modules/colorjs.io/src/spaces/hsv.js
var hsv_default = new ColorSpace({
  id: "hsv",
  name: "HSV",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    s: {
      range: [0, 100],
      name: "Saturation"
    },
    v: {
      range: [0, 100],
      name: "Value"
    }
  },
  base: hsl_default,
  // https://en.wikipedia.org/wiki/HSL_and_HSV#Interconversion
  fromBase(hsl) {
    let [h, s, l] = hsl;
    s /= 100;
    l /= 100;
    let v = l + s * Math.min(l, 1 - l);
    return [
      h,
      // h is the same
      v === 0 ? 0 : 200 * (1 - l / v),
      // s
      100 * v
    ];
  },
  // https://en.wikipedia.org/wiki/HSL_and_HSV#Interconversion
  toBase(hsv) {
    let [h, s, v] = hsv;
    s /= 100;
    v /= 100;
    let l = v * (1 - s / 2);
    return [
      h,
      // h is the same
      l === 0 || l === 1 ? 0 : (v - l) / Math.min(l, 1 - l) * 100,
      l * 100
    ];
  },
  formats: {
    color: {
      id: "--hsv",
      coords: ["<number> | <angle>", "<percentage> | <number>", "<percentage> | <number>"]
    }
  }
});

// node_modules/colorjs.io/src/spaces/hwb.js
var hwb_default = new ColorSpace({
  id: "hwb",
  name: "HWB",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    w: {
      range: [0, 100],
      name: "Whiteness"
    },
    b: {
      range: [0, 100],
      name: "Blackness"
    }
  },
  base: hsv_default,
  fromBase(hsv) {
    let [h, s, v] = hsv;
    return [h, v * (100 - s) / 100, 100 - v];
  },
  toBase(hwb) {
    let [h, w, b3] = hwb;
    w /= 100;
    b3 /= 100;
    let sum = w + b3;
    if (sum >= 1) {
      let gray = w / sum;
      return [h, 0, gray * 100];
    }
    let v = 1 - b3;
    let s = v === 0 ? 0 : 1 - w / v;
    return [h, s * 100, v * 100];
  },
  formats: {
    "hwb": {
      coords: ["<number> | <angle>", "<percentage> | <number>", "<percentage> | <number>"]
    }
  }
});

// node_modules/colorjs.io/src/spaces/a98rgb-linear.js
var toXYZ_M4 = [
  [0.5766690429101305, 0.1855582379065463, 0.1882286462349947],
  [0.29734497525053605, 0.6273635662554661, 0.07529145849399788],
  [0.02703136138641234, 0.07068885253582723, 0.9913375368376388]
];
var fromXYZ_M4 = [
  [2.0415879038107465, -0.5650069742788596, -0.34473135077832956],
  [-0.9692436362808795, 1.8759675015077202, 0.04155505740717557],
  [0.013444280632031142, -0.11836239223101838, 1.0151749943912054]
];
var a98rgb_linear_default = new RGBColorSpace({
  id: "a98rgb-linear",
  cssId: "--a98-rgb-linear",
  name: "Linear Adobe® 98 RGB compatible",
  white: "D65",
  toXYZ_M: toXYZ_M4,
  fromXYZ_M: fromXYZ_M4
});

// node_modules/colorjs.io/src/spaces/a98rgb.js
var a98rgb_default = new RGBColorSpace({
  id: "a98rgb",
  cssId: "a98-rgb",
  name: "Adobe® 98 RGB compatible",
  base: a98rgb_linear_default,
  toBase: (RGB2) => RGB2.map((val2) => Math.pow(Math.abs(val2), 563 / 256) * Math.sign(val2)),
  fromBase: (RGB2) => RGB2.map((val2) => Math.pow(Math.abs(val2), 256 / 563) * Math.sign(val2))
});

// node_modules/colorjs.io/src/spaces/prophoto-linear.js
var toXYZ_M5 = [
  [0.7977666449006423, 0.13518129740053308, 0.0313477341283922],
  [0.2880748288194013, 0.711835234241873, 8993693872564e-17],
  [0, 0, 0.8251046025104602]
];
var fromXYZ_M5 = [
  [1.3457868816471583, -0.25557208737979464, -0.05110186497554526],
  [-0.5446307051249019, 1.5082477428451468, 0.02052744743642139],
  [0, 0, 1.2119675456389452]
];
var prophoto_linear_default = new RGBColorSpace({
  id: "prophoto-linear",
  cssId: "--prophoto-rgb-linear",
  name: "Linear ProPhoto",
  white: "D50",
  base: xyz_d50_default,
  toXYZ_M: toXYZ_M5,
  fromXYZ_M: fromXYZ_M5
});

// node_modules/colorjs.io/src/spaces/prophoto.js
var Et = 1 / 512;
var Et2 = 16 / 512;
var prophoto_default = new RGBColorSpace({
  id: "prophoto",
  cssId: "prophoto-rgb",
  name: "ProPhoto",
  base: prophoto_linear_default,
  toBase(RGB2) {
    return RGB2.map((v) => v < Et2 ? v / 16 : v ** 1.8);
  },
  fromBase(RGB2) {
    return RGB2.map((v) => v >= Et ? v ** (1 / 1.8) : 16 * v);
  }
});

// node_modules/colorjs.io/src/spaces/oklch.js
var oklch_default = new ColorSpace({
  id: "oklch",
  name: "Oklch",
  coords: {
    l: {
      refRange: [0, 1],
      name: "Lightness"
    },
    c: {
      refRange: [0, 0.4],
      name: "Chroma"
    },
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    }
  },
  white: "D65",
  base: oklab_default,
  fromBase(oklab) {
    let [L, a2, b3] = oklab;
    let h;
    const ε11 = 2e-4;
    if (Math.abs(a2) < ε11 && Math.abs(b3) < ε11) {
      h = NaN;
    } else {
      h = Math.atan2(b3, a2) * 180 / Math.PI;
    }
    return [
      L,
      // OKLab L is still L
      Math.sqrt(a2 ** 2 + b3 ** 2),
      // Chroma
      constrain(h)
      // Hue, in degrees [0 to 360)
    ];
  },
  // Convert from polar form
  toBase(oklch) {
    let [L, C, h] = oklch;
    let a2, b3;
    if (isNaN(h)) {
      a2 = 0;
      b3 = 0;
    } else {
      a2 = C * Math.cos(h * Math.PI / 180);
      b3 = C * Math.sin(h * Math.PI / 180);
    }
    return [L, a2, b3];
  },
  formats: {
    "oklch": {
      coords: ["<percentage> | <number>", "<number> | <percentage>[0,1]", "<number> | <angle>"]
    }
  }
});

// node_modules/colorjs.io/src/spaces/luv.js
var white5 = WHITES.D65;
var ε7 = 216 / 24389;
var κ4 = 24389 / 27;
var [U_PRIME_WHITE, V_PRIME_WHITE] = uv({ space: xyz_d65_default, coords: white5 });
var luv_default = new ColorSpace({
  id: "luv",
  name: "Luv",
  coords: {
    l: {
      refRange: [0, 100],
      name: "Lightness"
    },
    // Reference ranges from https://facelessuser.github.io/coloraide/colors/luv/
    u: {
      refRange: [-215, 215]
    },
    v: {
      refRange: [-215, 215]
    }
  },
  white: white5,
  base: xyz_d65_default,
  // Convert D65-adapted XYZ to Luv
  // https://en.wikipedia.org/wiki/CIELUV#The_forward_transformation
  fromBase(XYZ) {
    let xyz = [skipNone(XYZ[0]), skipNone(XYZ[1]), skipNone(XYZ[2])];
    let y = xyz[1];
    let [up, vp] = uv({ space: xyz_d65_default, coords: xyz });
    if (!Number.isFinite(up) || !Number.isFinite(vp)) {
      return [0, 0, 0];
    }
    let L = y <= ε7 ? κ4 * y : 116 * Math.cbrt(y) - 16;
    return [
      L,
      13 * L * (up - U_PRIME_WHITE),
      13 * L * (vp - V_PRIME_WHITE)
    ];
  },
  // Convert Luv to D65-adapted XYZ
  // https://en.wikipedia.org/wiki/CIELUV#The_reverse_transformation
  toBase(Luv) {
    let [L, u, v] = Luv;
    if (L === 0 || isNone(L)) {
      return [0, 0, 0];
    }
    u = skipNone(u);
    v = skipNone(v);
    let up = u / (13 * L) + U_PRIME_WHITE;
    let vp = v / (13 * L) + V_PRIME_WHITE;
    let y = L <= 8 ? L / κ4 : Math.pow((L + 16) / 116, 3);
    return [
      y * (9 * up / (4 * vp)),
      y,
      y * ((12 - 3 * up - 20 * vp) / (4 * vp))
    ];
  },
  formats: {
    color: {
      id: "--luv",
      coords: ["<number> | <percentage>", "<number> | <percentage>[-1,1]", "<number> | <percentage>[-1,1]"]
    }
  }
});

// node_modules/colorjs.io/src/spaces/lchuv.js
var lchuv_default = new ColorSpace({
  id: "lchuv",
  name: "LChuv",
  coords: {
    l: {
      refRange: [0, 100],
      name: "Lightness"
    },
    c: {
      refRange: [0, 220],
      name: "Chroma"
    },
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    }
  },
  base: luv_default,
  fromBase(Luv) {
    let [L, u, v] = Luv;
    let hue;
    const ε11 = 0.02;
    if (Math.abs(u) < ε11 && Math.abs(v) < ε11) {
      hue = NaN;
    } else {
      hue = Math.atan2(v, u) * 180 / Math.PI;
    }
    return [
      L,
      // L is still L
      Math.sqrt(u ** 2 + v ** 2),
      // Chroma
      constrain(hue)
      // Hue, in degrees [0 to 360)
    ];
  },
  toBase(LCH2) {
    let [Lightness, Chroma, Hue] = LCH2;
    if (Chroma < 0) {
      Chroma = 0;
    }
    if (isNaN(Hue)) {
      Hue = 0;
    }
    return [
      Lightness,
      // L is still L
      Chroma * Math.cos(Hue * Math.PI / 180),
      // u
      Chroma * Math.sin(Hue * Math.PI / 180)
      // v
    ];
  },
  formats: {
    color: {
      id: "--lchuv",
      coords: ["<number> | <percentage>", "<number> | <percentage>", "<number> | <angle>"]
    }
  }
});

// node_modules/colorjs.io/src/spaces/hsluv.js
var ε8 = 216 / 24389;
var κ5 = 24389 / 27;
var m_r0 = fromXYZ_M3[0][0];
var m_r1 = fromXYZ_M3[0][1];
var m_r2 = fromXYZ_M3[0][2];
var m_g0 = fromXYZ_M3[1][0];
var m_g1 = fromXYZ_M3[1][1];
var m_g2 = fromXYZ_M3[1][2];
var m_b0 = fromXYZ_M3[2][0];
var m_b1 = fromXYZ_M3[2][1];
var m_b2 = fromXYZ_M3[2][2];
function distanceFromOriginAngle(slope, intercept, angle) {
  const d2 = intercept / (Math.sin(angle) - slope * Math.cos(angle));
  return d2 < 0 ? Infinity : d2;
}
function calculateBoundingLines(l) {
  const sub1 = Math.pow(l + 16, 3) / 1560896;
  const sub2 = sub1 > ε8 ? sub1 : l / κ5;
  const s1r = sub2 * (284517 * m_r0 - 94839 * m_r2);
  const s2r = sub2 * (838422 * m_r2 + 769860 * m_r1 + 731718 * m_r0);
  const s3r = sub2 * (632260 * m_r2 - 126452 * m_r1);
  const s1g = sub2 * (284517 * m_g0 - 94839 * m_g2);
  const s2g = sub2 * (838422 * m_g2 + 769860 * m_g1 + 731718 * m_g0);
  const s3g = sub2 * (632260 * m_g2 - 126452 * m_g1);
  const s1b = sub2 * (284517 * m_b0 - 94839 * m_b2);
  const s2b = sub2 * (838422 * m_b2 + 769860 * m_b1 + 731718 * m_b0);
  const s3b = sub2 * (632260 * m_b2 - 126452 * m_b1);
  return {
    r0s: s1r / s3r,
    r0i: s2r * l / s3r,
    r1s: s1r / (s3r + 126452),
    r1i: (s2r - 769860) * l / (s3r + 126452),
    g0s: s1g / s3g,
    g0i: s2g * l / s3g,
    g1s: s1g / (s3g + 126452),
    g1i: (s2g - 769860) * l / (s3g + 126452),
    b0s: s1b / s3b,
    b0i: s2b * l / s3b,
    b1s: s1b / (s3b + 126452),
    b1i: (s2b - 769860) * l / (s3b + 126452)
  };
}
function calcMaxChromaHsluv(lines, h) {
  const hueRad = h / 360 * Math.PI * 2;
  const r0 = distanceFromOriginAngle(lines.r0s, lines.r0i, hueRad);
  const r1 = distanceFromOriginAngle(lines.r1s, lines.r1i, hueRad);
  const g0 = distanceFromOriginAngle(lines.g0s, lines.g0i, hueRad);
  const g1 = distanceFromOriginAngle(lines.g1s, lines.g1i, hueRad);
  const b0 = distanceFromOriginAngle(lines.b0s, lines.b0i, hueRad);
  const b1 = distanceFromOriginAngle(lines.b1s, lines.b1i, hueRad);
  return Math.min(r0, r1, g0, g1, b0, b1);
}
var hsluv_default = new ColorSpace({
  id: "hsluv",
  name: "HSLuv",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    s: {
      range: [0, 100],
      name: "Saturation"
    },
    l: {
      range: [0, 100],
      name: "Lightness"
    }
  },
  base: lchuv_default,
  gamutSpace: srgb_default,
  // Convert LCHuv to HSLuv
  fromBase(lch) {
    let [l, c4, h] = [skipNone(lch[0]), skipNone(lch[1]), skipNone(lch[2])];
    let s;
    if (l > 99.9999999) {
      s = 0;
      l = 100;
    } else if (l < 1e-8) {
      s = 0;
      l = 0;
    } else {
      let lines = calculateBoundingLines(l);
      let max = calcMaxChromaHsluv(lines, h);
      s = c4 / max * 100;
    }
    return [h, s, l];
  },
  // Convert HSLuv to LCHuv
  toBase(hsl) {
    let [h, s, l] = [skipNone(hsl[0]), skipNone(hsl[1]), skipNone(hsl[2])];
    let c4;
    if (l > 99.9999999) {
      l = 100;
      c4 = 0;
    } else if (l < 1e-8) {
      l = 0;
      c4 = 0;
    } else {
      let lines = calculateBoundingLines(l);
      let max = calcMaxChromaHsluv(lines, h);
      c4 = max / 100 * s;
    }
    return [l, c4, h];
  },
  formats: {
    color: {
      id: "--hsluv",
      coords: ["<number> | <angle>", "<percentage> | <number>", "<percentage> | <number>"]
    }
  }
});

// node_modules/colorjs.io/src/spaces/hpluv.js
var ε9 = 216 / 24389;
var κ6 = 24389 / 27;
var m_r02 = fromXYZ_M3[0][0];
var m_r12 = fromXYZ_M3[0][1];
var m_r22 = fromXYZ_M3[0][2];
var m_g02 = fromXYZ_M3[1][0];
var m_g12 = fromXYZ_M3[1][1];
var m_g22 = fromXYZ_M3[1][2];
var m_b02 = fromXYZ_M3[2][0];
var m_b12 = fromXYZ_M3[2][1];
var m_b22 = fromXYZ_M3[2][2];
function distanceFromOrigin(slope, intercept) {
  return Math.abs(intercept) / Math.sqrt(Math.pow(slope, 2) + 1);
}
function calcMaxChromaHpluv(lines) {
  let r0 = distanceFromOrigin(lines.r0s, lines.r0i);
  let r1 = distanceFromOrigin(lines.r1s, lines.r1i);
  let g0 = distanceFromOrigin(lines.g0s, lines.g0i);
  let g1 = distanceFromOrigin(lines.g1s, lines.g1i);
  let b0 = distanceFromOrigin(lines.b0s, lines.b0i);
  let b1 = distanceFromOrigin(lines.b1s, lines.b1i);
  return Math.min(r0, r1, g0, g1, b0, b1);
}
var hpluv_default = new ColorSpace({
  id: "hpluv",
  name: "HPLuv",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    s: {
      range: [0, 100],
      name: "Saturation"
    },
    l: {
      range: [0, 100],
      name: "Lightness"
    }
  },
  base: lchuv_default,
  gamutSpace: "self",
  // Convert LCHuv to HPLuv
  fromBase(lch) {
    let [l, c4, h] = [skipNone(lch[0]), skipNone(lch[1]), skipNone(lch[2])];
    let s;
    if (l > 99.9999999) {
      s = 0;
      l = 100;
    } else if (l < 1e-8) {
      s = 0;
      l = 0;
    } else {
      let lines = calculateBoundingLines(l);
      let max = calcMaxChromaHpluv(lines);
      s = c4 / max * 100;
    }
    return [h, s, l];
  },
  // Convert HPLuv to LCHuv
  toBase(hsl) {
    let [h, s, l] = [skipNone(hsl[0]), skipNone(hsl[1]), skipNone(hsl[2])];
    let c4;
    if (l > 99.9999999) {
      l = 100;
      c4 = 0;
    } else if (l < 1e-8) {
      l = 0;
      c4 = 0;
    } else {
      let lines = calculateBoundingLines(l);
      let max = calcMaxChromaHpluv(lines, h);
      c4 = max / 100 * s;
    }
    return [l, c4, h];
  },
  formats: {
    color: {
      id: "--hpluv",
      coords: ["<number> | <angle>", "<percentage> | <number>", "<percentage> | <number>"]
    }
  }
});

// node_modules/colorjs.io/src/spaces/rec2100-pq.js
var Yw2 = 203;
var n2 = 2610 / 2 ** 14;
var ninv2 = 2 ** 14 / 2610;
var m = 2523 / 2 ** 5;
var minv = 2 ** 5 / 2523;
var c13 = 3424 / 2 ** 12;
var c23 = 2413 / 2 ** 7;
var c33 = 2392 / 2 ** 7;
var rec2100_pq_default = new RGBColorSpace({
  id: "rec2100pq",
  cssId: "rec2100-pq",
  name: "REC.2100-PQ",
  base: rec2020_linear_default,
  toBase(RGB2) {
    return RGB2.map(function(val2) {
      let x = (Math.max(val2 ** minv - c13, 0) / (c23 - c33 * val2 ** minv)) ** ninv2;
      return x * 1e4 / Yw2;
    });
  },
  fromBase(RGB2) {
    return RGB2.map(function(val2) {
      let x = Math.max(val2 * Yw2 / 1e4, 0);
      let num = c13 + c23 * x ** n2;
      let denom = 1 + c33 * x ** n2;
      return (num / denom) ** m;
    });
  }
});

// node_modules/colorjs.io/src/spaces/rec2100-hlg.js
var a = 0.17883277;
var b2 = 0.28466892;
var c = 0.55991073;
var scale = 3.7743;
var rec2100_hlg_default = new RGBColorSpace({
  id: "rec2100hlg",
  cssId: "rec2100-hlg",
  name: "REC.2100-HLG",
  referred: "scene",
  base: rec2020_linear_default,
  toBase(RGB2) {
    return RGB2.map(function(val2) {
      if (val2 <= 0.5) {
        return val2 ** 2 / 3 * scale;
      }
      return (Math.exp((val2 - c) / a) + b2) / 12 * scale;
    });
  },
  fromBase(RGB2) {
    return RGB2.map(function(val2) {
      val2 /= scale;
      if (val2 <= 1 / 12) {
        return Math.sqrt(3 * val2);
      }
      return a * Math.log(12 * val2 - b2) + c;
    });
  }
});

// node_modules/colorjs.io/src/CATs.js
var CATs = {};
hooks_default.add("chromatic-adaptation-start", (env) => {
  if (env.options.method) {
    env.M = adapt3(env.W1, env.W2, env.options.method);
  }
});
hooks_default.add("chromatic-adaptation-end", (env) => {
  if (!env.M) {
    env.M = adapt3(env.W1, env.W2, env.options.method);
  }
});
function defineCAT({ id, toCone_M, fromCone_M }) {
  CATs[id] = arguments[0];
}
function adapt3(W1, W2, id = "Bradford") {
  let method = CATs[id];
  let [ρs, γs, βs] = multiplyMatrices(method.toCone_M, W1);
  let [ρd, γd, βd] = multiplyMatrices(method.toCone_M, W2);
  let scale2 = [
    [ρd / ρs, 0, 0],
    [0, γd / γs, 0],
    [0, 0, βd / βs]
  ];
  let scaled_cone_M = multiplyMatrices(scale2, method.toCone_M);
  let adapt_M = multiplyMatrices(method.fromCone_M, scaled_cone_M);
  return adapt_M;
}
defineCAT({
  id: "von Kries",
  toCone_M: [
    [0.40024, 0.7076, -0.08081],
    [-0.2263, 1.16532, 0.0457],
    [0, 0, 0.91822]
  ],
  fromCone_M: [
    [1.8599363874558397, -1.1293816185800916, 0.21989740959619328],
    [0.3611914362417676, 0.6388124632850422, -6370596838649899e-21],
    [0, 0, 1.0890636230968613]
  ]
});
defineCAT({
  id: "Bradford",
  // Convert an array of XYZ values in the range 0.0 - 1.0
  // to cone fundamentals
  toCone_M: [
    [0.8951, 0.2664, -0.1614],
    [-0.7502, 1.7135, 0.0367],
    [0.0389, -0.0685, 1.0296]
  ],
  // and back
  fromCone_M: [
    [0.9869929054667121, -0.14705425642099013, 0.15996265166373122],
    [0.4323052697233945, 0.5183602715367774, 0.049291228212855594],
    [-0.00852866457517732, 0.04004282165408486, 0.96848669578755]
  ]
});
defineCAT({
  id: "CAT02",
  // with complete chromatic adaptation to W2, so D = 1.0
  toCone_M: [
    [0.7328, 0.4296, -0.1624],
    [-0.7036, 1.6975, 61e-4],
    [3e-3, 0.0136, 0.9834]
  ],
  fromCone_M: [
    [1.0961238208355142, -0.27886900021828726, 0.18274517938277307],
    [0.4543690419753592, 0.4735331543074117, 0.07209780371722911],
    [-0.009627608738429355, -0.00569803121611342, 1.0153256399545427]
  ]
});
defineCAT({
  id: "CAT16",
  toCone_M: [
    [0.401288, 0.650173, -0.051461],
    [-0.250268, 1.204414, 0.045854],
    [-2079e-6, 0.048952, 0.953127]
  ],
  // the extra precision is needed to avoid roundtripping errors
  fromCone_M: [
    [1.862067855087233, -1.0112546305316845, 0.14918677544445172],
    [0.3875265432361372, 0.6214474419314753, -0.008973985167612521],
    [-0.01584149884933386, -0.03412293802851557, 1.0499644368778496]
  ]
});
Object.assign(WHITES, {
  // whitepoint values from ASTM E308-01 with 10nm spacing, 1931 2 degree observer
  // all normalized to Y (luminance) = 1.00000
  // Illuminant A is a tungsten electric light, giving a very warm, orange light.
  A: [1.0985, 1, 0.35585],
  // Illuminant C was an early approximation to daylight: illuminant A with a blue filter.
  C: [0.98074, 1, 1.18232],
  // The daylight series of illuminants simulate natural daylight.
  // The color temperature (in degrees Kelvin/100) ranges from
  // cool, overcast daylight (D50) to bright, direct sunlight (D65).
  D55: [0.95682, 1, 0.92149],
  D75: [0.94972, 1, 1.22638],
  // Equal-energy illuminant, used in two-stage CAT16
  E: [1, 1, 1],
  // The F series of illuminants represent fluorescent lights
  F2: [0.99186, 1, 0.67393],
  F7: [0.95041, 1, 1.08747],
  F11: [1.00962, 1, 0.6435]
});

// node_modules/colorjs.io/src/spaces/acescg.js
WHITES.ACES = [0.32168 / 0.33767, 1, (1 - 0.32168 - 0.33767) / 0.33767];
var toXYZ_M6 = [
  [0.6624541811085053, 0.13400420645643313, 0.1561876870049078],
  [0.27222871678091454, 0.6740817658111484, 0.05368951740793705],
  [-0.005574649490394108, 0.004060733528982826, 1.0103391003129971]
];
var fromXYZ_M6 = [
  [1.6410233796943257, -0.32480329418479, -0.23642469523761225],
  [-0.6636628587229829, 1.6153315916573379, 0.016756347685530137],
  [0.011721894328375376, -0.008284441996237409, 0.9883948585390215]
];
var acescg_default = new RGBColorSpace({
  id: "acescg",
  cssId: "--acescg",
  name: "ACEScg",
  // ACEScg – A scene-referred, linear-light encoding of ACES Data
  // https://docs.acescentral.com/specifications/acescg/
  // uses the AP1 primaries, see section 4.3.1 Color primaries
  coords: {
    r: {
      range: [0, 65504],
      name: "Red"
    },
    g: {
      range: [0, 65504],
      name: "Green"
    },
    b: {
      range: [0, 65504],
      name: "Blue"
    }
  },
  referred: "scene",
  white: WHITES.ACES,
  toXYZ_M: toXYZ_M6,
  fromXYZ_M: fromXYZ_M6
});

// node_modules/colorjs.io/src/spaces/acescc.js
var ε10 = 2 ** -16;
var ACES_min_nonzero = -0.35828683;
var ACES_cc_max = (Math.log2(65504) + 9.72) / 17.52;
var acescc_default = new RGBColorSpace({
  id: "acescc",
  cssId: "--acescc",
  name: "ACEScc",
  // see S-2014-003 ACEScc – A Logarithmic Encoding of ACES Data
  // https://docs.acescentral.com/specifications/acescc/
  // uses the AP1 primaries, see section 4.3.1 Color primaries
  // Appendix A: "Very small ACES scene referred values below 7 1/4 stops
  // below 18% middle gray are encoded as negative ACEScc values.
  // These values should be preserved per the encoding in Section 4.4
  // so that all positive ACES values are maintained."
  coords: {
    r: {
      range: [ACES_min_nonzero, ACES_cc_max],
      name: "Red"
    },
    g: {
      range: [ACES_min_nonzero, ACES_cc_max],
      name: "Green"
    },
    b: {
      range: [ACES_min_nonzero, ACES_cc_max],
      name: "Blue"
    }
  },
  referred: "scene",
  base: acescg_default,
  // from section 4.4.2 Decoding Function
  toBase(RGB2) {
    const low = (9.72 - 15) / 17.52;
    return RGB2.map(function(val2) {
      if (val2 <= low) {
        return (2 ** (val2 * 17.52 - 9.72) - ε10) * 2;
      } else if (val2 < ACES_cc_max) {
        return 2 ** (val2 * 17.52 - 9.72);
      } else {
        return 65504;
      }
    });
  },
  // Non-linear encoding function from S-2014-003, section 4.4.1 Encoding Function
  fromBase(RGB2) {
    return RGB2.map(function(val2) {
      if (val2 <= 0) {
        return (Math.log2(ε10) + 9.72) / 17.52;
      } else if (val2 < ε10) {
        return (Math.log2(ε10 + val2 * 0.5) + 9.72) / 17.52;
      } else {
        return (Math.log2(val2) + 9.72) / 17.52;
      }
    });
  }
  // encoded media white (rgb 1,1,1) => linear  [ 222.861, 222.861, 222.861 ]
  // encoded media black (rgb 0,0,0) => linear [ 0.0011857, 0.0011857, 0.0011857]
});

// node_modules/p5/dist/color/color_spaces/hsb.js
var HSBSpace = new ColorSpace({
  id: "hsb",
  name: "HSB",
  coords: {
    h: {
      refRange: [0, 360],
      type: "angle",
      name: "Hue"
    },
    s: {
      range: [0, 100],
      name: "Saturation"
    },
    b: {
      range: [0, 100],
      name: "Brightness"
    }
  },
  base: srgb_default,
  fromBase: (rgb) => {
    const val2 = Math.max(...rgb);
    const chroma = val2 - Math.min(...rgb);
    let [red, green, blue] = rgb;
    let hue, sat;
    if (chroma === 0) {
      hue = 0;
      sat = 0;
    } else {
      sat = chroma / val2;
      if (red === val2) {
        hue = (green - blue) / chroma;
      } else if (green === val2) {
        hue = 2 + (blue - red) / chroma;
      } else if (blue === val2) {
        hue = 4 + (red - green) / chroma;
      }
      if (hue < 0) {
        hue += 6;
      } else if (hue >= 6) {
        hue -= 6;
      }
    }
    return [hue / 6 * 360, sat * 100, val2 * 100];
  },
  toBase,
  formats: {
    default: {
      type: "custom",
      serialize: (coords, alpha) => {
        const rgb = toBase(coords);
        let ret = `rgb(${Math.round(rgb[0] * 100 * 100) / 100}% ${Math.round(rgb[1] * 100 * 100) / 100}% ${Math.round(rgb[2] * 100 * 100) / 100}%`;
        if (alpha < 1) {
          ret += ` / ${alpha}`;
        }
        ret += ")";
        return ret;
      }
    },
    "hsb": {
      coords: ["<number> | <angle>", "<percentage>", "<percentage>"]
    },
    "hsba": {
      coords: ["<number> | <angle>", "<percentage>", "<percentage>"],
      commans: true,
      lastAlpha: true
    }
  }
});
function toBase(hsb) {
  const hue = hsb[0] / 360 * 6;
  const sat = hsb[1] / 100;
  const val2 = hsb[2] / 100;
  let RGB2 = [];
  if (sat === 0) {
    RGB2 = [val2, val2, val2];
  } else {
    const sector = Math.floor(hue);
    const tint1 = val2 * (1 - sat);
    const tint2 = val2 * (1 - sat * (hue - sector));
    const tint3 = val2 * (1 - sat * (1 + sector - hue));
    let red, green, blue;
    if (sector === 1) {
      red = tint2;
      green = val2;
      blue = tint1;
    } else if (sector === 2) {
      red = tint1;
      green = val2;
      blue = tint3;
    } else if (sector === 3) {
      red = tint1;
      green = tint2;
      blue = val2;
    } else if (sector === 4) {
      red = tint3;
      green = tint1;
      blue = val2;
    } else if (sector === 5) {
      red = val2;
      green = tint1;
      blue = tint2;
    } else {
      red = val2;
      green = tint3;
      blue = tint1;
    }
    RGB2 = [red, green, blue];
  }
  return RGB2;
}

// node_modules/p5/dist/creating_reading-BdolPjuO.js
var map = (n3, start1, stop1, start2, stop2, clamp2) => {
  let result = (n3 - start1) / (stop1 - start1) * (stop2 - start2) + start2;
  if (clamp2) {
    result = Math.max(result, Math.min(start2, stop2));
    result = Math.min(result, Math.max(start2, stop2));
  }
  return result;
};
var serializationMap = {};
var _colorjsMaxes, _grayscaleMap, _Color_instances, toColorMode_fn;
var _Color = class _Color {
  constructor(vals, colorMode, colorMaxes, { clamp: clamp2 = false } = {}) {
    __privateAdd(this, _Color_instances);
    // Reference to underlying color object depending on implementation
    // Not meant to be used publicly unless the implementation is known for sure
    __publicField(this, "_color");
    // Color mode of the Color object, uses p5 color modes
    __publicField(this, "mode");
    this.mode = colorMode || RGB;
    if (vals instanceof _Color) {
      const mode = colorMode ? _Color.colorMap[colorMode] : _Color.colorMap[vals.mode];
      this._color = to(vals._color, mode);
      this.mode = mode;
    } else if (typeof vals === "object" && !Array.isArray(vals) && vals !== null) {
      const mode = colorMode ? _Color.colorMap[colorMode] : vals.spaceId;
      this._color = to(vals, mode);
      this.mode = colorMode || Object.entries(_Color.colorMap).find(([key, val2]) => {
        return val2 === this._color.spaceId;
      });
    } else if (typeof vals[0] === "string") {
      try {
        this._color = parse(vals[0]);
        const [mode] = Object.entries(_Color.colorMap).find(([key, val2]) => {
          return val2 === this._color.spaceId;
        });
        this.mode = mode;
        this._color = to(this._color, this._color.spaceId);
      } catch (err2) {
        throw new Error("Invalid color string");
      }
    } else {
      let mappedVals;
      if (colorMaxes) {
        if (vals.length === 4) {
          mappedVals = _Color.mapColorRange(vals, this.mode, colorMaxes, clamp2);
        } else if (vals.length === 3) {
          mappedVals = _Color.mapColorRange([vals[0], vals[1], vals[2]], this.mode, colorMaxes, clamp2);
          mappedVals.push(1);
        } else if (vals.length === 2) {
          if (__privateGet(_Color, _grayscaleMap)[this.mode]) {
            mappedVals = __privateGet(_Color, _grayscaleMap)[this.mode](vals[0], colorMaxes, clamp2);
          } else {
            mappedVals = _Color.mapColorRange([vals[0], vals[0], vals[0]], this.mode, colorMaxes, clamp2);
          }
          const alphaMaxes = Array.isArray(colorMaxes[colorMaxes.length - 1]) ? colorMaxes[colorMaxes.length - 1] : [0, colorMaxes[colorMaxes.length - 1]];
          mappedVals.push(
            map(
              vals[1],
              alphaMaxes[0],
              alphaMaxes[1],
              0,
              1,
              clamp2
            )
          );
        } else if (vals.length === 1) {
          if (__privateGet(_Color, _grayscaleMap)[this.mode]) {
            mappedVals = __privateGet(_Color, _grayscaleMap)[this.mode](vals[0], colorMaxes, clamp2);
          } else {
            mappedVals = _Color.mapColorRange([vals[0], vals[0], vals[0]], this.mode, colorMaxes, clamp2);
          }
          mappedVals.push(1);
        } else {
          throw new Error("Invalid color");
        }
      } else {
        mappedVals = vals;
      }
      const space = _Color.colorMap[this.mode] || console.error("Invalid color mode");
      const coords = mappedVals.slice(0, 3);
      const color3 = {
        space,
        coords,
        alpha: mappedVals[3]
      };
      this._color = to(color3, space);
    }
  }
  // Used to add additional color modes to p5.js
  // Uses underlying library's definition
  static addColorMode(mode, definition) {
    ColorSpace.register(definition);
    _Color.colorMap[mode] = definition.id;
    __privateGet(_Color, _colorjsMaxes)[mode] = Object.values(definition.coords).reduce((acc, v) => {
      acc.push(v.refRange || v.range);
      return acc;
    }, []);
    __privateGet(_Color, _colorjsMaxes)[mode].push([0, 1]);
    __privateGet(_Color, _grayscaleMap)[mode] = definition.fromGray;
  }
  // Convert from p5 color range to color.js color range
  static mapColorRange(origin, mode, maxes, clamp2) {
    const p5Maxes = maxes.map((max) => {
      if (!Array.isArray(max)) {
        return [0, max];
      } else {
        return max;
      }
    });
    const colorjsMaxes = __privateGet(_Color, _colorjsMaxes)[mode];
    return origin.map((channel, i) => {
      const newval = map(channel, p5Maxes[i][0], p5Maxes[i][1], colorjsMaxes[i][0], colorjsMaxes[i][1], clamp2);
      return newval;
    });
  }
  // Convert from color.js color range to p5 color range
  static unmapColorRange(origin, mode, maxes) {
    const p5Maxes = maxes.map((max) => {
      if (!Array.isArray(max)) {
        return [0, max];
      } else {
        return max;
      }
    });
    const colorjsMaxes = __privateGet(_Color, _colorjsMaxes)[mode];
    return origin.map((channel, i) => {
      const newval = map(channel, colorjsMaxes[i][0], colorjsMaxes[i][1], p5Maxes[i][0], p5Maxes[i][1]);
      return newval;
    });
  }
  // Get raw coordinates of underlying library, can differ between libraries
  get _array() {
    return this._getRGBA();
  }
  array() {
    return this._array;
  }
  lerp(color3, amt, mode) {
    let spaceIndex = -1;
    while ((spaceIndex + 1 < this._color.space.path.length || spaceIndex + 1 < color3._color.space.path.length) && this._color.space.path[spaceIndex + 1] === color3._color.space.path[spaceIndex + 1]) {
      spaceIndex += 1;
    }
    if (spaceIndex === -1) {
      throw new Error("Cannot lerp colors. No common color space found");
    }
    const obj = range(this._color, color3._color, {
      space: this._color.space.path[spaceIndex].id
    })(amt);
    return new _Color(obj, mode || this.mode);
  }
  /**
   * Returns the color formatted as a `String`.
   *
   * Calling `myColor.toString()` can be useful for debugging, as in
   * `print(myColor.toString())`. It's also helpful for using p5.js with other
   * libraries.
   *
   * The parameter, `format`, is optional. If a format string is passed, as in
   * `myColor.toString('#rrggbb')`, it will determine how the color string is
   * formatted. By default, color strings are formatted as `'rgba(r, g, b, a)'`.
   *
   * @param {String} [format] how the color string will be formatted.
   * Leaving this empty formats the string as rgba(r, g, b, a).
   * '#rgb' '#rgba' '#rrggbb' and '#rrggbbaa' format as hexadecimal color codes.
   * 'rgb' 'hsb' and 'hsl' return the color formatted in the specified color mode.
   * 'rgba' 'hsba' and 'hsla' are the same as above but with alpha channels.
   * 'rgb%' 'hsb%' 'hsl%' 'rgba%' 'hsba%' and 'hsla%' format as percentages.
   * @return {String} the formatted string.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object.
   *   let myColor = color('darkorchid');
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the text.
   *   text(myColor.toString('#rrggbb'), 50, 50);
   *
   *   describe('The text "#9932cc" written in purple on a gray background.');
   * }
   * </code>
   * </div>
   */
  toString(format) {
    const key = `${this._color.space.id}-${this._color.coords.join(",")}-${this._color.alpha}-${format}`;
    let colorString = serializationMap[key];
    if (!colorString) {
      colorString = serialize(this._color, {
        format
      });
      serializationMap[key] = colorString;
    }
    return colorString;
  }
  /**
   * Sets the red component of a color.
   *
   * The range depends on the <a href="#/p5/colorMode">colorMode()</a>. In the
   * default RGB mode it's between 0 and 255.
   *
   * @param {Number} red the new red value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object.
   *   let c = color(255, 128, 128);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 20, 35, 60);
   *
   *   // Change the red value.
   *   c.setRed(64);
   *
   *   // Draw the right rectangle.
   *   fill(c);
   *   rect(50, 20, 35, 60);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is teal.');
   * }
   * </code>
   * </div>
   */
  setRed(new_red, max = [0, 1]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    const colorjsMax = __privateGet(_Color, _colorjsMaxes)[RGB][0];
    const newval = map(new_red, max[0], max[1], colorjsMax[0], colorjsMax[1]);
    if (this.mode === RGB || this.mode === RGBHDR) {
      this._color.coords[0] = newval;
    } else {
      const space = this._color.space.id;
      const representation = to(this._color, "srgb");
      representation.coords[0] = newval;
      this._color = to(representation, space);
    }
  }
  /**
   * Sets the green component of a color.
   *
   * The range depends on the <a href="#/p5/colorMode">colorMode()</a>. In the
   * default RGB mode it's between 0 and 255.
   *
   * @param {Number} green the new green value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object.
   *   let c = color(255, 128, 128);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 20, 35, 60);
   *
   *   // Change the green value.
   *   c.setGreen(255);
   *
   *   // Draw the right rectangle.
   *   fill(c);
   *   rect(50, 20, 35, 60);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is yellow.');
   * }
   * </code>
   * </div>
   */
  setGreen(new_green, max = [0, 1]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    const colorjsMax = __privateGet(_Color, _colorjsMaxes)[RGB][1];
    const newval = map(new_green, max[0], max[1], colorjsMax[0], colorjsMax[1]);
    if (this.mode === RGB || this.mode === RGBHDR) {
      this._color.coords[1] = newval;
    } else {
      const space = this._color.space.id;
      const representation = to(this._color, "srgb");
      representation.coords[1] = newval;
      this._color = to(representation, space);
    }
  }
  /**
   * Sets the blue component of a color.
   *
   * The range depends on the <a href="#/p5/colorMode">colorMode()</a>. In the
   * default RGB mode it's between 0 and 255.
   *
   * @param {Number} blue the new blue value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object.
   *   let c = color(255, 128, 128);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 20, 35, 60);
   *
   *   // Change the blue value.
   *   c.setBlue(255);
   *
   *   // Draw the right rectangle.
   *   fill(c);
   *   rect(50, 20, 35, 60);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is pale fuchsia.');
   * }
   * </code>
   * </div>
   **/
  setBlue(new_blue, max = [0, 1]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    const colorjsMax = __privateGet(_Color, _colorjsMaxes)[RGB][2];
    const newval = map(new_blue, max[0], max[1], colorjsMax[0], colorjsMax[1]);
    if (this.mode === RGB || this.mode === RGBHDR) {
      this._color.coords[2] = newval;
    } else {
      const space = this._color.space.id;
      const representation = to(this._color, "srgb");
      representation.coords[2] = newval;
      this._color = to(representation, space);
    }
  }
  /**
   * Sets the alpha (transparency) value of a color.
   *
   * The range depends on the
   * <a href="#/p5/colorMode">colorMode()</a>. In the default RGB mode it's
   * between 0 and 255.
   *
   * @param {Number} alpha the new alpha value.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object.
   *   let c = color(255, 128, 128);
   *
   *   // Draw the left rectangle.
   *   noStroke();
   *   fill(c);
   *   rect(15, 20, 35, 60);
   *
   *   // Change the alpha value.
   *   c.setAlpha(128);
   *
   *   // Draw the right rectangle.
   *   fill(c);
   *   rect(50, 20, 35, 60);
   *
   *   describe('Two rectangles. The left one is salmon pink and the right one is faded pink.');
   * }
   * </code>
   * </div>
   */
  setAlpha(new_alpha, max = [0, 1]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    const colorjsMax = __privateGet(_Color, _colorjsMaxes)[this.mode][3];
    const newval = map(new_alpha, max[0], max[1], colorjsMax[0], colorjsMax[1]);
    this._color.alpha = newval;
  }
  _getRGBA(maxes = [1, 1, 1, 1]) {
    const colorjsMaxes = __privateGet(_Color, _colorjsMaxes)[RGB];
    let coords = structuredClone(to(this._color, "srgb").coords);
    coords.push(this._color.alpha);
    const rangeMaxes = maxes.map((v) => {
      if (!Array.isArray(v)) {
        return [0, v];
      } else {
        return v;
      }
    });
    coords = coords.map((coord, i) => {
      return map(coord, colorjsMaxes[i][0], colorjsMaxes[i][1], rangeMaxes[i][0], rangeMaxes[i][1]);
    });
    return coords;
  }
  _getMode() {
    return this.mode;
  }
  _getRed(max = [0, 1]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    if (this.mode === RGB || this.mode === RGBHDR) {
      const colorjsMax = __privateGet(_Color, _colorjsMaxes)[this.mode][0];
      return map(this._color.coords[0], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    } else {
      const colorjsMax = __privateGet(_Color, _colorjsMaxes)[RGB][0];
      return map(to(this._color, "srgb").coords[0], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    }
  }
  /**
   * This function extracts the green value from a color object and
   * returns it in the range 0–255 by default. When `colorMode()` is given to an
   * RBG value, the green value within the givin range is returned
   */
  _getGreen(max = [0, 1]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    if (this.mode === RGB || this.mode === RGBHDR) {
      const colorjsMax = __privateGet(_Color, _colorjsMaxes)[this.mode][1];
      return map(this._color.coords[1], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    } else {
      const colorjsMax = __privateGet(_Color, _colorjsMaxes)[RGB][1];
      return map(to(this._color, "srgb").coords[1], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    }
  }
  _getBlue(max = [0, 1]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    if (this.mode === RGB || this.mode === RGBHDR) {
      const colorjsMax = __privateGet(_Color, _colorjsMaxes)[this.mode][2];
      return map(this._color.coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    } else {
      const colorjsMax = __privateGet(_Color, _colorjsMaxes)[RGB][2];
      return map(to(this._color, "srgb").coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    }
  }
  _getAlpha(max = [0, 1]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    const colorjsMax = __privateGet(_Color, _colorjsMaxes)[this.mode][3];
    return map(this._color.alpha, colorjsMax[0], colorjsMax[1], max[0], max[1]);
  }
  /**
   * Hue is the same in HSB and HSL, but the maximum value may be different.
   * This function will return the HSB-normalized saturation when supplied with
   * an HSB color object, but will default to the HSL-normalized saturation
   * otherwise.
   */
  _getHue(max = [0, 360]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    if (this.mode === HSB || this.mode === HSL) {
      const colorjsMax = __privateGet(_Color, _colorjsMaxes)[this.mode][0];
      return map(this._color.coords[0], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    } else {
      const colorjsMax = __privateGet(_Color, _colorjsMaxes)[HSL][0];
      return map(to(this._color, "hsl").coords[0], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    }
  }
  /**
   * Saturation is scaled differently in HSB and HSL. This function will return
   * the HSB saturation when supplied with an HSB color object, but will default
   * to the HSL saturation otherwise.
   */
  _getSaturation(max = [0, 100]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    if (this.mode === HSB || this.mode === HSL) {
      const colorjsMax = __privateGet(_Color, _colorjsMaxes)[this.mode][1];
      return map(this._color.coords[1], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    } else {
      const colorjsMax = __privateGet(_Color, _colorjsMaxes)[HSL][1];
      return map(to(this._color, "hsl").coords[1], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    }
  }
  /**
   * Brightness obtains the HSB brightness value from either a p5.Color object,
   * an array of color components, or a CSS color string.Depending on value,
   * when `colorMode()` is set to HSB, this function will return the
   * brightness value in the range. By default, this function will return
   * the HSB brightness within the range 0 - 100.
   */
  _getBrightness(max = [0, 100]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    if (this.mode === HSB) {
      const colorjsMax = __privateGet(_Color, _colorjsMaxes)[this.mode][2];
      return map(this._color.coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    } else {
      const colorjsMax = __privateGet(_Color, _colorjsMaxes)[HSB][2];
      return map(to(this._color, "hsb").coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    }
  }
  _getLightness(max = [0, 100]) {
    if (!Array.isArray(max)) {
      max = [0, max];
    }
    if (this.mode === HSL) {
      const colorjsMax = __privateGet(_Color, _colorjsMaxes)[this.mode][2];
      return map(this._color.coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    } else {
      const colorjsMax = __privateGet(_Color, _colorjsMaxes)[HSL][2];
      return map(to(this._color, "hsl").coords[2], colorjsMax[0], colorjsMax[1], max[0], max[1]);
    }
  }
};
_colorjsMaxes = new WeakMap();
_grayscaleMap = new WeakMap();
_Color_instances = new WeakSet();
// Will do conversion in-Gamut as out of Gamut conversion is only really useful for futher conversions
toColorMode_fn = function(mode) {
  return new _Color(this._color, mode);
};
__publicField(_Color, "colorMap", {});
__privateAdd(_Color, _colorjsMaxes, {});
__privateAdd(_Color, _grayscaleMap, {});
var Color = _Color;
function color(p53, fn2, lifecycles) {
  p53.Color = Color;
  srgb_default.fromGray = p3_default.fromGray = function(val2, maxes, clamp2) {
    const p5Maxes = maxes.map((max) => {
      if (!Array.isArray(max)) {
        return [0, max];
      } else {
        return max;
      }
    });
    const v = map(val2, p5Maxes[2][0], p5Maxes[2][1], 0, 1, clamp2);
    return [v, v, v];
  };
  HSBSpace.fromGray = hsl_default.fromGray = function(val2, maxes, clamp2) {
    const p5Maxes = maxes.map((max) => {
      if (!Array.isArray(max)) {
        return [0, max];
      } else {
        return max;
      }
    });
    const v = map(val2, p5Maxes[2][0], p5Maxes[2][1], 0, 100, clamp2);
    return [0, 0, v];
  };
  hwb_default.fromGray = function(val2, maxes, clamp2) {
    const p5Maxes = maxes.map((max) => {
      if (!Array.isArray(max)) {
        return [0, max];
      } else {
        return max;
      }
    });
    const wbMax = Math.abs(p5Maxes[1][0] - p5Maxes[1][1]) / 2 + Math.abs(p5Maxes[2][0] - p5Maxes[2][1]) / 2;
    const nVal = map(val2, 0, wbMax, 0, 100);
    let white6, black;
    if (nVal < 50) {
      black = nVal;
      white6 = 100 - nVal;
    } else if (nVal >= 50) {
      white6 = nVal;
      black = 100 - nVal;
    }
    return [0, white6, black];
  };
  lab_default.fromGray = lch_default.fromGray = oklab_default.fromGray = oklch_default.fromGray = function(val2, maxes, clamp2) {
    const p5Maxes = maxes.map((max) => {
      if (!Array.isArray(max)) {
        return [0, max];
      } else {
        return max;
      }
    });
    const v = map(val2, p5Maxes[0][0], p5Maxes[0][1], 0, 100, clamp2);
    return [v, 0, 0];
  };
  p53.Color.addColorMode(RGB, srgb_default);
  p53.Color.addColorMode(RGBHDR, p3_default);
  p53.Color.addColorMode(HSB, HSBSpace);
  p53.Color.addColorMode(HSL, hsl_default);
  p53.Color.addColorMode(HWB, hwb_default);
  p53.Color.addColorMode(LAB, lab_default);
  p53.Color.addColorMode(LCH, lch_default);
  p53.Color.addColorMode(OKLAB, oklab_default);
  p53.Color.addColorMode(OKLCH, oklch_default);
  lifecycles.presetup = function() {
    const pInst = this;
    const setMethods = ["Red", "Green", "Blue", "Alpha"];
    for (let i in setMethods) {
      const method = setMethods[i];
      const setCopy = p53.Color.prototype["set" + method];
      p53.Color.prototype["set" + method] = function(newval, max) {
        var _a2, _b2, _c2;
        max = max || ((_c2 = (_b2 = (_a2 = pInst == null ? void 0 : pInst._renderer) == null ? void 0 : _a2.states) == null ? void 0 : _b2.colorMaxes) == null ? void 0 : _c2[RGB][i]);
        return setCopy.call(this, newval, max);
      };
    }
    function decorateGet(channel, modes) {
      const getCopy = p53.Color.prototype["_get" + channel];
      p53.Color.prototype["_get" + channel] = function(max) {
        var _a2, _b2, _c2, _d, _e, _f;
        if (Object.keys(modes).includes(this.mode)) {
          max = max || ((_c2 = (_b2 = (_a2 = pInst == null ? void 0 : pInst._renderer) == null ? void 0 : _a2.states) == null ? void 0 : _b2.colorMaxes) == null ? void 0 : _c2[this.mode][modes[this.mode]]);
        } else {
          const defaultMode = Object.keys(modes)[0];
          max = max || ((_f = (_e = (_d = pInst == null ? void 0 : pInst._renderer) == null ? void 0 : _d.states) == null ? void 0 : _e.colorMaxes) == null ? void 0 : _f[defaultMode][modes[defaultMode]]);
        }
        return getCopy.call(this, max);
      };
    }
    decorateGet("Red", {
      [RGB]: 0,
      [RGBHDR]: 0
    });
    decorateGet("Green", {
      [RGB]: 1,
      [RGBHDR]: 1
    });
    decorateGet("Blue", {
      [RGB]: 2,
      [RGBHDR]: 2
    });
    decorateGet("Alpha", {
      [RGB]: 3,
      [RGBHDR]: 3,
      [HSB]: 3,
      [HSL]: 3,
      [HWB]: 3,
      [LAB]: 3,
      [LCH]: 3,
      [OKLAB]: 3,
      [OKLCH]: 3
    });
    decorateGet("Hue", {
      [HSL]: 0,
      [HSB]: 0,
      [HWB]: 0,
      [LCH]: 2,
      [OKLCH]: 2
    });
    decorateGet("Saturation", {
      [HSL]: 1,
      [HSB]: 1
    });
    decorateGet("Brightness", {
      [HSB]: 2
    });
    decorateGet("Lightness", {
      [HSL]: 2
    });
  };
}
if (typeof p5 !== "undefined") {
  color(p5, p5.prototype);
}
var RGB = "rgb";
var RGBHDR = "rgbhdr";
var HSB = "hsb";
var HSL = "hsl";
var HWB = "hwb";
var LAB = "lab";
var LCH = "lch";
var OKLAB = "oklab";
var OKLCH = "oklch";
var RGBA = "rgba";
function creatingReading(p53, fn2) {
  fn2.RGB = RGB;
  fn2.RGBHDR = RGBHDR;
  fn2.HSB = HSB;
  fn2.HSL = HSL;
  fn2.HWB = HWB;
  fn2.LAB = LAB;
  fn2.LCH = LCH;
  fn2.OKLAB = OKLAB;
  fn2.OKLCH = OKLCH;
  fn2.RGBA = RGBA;
  p53.Renderer.states.colorMode = RGB;
  p53.Renderer.states.colorMaxes = {
    [RGB]: [255, 255, 255, 255],
    [RGBHDR]: [255, 255, 255, 255],
    [HSB]: [360, 100, 100, 1],
    [HSL]: [360, 100, 100, 1],
    [HWB]: [360, 100, 100, 1],
    [LAB]: [100, [-125, 125], [-125, 125], 1],
    [LCH]: [100, 150, 360, 1],
    [OKLAB]: [100, [-125, 125], [-125, 125], 1],
    [OKLCH]: [100, 150, 360, 1],
    clone: function() {
      const cloned = { ...this };
      for (const key in cloned) {
        if (cloned[key] instanceof Array) {
          cloned[key] = [...cloned[key]];
        }
      }
      return cloned;
    }
  };
  fn2.color = function(...args) {
    if (args[0] instanceof Color) {
      return args[0];
    }
    const arg = Array.isArray(args[0]) ? args[0] : args;
    return new Color(
      arg,
      this._renderer.states.colorMode,
      this._renderer.states.colorMaxes[this._renderer.states.colorMode],
      { clamp: true }
    );
  };
  fn2.red = function(c4) {
    return this.color(c4)._getRed();
  };
  fn2.green = function(c4) {
    return this.color(c4)._getGreen();
  };
  fn2.blue = function(c4) {
    return this.color(c4)._getBlue();
  };
  fn2.alpha = function(c4) {
    return this.color(c4)._getAlpha();
  };
  fn2.hue = function(c4) {
    return this.color(c4)._getHue();
  };
  fn2.saturation = function(c4) {
    return this.color(c4)._getSaturation();
  };
  fn2.brightness = function(c4) {
    return this.color(c4)._getBrightness();
  };
  fn2.lightness = function(c4) {
    return this.color(c4)._getLightness();
  };
  fn2.lerpColor = function(c14, c24, amt) {
    return c14.lerp(c24, amt, this._renderer.states.colorMode);
  };
  fn2.paletteLerp = function(color_stops, amt) {
    const first_color_stop = color_stops[0];
    if (amt < first_color_stop[1])
      return this.color(first_color_stop[0]);
    for (let i = 1; i < color_stops.length; i++) {
      const color_stop = color_stops[i];
      if (amt < color_stop[1]) {
        const prev_color_stop = color_stops[i - 1];
        return this.lerpColor(
          this.color(prev_color_stop[0]),
          this.color(color_stop[0]),
          (amt - prev_color_stop[1]) / (color_stop[1] - prev_color_stop[1])
        );
      }
    }
    return this.color(color_stops[color_stops.length - 1][0]);
  };
}
if (typeof p5 !== "undefined") {
  creatingReading(p5, p5.prototype);
}

// node_modules/p5/dist/io/p5.XML.js
var XML = class _XML {
  constructor(DOM) {
    if (!DOM) {
      const xmlDoc = document.implementation.createDocument(null, "doc");
      this.DOM = xmlDoc.createElement("root");
    } else {
      this.DOM = DOM;
    }
  }
  /**
   * Returns the element's parent element as a new <a href="#/p5.XML">p5.XML</a>
   * object.
   *
   * @return {p5.XML} parent element.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get an array with all mammal elements.
   *   let mammals = myXML.getChildren('mammal');
   *
   *   // Get the first mammal element.
   *   let firstMammal = mammals[0];
   *
   *   // Get the parent element.
   *   let parent = firstMammal.getParent();
   *
   *   // Get the parent element's name.
   *   let name = parent.getName();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the parent element's name.
   *   text(name, 50, 50);
   *
   *   describe('The word "animals" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */
  getParent() {
    return new _XML(this.DOM.parentElement);
  }
  /**
   * Returns the element's name as a `String`.
   *
   * An XML element's name is given by its tag. For example, the element
   * `&lt;language&gt;JavaScript&lt;/language&gt;` has the name `language`.
   *
   * @return {String} name of the element.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get an array with all mammal elements.
   *   let mammals = myXML.getChildren('mammal');
   *
   *   // Get the first mammal element.
   *   let firstMammal = mammals[0];
   *
   *   // Get the mammal element's name.
   *   let name = firstMammal.getName();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the element's name.
   *   text(name, 50, 50);
   *
   *   describe('The word "mammal" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */
  getName() {
    return this.DOM.tagName;
  }
  /**
   * Sets the element's tag name.
   *
   * An XML element's name is given by its tag. For example, the element
   * `&lt;language&gt;JavaScript&lt;/language&gt;` has the name `language`.
   *
   * The parameter, `name`, is the element's new name as a string. For example,
   * calling `myXML.setName('planet')` will make the element's new tag name
   * `&lt;planet&gt;&lt;/planet&gt;`.
   *
   * @param {String} name new tag name of the element.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the element's original name.
   *   let oldName = myXML.getName();
   *
   *   // Set the element's name.
   *   myXML.setName('monsters');
   *
   *   // Get the element's new name.
   *   let newName = myXML.getName();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the element's names.
   *   text(oldName, 50, 33);
   *   text(newName, 50, 67);
   *
   *   describe(
   *     'The words "animals" and "monsters" written on separate lines. The text is black on a gray background.'
   *   );
   * }
   * </code></div>
   */
  setName(name) {
    const content = this.DOM.innerHTML;
    const attributes2 = this.DOM.attributes;
    const xmlDoc = document.implementation.createDocument(null, "default");
    const newDOM = xmlDoc.createElement(name);
    newDOM.innerHTML = content;
    for (let i = 0; i < attributes2.length; i++) {
      newDOM.setAttribute(attributes2[i].nodeName, attributes2[i].nodeValue);
    }
    this.DOM = newDOM;
  }
  /**
   * Returns `true` if the element has child elements and `false` if not.
   *
   * @return {boolean} whether the element has children.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Check whether the element has child elements.
   *   let isParent = myXML.hasChildren();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Style the text.
   *   if (isParent === true) {
   *     text('Parent', 50, 50);
   *   } else {
   *     text('Not Parent', 50, 50);
   *   }
   *
   *   describe('The word "Parent" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */
  hasChildren() {
    return this.DOM.children.length > 0;
  }
  /**
   * Returns an array with the names of the element's child elements as
   * `String`s.
   *
   * @return {String[]} names of the child elements.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the names of the element's children as an array.
   *   let children = myXML.listChildren();
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Iterate over the array.
   *   for (let i = 0; i < children.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 25;
   *
   *     // Display the child element's name.
   *     text(children[i], 10, y);
   *   }
   *
   *   describe(
   *     'The words "mammal", "mammal", "mammal", and "reptile" written on separate lines. The text is black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   */
  listChildren() {
    const arr2 = [];
    for (let i = 0; i < this.DOM.childNodes.length; i++) {
      arr2.push(this.DOM.childNodes[i].nodeName);
    }
    return arr2;
  }
  /**
   * Returns an array with the element's child elements as new
   * <a href="#/p5.XML">p5.XML</a> objects.
   *
   * The parameter, `name`, is optional. If a string is passed, as in
   * `myXML.getChildren('cat')`, then the method will only return child elements
   * with the tag `&lt;cat&gt;`.
   *
   * @param {String} [name] name of the elements to return.
   * @return {p5.XML[]} child elements.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get an array of the child elements.
   *   let children = myXML.getChildren();
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Iterate over the array.
   *   for (let i = 0; i < children.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 20;
   *
   *     // Get the child element's content.
   *     let content = children[i].getContent();
   *
   *     // Display the child element's content.
   *     text(content, 10, y);
   *   }
   *
   *   describe(
   *     'The words "Goat", "Leopard", "Zebra", and "Turtle" written on separate lines. The text is black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get an array of the child elements
   *   // that are mammals.
   *   let children = myXML.getChildren('mammal');
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Iterate over the array.
   *   for (let i = 0; i < children.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 20;
   *
   *     // Get the child element's content.
   *     let content = children[i].getContent();
   *
   *     // Display the child element's content.
   *     text(content, 10, y);
   *   }
   *
   *   describe(
   *     'The words "Goat", "Leopard", and "Zebra" written on separate lines. The text is black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   */
  getChildren(param) {
    if (param) {
      return elementsToP5XML(this.DOM.getElementsByTagName(param));
    } else {
      return elementsToP5XML(this.DOM.children);
    }
  }
  /**
   * Returns the first matching child element as a new
   * <a href="#/p5.XML">p5.XML</a> object.
   *
   * The parameter, `name`, is optional. If a string is passed, as in
   * `myXML.getChild('cat')`, then the first child element with the tag
   * `&lt;cat&gt;` will be returned. If a number is passed, as in
   * `myXML.getChild(1)`, then the child element at that index will be returned.
   *
   * @param {String|Integer} name element name or index.
   * @return {p5.XML} child element.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first child element that is a mammal.
   *   let goat = myXML.getChild('mammal');
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Get the child element's content.
   *   let content = goat.getContent();
   *
   *   // Display the child element's content.
   *   text(content, 50, 50);
   *
   *   describe('The word "Goat" written in black on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the child element at index 1.
   *   let leopard = myXML.getChild(1);
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Get the child element's content.
   *   let content = leopard.getContent();
   *
   *   // Display the child element's content.
   *   text(content, 50, 50);
   *
   *   describe('The word "Leopard" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */
  getChild(param) {
    if (typeof param === "string") {
      for (const child of this.DOM.children) {
        if (child.tagName === param) return new _XML(child);
      }
    } else {
      return new _XML(this.DOM.children[param]);
    }
  }
  /**
   * Adds a new child element and returns a reference to it.
   *
   * The parameter, `child`, is the <a href="#/p5.XML">p5.XML</a> object to add
   * as a child element. For example, calling `myXML.addChild(otherXML)` inserts
   * `otherXML` as a child element of `myXML`.
   *
   * @param {p5.XML} child child element to add.
   * @return {p5.XML} added child element.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a new p5.XML object.
   *   let newAnimal = new p5.XML();
   *
   *   // Set its properties.
   *   newAnimal.setName('hydrozoa');
   *   newAnimal.setAttribute('id', 4);
   *   newAnimal.setAttribute('species', 'Physalia physalis');
   *   newAnimal.setContent('Bluebottle');
   *
   *   // Add the child element.
   *   myXML.addChild(newAnimal);
   *
   *   // Get the first child element that is a hydrozoa.
   *   let blueBottle = myXML.getChild('hydrozoa');
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Get the child element's content.
   *   let content = blueBottle.getContent();
   *
   *   // Display the child element's content.
   *   text(content, 50, 50);
   *
   *   describe('The word "Bluebottle" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */
  addChild(node) {
    if (node instanceof _XML) {
      this.DOM.appendChild(node.DOM);
    }
  }
  /**
   * Removes the first matching child element.
   *
   * The parameter, `name`, is the child element to remove. If a string is
   * passed, as in `myXML.removeChild('cat')`, then the first child element
   * with the tag `&lt;cat&gt;` will be removed. If a number is passed, as in
   * `myXML.removeChild(1)`, then the child element at that index will be
   * removed.
   *
   * @param {String|Integer} name name or index of the child element to remove.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Remove the first mammal element.
   *   myXML.removeChild('mammal');
   *
   *   // Get an array of child elements.
   *   let children = myXML.getChildren();
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Iterate over the array.
   *   for (let i = 0; i < children.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 25;
   *
   *     // Get the child element's content.
   *     let content = children[i].getContent();
   *
   *     // Display the child element's content.
   *     text(content, 10, y);
   *   }
   *
   *   describe(
   *     'The words "Leopard", "Zebra", and "Turtle" written on separate lines. The text is black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Remove the element at index 2.
   *   myXML.removeChild(2);
   *
   *   // Get an array of child elements.
   *   let children = myXML.getChildren();
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Iterate over the array.
   *   for (let i = 0; i < children.length; i += 1) {
   *
   *     // Calculate the y-coordinate.
   *     let y = (i + 1) * 25;
   *
   *     // Get the child element's content.
   *     let content = children[i].getContent();
   *
   *     // Display the child element's content.
   *     text(content, 10, y);
   *   }
   *
   *   describe(
   *     'The words "Goat", "Leopard", and "Turtle" written on separate lines. The text is black on a gray background.'
   *   );
   * }
   * </code>
   * </div>
   */
  removeChild(param) {
    let ind = -1;
    if (typeof param === "string") {
      for (let i = 0; i < this.DOM.children.length; i++) {
        if (this.DOM.children[i].tagName === param) {
          ind = i;
          break;
        }
      }
    } else {
      ind = param;
    }
    if (ind !== -1) {
      this.DOM.removeChild(this.DOM.children[ind]);
    }
  }
  /**
   * Returns the number of attributes the element has.
   *
   * @return {Integer} number of attributes.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first child element.
   *   let first = myXML.getChild(0);
   *
   *   // Get the number of attributes.
   *   let numAttributes = first.getAttributeCount();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the number of attributes.
   *   text(numAttributes, 50, 50);
   *
   *   describe('The number "2" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */
  getAttributeCount() {
    return this.DOM.attributes.length;
  }
  /**
   * Returns an `Array` with the names of the element's attributes.
   *
   * Note: Use
   * <a href="#/p5.XML/getString">myXML.getString()</a> or
   * <a href="#/p5.XML/getNum">myXML.getNum()</a> to return an attribute's value.
   *
   * @return {String[]} attribute names.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first child element.
   *   let first = myXML.getChild(0);
   *
   *   // Get the number of attributes.
   *   let attributes = first.listAttributes();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the element's attributes.
   *   text(attributes, 50, 50);
   *
   *   describe('The text "id,species" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */
  listAttributes() {
    const arr2 = [];
    for (const attribute of this.DOM.attributes) {
      arr2.push(attribute.nodeName);
    }
    return arr2;
  }
  /**
   * Returns `true` if the element has a given attribute and `false` if not.
   *
   * The parameter, `name`, is a string with the name of the attribute being
   * checked.
   *
   * Note: Use
   * <a href="#/p5.XML/getString">myXML.getString()</a> or
   * <a href="#/p5.XML/getNum">myXML.getNum()</a> to return an attribute's value.
   *
   * @param {String} name name of the attribute to be checked.
   * @return {boolean} whether the element has the attribute.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first mammal child element.
   *   let mammal = myXML.getChild('mammal');
   *
   *   // Check whether the element has an
   *   // species attribute.
   *   let hasSpecies = mammal.hasAttribute('species');
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display whether the element has a species attribute.
   *   if (hasSpecies === true) {
   *     text('Species', 50, 50);
   *   } else {
   *     text('No species', 50, 50);
   *   }
   *
   *   describe('The text "Species" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */
  hasAttribute(name) {
    const obj = {};
    for (const attribute of this.DOM.attributes) {
      obj[attribute.nodeName] = attribute.nodeValue;
    }
    return obj[name] ? true : false;
  }
  /**
   * Return an attribute's value as a `Number`.
   *
   * The first parameter, `name`, is a string with the name of the attribute
   * being checked. For example, calling `myXML.getNum('id')` returns the
   * element's `id` attribute as a number.
   *
   * The second parameter, `defaultValue`, is optional. If a number is passed,
   * as in `myXML.getNum('id', -1)`, it will be returned if the attribute
   * doesn't exist or can't be converted to a number.
   *
   * Note: Use
   * <a href="#/p5.XML/getString">myXML.getString()</a> or
   * <a href="#/p5.XML/getNum">myXML.getNum()</a> to return an attribute's value.
   *
   * @param {String} name name of the attribute to be checked.
   * @param {Number} [defaultValue] value to return if the attribute doesn't exist.
   * @return {Number} attribute value as a number.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first reptile child element.
   *   let reptile = myXML.getChild('reptile');
   *
   *   // Get the reptile's content.
   *   let content = reptile.getContent();
   *
   *   // Get the reptile's ID.
   *   let id = reptile.getNum('id');
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the ID attribute.
   *   text(`${content} is ${id + 1}th`, 5, 50, 90);
   *
   *   describe(`The text "${content} is ${id + 1}th" written in black on a gray background.`);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first reptile child element.
   *   let reptile = myXML.getChild('reptile');
   *
   *   // Get the reptile's content.
   *   let content = reptile.getContent();
   *
   *   // Get the reptile's size.
   *   let weight = reptile.getNum('weight', 135);
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the ID attribute.
   *   text(`${content} is ${weight}kg`, 5, 50, 90);
   *
   *   describe(
   *     `The text "${content} is ${weight}kg" written in black on a gray background.`
   *   );
   * }
   * </code>
   * </div>
   */
  getNum(name, defaultValue) {
    const obj = {};
    for (const attribute of this.DOM.attributes) {
      obj[attribute.nodeName] = attribute.nodeValue;
    }
    return Number(obj[name]) || defaultValue || 0;
  }
  /**
   * Return an attribute's value as a string.
   *
   * The first parameter, `name`, is a string with the name of the attribute
   * being checked. For example, calling `myXML.getString('color')` returns the
   * element's `id` attribute as a string.
   *
   * The second parameter, `defaultValue`, is optional. If a string is passed,
   * as in `myXML.getString('color', 'deeppink')`, it will be returned if the
   * attribute doesn't exist.
   *
   * Note: Use
   * <a href="#/p5.XML/getString">myXML.getString()</a> or
   * <a href="#/p5.XML/getNum">myXML.getNum()</a> to return an attribute's value.
   *
   * @param {String} name name of the attribute to be checked.
   * @param {Number} [defaultValue] value to return if the attribute doesn't exist.
   * @return {String} attribute value as a string.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first reptile child element.
   *   let reptile = myXML.getChild('reptile');
   *
   *   // Get the reptile's content.
   *   let content = reptile.getContent();
   *
   *   // Get the reptile's species.
   *   let species = reptile.getString('species');
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the species attribute.
   *   text(`${content}: ${species}`, 5, 50, 90);
   *
   *   describe(`The text "${content}: ${species}" written in black on a gray background.`);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first reptile child element.
   *   let reptile = myXML.getChild('reptile');
   *
   *   // Get the reptile's content.
   *   let content = reptile.getContent();
   *
   *   // Get the reptile's color.
   *   let attribute = reptile.getString('color', 'green');
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *   fill(attribute);
   *
   *   // Display the element's content.
   *   text(content, 50, 50);
   *
   *   describe(`The text "${content}" written in green on a gray background.`);
   * }
   * </code>
   * </div>
   */
  getString(name, defaultValue) {
    const obj = {};
    for (const attribute of this.DOM.attributes) {
      obj[attribute.nodeName] = attribute.nodeValue;
    }
    return obj[name] ? String(obj[name]) : defaultValue || null;
  }
  /**
   * Sets an attribute to a given value.
   *
   * The first parameter, `name`, is a string with the name of the attribute
   * being set.
   *
   * The second parameter, `value`, is the attribute's new value. For example,
   * calling `myXML.setAttribute('id', 123)` sets the `id` attribute to the
   * value 123.
   *
   * @param {String} name name of the attribute to be set.
   * @param {Number|String|Boolean} value attribute's new value.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first reptile child element.
   *   let reptile = myXML.getChild('reptile');
   *
   *   // Set the reptile's color.
   *   reptile.setAttribute('color', 'green');
   *
   *   // Get the reptile's content.
   *   let content = reptile.getContent();
   *
   *   // Get the reptile's color.
   *   let attribute = reptile.getString('color');
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the element's content.
   *   text(`${content} is ${attribute}`, 5, 50, 90);
   *
   *   describe(
   *     `The text "${content} is ${attribute}" written in green on a gray background.`
   *   );
   * }
   * </code>
   * </div>
   */
  setAttribute(name, value) {
    this.DOM.setAttribute(name, value);
  }
  /**
   * Returns the element's content as a `String`.
   *
   * The parameter, `defaultValue`, is optional. If a string is passed, as in
   * `myXML.getContent('???')`, it will be returned if the element has no
   * content.
   *
   * @param {String} [defaultValue] value to return if the element has no
   *                                content.
   * @return {String} element's content as a string.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first reptile child element.
   *   let reptile = myXML.getChild('reptile');
   *
   *   // Get the reptile's content.
   *   let content = reptile.getContent();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the element's content.
   *   text(content, 5, 50, 90);
   *
   *   describe(`The text "${content}" written in green on a gray background.`);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.XML object.
   *   let blankSpace = new p5.XML();
   *
   *   // Get the element's content and use a default value.
   *   let content = blankSpace.getContent('Your name');
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the element's content.
   *   text(content, 5, 50, 90);
   *
   *   describe(`The text "${content}" written in green on a gray background.`);
   * }
   * </code>
   * </div>
   */
  getContent(defaultValue) {
    let str;
    str = this.DOM.textContent;
    str = str.replace(/\s\s+/g, ",");
    return str || defaultValue || null;
  }
  /**
   * Sets the element's content.
   *
   * An element's content is the text between its tags. For example, the element
   * `&lt;language&gt;JavaScript&lt;/language&gt;` has the content `JavaScript`.
   *
   * The parameter, `content`, is a string with the element's new content.
   *
   * @method setContent
   * @param {String} content new content for the element.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Get the first reptile child element.
   *   let reptile = myXML.getChild('reptile');
   *
   *   // Get the reptile's original content.
   *   let oldContent = reptile.getContent();
   *
   *   // Set the reptile's content.
   *   reptile.setContent('Loggerhead');
   *
   *   // Get the reptile's new content.
   *   let newContent = reptile.getContent();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont('Courier New');
   *   textSize(14);
   *
   *   // Display the element's old and new content.
   *   text(`${oldContent}: ${newContent}`, 5, 50, 90);
   *
   *   describe(
   *     `The text "${oldContent}: ${newContent}" written in green on a gray background.`
   *   );
   * }
   * </code>
   * </div>
   */
  setContent(content) {
    if (!this.DOM.children.length) {
      this.DOM.textContent = content;
    }
  }
  /**
   * Returns the element as a `String`.
   *
   * `myXML.serialize()` is useful for sending the element over the network or
   * saving it to a file.
   *
   * @return {String} element as a string.
   *
   * @example
   * <div>
   * <code>
   * let myXML;
   *
   * async function setup() {
   *   // Load the XML and create a p5.XML object.
   *   myXML = await loadXML('assets/animals.xml');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(LEFT, CENTER);
   *   textFont('Courier New');
   *   textSize(12);
   *
   *   // Display instructions.
   *   text('Double-click to save', 5, 50, 90);
   *
   *   describe('The text "Double-click to save" written in black on a gray background.');
   * }
   *
   * // Save the file when the user double-clicks.
   * function doubleClicked() {
   *   // Create a p5.PrintWriter object.
   *   // Use the file format .xml.
   *   let myWriter = createWriter('animals', 'xml');
   *
   *   // Serialize the XML data to a string.
   *   let data = myXML.serialize();
   *
   *   // Write the data to the print stream.
   *   myWriter.write(data);
   *
   *   // Save the file and close the print stream.
   *   myWriter.close();
   * }
   * </code>
   * </div>
   */
  serialize() {
    const xmlSerializer = new XMLSerializer();
    return xmlSerializer.serializeToString(this.DOM);
  }
};
function elementsToP5XML(elements) {
  const arr2 = [];
  for (let i = 0; i < elements.length; i++) {
    arr2.push(new XML(elements[i]));
  }
  return arr2;
}
function xml(p53, fn2) {
  p53.XML = XML;
}
if (typeof p5 !== "undefined") {
  xml(p5, p5.prototype);
}

// node_modules/p5/dist/dom/p5.File.js
var File2 = class _File {
  constructor(file3, pInst) {
    this.file = file3;
    this._pInst = pInst;
    const typeList = file3.type.split("/");
    this.type = typeList[0];
    this.subtype = typeList[1];
    this.name = file3.name;
    this.size = file3.size;
    this.data = void 0;
  }
  static _createLoader(theFile, callback) {
    const reader = new FileReader();
    reader.onload = function(e2) {
      const p5file = new _File(theFile);
      if (p5file.file.type === "application/json") {
        p5file.data = JSON.parse(e2.target.result);
      } else if (p5file.file.type === "text/xml") {
        const parser = new DOMParser();
        const xml2 = parser.parseFromString(e2.target.result, "text/xml");
        p5file.data = new XML(xml2.documentElement);
      } else {
        p5file.data = e2.target.result;
      }
      callback(p5file);
    };
    return reader;
  }
  static _load(f, callback) {
    if (/^text\//.test(f.type) || f.type === "application/json") {
      _File._createLoader(f, callback).readAsText(f);
    } else if (!/^(video|audio)\//.test(f.type)) {
      _File._createLoader(f, callback).readAsDataURL(f);
    } else {
      const file3 = new _File(f);
      file3.data = URL.createObjectURL(f);
      callback(file3);
    }
  }
};
function file(p53, fn2) {
  p53.File = File2;
}
if (typeof p5 !== "undefined") {
  file(p5, p5.prototype);
}

// node_modules/p5/dist/dom/p5.Element.js
var Element = class _Element {
  constructor(elt, pInst) {
    __publicField(this, "width");
    __publicField(this, "height");
    __publicField(this, "elt");
    this.elt = elt;
    this._pInst = this._pixelsState = pInst;
    this._events = {};
    this.width = this.elt.offsetWidth;
    this.height = this.elt.offsetHeight;
  }
  /**
   * Removes the element, stops all audio/video streams, and removes all
   * callback functions.
   *
   * @example
   * <div>
   * <code>
   * let p;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a paragraph element.
   *   p = createP('p5*js');
   *   p.position(10, 10);
   *
   *   describe('The text "p5*js" written at the center of a gray square. ');
   * }
   *
   * // Remove the paragraph when the user double-clicks.
   * function doubleClicked() {
   *   p.remove();
   * }
   * </code>
   * </div>
   */
  remove() {
    if (this.stop) {
      this.stop();
      const sources = this.elt.srcObject;
      if (sources !== null) {
        const tracks = sources.getTracks();
        tracks.forEach((track) => {
          track.stop();
        });
      }
    }
    let sketch = this._pInst;
    if (sketch && !sketch._elements && sketch._pInst) {
      sketch = sketch._pInst;
    }
    if (sketch && sketch._elements) {
      const i = sketch._elements.indexOf(this);
      if (i !== -1) sketch._elements.splice(i, 1);
    }
    for (let ev in this._events) {
      this.elt.removeEventListener(ev, this._events[ev]);
    }
    if (this.elt && this.elt.parentNode) {
      this.elt.parentNode.removeChild(this.elt);
    }
  }
  /**
   * Attaches the element to a parent element.
   *
   * For example, a `&lt;div&gt;&lt;/div&gt;` element may be used as a box to
   * hold two pieces of text, a header and a paragraph. The
   * `&lt;div&gt;&lt;/div&gt;` is the parent element of both the header and
   * paragraph.
   *
   * The parameter `parent` can have one of three types. `parent` can be a
   * string with the parent element's ID, as in
   * `myElement.parent('container')`. It can also be another
   * <a href="#/p5.Element">p5.Element</a> object, as in
   * `myElement.parent(myDiv)`. Finally, `parent` can be an `HTMLElement`
   * object, as in `myElement.parent(anotherElement)`.
   *
   * Calling `myElement.parent()` without an argument returns the element's
   * parent.
   *
   * @param  {String|p5.Element|Object} parent ID, <a href="#/p5.Element">p5.Element</a>,
   *                                           or HTMLElement of desired parent element.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup()  {
   *   background(200);
   *
   *   // Create a div element.
   *   let div = createDiv();
   *
   *   // Place the div in the top-left corner.
   *   div.position(10, 20);
   *
   *   // Set its width and height.
   *   div.size(80, 60);
   *
   *   // Set its background color to white
   *   div.style('background-color', 'white');
   *
   *   // Align any text to the center.
   *   div.style('text-align', 'center');
   *
   *   // Set its ID to "container".
   *   div.id('container');
   *
   *   // Create a paragraph element.
   *   let p = createP('p5*js');
   *
   *   // Make the div its parent
   *   // using its ID "container".
   *   p.parent('container');
   *
   *   describe('The text "p5*js" written in black at the center of a white rectangle. The rectangle is inside a gray square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup()  {
   *   background(200);
   *
   *   // Create rectangular div element.
   *   let div = createDiv();
   *
   *   // Place the div in the top-left corner.
   *   div.position(10, 20);
   *
   *   // Set its width and height.
   *   div.size(80, 60);
   *
   *   // Set its background color and align
   *   // any text to the center.
   *   div.style('background-color', 'white');
   *   div.style('text-align', 'center');
   *
   *   // Create a paragraph element.
   *   let p = createP('p5*js');
   *
   *   // Make the div its parent.
   *   p.parent(div);
   *
   *   describe('The text "p5*js" written in black at the center of a white rectangle. The rectangle is inside a gray square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup()  {
   *   background(200);
   *
   *   // Create rectangular div element.
   *   let div = createDiv();
   *
   *   // Place the div in the top-left corner.
   *   div.position(10, 20);
   *
   *   // Set its width and height.
   *   div.size(80, 60);
   *
   *   // Set its background color and align
   *   // any text to the center.
   *   div.style('background-color', 'white');
   *   div.style('text-align', 'center');
   *
   *   // Create a paragraph element.
   *   let p = createP('p5*js');
   *
   *   // Make the div its parent
   *   // using the underlying
   *   // HTMLElement.
   *   p.parent(div.elt);
   *
   *   describe('The text "p5*js" written in black at the center of a white rectangle. The rectangle is inside a gray square.');
   * }
   * </code>
   * </div>
   */
  /**
   * @return {p5.Element}
   */
  parent(p2) {
    if (typeof p2 === "undefined") {
      return this.elt.parentNode;
    }
    if (typeof p2 === "string") {
      if (p2[0] === "#") {
        p2 = p2.substring(1);
      }
      p2 = document.getElementById(p2);
    } else if (p2 instanceof _Element) {
      p2 = p2.elt;
    }
    p2.appendChild(this.elt);
    return this;
  }
  /**
   * Attaches the element as a child of another element.
   *
   * `myElement.child()` accepts either a string ID, DOM node, or
   * <a href="#/p5.Element">p5.Element</a>. For example,
   * `myElement.child(otherElement)`. If no argument is provided, an array of
   * children DOM nodes is returned.
   *
   * @returns {Node[]} an array of child nodes.
   *
   * @example
   * <div class='norender'>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create the div elements.
   *   let div0 = createDiv('Parent');
   *   let div1 = createDiv('Child');
   *
   *   // Make div1 the child of div0
   *   // using the p5.Element.
   *   div0.child(div1);
   *
   *   describe('A gray square with the words "Parent" and "Child" written beneath it.');
   * }
   * </code>
   * </div>
   *
   * <div class='norender'>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create the div elements.
   *   let div0 = createDiv('Parent');
   *   let div1 = createDiv('Child');
   *
   *   // Give div1 an ID.
   *   div1.id('apples');
   *
   *   // Make div1 the child of div0
   *   // using its ID.
   *   div0.child('apples');
   *
   *   describe('A gray square with the words "Parent" and "Child" written beneath it.');
   * }
   * </code>
   * </div>
   *
   * <div class='norender notest'>
   * <code>
   * // This example assumes there is a div already on the page
   * // with id "myChildDiv".
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create the div elements.
   *   let div0 = createDiv('Parent');
   *
   *   // Select the child element by its ID.
   *   let elt = document.getElementById('myChildDiv');
   *
   *   // Make div1 the child of div0
   *   // using its HTMLElement object.
   *   div0.child(elt);
   *
   *   describe('A gray square with the words "Parent" and "Child" written beneath it.');
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {String|p5.Element} [child] the ID, DOM node, or <a href="#/p5.Element">p5.Element</a>
   *                         to add to the current element
   * @chainable
   */
  child(childNode) {
    if (typeof childNode === "undefined") {
      return this.elt.childNodes;
    }
    if (typeof childNode === "string") {
      if (childNode[0] === "#") {
        childNode = childNode.substring(1);
      }
      childNode = document.getElementById(childNode);
    } else if (childNode instanceof _Element) {
      childNode = childNode.elt;
    }
    if (childNode instanceof HTMLElement) {
      this.elt.appendChild(childNode);
    }
    return this;
  }
  /**
   * Sets the inner HTML of the element, replacing any existing HTML.
   *
   * The second parameter, `append`, is optional. If `true` is passed, as in
   * `myElement.html('hi', true)`, the HTML is appended instead of replacing
   * existing HTML.
   *
   * If no arguments are passed, as in `myElement.html()`, the element's inner
   * HTML is returned.
   *
   * @for p5.Element
   * @returns {String} the inner HTML of the element
   *
   * @example
   * <div class='norender'>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create the div element and set its size.
   *   let div = createDiv('');
   *   div.size(100, 100);
   *
   *   // Set the inner HTML to "hi".
   *   div.html('hi');
   *
   *   describe('A gray square with the word "hi" written beneath it.');
   * }
   * </code>
   * </div>
   *
   * <div class='norender'>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create the div element and set its size.
   *   let div = createDiv('Hello ');
   *   div.size(100, 100);
   *
   *   // Append "World" to the div's HTML.
   *   div.html('World', true);
   *
   *   describe('A gray square with the text "Hello World" written beneath it.');
   * }
   * </code>
   * </div>
   *
   * <div class='norender'>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create the div element.
   *   let div = createDiv('Hello');
   *
   *   // Prints "Hello" to the console.
   *   print(div.html());
   *
   *   describe('A gray square with the word "Hello!" written beneath it.');
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {String} [html] the HTML to be placed inside the element
   * @param  {Boolean} [append] whether to append HTML to existing
   * @chainable
   */
  html(...args) {
    if (args.length === 0) {
      return this.elt.innerHTML;
    } else if (args[1]) {
      this.elt.insertAdjacentHTML("beforeend", args[0]);
      return this;
    } else {
      this.elt.innerHTML = args[0];
      return this;
    }
  }
  /**
   * Sets the element's ID using a given string.
   *
   * Calling `myElement.id()` without an argument returns its ID as a string.
   *
   * @param  {String} id ID of the element.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Set the canvas' ID
   *   // to "mycanvas".
   *   cnv.id('mycanvas');
   *
   *   // Get the canvas' ID.
   *   let id = cnv.id();
   *   text(id, 24, 54);
   *
   *   describe('The text "mycanvas" written in black on a gray background.');
   * }
   * </code>
   * </div>
   */
  /**
   * @return {String} ID of the element.
   */
  id(id) {
    if (typeof id === "undefined") {
      return this.elt.id;
    }
    this.elt.id = id;
    this.width = this.elt.offsetWidth;
    this.height = this.elt.offsetHeight;
    return this;
  }
  /**
   * Adds a
   * <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/class" target="_blank">class attribute</a>
   * to the element using a given string.
   *
   * Calling `myElement.class()` without an argument returns a string with its current classes.
   *
   * @param  {String} class class to add.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Add the class "small" to the
   *   // canvas element.
   *   cnv.class('small');
   *
   *   // Get the canvas element's class
   *   // and display it.
   *   let c = cnv.class();
   *   text(c, 35, 54);
   *
   *   describe('The word "small" written in black on a gray canvas.');
   *
   * }
   * </code>
   * </div>
   */
  /**
   * @return {String} element's classes, if any.
   */
  class(c4) {
    if (typeof c4 === "undefined") {
      return this.elt.className;
    }
    this.elt.className = c4;
    return this;
  }
  /**
   *
   * Adds a class to the element.
   *
   * @for p5.Element
   * @param  {String} class name of class to add.
   * @chainable
   *
   * @example
   * <div class='norender'>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a div element.
   *   let div = createDiv('div');
   *
   *   // Add a class to the div.
   *   div.addClass('myClass');
   *
   *   describe('A gray square.');
   * }
   * </code>
   * </div>
   */
  addClass(c4) {
    if (this.elt.className) {
      if (!this.hasClass(c4)) {
        this.elt.className = this.elt.className + " " + c4;
      }
    } else {
      this.elt.className = c4;
    }
    return this;
  }
  /**
   * Removes a class from the element.
   *
   * @param  {String} class name of class to remove.
   * @chainable
   *
   * @example
   * <div class='norender'>
   * <code>
   * // In this example, a class is set when the div is created
   * // and removed when mouse is pressed. This could link up
   * // with a CSS style rule to toggle style properties.
   *
   * let div;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a div element.
   *   div = createDiv('div');
   *
   *   // Add a class to the div.
   *   div.addClass('myClass');
   *
   *   describe('A gray square.');
   * }
   *
   * // Remove 'myClass' from the div when the user presses the mouse.
   * function mousePressed() {
   *   div.removeClass('myClass');
   * }
   * </code>
   * </div>
   */
  removeClass(c4) {
    this.elt.classList.remove(c4);
    return this;
  }
  /**
   * Checks if a class is already applied to element.
   *
   * @returns {boolean} a boolean value if element has specified class.
   * @param c {String} name of class to check.
   *
   * @example
   * <div class='norender'>
   * <code>
   * let div;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a div element.
   *   div = createDiv('div');
   *
   *   // Add the class 'show' to the div.
   *   div.addClass('show');
   *
   *   describe('A gray square.');
   * }
   *
   * // Toggle the class 'show' when the mouse is pressed.
   * function mousePressed() {
   *   if (div.hasClass('show')) {
   *     div.addClass('show');
   *   } else {
   *     div.removeClass('show');
   *   }
   * }
   * </code>
   * </div>
   */
  hasClass(c4) {
    return this.elt.classList.contains(c4);
  }
  /**
   * Toggles whether a class is applied to the element.
   *
   * @param c {String} class name to toggle.
   * @chainable
   *
   * @example
   * <div class='norender'>
   * <code>
   * let div;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a div element.
   *   div = createDiv('div');
   *
   *   // Add the 'show' class to the div.
   *   div.addClass('show');
   *
   *   describe('A gray square.');
   * }
   *
   * // Toggle the 'show' class when the mouse is pressed.
   * function mousePressed() {
   *   div.toggleClass('show');
   * }
   * </code>
   * </div>
   */
  toggleClass(c4) {
    if (this.elt.classList.contains(c4)) {
      this.elt.classList.remove(c4);
    } else {
      this.elt.classList.add(c4);
    }
    return this;
  }
  /**
   * Centers the element either vertically, horizontally, or both.
   *
   * `center()` will center the element relative to its parent or according to
   * the page's body if the element has no parent.
   *
   * If no argument is passed, as in `myElement.center()` the element is aligned
   * both vertically and horizontally.
   *
   * @param  {String} [align] passing 'vertical', 'horizontal' aligns element accordingly
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create the div element and style it.
   *   let div = createDiv('');
   *   div.size(10, 10);
   *   div.style('background-color', 'orange');
   *
   *   // Center the div relative to the page's body.
   *   div.center();
   *
   *   describe('A gray square and an orange rectangle. The rectangle is at the center of the page.');
   * }
   * </code>
   * </div>
   */
  center(align) {
    const style = this.elt.style.display;
    const hidden = this.elt.style.display === "none";
    const parentHidden = this.parent().style.display === "none";
    const pos = { x: this.elt.offsetLeft, y: this.elt.offsetTop };
    if (hidden) this.show();
    if (parentHidden) this.parent().show();
    this.elt.style.display = "block";
    this.position(0, 0);
    const wOffset = Math.abs(this.parent().offsetWidth - this.elt.offsetWidth);
    const hOffset = Math.abs(this.parent().offsetHeight - this.elt.offsetHeight);
    if (align === "both" || align === void 0) {
      this.position(
        wOffset / 2 + this.parent().offsetLeft,
        hOffset / 2 + this.parent().offsetTop
      );
    } else if (align === "horizontal") {
      this.position(wOffset / 2 + this.parent().offsetLeft, pos.y);
    } else if (align === "vertical") {
      this.position(pos.x, hOffset / 2 + this.parent().offsetTop);
    }
    this.style("display", style);
    if (hidden) this.hide();
    if (parentHidden) this.parent().hide();
    return this;
  }
  /**
   * Sets the element's position.
   *
   * The first two parameters, `x` and `y`, set the element's position relative
   * to the top-left corner of the web page.
   *
   * The third parameter, `positionType`, is optional. It sets the element's
   * <a target="_blank"
   * href="https://developer.mozilla.org/en-US/docs/Web/CSS/position">positioning scheme</a>.
   * `positionType` is a string that can be either `'static'`, `'fixed'`,
   * `'relative'`, `'sticky'`, `'initial'`, or `'inherit'`.
   *
   * If no arguments passed, as in `myElement.position()`, the method returns
   * the element's position in an object, as in `{ x: 0, y: 0 }`.
   *
   * @returns {Object} object of form `{ x: 0, y: 0 }` containing the element's position.
   *
   * @example
   * <div>
   * <code class='norender'>
   * function setup() {
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Positions the canvas 50px to the right and 100px
   *   // below the top-left corner of the window.
   *   cnv.position(50, 100);
   *
   *   describe('A gray square that is 50 pixels to the right and 100 pixels down from the top-left corner of the web page.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code class='norender'>
   * function setup() {
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Positions the canvas at the top-left corner
   *   // of the window with a 'fixed' position type.
   *   cnv.position(0, 0, 'fixed');
   *
   *   describe('A gray square in the top-left corner of the web page.');
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {Number} [x] x-position relative to top-left of window (optional)
   * @param  {Number} [y] y-position relative to top-left of window (optional)
   * @param  {String} [positionType] it can be static, fixed, relative, sticky, initial or inherit (optional)
   * @chainable
   */
  position(...args) {
    if (args.length === 0) {
      return { x: this.elt.offsetLeft, y: this.elt.offsetTop };
    } else {
      let positionType = "absolute";
      if (args[2] === "static" || args[2] === "fixed" || args[2] === "relative" || args[2] === "sticky" || args[2] === "initial" || args[2] === "inherit") {
        positionType = args[2];
      }
      this.elt.style.position = positionType;
      this.elt.style.left = args[0] + "px";
      this.elt.style.top = args[1] + "px";
      this.x = args[0];
      this.y = args[1];
      return this;
    }
  }
  /**
   * Shows the current element.
   *
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let p;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a paragraph element and hide it.
   *   p = createP('p5*js');
   *   p.position(10, 10);
   *   p.hide();
   *
   *   describe('A gray square. The text "p5*js" appears when the user double-clicks the square.');
   * }
   *
   * // Show the paragraph when the user double-clicks.
   * function doubleClicked() {
   *   p.show();
   * }
   * </code>
   * </div>
   */
  show() {
    this.elt.style.display = "block";
    return this;
  }
  /**
   * Hides the current element.
   *
   * @chainable
   *
   * @example
   * let p;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a paragraph element.
   *   p = createP('p5*js');
   *   p.position(10, 10);
   *
   *   describe('The text "p5*js" at the center of a gray square. The text disappears when the user double-clicks the square.');
   * }
   *
   * // Hide the paragraph when the user double-clicks.
   * function doubleClicked() {
   *   p.hide();
   * }
   * </code>
   * </div>
   */
  hide() {
    this.elt.style.display = "none";
    return this;
  }
  /**
   * Sets the element's width and height.
   *
   * Calling `myElement.size()` without an argument returns the element's size
   * as an object with the properties `width` and `height`. For example,
   *  `{ width: 20, height: 10 }`.
   *
   * The first parameter, `width`, is optional. It's a number used to set the
   * element's width. Calling `myElement.size(10)`
   *
   * The second parameter, 'height`, is also optional. It's a
   * number used to set the element's height. For example, calling
   * `myElement.size(20, 10)` sets the element's width to 20 pixels and height
   * to 10 pixels.
   *
   * The constant `AUTO` can be used to adjust one dimension at a time while
   * maintaining the aspect ratio, which is `width / height`. For example,
   * consider an element that's 200 pixels wide and 100 pixels tall. Calling
   * `myElement.size(20, AUTO)` sets the width to 20 pixels and height to 10
   * pixels.
   *
   * Note: In the case of elements that need to load data, such as images, wait
   * to call `myElement.size()` until after the data loads.
   *
   * @return {Object} width and height of the element in an object.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a pink div element and place it at the top-left corner.
   *   let div = createDiv();
   *   div.position(10, 10);
   *   div.style('background-color', 'deeppink');
   *
   *   // Set the div's width to 80 pixels and height to 20 pixels.
   *   div.size(80, 20);
   *
   *   describe('A gray square with a pink rectangle near its top.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a pink div element and place it at the top-left corner.
   *   let div = createDiv();
   *   div.position(10, 10);
   *   div.style('background-color', 'deeppink');
   *
   *   // Set the div's width to 80 pixels and height to 40 pixels.
   *   div.size(80, 40);
   *
   *   // Get the div's size as an object.
   *   let s = div.size();
   *
   *   // Display the div's dimensions.
   *   div.html(`${s.width} x ${s.height}`);
   *
   *   describe('A gray square with a pink rectangle near its top. The text "80 x 40" is written within the rectangle.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img1;
   * let img2;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Load an image of an astronaut on the moon
   *   // and place it at the top-left of the canvas.
   *   img1 = createImg(
   *     'assets/moonwalk.jpg',
   *     'An astronaut walking on the moon',
   *     ''
   *   );
   *   img1.position(0, 0);
   *
   *   // Load an image of an astronaut on the moon
   *   // and place it at the top-left of the canvas.
   *   // Resize the image once it's loaded.
   *   img2 = createImg(
   *     'assets/moonwalk.jpg',
   *     'An astronaut walking on the moon',
   *     '',
   *     resizeImage
   *   );
   *   img2.position(0, 0);
   *
   *   describe('A gray square two copies of a space image at the top-left. The copy in front is smaller.');
   * }
   *
   * // Resize img2 and keep its aspect ratio.
   * function resizeImage() {
   *   img2.size(50, AUTO);
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {(Number|AUTO)} [w]   width of the element, either AUTO, or a number.
   * @param  {(Number|AUTO)} [h] height of the element, either AUTO, or a number.
   * @chainable
   */
  size(w, h) {
    if (arguments.length === 0) {
      return { width: this.elt.offsetWidth, height: this.elt.offsetHeight };
    } else {
      let aW = w;
      let aH = h;
      const AUTO$1 = AUTO;
      if (aW !== AUTO$1 || aH !== AUTO$1) {
        if (aW === AUTO$1) {
          aW = h * this.width / this.height;
        } else if (aH === AUTO$1) {
          aH = w * this.height / this.width;
        }
        if (this.elt instanceof HTMLCanvasElement) {
          const j2 = {};
          const k = this.elt.getContext("2d");
          let prop;
          for (prop in k) {
            j2[prop] = k[prop];
          }
          this.elt.setAttribute("width", aW * this._pInst._pixelDensity);
          this.elt.setAttribute("height", aH * this._pInst._pixelDensity);
          this.elt.style.width = aW + "px";
          this.elt.style.height = aH + "px";
          this._pInst.scale(this._pInst._pixelDensity, this._pInst._pixelDensity);
          for (prop in j2) {
            this.elt.getContext("2d")[prop] = j2[prop];
          }
        } else {
          this.elt.style.width = aW + "px";
          this.elt.style.height = aH + "px";
          this.elt.width = aW;
          this.elt.height = aH;
        }
        this.width = aW;
        this.height = aH;
        if (this._pInst && this._pInst._curElement) {
          if (this._pInst._curElement.elt === this.elt) {
            this._pInst.width = aW;
            this._pInst.height = aH;
          }
        }
      }
      return this;
    }
  }
  /**
   * Applies a style to the element by adding a
   * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Syntax" target="_blank">CSS declaration</a>.
   *
   * The first parameter, `property`, is a string. If the name of a style
   * property is passed, as in `myElement.style('color')`, the method returns
   * the current value as a string or `null` if it hasn't been set. If a
   * `property:style` string is passed, as in
   * `myElement.style('color:deeppink')`, the method sets the style `property`
   * to `value`.
   *
   * The second parameter, `value`, is optional. It sets the property's value.
   * `value` can be a string, as in
   * `myElement.style('color', 'deeppink')`, or a
   * <a href="#/p5.Color">p5.Color</a> object, as in
   * `myElement.style('color', myColor)`.
   *
   * @param  {String} property style property to set.
   * @returns {String} value of the property.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a paragraph element and set its font color to "deeppink".
   *   let p = createP('p5*js');
   *   p.position(25, 20);
   *   p.style('color', 'deeppink');
   *
   *   describe('The text p5*js written in pink on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Color object.
   *   let c = color('deeppink');
   *
   *   // Create a paragraph element and set its font color using a p5.Color object.
   *   let p = createP('p5*js');
   *   p.position(25, 20);
   *   p.style('color', c);
   *
   *   describe('The text p5*js written in pink on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a paragraph element and set its font color to "deeppink"
   *   // using property:value syntax.
   *   let p = createP('p5*js');
   *   p.position(25, 20);
   *   p.style('color:deeppink');
   *
   *   describe('The text p5*js written in pink on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create an empty paragraph element and set its font color to "deeppink".
   *   let p = createP();
   *   p.position(5, 5);
   *   p.style('color', 'deeppink');
   *
   *   // Get the element's color as an  RGB color string.
   *   let c = p.style('color');
   *
   *   // Set the element's inner HTML using the RGB color string.
   *   p.html(c);
   *
   *   describe('The text "rgb(255, 20, 147)" written in pink on a gray background.');
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {String} property
   * @param  {String|p5.Color} value value to assign to the property.
   * @return {String} value of the property.
   * @chainable
   */
  style(prop, val2) {
    const self2 = this;
    if (val2 instanceof Color) {
      val2 = val2.toString();
    }
    if (typeof val2 === "undefined") {
      if (prop.indexOf(":") === -1) {
        let styles = window.getComputedStyle(self2.elt);
        let style = styles.getPropertyValue(prop);
        return style;
      } else {
        const attrs = prop.split(";");
        for (let i = 0; i < attrs.length; i++) {
          const parts = attrs[i].split(":");
          if (parts[0] && parts[1]) {
            this.elt.style[parts[0].trim()] = parts[1].trim();
          }
        }
      }
    } else {
      this.elt.style[prop] = val2;
      if (prop === "width" || prop === "height" || prop === "left" || prop === "top") {
        let styles = window.getComputedStyle(self2.elt);
        let styleVal = styles.getPropertyValue(prop);
        let numVal = styleVal.replace(/[^\d.]/g, "");
        this[prop] = Math.round(parseFloat(numVal, 10));
      }
    }
    return this;
  }
  /* Helper method called by p5.Element.style() */
  _translate(...args) {
    this.elt.style.position = "absolute";
    let transform3 = "";
    if (this.elt.style.transform) {
      transform3 = this.elt.style.transform.replace(/translate3d\(.*\)/g, "");
      transform3 = transform3.replace(/translate[X-Z]?\(.*\)/g, "");
    }
    if (args.length === 2) {
      this.elt.style.transform = "translate(" + args[0] + "px, " + args[1] + "px)";
    } else if (args.length > 2) {
      this.elt.style.transform = "translate3d(" + args[0] + "px," + args[1] + "px," + args[2] + "px)";
      if (args.length === 3) {
        this.elt.parentElement.style.perspective = "1000px";
      } else {
        this.elt.parentElement.style.perspective = args[3] + "px";
      }
    }
    this.elt.style.transform += transform3;
    return this;
  }
  /* Helper method called by p5.Element.style() */
  _rotate(...args) {
    let transform3 = "";
    if (this.elt.style.transform) {
      transform3 = this.elt.style.transform.replace(/rotate3d\(.*\)/g, "");
      transform3 = transform3.replace(/rotate[X-Z]?\(.*\)/g, "");
    }
    if (args.length === 1) {
      this.elt.style.transform = "rotate(" + args[0] + "deg)";
    } else if (args.length === 2) {
      this.elt.style.transform = "rotate(" + args[0] + "deg, " + args[1] + "deg)";
    } else if (args.length === 3) {
      this.elt.style.transform = "rotateX(" + args[0] + "deg)";
      this.elt.style.transform += "rotateY(" + args[1] + "deg)";
      this.elt.style.transform += "rotateZ(" + args[2] + "deg)";
    }
    this.elt.style.transform += transform3;
    return this;
  }
  /**
   * Adds an
   * <a href="https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Getting_started#attributes" target="_blank">attribute</a>
   * to the element.
   *
   * This method is useful for advanced tasks. Most commonly-used attributes,
   * such as `id`, can be set with their dedicated methods. For example,
   * `nextButton.id('next')` sets an element's `id` attribute. Calling
   * `nextButton.attribute('id', 'next')` has the same effect.
   *
   * The first parameter, `attr`, is the attribute's name as a string. Calling
   * `myElement.attribute('align')` returns the attribute's current value as a
   * string or `null` if it hasn't been set.
   *
   * The second parameter, `value`, is optional. It's a string used to set the
   * attribute's value. For example, calling
   * `myElement.attribute('align', 'center')` sets the element's horizontal
   * alignment to `center`.
   *
   * @return {String} value of the attribute.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a container div element and place it at the top-left corner.
   *   let container = createDiv();
   *   container.position(0, 0);
   *
   *   // Create a paragraph element and place it within the container.
   *   // Set its horizontal alignment to "left".
   *   let p1 = createP('hi');
   *   p1.parent(container);
   *   p1.attribute('align', 'left');
   *
   *   // Create a paragraph element and place it within the container.
   *   // Set its horizontal alignment to "center".
   *   let p2 = createP('hi');
   *   p2.parent(container);
   *   p2.attribute('align', 'center');
   *
   *   // Create a paragraph element and place it within the container.
   *   // Set its horizontal alignment to "right".
   *   let p3 = createP('hi');
   *   p3.parent(container);
   *   p3.attribute('align', 'right');
   *
   *   describe('A gray square with the text "hi" written on three separate lines, each placed further to the right.');
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {String} attr       attribute to set.
   * @param  {String} value      value to assign to the attribute.
   * @chainable
   */
  attribute(attr, value) {
    if (this.elt.firstChild != null && (this.elt.firstChild.type === "checkbox" || this.elt.firstChild.type === "radio")) {
      if (typeof value === "undefined") {
        return this.elt.firstChild.getAttribute(attr);
      } else {
        for (let i = 0; i < this.elt.childNodes.length; i++) {
          this.elt.childNodes[i].setAttribute(attr, value);
        }
      }
    } else if (typeof value === "undefined") {
      return this.elt.getAttribute(attr);
    } else {
      this.elt.setAttribute(attr, value);
      return this;
    }
  }
  /**
   * Removes an attribute from the element.
   *
   * The parameter `attr` is the attribute's name as a string. For example,
   * calling `myElement.removeAttribute('align')` removes its `align`
   * attribute if it's been set.
   *
   * @param  {String} attr       attribute to remove.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let p;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a paragraph element and place it in the center of the canvas.
   *   // Set its "align" attribute to "center".
   *   p = createP('hi');
   *   p.position(0, 20);
   *   p.attribute('align', 'center');
   *
   *   describe('The text "hi" written in black at the center of a gray square. The text moves to the left edge when double-clicked.');
   * }
   *
   * // Remove the 'align' attribute when the user double-clicks the paragraph.
   * function doubleClicked() {
   *   p.removeAttribute('align');
   * }
   * </code>
   * </div>
   */
  removeAttribute(attr) {
    if (this.elt.firstChild != null && (this.elt.firstChild.type === "checkbox" || this.elt.firstChild.type === "radio")) {
      for (let i = 0; i < this.elt.childNodes.length; i++) {
        this.elt.childNodes[i].removeAttribute(attr);
      }
    }
    this.elt.removeAttribute(attr);
    return this;
  }
  /**
   * Returns or sets the element's value.
   *
   * Calling `myElement.value()` returns the element's current value.
   *
   * The parameter, `value`, is an optional number or string. If provided,
   * as in `myElement.value(123)`, it's used to set the element's value.
   *
   * @return {String|Number} value of the element.
   *
   * @example
   * <div>
   * <code>
   * let input;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a text input and place it beneath the canvas.
   *   // Set its default value to "hello".
   *   input = createInput('hello');
   *   input.position(0, 100);
   *
   *   describe('The text from an input box is displayed on a gray square.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Use the input's value to display a message.
   *   let msg = input.value();
   *   text(msg, 0, 55);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let input;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a text input and place it beneath the canvas.
   *   // Set its default value to "hello".
   *   input = createInput('hello');
   *   input.position(0, 100);
   *
   *   describe('The text from an input box is displayed on a gray square. The text resets to "hello" when the user double-clicks the square.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Use the input's value to display a message.
   *   let msg = input.value();
   *   text(msg, 0, 55);
   * }
   *
   * // Reset the input's value.
   * function doubleClicked() {
   *   input.value('hello');
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {String|Number}     value
   * @chainable
   */
  value(...args) {
    if (args.length > 0) {
      this.elt.value = args[0];
      return this;
    } else {
      if (this.elt.type === "range") {
        return parseFloat(this.elt.value);
      } else return this.elt.value;
    }
  }
  /**
   * Calls a function when the mouse is pressed over the element.
   *
   * Calling `myElement.mousePressed(false)` disables the function.
   *
   * Note: Some mobile browsers may also trigger this event when the element
   * receives a quick tap.
   *
   * @param  {Function|Boolean} fxn function to call when the mouse is
   *                                pressed over the element.
   *                                `false` disables the function.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call randomColor() when the canvas
   *   // is pressed.
   *   cnv.mousePressed(randomColor);
   *
   *   describe('A gray square changes color when the mouse is pressed.');
   * }
   *
   * // Paint the background either
   * // red, yellow, blue, or green.
   * function randomColor() {
   *   let c = random(['red', 'yellow', 'blue', 'green']);
   *   background(c);
   * }
   * </code>
   * </div>
   */
  mousePressed(fxn) {
    const eventPrependedFxn = function(event) {
      this._pInst.mouseIsPressed = true;
      this._pInst._activePointers.set(event.pointerId, event);
      this._pInst._setMouseButton(event);
      this._pInst._updatePointerCoords(event);
      return fxn.call(this, event);
    };
    _Element._adjustListener("pointerdown", eventPrependedFxn, this);
    return this;
  }
  /**
   * Calls a function when the mouse is pressed twice over the element.
   *
   * Calling `myElement.doubleClicked(false)` disables the function.
   *
   * @param  {Function|Boolean} fxn function to call when the mouse is
   *                                double clicked over the element.
   *                                `false` disables the function.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call randomColor() when the
   *   // canvas is double-clicked.
   *   cnv.doubleClicked(randomColor);
   *
   *   describe('A gray square changes color when the user double-clicks the canvas.');
   * }
   *
   * // Paint the background either
   * // red, yellow, blue, or green.
   * function randomColor() {
   *   let c = random(['red', 'yellow', 'blue', 'green']);
   *   background(c);
   * }
   * </code>
   * </div>
   */
  doubleClicked(fxn) {
    _Element._adjustListener("dblclick", fxn, this);
    return this;
  }
  /**
   * Calls a function when the mouse wheel scrolls over the element.
   *
   * The callback function, `fxn`, is passed an `event` object. `event` has
   * two numeric properties, `deltaY` and `deltaX`. `event.deltaY` is
   * negative if the mouse wheel rotates away from the user. It's positive if
   * the mouse wheel rotates toward the user. `event.deltaX` is positive if
   * the mouse wheel moves to the right. It's negative if the mouse wheel moves
   * to the left.
   *
   * Calling `myElement.mouseWheel(false)` disables the function.
   *
   * @param  {Function|Boolean} fxn function to call when the mouse wheel is
   *                                scrolled over the element.
   *                                `false` disables the function.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call randomColor() when the
   *   // mouse wheel moves.
   *   cnv.mouseWheel(randomColor);
   *
   *   describe('A gray square changes color when the user scrolls the mouse wheel over the canvas.');
   * }
   *
   * // Paint the background either
   * // red, yellow, blue, or green.
   * function randomColor() {
   *   let c = random(['red', 'yellow', 'blue', 'green']);
   *   background(c);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call changeBackground() when the
   *   // mouse wheel moves.
   *   cnv.mouseWheel(changeBackground);
   *
   *   describe('A gray square. When the mouse wheel scrolls over the square, it changes color and displays shapes.');
   * }
   *
   * function changeBackground(event) {
   *   // Change the background color
   *   // based on deltaY.
   *   if (event.deltaY > 0) {
   *     background('deeppink');
   *   } else if (event.deltaY < 0) {
   *     background('cornflowerblue');
   *   } else {
   *     background(200);
   *   }
   *
   *   // Draw a shape based on deltaX.
   *   if (event.deltaX > 0) {
   *     circle(50, 50, 20);
   *   } else if (event.deltaX < 0) {
   *     square(40, 40, 20);
   *   }
   * }
   * </code>
   * </div>
   */
  mouseWheel(fxn) {
    _Element._adjustListener("wheel", fxn, this);
    return this;
  }
  /**
   * Calls a function when the mouse is released over the element.
   *
   * Calling `myElement.mouseReleased(false)` disables the function.
   *
   * Note: Some mobile browsers may also trigger this event when the element
   * receives a quick tap.
   *
   * @param  {Function|Boolean} fxn function to call when the mouse is
   *                                pressed over the element.
   *                                `false` disables the function.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call randomColor() when a
   *   // mouse press ends.
   *   cnv.mouseReleased(randomColor);
   *
   *   describe('A gray square changes color when the user releases a mouse press.');
   * }
   *
   * // Paint the background either
   * // red, yellow, blue, or green.
   * function randomColor() {
   *   let c = random(['red', 'yellow', 'blue', 'green']);
   *   background(c);
   * }
   * </code>
   * </div>
   */
  mouseReleased(fxn) {
    _Element._adjustListener("pointerup", fxn, this);
    return this;
  }
  /**
   * Calls a function when the mouse is pressed and released over the element.
   *
   * Calling `myElement.mouseReleased(false)` disables the function.
   *
   * Note: Some mobile browsers may also trigger this event when the element
   * receives a quick tap.
   *
   * @param  {Function|Boolean} fxn function to call when the mouse is
   *                                pressed and released over the element.
   *                                `false` disables the function.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call randomColor() when a
   *   // mouse press ends.
   *   cnv.mouseClicked(randomColor);
   *
   *   describe('A gray square changes color when the user releases a mouse press.');
   * }
   *
   * // Paint the background either
   * // red, yellow, blue, or green.
   * function randomColor() {
   *   let c = random(['red', 'yellow', 'blue', 'green']);
   *   background(c);
   * }
   * </code>
   * </div>
   */
  mouseClicked(fxn) {
    _Element._adjustListener("click", fxn, this);
    return this;
  }
  /**
   * Calls a function when the mouse moves over the element.
   *
   * Calling `myElement.mouseMoved(false)` disables the function.
   *
   * @param  {Function|Boolean} fxn function to call when the mouse
   *                                moves over the element.
   *                                `false` disables the function.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call randomColor() when the
   *   // mouse moves.
   *   cnv.mouseMoved(randomColor);
   *
   *   describe('A gray square changes color when the mouse moves over the canvas.');
   * }
   *
   * // Paint the background either
   * // red, yellow, blue, or green.
   * function randomColor() {
   *   let c = random(['red', 'yellow', 'blue', 'green']);
   *   background(c);
   * }
   * </code>
   * </div>
   */
  mouseMoved(fxn) {
    _Element._adjustListener("pointermove", fxn, this);
    return this;
  }
  /**
   * Calls a function when the mouse moves onto the element.
   *
   * Calling `myElement.mouseOver(false)` disables the function.
   *
   * @param  {Function|Boolean} fxn function to call when the mouse
   *                                moves onto the element.
   *                                `false` disables the function.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call randomColor() when the
   *   // mouse moves onto the canvas.
   *   cnv.mouseOver(randomColor);
   *
   *   describe('A gray square changes color when the mouse moves onto the canvas.');
   * }
   *
   * // Paint the background either
   * // red, yellow, blue, or green.
   * function randomColor() {
   *   let c = random(['red', 'yellow', 'blue', 'green']);
   *   background(c);
   * }
   * </code>
   * </div>
   */
  mouseOver(fxn) {
    _Element._adjustListener("pointerover", fxn, this);
    return this;
  }
  /**
   * Calls a function when the mouse moves off the element.
   *
   * Calling `myElement.mouseOut(false)` disables the function.
   *
   * @param  {Function|Boolean} fxn function to call when the mouse
   *                                moves off the element.
   *                                `false` disables the function.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call randomColor() when the
   *   // mouse moves off the canvas.
   *   cnv.mouseOut(randomColor);
   *
   *   describe('A gray square changes color when the mouse moves off the canvas.');
   * }
   *
   * // Paint the background either
   * // red, yellow, blue, or green.
   * function randomColor() {
   *   let c = random(['red', 'yellow', 'blue', 'green']);
   *   background(c);
   * }
   * </code>
   * </div>
   */
  mouseOut(fxn) {
    _Element._adjustListener("pointerout", fxn, this);
    return this;
  }
  /**
  * Calls a function when a file is dragged over the element.
  *
  * Calling `myElement.dragOver(false)` disables the function.
  *
  * @param  {Function|Boolean} fxn function to call when the file is
  *                                dragged over the element.
  *                                `false` disables the function.
  * @chainable
  *
  * @example
  * <div>
  * <code>
  * // Drag a file over the canvas to test.
  *
  * function setup() {
  *   // Create a canvas element and
  *   // assign it to cnv.
  *   let cnv = createCanvas(100, 100);
  *
  *   background(200);
  *
  *   // Call helloFile() when a
  *   // file is dragged over
  *   // the canvas.
  *   cnv.dragOver(helloFile);
  *
  *   describe('A gray square. The text "hello, file" appears when a file is dragged over the square.');
  * }
  *
  * function helloFile() {
  *   text('hello, file', 50, 50);
  * }
  * </code>
  * </div>
  */
  dragOver(fxn) {
    _Element._adjustListener("dragover", fxn, this);
    return this;
  }
  /**
   * Calls a function when a file is dragged off the element.
   *
   * Calling `myElement.dragLeave(false)` disables the function.
   *
   * @param  {Function|Boolean} fxn function to call when the file is
   *                                dragged off the element.
   *                                `false` disables the function.
   * @chainable
   * @example
   * <div>
   * <code>
   * // Drag a file over, then off
   * // the canvas to test.
   *
   * function setup() {
   *   // Create a canvas element and
   *   // assign it to cnv.
   *   let cnv = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call byeFile() when a
   *   // file is dragged over,
   *   // then off the canvas.
   *   cnv.dragLeave(byeFile);
   *
   *   describe('A gray square. The text "bye, file" appears when a file is dragged over, then off the square.');
   * }
   *
   * function byeFile() {
   *   text('bye, file', 50, 50);
   * }
   * </code>
   * </div>
   */
  dragLeave(fxn) {
    _Element._adjustListener("dragleave", fxn, this);
    return this;
  }
  /**
   * Calls a function when the element changes.
   *
   * Calling `myElement.changed(false)` disables the function.
   *
   * @param  {Function|Boolean} fxn function to call when the element changes.
   *                                `false` disables the function.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let dropdown;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a dropdown menu and add a few color options.
   *   dropdown = createSelect();
   *   dropdown.position(0, 0);
   *   dropdown.option('red');
   *   dropdown.option('green');
   *   dropdown.option('blue');
   *
   *   // Call paintBackground() when the color option changes.
   *   dropdown.changed(paintBackground);
   *
   *   describe('A gray square with a dropdown menu at the top. The square changes color when an option is selected.');
   * }
   *
   * // Paint the background with the selected color.
   * function paintBackground() {
   *   let c = dropdown.value();
   *   background(c);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let checkbox;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a checkbox and place it beneath the canvas.
   *   checkbox = createCheckbox(' circle');
   *   checkbox.position(0, 100);
   *
   *   // Call repaint() when the checkbox changes.
   *   checkbox.changed(repaint);
   *
   *   describe('A gray square with a checkbox underneath it that says "circle". A white circle appears when the box is checked and disappears otherwise.');
   * }
   *
   * // Paint the background gray and determine whether to draw a circle.
   * function repaint() {
   *   background(200);
   *   if (checkbox.checked() === true) {
   *     circle(50, 50, 30);
   *   }
   * }
   * </code>
   * </div>
   */
  changed(fxn) {
    _Element._adjustListener("change", fxn, this);
    return this;
  }
  /**
   * Calls a function when the element receives input.
   *
   * `myElement.input()` is often used to with text inputs and sliders. Calling
   * `myElement.input(false)` disables the function.
   *
   * @param  {Function|Boolean} fxn function to call when input is detected within
   *                                the element.
   *                                `false` disables the function.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let slider;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a slider and place it beneath the canvas.
   *   slider = createSlider(0, 255, 200);
   *   slider.position(0, 100);
   *
   *   // Call repaint() when the slider changes.
   *   slider.input(repaint);
   *
   *   describe('A gray square with a range slider underneath it. The background changes shades of gray when the slider is moved.');
   * }
   *
   * // Paint the background using slider's value.
   * function repaint() {
   *   let g = slider.value();
   *   background(g);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let input;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create an input and place it beneath the canvas.
   *   input = createInput('');
   *   input.position(0, 100);
   *
   *   // Call repaint() when input is detected.
   *   input.input(repaint);
   *
   *   describe('A gray square with a text input bar beneath it. Any text written in the input appears in the middle of the square.');
   * }
   *
   * // Paint the background gray and display the input's value.
   * function repaint() {
   *   background(200);
   *   let msg = input.value();
   *   text(msg, 5, 50);
   * }
   * </code>
   * </div>
   */
  input(fxn) {
    _Element._adjustListener("input", fxn, this);
    return this;
  }
  /**
   * Calls a function when the user drops a file on the element.
   *
   * The first parameter, `callback`, is a function to call once the file loads.
   * The callback function should have one parameter, `file`, that's a
   * <a href="#/p5.File">p5.File</a> object. If the user drops multiple files on
   * the element, `callback`, is called once for each file.
   *
   * The second parameter, `fxn`, is a function to call when the browser detects
   * one or more dropped files. The callback function should have one
   * parameter, `event`, that's a
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/DragEvent">DragEvent</a>.
   *
   * @param  {Function} callback  called when a file loads. Called once for each file dropped.
   * @param  {Function} [fxn]     called once when any files are dropped.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * // Drop an image on the canvas to view
   * // this example.
   * let img;
   *
   * function setup() {
   *   let c = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call handleFile() when a file that's dropped on the canvas has loaded.
   *   c.drop(handleFile);
   *
   *   describe('A gray square. When the user drops an image on the square, it is displayed.');
   * }
   *
   * // Remove the existing image and display the new one.
   * function handleFile(file) {
   *   // Remove the current image, if any.
   *   if (img) {
   *     img.remove();
   *   }
   *
   *   // Create an <img> element with the
   *   // dropped file.
   *   img = createImg(file.data, '');
   *   img.hide();
   *
   *   // Draw the image.
   *   image(img, 0, 0, width, height);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Drop an image on the canvas to view
   * // this example.
   * let img;
   * let msg;
   *
   * function setup() {
   *   let c = createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Call functions when the user drops a file on the canvas
   *   // and when the file loads.
   *   c.drop(handleFile, handleDrop);
   *
   *   describe('A gray square. When the user drops an image on the square, it is displayed. The id attribute of canvas element is also displayed.');
   * }
   *
   * // Display the image when it loads.
   * function handleFile(file) {
   *   // Remove the current image, if any.
   *   if (img) {
   *     img.remove();
   *   }
   *
   *   // Create an img element with the dropped file.
   *   img = createImg(file.data, '');
   *   img.hide();
   *
   *   // Draw the image.
   *   image(img, 0, 0, width, height);
   * }
   *
   * // Display the file's name when it loads.
   * function handleDrop(event) {
   *   // Remove current paragraph, if any.
   *   if (msg) {
   *     msg.remove();
   *   }
   *
   *   // Use event to get the drop target's id.
   *   let id = event.target.id;
   *
   *   // Write the canvas' id beneath it.
   *   msg = createP(id);
   *   msg.position(0, 100);
   *
   *   // Set the font color randomly for each drop.
   *   let c = random(['red', 'green', 'blue']);
   *   msg.style('color', c);
   *   msg.style('font-size', '12px');
   * }
   * </code>
   * </div>
   */
  drop(callback, fxn) {
    if (window.File && window.FileReader && window.FileList && window.Blob) {
      if (!this._dragDisabled) {
        this._dragDisabled = true;
        const preventDefault = function(evt) {
          evt.preventDefault();
        };
        this.elt.addEventListener("dragover", preventDefault);
        this.elt.addEventListener("dragleave", preventDefault);
      }
      _Element._attachListener(
        "drop",
        function(evt) {
          evt.preventDefault();
          if (typeof fxn === "function") {
            fxn.call(this, evt);
          }
          const files2 = evt.dataTransfer.files;
          for (const f of files2) {
            File2._load(f, callback);
          }
        },
        this
      );
    } else {
      console.log("The File APIs are not fully supported in this browser.");
    }
    return this;
  }
  /**
   * Makes the element draggable.
   *
   * The parameter, `elmnt`, is optional. If another
   * <a href="#/p5.Element">p5.Element</a> object is passed, as in
   * `myElement.draggable(otherElement)`, the other element will become draggable.
   *
   * @param  {p5.Element} [elmnt]  another <a href="#/p5.Element">p5.Element</a>.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let stickyNote;
   * let textInput;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a div element and style it.
   *   stickyNote = createDiv('Note');
   *   stickyNote.position(5, 5);
   *   stickyNote.size(80, 20);
   *   stickyNote.style('font-size', '16px');
   *   stickyNote.style('font-family', 'Comic Sans MS');
   *   stickyNote.style('background', 'orchid');
   *   stickyNote.style('padding', '5px');
   *
   *   // Make the note draggable.
   *   stickyNote.draggable();
   *
   *   // Create a panel div and style it.
   *   let panel = createDiv('');
   *   panel.position(5, 40);
   *   panel.size(80, 50);
   *   panel.style('background', 'orchid');
   *   panel.style('font-size', '16px');
   *   panel.style('padding', '5px');
   *   panel.style('text-align', 'center');
   *
   *   // Make the panel draggable.
   *   panel.draggable();
   *
   *   // Create a text input and style it.
   *   textInput = createInput('Note');
   *   textInput.size(70);
   *
   *   // Add the input to the panel.
   *   textInput.parent(panel);
   *
   *   // Call handleInput() when text is input.
   *   textInput.input(handleInput);
   *
   *   describe(
   *     'A gray square with two purple rectangles that move when dragged. The top rectangle displays the text that is typed into the bottom rectangle.'
   *   );
   * }
   *
   * // Update stickyNote's HTML when text is input.
   * function handleInput() {
   *   stickyNote.html(textInput.value());
   * }
   * </code>
   * </div>
   */
  draggable(elmMove) {
    let isTouch = "ontouchstart" in window;
    let x = 0, y = 0, px = 0, py = 0, elmDrag, dragMouseDownEvt = isTouch ? "touchstart" : "mousedown", closeDragElementEvt = isTouch ? "touchend" : "mouseup", elementDragEvt = isTouch ? "touchmove" : "mousemove";
    if (elmMove === void 0) {
      elmMove = this.elt;
      elmDrag = elmMove;
    } else if (elmMove !== this.elt && elmMove.elt !== this.elt) {
      elmMove = elmMove.elt;
      elmDrag = this.elt;
    }
    elmDrag.addEventListener(dragMouseDownEvt, dragMouseDown, false);
    elmDrag.style.cursor = "move";
    function dragMouseDown(e2) {
      e2 = e2 || window.event;
      if (isTouch) {
        const touches = e2.changedTouches;
        px = parseInt(touches[0].clientX);
        py = parseInt(touches[0].clientY);
      } else {
        px = parseInt(e2.clientX);
        py = parseInt(e2.clientY);
      }
      document.addEventListener(closeDragElementEvt, closeDragElement, false);
      document.addEventListener(elementDragEvt, elementDrag, false);
      return false;
    }
    function elementDrag(e2) {
      e2 = e2 || window.event;
      if (isTouch) {
        const touches = e2.changedTouches;
        x = px - parseInt(touches[0].clientX);
        y = py - parseInt(touches[0].clientY);
        px = parseInt(touches[0].clientX);
        py = parseInt(touches[0].clientY);
      } else {
        x = px - parseInt(e2.clientX);
        y = py - parseInt(e2.clientY);
        px = parseInt(e2.clientX);
        py = parseInt(e2.clientY);
      }
      elmMove.style.left = elmMove.offsetLeft - x + "px";
      elmMove.style.top = elmMove.offsetTop - y + "px";
    }
    function closeDragElement() {
      document.removeEventListener(closeDragElementEvt, closeDragElement, false);
      document.removeEventListener(elementDragEvt, elementDrag, false);
    }
    return this;
  }
  /**
   *
   * @private
   * @static
   * @param {String} ev
   * @param {Boolean|Function} fxn
   * @param {Element} ctx
   * @chainable
   * @alt
   * General handler for event attaching and detaching
   */
  static _adjustListener(ev, fxn, ctx) {
    if (fxn === false) {
      _Element._detachListener(ev, ctx);
    } else {
      _Element._attachListener(ev, fxn, ctx);
    }
    return this;
  }
  /**
   *
   * @private
   * @static
   * @param {String} ev
   * @param {Function} fxn
   * @param {Element} ctx
   */
  static _attachListener(ev, fxn, ctx) {
    if (ctx._events[ev]) {
      _Element._detachListener(ev, ctx);
    }
    const f = fxn.bind(ctx);
    ctx.elt.addEventListener(ev, f, false);
    ctx._events[ev] = f;
  }
  /**
   *
   * @private
   * @static
   * @param {String} ev
   * @param {Element} ctx
   */
  static _detachListener(ev, ctx) {
    const f = ctx._events[ev];
    ctx.elt.removeEventListener(ev, f, false);
    ctx._events[ev] = null;
  }
};
function element(p53, fn2) {
  p53.Element = Element;
}
if (typeof p5 !== "undefined") {
  element(p5, p5.prototype);
}

// node_modules/p5/dist/image/filters.js
var Filters = {
  /*
   * Helper functions
   */
  /**
   * Returns the pixel buffer for a canvas.
   *
   * @private
   *
   * @param  {Canvas|ImageData} canvas the canvas to get pixels from
   * @return {Uint8ClampedArray}       a one-dimensional array containing
   *                                   the data in the RGBA order, with integer
   *                                   values between 0 and 255.
   */
  _toPixels(canvas2) {
    if (canvas2 instanceof ImageData) {
      return canvas2.data;
    } else {
      if (canvas2.getContext("2d")) {
        return canvas2.getContext("2d").getImageData(0, 0, canvas2.width, canvas2.height).data;
      } else if (canvas2.getContext("webgl")) {
        const gl = canvas2.getContext("webgl");
        const len = gl.drawingBufferWidth * gl.drawingBufferHeight * 4;
        const data3 = new Uint8Array(len);
        gl.readPixels(
          0,
          0,
          canvas2.width,
          canvas2.height,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          data3
        );
        return data3;
      }
    }
  },
  /**
   * Returns a 32-bit number containing ARGB data at the ith pixel in the
   * 1D array containing pixels data.
   *
   * @private
   *
   * @param  {Uint8ClampedArray} data array returned by _toPixels()
   * @param  {Integer}           i    index of a 1D Image Array
   * @return {Integer}                32-bit integer value representing
   *                                  ARGB value.
   */
  _getARGB(data3, i) {
    const offset2 = i * 4;
    return (
      // Combining the extracted components using bitwise OR operations to form the final ARGB value.
      data3[offset2 + 3] << 24 & 4278190080 | //Extract alpha component
      data3[offset2] << 16 & 16711680 | //Extract Red component
      data3[offset2 + 1] << 8 & 65280 | //Extract green component
      data3[offset2 + 2] & 255
    );
  },
  /**
   * Modifies pixels RGBA values to values contained in the data object.
   *
   * @private
   *
   * @param {Uint8ClampedArray} pixels array returned by _toPixels()
   * @param {Int32Array}        data   source 1D array where each value
   *                                   represents ARGB values
   */
  _setPixels(pixels2, data3) {
    let offset2 = 0;
    for (let i = 0, al = pixels2.length; i < al; i++) {
      offset2 = i * 4;
      pixels2[offset2 + 0] = (data3[i] & 16711680) >>> 16;
      pixels2[offset2 + 1] = (data3[i] & 65280) >>> 8;
      pixels2[offset2 + 2] = data3[i] & 255;
      pixels2[offset2 + 3] = (data3[i] & 4278190080) >>> 24;
    }
  },
  /**
   * Returns the ImageData object for a canvas.
   * https://developer.mozilla.org/en-US/docs/Web/API/ImageData
   *
   * @private
   *
   * @param  {Canvas|ImageData} canvas canvas to get image data from
   * @return {ImageData}               Holder of pixel data (and width and
   *                                   height) for a canvas
   */
  _toImageData(canvas2) {
    if (canvas2 instanceof ImageData) {
      return canvas2;
    } else {
      return canvas2.getContext("2d").getImageData(0, 0, canvas2.width, canvas2.height);
    }
  },
  /**
   * Returns a blank ImageData object.
   *
   * @private
   *
   * @param  {Integer} width
   * @param  {Integer} height
   * @return {ImageData}
   */
  _createImageData(width, height) {
    Filters._tmpCanvas = document.createElement("canvas");
    Filters._tmpCtx = Filters._tmpCanvas.getContext("2d");
    return this._tmpCtx.createImageData(width, height);
  },
  /**
   * Applys a filter function to a canvas.
   *
   * The difference between this and the actual filter functions defined below
   * is that the filter functions generally modify the pixel buffer but do
   * not actually put that data back to the canvas (where it would actually
   * update what is visible). By contrast this method does make the changes
   * actually visible in the canvas.
   *
   * The apply method is the method that callers of this module would generally
   * use. It has been separated from the actual filters to support an advanced
   * use case of creating a filter chain that executes without actually updating
   * the canvas in between everystep.
   *
   * @private
   * @param  {HTMLCanvasElement} canvas The input canvas to apply the filter on.
   * @param  {function(ImageData,Object)} func The filter function to apply to the canvas's pixel data.
   * @param  {Object} filterParam An optional parameter to pass to the filter function.
   */
  apply(canvas2, func, filterParam) {
    const pixelsState = canvas2.getContext("2d");
    const imageData = pixelsState.getImageData(
      0,
      0,
      canvas2.width,
      canvas2.height
    );
    const newImageData = func(imageData, filterParam);
    if (newImageData instanceof ImageData) {
      pixelsState.putImageData(
        newImageData,
        0,
        0,
        0,
        0,
        canvas2.width,
        canvas2.height
      );
    } else {
      pixelsState.putImageData(
        imageData,
        0,
        0,
        0,
        0,
        canvas2.width,
        canvas2.height
      );
    }
  },
  /*
   * Filters
   */
  /**
   * Converts the image to black and white pixels depending if they are above or
   * below the threshold defined by the level parameter. The parameter must be
   * between 0.0 (black) and 1.0 (white). If no level is specified, 0.5 is used.
   *
   * Borrowed from http://www.html5rocks.com/en/tutorials/canvas/imagefilters/
   *
   * @private
   * @param  {Canvas} canvas Canvas to apply thershold filter on.
   * @param  {Float} level Threshold level (0-1).
   */
  threshold(canvas2, level = 0.5) {
    const pixels2 = Filters._toPixels(canvas2);
    const thresh = Math.floor(level * 255);
    for (let i = 0; i < pixels2.length; i += 4) {
      const r = pixels2[i];
      const g2 = pixels2[i + 1];
      const b3 = pixels2[i + 2];
      const gray = 0.2126 * r + 0.7152 * g2 + 0.0722 * b3;
      let val2;
      if (gray >= thresh) {
        val2 = 255;
      } else {
        val2 = 0;
      }
      pixels2[i] = pixels2[i + 1] = pixels2[i + 2] = val2;
    }
  },
  /**
   * Converts any colors in the image to grayscale equivalents.
   * No parameter is used.
   *
   * Borrowed from http://www.html5rocks.com/en/tutorials/canvas/imagefilters/
   *
   * @private
   * @param {Canvas} canvas Canvas to apply gray filter on.
   */
  gray(canvas2) {
    const pixels2 = Filters._toPixels(canvas2);
    for (let i = 0; i < pixels2.length; i += 4) {
      const r = pixels2[i];
      const g2 = pixels2[i + 1];
      const b3 = pixels2[i + 2];
      const gray = 0.2126 * r + 0.7152 * g2 + 0.0722 * b3;
      pixels2[i] = pixels2[i + 1] = pixels2[i + 2] = gray;
    }
  },
  /**
   * Sets the alpha channel to entirely opaque. No parameter is used.
   *
   * @private
   * @param {Canvas} canvas
   */
  opaque(canvas2) {
    const pixels2 = Filters._toPixels(canvas2);
    for (let i = 0; i < pixels2.length; i += 4) {
      pixels2[i + 3] = 255;
    }
    return pixels2;
  },
  /**
   * Sets each pixel to its inverse value. No parameter is used.
   * @private
   * @param  {Canvas} canvas
   */
  invert(canvas2) {
    const pixels2 = Filters._toPixels(canvas2);
    for (let i = 0; i < pixels2.length; i += 4) {
      pixels2[i] = 255 - pixels2[i];
      pixels2[i + 1] = 255 - pixels2[i + 1];
      pixels2[i + 2] = 255 - pixels2[i + 2];
    }
  },
  /**
   * Limits each channel of the image to the number of colors specified as
   * the parameter. The parameter can be set to values between 2 and 255, but
   * results are most noticeable in the lower ranges.
   *
   * Adapted from java based processing implementation
   *
   * @private
   * @param  {Canvas} canvas
   * @param  {Integer} level
   */
  posterize(canvas2, level = 4) {
    const pixels2 = Filters._toPixels(canvas2);
    if (level < 2 || level > 255) {
      throw new Error(
        "Level must be greater than 2 and less than 255 for posterize"
      );
    }
    const levels1 = level - 1;
    for (let i = 0; i < pixels2.length; i += 4) {
      const rlevel = pixels2[i];
      const glevel = pixels2[i + 1];
      const blevel = pixels2[i + 2];
      pixels2[i] = (rlevel * level >> 8) * 255 / levels1;
      pixels2[i + 1] = (glevel * level >> 8) * 255 / levels1;
      pixels2[i + 2] = (blevel * level >> 8) * 255 / levels1;
    }
  },
  /**
   * Increases the bright areas in an image.
   * @private
   * @param  {Canvas} canvas
   */
  dilate(canvas2) {
    const pixels2 = Filters._toPixels(canvas2);
    let currIdx = 0;
    const maxIdx = pixels2.length ? pixels2.length / 4 : 0;
    const out = new Int32Array(maxIdx);
    let currRowIdx, maxRowIdx, colOrig, colOut, currLum;
    let idxRight, idxLeft, idxUp, idxDown;
    let colRight, colLeft, colUp, colDown;
    let lumRight, lumLeft, lumUp, lumDown;
    while (currIdx < maxIdx) {
      currRowIdx = currIdx;
      maxRowIdx = currIdx + canvas2.width;
      while (currIdx < maxRowIdx) {
        colOrig = colOut = Filters._getARGB(pixels2, currIdx);
        idxLeft = currIdx - 1;
        idxRight = currIdx + 1;
        idxUp = currIdx - canvas2.width;
        idxDown = currIdx + canvas2.width;
        if (idxLeft < currRowIdx) {
          idxLeft = currIdx;
        }
        if (idxRight >= maxRowIdx) {
          idxRight = currIdx;
        }
        if (idxUp < 0) {
          idxUp = 0;
        }
        if (idxDown >= maxIdx) {
          idxDown = currIdx;
        }
        colUp = Filters._getARGB(pixels2, idxUp);
        colLeft = Filters._getARGB(pixels2, idxLeft);
        colDown = Filters._getARGB(pixels2, idxDown);
        colRight = Filters._getARGB(pixels2, idxRight);
        currLum = 77 * (colOrig >> 16 & 255) + 151 * (colOrig >> 8 & 255) + 28 * (colOrig & 255);
        lumLeft = 77 * (colLeft >> 16 & 255) + 151 * (colLeft >> 8 & 255) + 28 * (colLeft & 255);
        lumRight = 77 * (colRight >> 16 & 255) + 151 * (colRight >> 8 & 255) + 28 * (colRight & 255);
        lumUp = 77 * (colUp >> 16 & 255) + 151 * (colUp >> 8 & 255) + 28 * (colUp & 255);
        lumDown = 77 * (colDown >> 16 & 255) + 151 * (colDown >> 8 & 255) + 28 * (colDown & 255);
        if (lumLeft > currLum) {
          colOut = colLeft;
          currLum = lumLeft;
        }
        if (lumRight > currLum) {
          colOut = colRight;
          currLum = lumRight;
        }
        if (lumUp > currLum) {
          colOut = colUp;
          currLum = lumUp;
        }
        if (lumDown > currLum) {
          colOut = colDown;
          currLum = lumDown;
        }
        out[currIdx++] = colOut;
      }
    }
    Filters._setPixels(pixels2, out);
  },
  /**
   * Reduces the bright areas in an image.
   * Similar to `dilate()`, but updates the output color based on the lowest luminance value.
   * @private
   * @param  {Canvas} canvas
   */
  erode(canvas2) {
    const pixels2 = Filters._toPixels(canvas2);
    let currIdx = 0;
    const maxIdx = pixels2.length ? pixels2.length / 4 : 0;
    const out = new Int32Array(maxIdx);
    let currRowIdx, maxRowIdx, colOrig, colOut, currLum;
    let idxRight, idxLeft, idxUp, idxDown;
    let colRight, colLeft, colUp, colDown;
    let lumRight, lumLeft, lumUp, lumDown;
    while (currIdx < maxIdx) {
      currRowIdx = currIdx;
      maxRowIdx = currIdx + canvas2.width;
      while (currIdx < maxRowIdx) {
        colOrig = colOut = Filters._getARGB(pixels2, currIdx);
        idxLeft = currIdx - 1;
        idxRight = currIdx + 1;
        idxUp = currIdx - canvas2.width;
        idxDown = currIdx + canvas2.width;
        if (idxLeft < currRowIdx) {
          idxLeft = currIdx;
        }
        if (idxRight >= maxRowIdx) {
          idxRight = currIdx;
        }
        if (idxUp < 0) {
          idxUp = 0;
        }
        if (idxDown >= maxIdx) {
          idxDown = currIdx;
        }
        colUp = Filters._getARGB(pixels2, idxUp);
        colLeft = Filters._getARGB(pixels2, idxLeft);
        colDown = Filters._getARGB(pixels2, idxDown);
        colRight = Filters._getARGB(pixels2, idxRight);
        currLum = 77 * (colOrig >> 16 & 255) + 151 * (colOrig >> 8 & 255) + 28 * (colOrig & 255);
        lumLeft = 77 * (colLeft >> 16 & 255) + 151 * (colLeft >> 8 & 255) + 28 * (colLeft & 255);
        lumRight = 77 * (colRight >> 16 & 255) + 151 * (colRight >> 8 & 255) + 28 * (colRight & 255);
        lumUp = 77 * (colUp >> 16 & 255) + 151 * (colUp >> 8 & 255) + 28 * (colUp & 255);
        lumDown = 77 * (colDown >> 16 & 255) + 151 * (colDown >> 8 & 255) + 28 * (colDown & 255);
        if (lumLeft < currLum) {
          colOut = colLeft;
          currLum = lumLeft;
        }
        if (lumRight < currLum) {
          colOut = colRight;
          currLum = lumRight;
        }
        if (lumUp < currLum) {
          colOut = colUp;
          currLum = lumUp;
        }
        if (lumDown < currLum) {
          colOut = colDown;
          currLum = lumDown;
        }
        out[currIdx++] = colOut;
      }
    }
    Filters._setPixels(pixels2, out);
  },
  blur(canvas2, radius) {
    blurARGB(canvas2, radius);
  }
};
var blurRadius;
var blurKernelSize;
var blurKernel;
var blurMult;
function buildBlurKernel(r) {
  let radius = r * 3.5 | 0;
  radius = radius < 1 ? 1 : radius < 248 ? radius : 248;
  if (blurRadius !== radius) {
    blurRadius = radius;
    blurKernelSize = 1 + blurRadius << 1;
    blurKernel = new Int32Array(blurKernelSize);
    blurMult = new Array(blurKernelSize);
    for (let l = 0; l < blurKernelSize; l++) {
      blurMult[l] = new Int32Array(256);
    }
    let bk, bki;
    let bm, bmi;
    for (let i = 1, radiusi = radius - 1; i < radius; i++) {
      blurKernel[radius + i] = blurKernel[radiusi] = bki = radiusi * radiusi;
      bm = blurMult[radius + i];
      bmi = blurMult[radiusi--];
      for (let j2 = 0; j2 < 256; j2++) {
        bm[j2] = bmi[j2] = bki * j2;
      }
    }
    bk = blurKernel[radius] = radius * radius;
    bm = blurMult[radius];
    for (let k = 0; k < 256; k++) {
      bm[k] = bk * k;
    }
  }
}
function blurARGB(canvas2, radius) {
  const pixels2 = Filters._toPixels(canvas2);
  const width = canvas2.width;
  const height = canvas2.height;
  const numPackedPixels = width * height;
  const argb = new Int32Array(numPackedPixels);
  for (let j2 = 0; j2 < numPackedPixels; j2++) {
    argb[j2] = Filters._getARGB(pixels2, j2);
  }
  let sum, cr, cg, cb, ca;
  let read2, ri, ym, ymi, bk0;
  const a2 = new Int32Array(numPackedPixels);
  const r2 = new Int32Array(numPackedPixels);
  const g2 = new Int32Array(numPackedPixels);
  const b22 = new Int32Array(numPackedPixels);
  let yi = 0;
  buildBlurKernel(radius);
  let x, y, i;
  let bm;
  for (y = 0; y < height; y++) {
    for (x = 0; x < width; x++) {
      cb = cg = cr = ca = sum = 0;
      read2 = x - blurRadius;
      if (read2 < 0) {
        bk0 = -read2;
        read2 = 0;
      } else {
        if (read2 >= width) {
          break;
        }
        bk0 = 0;
      }
      for (i = bk0; i < blurKernelSize; i++) {
        if (read2 >= width) {
          break;
        }
        const c4 = argb[read2 + yi];
        bm = blurMult[i];
        ca += bm[(c4 & -16777216) >>> 24];
        cr += bm[(c4 & 16711680) >> 16];
        cg += bm[(c4 & 65280) >> 8];
        cb += bm[c4 & 255];
        sum += blurKernel[i];
        read2++;
      }
      ri = yi + x;
      a2[ri] = ca / sum;
      r2[ri] = cr / sum;
      g2[ri] = cg / sum;
      b22[ri] = cb / sum;
    }
    yi += width;
  }
  yi = 0;
  ym = -blurRadius;
  ymi = ym * width;
  for (y = 0; y < height; y++) {
    for (x = 0; x < width; x++) {
      cb = cg = cr = ca = sum = 0;
      if (ym < 0) {
        bk0 = ri = -ym;
        read2 = x;
      } else {
        if (ym >= height) {
          break;
        }
        bk0 = 0;
        ri = ym;
        read2 = x + ymi;
      }
      for (i = bk0; i < blurKernelSize; i++) {
        if (ri >= height) {
          break;
        }
        bm = blurMult[i];
        ca += bm[a2[read2]];
        cr += bm[r2[read2]];
        cg += bm[g2[read2]];
        cb += bm[b22[read2]];
        sum += blurKernel[i];
        ri++;
        read2 += width;
      }
      argb[x + yi] = ca / sum << 24 | cr / sum << 16 | cg / sum << 8 | cb / sum;
    }
    yi += width;
    ymi += width;
    ym++;
  }
  Filters._setPixels(pixels2, argb);
}

// node_modules/p5/dist/shape/custom_shapes.js
function polylineLength(vertices) {
  let length = 0;
  for (let i = 1; i < vertices.length; i++) {
    length += vertices[i - 1].position.dist(vertices[i].position);
  }
  return length;
}
var Vertex = class {
  constructor(properties) {
    for (const [key, value] of Object.entries(properties)) {
      this[key] = value;
    }
  }
  /*
  get array() {
    // convert to 1D array
    // call `toArray()` if value is an object with a toArray() method
    // handle primitive values separately
    // maybe handle object literals too, with Object.values()?
    // probably don’t need anything else for now?
  }
  */
  // TODO: make sure name of array conversion method is
  // consistent with any modifications to the names of corresponding
  // properties of p5.Vector and p5.Color
};
var ShapePrimitive = class _ShapePrimitive {
  constructor(...vertices) {
    __publicField(this, "vertices");
    __publicField(this, "_shape", null);
    __publicField(this, "_primitivesIndex", null);
    __publicField(this, "_contoursIndex", null);
    __publicField(this, "isClosing", false);
    if (this.constructor === _ShapePrimitive) {
      throw new Error("ShapePrimitive is an abstract class: it cannot be instantiated.");
    }
    if (vertices.length > 0) {
      this.vertices = vertices;
    } else {
      throw new Error("At least one vertex must be passed to the constructor.");
    }
  }
  get vertexCount() {
    return this.vertices.length;
  }
  get vertexCapacity() {
    throw new Error("Getter vertexCapacity must be implemented.");
  }
  get _firstInterpolatedVertex() {
    return this.startVertex();
  }
  get canOverrideAnchor() {
    return false;
  }
  accept(visitor) {
    throw new Error("Method accept() must be implemented.");
  }
  addToShape(shape2) {
    let lastContour = shape2.at(-1);
    if (lastContour.primitives.length === 0) {
      lastContour.primitives.push(this);
    } else {
      let lastPrimitive = shape2.at(-1, -1);
      let hasSameType = lastPrimitive instanceof this.constructor;
      let spareCapacity = lastPrimitive.vertexCapacity - lastPrimitive.vertexCount;
      let pushableVertices;
      let remainingVertices;
      if (hasSameType && spareCapacity > 0) {
        pushableVertices = this.vertices.splice(0, spareCapacity);
        remainingVertices = this.vertices;
        lastPrimitive.vertices.push(...pushableVertices);
        if (remainingVertices.length > 0) {
          lastContour.primitives.push(this);
        }
      } else {
        lastContour.primitives.push(this);
      }
    }
    let addedToShape = this.vertices.length > 0;
    if (addedToShape) {
      let lastContour2 = shape2.at(-1);
      this._primitivesIndex = lastContour2.primitives.length - 1;
      this._contoursIndex = shape2.contours.length - 1;
      this._shape = shape2;
    }
    return shape2.at(-1, -1);
  }
  get _nextPrimitive() {
    return this._belongsToShape ? this._shape.at(this._contoursIndex, this._primitivesIndex + 1) : null;
  }
  get _belongsToShape() {
    return this._shape !== null;
  }
  handlesClose() {
    return false;
  }
  close(vertex2) {
    throw new Error("Unimplemented!");
  }
};
var _kind;
var Contour = class {
  constructor(kind = PATH) {
    __privateAdd(this, _kind);
    __publicField(this, "primitives");
    __privateSet(this, _kind, kind);
    this.primitives = [];
  }
  get kind() {
    const isEmpty = this.primitives.length === 0;
    const isPath = __privateGet(this, _kind) === PATH;
    return isEmpty && isPath ? EMPTY_PATH : __privateGet(this, _kind);
  }
  accept(visitor) {
    for (const primitive of this.primitives) {
      primitive.accept(visitor);
    }
  }
};
_kind = new WeakMap();
var _vertexCapacity;
var Anchor = class extends ShapePrimitive {
  constructor() {
    super(...arguments);
    __privateAdd(this, _vertexCapacity, 1);
  }
  get vertexCapacity() {
    return __privateGet(this, _vertexCapacity);
  }
  accept(visitor) {
    visitor.visitAnchor(this);
  }
  getEndVertex() {
    return this.vertices[0];
  }
};
_vertexCapacity = new WeakMap();
var Segment = class _Segment extends ShapePrimitive {
  constructor(...vertices) {
    super(...vertices);
    if (this.constructor === _Segment) {
      throw new Error("Segment is an abstract class: it cannot be instantiated.");
    }
  }
  // segments in a shape always have a predecessor
  // (either an anchor or another segment)
  get _previousPrimitive() {
    return this._belongsToShape ? this._shape.at(this._contoursIndex, this._primitivesIndex - 1) : null;
  }
  getStartVertex() {
    return this._previousPrimitive.getEndVertex();
  }
  getEndVertex() {
    return this.vertices.at(-1);
  }
};
var _vertexCapacity2;
var LineSegment = class extends Segment {
  constructor() {
    super(...arguments);
    __privateAdd(this, _vertexCapacity2, 1);
  }
  get vertexCapacity() {
    return __privateGet(this, _vertexCapacity2);
  }
  accept(visitor) {
    visitor.visitLineSegment(this);
  }
};
_vertexCapacity2 = new WeakMap();
var _order, _vertexCapacity3, __hullLength;
var BezierSegment = class extends Segment {
  constructor(order, ...vertices) {
    super(...vertices);
    __privateAdd(this, _order);
    __privateAdd(this, _vertexCapacity3);
    __privateAdd(this, __hullLength);
    let numericalOrder = Array.isArray(order) ? order[0] : order;
    __privateSet(this, _order, numericalOrder);
    __privateSet(this, _vertexCapacity3, numericalOrder);
  }
  get order() {
    return __privateGet(this, _order);
  }
  get vertexCapacity() {
    return __privateGet(this, _vertexCapacity3);
  }
  hullLength() {
    if (__privateGet(this, __hullLength) === void 0) {
      __privateSet(this, __hullLength, polylineLength([
        this.getStartVertex(),
        ...this.vertices
      ]));
    }
    return __privateGet(this, __hullLength);
  }
  accept(visitor) {
    visitor.visitBezierSegment(this);
  }
};
_order = new WeakMap();
_vertexCapacity3 = new WeakMap();
__hullLength = new WeakMap();
var _vertexCapacity4;
var SplineSegment = class extends Segment {
  constructor() {
    super(...arguments);
    __privateAdd(this, _vertexCapacity4, Infinity);
    __publicField(this, "_splineProperties", {
      ends: INCLUDE,
      tightness: 0
    });
  }
  get vertexCapacity() {
    return __privateGet(this, _vertexCapacity4);
  }
  accept(visitor) {
    visitor.visitSplineSegment(this);
  }
  get _comesAfterSegment() {
    return this._previousPrimitive instanceof Segment;
  }
  get canOverrideAnchor() {
    return this._splineProperties.ends === EXCLUDE;
  }
  // assuming for now that the first interpolated vertex is always
  // the second vertex passed to splineVertex()
  // if this spline segment doesn't follow another segment,
  // the first vertex is in an anchor
  get _firstInterpolatedVertex() {
    if (this._splineProperties.ends === EXCLUDE) {
      return this._comesAfterSegment ? this.vertices[1] : this.vertices[0];
    } else {
      return this.getStartVertex();
    }
  }
  get _chainedToSegment() {
    if (this._belongsToShape && this._comesAfterSegment) {
      let interpolatedStartPosition = this._firstInterpolatedVertex.position;
      let predecessorEndPosition = this.getStartVertex().position;
      return predecessorEndPosition.equals(interpolatedStartPosition);
    } else {
      return false;
    }
  }
  // extend addToShape() with a warning in case second vertex
  // doesn't line up with end of last segment
  addToShape(shape2) {
    const added = super.addToShape(shape2);
    this._splineProperties.ends = shape2._splineProperties.ends;
    this._splineProperties.tightness = shape2._splineProperties.tightness;
    if (this._splineProperties.ends !== EXCLUDE) return added;
    let verticesPushed = !this._belongsToShape;
    let lastPrimitive = shape2.at(-1, -1);
    let message = (array1, array2) => `Spline does not start where previous path segment ends:
      second spline vertex at (${array1})
      expected to be at (${array2}).`;
    if (verticesPushed && // Only check once the first interpolated vertex has been added
    lastPrimitive.vertices.length === 2 && lastPrimitive._comesAfterSegment && !lastPrimitive._chainedToSegment) {
      let interpolatedStart = lastPrimitive._firstInterpolatedVertex.position;
      let predecessorEnd = lastPrimitive.getStartVertex().position;
      console.warn(
        message(interpolatedStart.array(), predecessorEnd.array())
      );
    }
    return added;
  }
  // override method on base class
  getEndVertex() {
    if (this._splineProperties.ends === INCLUDE) {
      return super.getEndVertex();
    } else if (this._splineProperties.ends === EXCLUDE) {
      return this.vertices.at(-2);
    } else {
      return this.getStartVertex();
    }
  }
  getControlPoints() {
    let points = [];
    if (this._comesAfterSegment) {
      points.push(this.getStartVertex());
    }
    points.push(this.getStartVertex());
    for (const vertex2 of this.vertices) {
      points.push(vertex2);
    }
    const prevVertex = this.getStartVertex();
    if (this._splineProperties.ends === INCLUDE) {
      points.unshift(prevVertex);
      points.push(this.vertices.at(-1));
    } else if (this._splineProperties.ends === JOIN) {
      points.unshift(this.vertices.at(-1));
      points.push(prevVertex, this.vertices.at(0));
    }
    return points;
  }
  handlesClose() {
    if (!this._belongsToShape) return false;
    const contour = this._shape.at(this._contoursIndex);
    return contour.primitives.length === 2 && this._primitivesIndex === 1;
  }
  close() {
    this._splineProperties.ends = JOIN;
  }
};
_vertexCapacity4 = new WeakMap();
var _vertexCapacity5;
var Point = class extends ShapePrimitive {
  constructor() {
    super(...arguments);
    __privateAdd(this, _vertexCapacity5, 1);
  }
  get vertexCapacity() {
    return __privateGet(this, _vertexCapacity5);
  }
  accept(visitor) {
    visitor.visitPoint(this);
  }
};
_vertexCapacity5 = new WeakMap();
var _vertexCapacity6;
var Line = class extends ShapePrimitive {
  constructor() {
    super(...arguments);
    __privateAdd(this, _vertexCapacity6, 2);
  }
  get vertexCapacity() {
    return __privateGet(this, _vertexCapacity6);
  }
  accept(visitor) {
    visitor.visitLine(this);
  }
};
_vertexCapacity6 = new WeakMap();
var _vertexCapacity7;
var Triangle = class extends ShapePrimitive {
  constructor() {
    super(...arguments);
    __privateAdd(this, _vertexCapacity7, 3);
  }
  get vertexCapacity() {
    return __privateGet(this, _vertexCapacity7);
  }
  accept(visitor) {
    visitor.visitTriangle(this);
  }
};
_vertexCapacity7 = new WeakMap();
var _vertexCapacity8;
var Quad = class extends ShapePrimitive {
  constructor() {
    super(...arguments);
    __privateAdd(this, _vertexCapacity8, 4);
  }
  get vertexCapacity() {
    return __privateGet(this, _vertexCapacity8);
  }
  accept(visitor) {
    visitor.visitQuad(this);
  }
};
_vertexCapacity8 = new WeakMap();
var _vertexCapacity9;
var TriangleFan = class extends ShapePrimitive {
  constructor() {
    super(...arguments);
    __privateAdd(this, _vertexCapacity9, Infinity);
  }
  get vertexCapacity() {
    return __privateGet(this, _vertexCapacity9);
  }
  accept(visitor) {
    visitor.visitTriangleFan(this);
  }
};
_vertexCapacity9 = new WeakMap();
var _vertexCapacity10;
var TriangleStrip = class extends ShapePrimitive {
  constructor() {
    super(...arguments);
    __privateAdd(this, _vertexCapacity10, Infinity);
  }
  get vertexCapacity() {
    return __privateGet(this, _vertexCapacity10);
  }
  accept(visitor) {
    visitor.visitTriangleStrip(this);
  }
};
_vertexCapacity10 = new WeakMap();
var _vertexCapacity11;
var QuadStrip = class extends ShapePrimitive {
  constructor() {
    super(...arguments);
    __privateAdd(this, _vertexCapacity11, Infinity);
  }
  get vertexCapacity() {
    return __privateGet(this, _vertexCapacity11);
  }
  accept(visitor) {
    visitor.visitQuadStrip(this);
  }
};
_vertexCapacity11 = new WeakMap();
var PrimitiveShapeCreators = class {
  constructor() {
    // TODO: make creators private?
    // That'd probably be better, but for now, it may be convenient to use
    // native Map properties like size, e.g. for testing, and it's simpler to
    // not have to wrap all the properties that might be useful
    __publicField(this, "creators");
    let creators = /* @__PURE__ */ new Map();
    creators.set(`vertex-${EMPTY_PATH}`, (...vertices) => new Anchor(...vertices));
    creators.set(`vertex-${PATH}`, (...vertices) => new LineSegment(...vertices));
    creators.set(`vertex-${POINTS}`, (...vertices) => new Point(...vertices));
    creators.set(`vertex-${LINES}`, (...vertices) => new Line(...vertices));
    creators.set(`vertex-${TRIANGLES}`, (...vertices) => new Triangle(...vertices));
    creators.set(`vertex-${QUADS}`, (...vertices) => new Quad(...vertices));
    creators.set(`vertex-${TRIANGLE_FAN}`, (...vertices) => new TriangleFan(...vertices));
    creators.set(`vertex-${TRIANGLE_STRIP}`, (...vertices) => new TriangleStrip(...vertices));
    creators.set(`vertex-${QUAD_STRIP}`, (...vertices) => new QuadStrip(...vertices));
    creators.set(`bezierVertex-${EMPTY_PATH}`, (order, ...vertices) => new Anchor(...vertices));
    creators.set(`bezierVertex-${PATH}`, (order, ...vertices) => new BezierSegment(order, ...vertices));
    creators.set(`splineVertex-${EMPTY_PATH}`, (...vertices) => new Anchor(...vertices));
    creators.set(`splineVertex-${PATH}`, (...vertices) => new SplineSegment(...vertices));
    this.creators = creators;
  }
  get(vertexKind, shapeKind) {
    const key = `${vertexKind}-${shapeKind}`;
    return this.creators.get(key);
  }
  set(vertexKind, shapeKind, creator) {
    const key = `${vertexKind}-${shapeKind}`;
    this.creators.set(key, creator);
  }
  clear() {
    this.creators.clear();
  }
};
var _vertexProperties, _initialVertexProperties, _primitiveShapeCreators, _bezierOrder, _Shape_instances, createVertex_fn, createPrimitiveShape_fn, generalVertex_fn;
var Shape = class {
  constructor(vertexProperties, primitiveShapeCreators = new PrimitiveShapeCreators()) {
    __privateAdd(this, _Shape_instances);
    __privateAdd(this, _vertexProperties);
    __privateAdd(this, _initialVertexProperties);
    __privateAdd(this, _primitiveShapeCreators);
    __privateAdd(this, _bezierOrder, 3);
    __publicField(this, "kind", null);
    __publicField(this, "contours", []);
    __publicField(this, "_splineProperties", {
      tightness: 0,
      ends: INCLUDE
    });
    __publicField(this, "userVertexProperties", null);
    __privateSet(this, _initialVertexProperties, vertexProperties);
    __privateSet(this, _vertexProperties, vertexProperties);
    __privateSet(this, _primitiveShapeCreators, primitiveShapeCreators);
    for (const key in __privateGet(this, _vertexProperties)) {
      if (key !== "position" && key !== "textureCoordinates") {
        this[key] = function(value) {
          __privateGet(this, _vertexProperties)[key] = value;
        };
      }
    }
  }
  serializeToArray(val2) {
    if (val2 === null || val2 === void 0) {
      return [];
    }
    if (val2 instanceof Number) {
      return [val2];
    } else if (val2 instanceof Array) {
      return val2;
    } else if (val2.array instanceof Function) {
      return val2.array();
    } else {
      throw new Error(`Can't convert ${val2} to array!`);
    }
  }
  vertexToArray(vertex2) {
    const array2 = [];
    for (const key in __privateGet(this, _vertexProperties)) {
      if (this.userVertexProperties && key in this.userVertexProperties)
        continue;
      const val2 = vertex2[key];
      array2.push(...this.serializeToArray(val2));
    }
    for (const key in this.userVertexProperties) {
      if (key in vertex2) {
        array2.push(...this.serializeToArray(vertex2[key]));
      } else {
        array2.push(...new Array(this.userVertexProperties[key]).fill(0));
      }
    }
    return array2;
  }
  hydrateValue(queue, original) {
    if (original === null) {
      return null;
    } else if (original instanceof Number) {
      return queue.shift();
    } else if (original instanceof Array) {
      const array2 = [];
      for (let i = 0; i < original.length; i++) {
        array2.push(queue.shift());
      }
      return array2;
    } else if (original instanceof Vector) {
      return new Vector(queue.shift(), queue.shift(), queue.shift());
    } else if (original instanceof Color) {
      const array2 = [
        queue.shift(),
        queue.shift(),
        queue.shift(),
        queue.shift()
      ];
      return new Color(array2);
    }
  }
  arrayToVertex(array2) {
    const vertex2 = {};
    const queue = [...array2];
    for (const key in __privateGet(this, _vertexProperties)) {
      if (this.userVertexProperties && key in this.userVertexProperties)
        continue;
      const original = __privateGet(this, _vertexProperties)[key];
      vertex2[key] = this.hydrateValue(queue, original);
    }
    for (const key in this.userVertexProperties) {
      const original = __privateGet(this, _vertexProperties)[key];
      vertex2[key] = this.hydrateValue(queue, original);
    }
    return vertex2;
  }
  arrayScale(array2, scale2) {
    return array2.map((v) => v * scale2);
  }
  arraySum(first, ...rest) {
    return first.map((v, i) => {
      let result = v;
      for (let j2 = 0; j2 < rest.length; j2++) {
        result += rest[j2][i];
      }
      return result;
    });
  }
  arrayMinus(a2, b3) {
    return a2.map((v, i) => v - b3[i]);
  }
  evaluateCubicBezier([a2, b3, c4, d2], t) {
    return this.arraySum(
      this.arrayScale(a2, Math.pow(1 - t, 3)),
      this.arrayScale(b3, 3 * Math.pow(1 - t, 2) * t),
      this.arrayScale(c4, 3 * (1 - t) * Math.pow(t, 2)),
      this.arrayScale(d2, Math.pow(t, 3))
    );
  }
  evaluateQuadraticBezier([a2, b3, c4], t) {
    return this.arraySum(
      this.arrayScale(a2, Math.pow(1 - t, 2)),
      this.arrayScale(b3, 2 * (1 - t) * t),
      this.arrayScale(c4, t * t)
    );
  }
  /*
    catmullRomToBezier(vertices, tightness)

    Abbreviated description:
    Converts a Catmull-Rom spline to a sequence of Bezier curveTo points.

    Parameters:
    vertices -> Array [v0, v1, v2, v3, ...] of at least four vertices
    tightness -> Number affecting shape of curve

    Returns:
    array of Bezier curveTo control points, each represented as [c1, c2, c3][]

    TODO:
    1. It seems p5 contains code for converting from Catmull-Rom to Bezier in at least two places:

    catmullRomToBezier() is based on code in the legacy endShape() function:
    https://github.com/processing/p5.js/blob/1b66f097761d3c2057c0cec4349247d6125f93ca/src/core/p5.Renderer2D.js#L859C1-L886C1

    A different conversion can be found elsewhere in p5:
    https://github.com/processing/p5.js/blob/17304ce9e9ef3f967bd828102a51b62a2d39d4f4/src/typography/p5.Font.js#L1179

    A more careful review and comparison of both implementations would be helpful. They're different. I put
    catmullRomToBezier() together quickly without checking the math/algorithm, when I made the proof of concept
    for the refactor.

    2. It may be possible to replace the code in p5.Font.js with the code here, to reduce duplication.
    */
  catmullRomToBezier(vertices, tightness) {
    let s = 1 - tightness;
    let bezArrays = [];
    for (let i = 0; i + 3 < vertices.length; i++) {
      const [a2, b3, c4, d2] = vertices.slice(i, i + 4);
      const bezB = this.arraySum(
        b3,
        this.arrayScale(this.arrayMinus(c4, a2), s / 6)
      );
      const bezC = this.arraySum(
        c4,
        this.arrayScale(this.arrayMinus(b3, d2), s / 6)
      );
      const bezD = c4;
      bezArrays.push([bezB, bezC, bezD]);
    }
    return bezArrays;
  }
  // TODO for at() method:
  // RENAME?
  // -at() indicates it works like Array.prototype.at(), e.g. with negative indices
  // -get() may work better if we want to add a corresponding set() method
  // -a set() method could maybe check for problematic usage (e.g. inserting a Triangle into a PATH)
  // -renaming or removing would necessitate changes at call sites (it's already in use)
  // REFACTOR?
  // TEST
  at(contoursIndex, primitivesIndex, verticesIndex) {
    let contour;
    let primitive;
    contour = this.contours.at(contoursIndex);
    switch (arguments.length) {
      case 1:
        return contour;
      case 2:
        return contour.primitives.at(primitivesIndex);
      case 3:
        primitive = contour.primitives.at(primitivesIndex);
        return primitive.vertices.at(verticesIndex);
    }
  }
  // maybe call this clear() for consistency with PrimitiveShapeCreators.clear()?
  // note: p5.Geometry has a reset() method, but also clearColors()
  // looks like reset() isn't in the public reference, so maybe we can switch
  // everything to clear()? Not sure if reset/clear is used in other classes,
  // but it'd be good if geometries and shapes are consistent
  reset() {
    __privateSet(this, _vertexProperties, { ...__privateGet(this, _initialVertexProperties) });
    this.kind = null;
    this.contours = [];
    this.userVertexProperties = null;
  }
  vertexProperty(name, data3) {
    this.userVertexProperties = this.userVertexProperties || {};
    const key = this.vertexPropertyKey(name);
    const dataArray2 = Array.isArray(data3) ? data3 : [data3];
    if (!this.userVertexProperties[key]) {
      this.userVertexProperties[key] = dataArray2.length;
    }
    __privateGet(this, _vertexProperties)[key] = dataArray2;
  }
  vertexPropertyName(key) {
    return key.replace(/Src$/, "");
  }
  vertexPropertyKey(name) {
    return name + "Src";
  }
  bezierOrder(...order) {
    __privateSet(this, _bezierOrder, order);
  }
  splineProperty(key, value) {
    this._splineProperties[key] = value;
  }
  splineProperties(values) {
    if (values) {
      for (const key in values) {
        this.splineProperty(key, values[key]);
      }
    } else {
      return this._splineProperties;
    }
  }
  vertex(position, textureCoordinates, { isClosing = false } = {}) {
    const added = __privateMethod(this, _Shape_instances, generalVertex_fn).call(this, "vertex", position, textureCoordinates);
    added.isClosing = isClosing;
  }
  bezierVertex(position, textureCoordinates) {
    __privateMethod(this, _Shape_instances, generalVertex_fn).call(this, "bezierVertex", position, textureCoordinates);
  }
  splineVertex(position, textureCoordinates) {
    __privateMethod(this, _Shape_instances, generalVertex_fn).call(this, "splineVertex", position, textureCoordinates);
  }
  arcVertex(position, textureCoordinates) {
    __privateMethod(this, _Shape_instances, generalVertex_fn).call(this, "arcVertex", position, textureCoordinates);
  }
  beginContour(shapeKind = PATH) {
    var _a2;
    if (((_a2 = this.at(-1)) == null ? void 0 : _a2.kind) === EMPTY_PATH) {
      this.contours.pop();
    }
    this.contours.push(new Contour(shapeKind));
  }
  endContour(closeMode = OPEN, _index = this.contours.length - 1) {
    const contour = this.at(_index);
    if (closeMode === CLOSE) {
      const isPath = contour.kind === PATH;
      const anchorVertex = this.at(_index, 0, 0);
      const anchorHasPosition = Object.hasOwn(anchorVertex, "position");
      const lastSegment = this.at(_index, -1);
      if (isPath && anchorHasPosition) {
        if (lastSegment.handlesClose()) {
          lastSegment.close(anchorVertex);
        } else {
          const rest = this.contours.splice(
            _index + 1,
            this.contours.length - _index - 1
          );
          const prevVertexProperties = __privateGet(this, _vertexProperties);
          __privateSet(this, _vertexProperties, { ...prevVertexProperties });
          for (const key in anchorVertex) {
            if (["position", "textureCoordinates"].includes(key)) continue;
            __privateGet(this, _vertexProperties)[key] = anchorVertex[key];
          }
          this.vertex(
            anchorVertex.position,
            anchorVertex.textureCoordinates,
            { isClosing: true }
          );
          __privateSet(this, _vertexProperties, prevVertexProperties);
          this.contours.push(...rest);
        }
      }
    }
  }
  beginShape(shapeKind = PATH) {
    this.kind = shapeKind;
    this.beginContour(shapeKind);
  }
  /* TO-DO:
     Refactor?
     - Might not need anchorHasPosition.
     - Might combine conditions at top, and rely on shortcircuiting.
     Does nothing if shape is not a path or has multiple contours. Might discuss this.
  */
  endShape(closeMode = OPEN) {
    if (closeMode === CLOSE) {
      this.endContour(closeMode, 0);
    }
  }
  accept(visitor) {
    for (const contour of this.contours) {
      contour.accept(visitor);
    }
  }
};
_vertexProperties = new WeakMap();
_initialVertexProperties = new WeakMap();
_primitiveShapeCreators = new WeakMap();
_bezierOrder = new WeakMap();
_Shape_instances = new WeakSet();
/*
To-do: Maybe refactor #createVertex() since this has side effects that aren't advertised
in the method name?
*/
createVertex_fn = function(position, textureCoordinates) {
  __privateGet(this, _vertexProperties).position = position;
  if (textureCoordinates !== void 0) {
    __privateGet(this, _vertexProperties).textureCoordinates = textureCoordinates;
  }
  return new Vertex(__privateGet(this, _vertexProperties));
};
createPrimitiveShape_fn = function(vertexKind, shapeKind, ...vertices) {
  let primitiveShapeCreator = __privateGet(this, _primitiveShapeCreators).get(
    vertexKind,
    shapeKind
  );
  return vertexKind === "bezierVertex" ? primitiveShapeCreator(__privateGet(this, _bezierOrder), ...vertices) : primitiveShapeCreator(...vertices);
};
/*
    #generalVertex() is reused by the special vertex functions,
    including vertex(), bezierVertex(), splineVertex(), and arcVertex():

    It creates a vertex, builds a primitive including that
    vertex, and has the primitive add itself to the shape.
  */
generalVertex_fn = function(kind, position, textureCoordinates) {
  let vertexKind = kind;
  let lastContourKind = this.at(-1).kind;
  let vertex2 = __privateMethod(this, _Shape_instances, createVertex_fn).call(this, position, textureCoordinates);
  let primitiveShape = __privateMethod(this, _Shape_instances, createPrimitiveShape_fn).call(this, vertexKind, lastContourKind, vertex2);
  return primitiveShape.addToShape(this);
};
var PrimitiveVisitor = class _PrimitiveVisitor {
  constructor() {
    if (this.constructor === _PrimitiveVisitor) {
      throw new Error("PrimitiveVisitor is an abstract class: it cannot be instantiated.");
    }
  }
  // path primitives
  visitAnchor(anchor) {
    throw new Error("Method visitAnchor() has not been implemented.");
  }
  visitLineSegment(lineSegment) {
    throw new Error("Method visitLineSegment() has not been implemented.");
  }
  visitBezierSegment(bezierSegment) {
    throw new Error("Method visitBezierSegment() has not been implemented.");
  }
  visitSplineSegment(curveSegment) {
    throw new Error("Method visitSplineSegment() has not been implemented.");
  }
  visitArcSegment(arcSegment) {
    throw new Error("Method visitArcSegment() has not been implemented.");
  }
  // isolated primitives
  visitPoint(point) {
    throw new Error("Method visitPoint() has not been implemented.");
  }
  visitLine(line) {
    throw new Error("Method visitLine() has not been implemented.");
  }
  visitTriangle(triangle) {
    throw new Error("Method visitTriangle() has not been implemented.");
  }
  visitQuad(quad) {
    throw new Error("Method visitQuad() has not been implemented.");
  }
  // tessellation primitives
  visitTriangleFan(triangleFan) {
    throw new Error("Method visitTriangleFan() has not been implemented.");
  }
  visitTriangleStrip(triangleStrip) {
    throw new Error("Method visitTriangleStrip() has not been implemented.");
  }
  visitQuadStrip(quadStrip) {
    throw new Error("Method visitQuadStrip() has not been implemented.");
  }
};
var PrimitiveToPath2DConverter = class extends PrimitiveVisitor {
  constructor({ strokeWeight }) {
    super();
    __publicField(this, "path", new Path2D());
    __publicField(this, "strokeWeight");
    this.strokeWeight = strokeWeight;
  }
  // path primitives
  visitAnchor(anchor) {
    let vertex2 = anchor.getEndVertex();
    this.path.moveTo(vertex2.position.x, vertex2.position.y);
  }
  visitLineSegment(lineSegment) {
    if (lineSegment.isClosing) {
      this.path.closePath();
    } else {
      let vertex2 = lineSegment.getEndVertex();
      this.path.lineTo(vertex2.position.x, vertex2.position.y);
    }
  }
  visitBezierSegment(bezierSegment) {
    let [v1, v2, v3] = bezierSegment.vertices;
    switch (bezierSegment.order) {
      case 2:
        this.path.quadraticCurveTo(
          v1.position.x,
          v1.position.y,
          v2.position.x,
          v2.position.y
        );
        break;
      case 3:
        this.path.bezierCurveTo(
          v1.position.x,
          v1.position.y,
          v2.position.x,
          v2.position.y,
          v3.position.x,
          v3.position.y
        );
        break;
    }
  }
  visitSplineSegment(splineSegment) {
    const shape2 = splineSegment._shape;
    if (splineSegment._splineProperties.ends === EXCLUDE && !splineSegment._comesAfterSegment) {
      let startVertex = splineSegment._firstInterpolatedVertex;
      this.path.moveTo(startVertex.position.x, startVertex.position.y);
    }
    const arrayVertices = splineSegment.getControlPoints().map(
      (v) => shape2.vertexToArray(v)
    );
    let bezierArrays = shape2.catmullRomToBezier(
      arrayVertices,
      splineSegment._splineProperties.tightness
    ).map((arr2) => arr2.map((vertArr) => shape2.arrayToVertex(vertArr)));
    for (const array2 of bezierArrays) {
      const points = array2.flatMap((vert) => [vert.position.x, vert.position.y]);
      this.path.bezierCurveTo(...points);
    }
  }
  visitPoint(point) {
    const { x, y } = point.vertices[0].position;
    this.path.moveTo(x, y);
    this.path.lineTo(x + 1e-5, y);
  }
  visitLine(line) {
    const { x: x0, y: y0 } = line.vertices[0].position;
    const { x: x1, y: y1 } = line.vertices[1].position;
    this.path.moveTo(x0, y0);
    this.path.lineTo(x1, y1);
  }
  visitTriangle(triangle) {
    const [v0, v1, v2] = triangle.vertices;
    this.path.moveTo(v0.position.x, v0.position.y);
    this.path.lineTo(v1.position.x, v1.position.y);
    this.path.lineTo(v2.position.x, v2.position.y);
    this.path.closePath();
  }
  visitQuad(quad) {
    const [v0, v1, v2, v3] = quad.vertices;
    this.path.moveTo(v0.position.x, v0.position.y);
    this.path.lineTo(v1.position.x, v1.position.y);
    this.path.lineTo(v2.position.x, v2.position.y);
    this.path.lineTo(v3.position.x, v3.position.y);
    this.path.closePath();
  }
  visitTriangleFan(triangleFan) {
    const [v0, ...rest] = triangleFan.vertices;
    for (let i = 0; i < rest.length - 1; i++) {
      const v1 = rest[i];
      const v2 = rest[i + 1];
      this.path.moveTo(v0.position.x, v0.position.y);
      this.path.lineTo(v1.position.x, v1.position.y);
      this.path.lineTo(v2.position.x, v2.position.y);
      this.path.closePath();
    }
  }
  visitTriangleStrip(triangleStrip) {
    for (let i = 0; i < triangleStrip.vertices.length - 2; i++) {
      const v0 = triangleStrip.vertices[i];
      const v1 = triangleStrip.vertices[i + 1];
      const v2 = triangleStrip.vertices[i + 2];
      this.path.moveTo(v0.position.x, v0.position.y);
      this.path.lineTo(v1.position.x, v1.position.y);
      this.path.lineTo(v2.position.x, v2.position.y);
      this.path.closePath();
    }
  }
  visitQuadStrip(quadStrip) {
    for (let i = 0; i < quadStrip.vertices.length - 3; i += 2) {
      const v0 = quadStrip.vertices[i];
      const v1 = quadStrip.vertices[i + 1];
      const v2 = quadStrip.vertices[i + 2];
      const v3 = quadStrip.vertices[i + 3];
      this.path.moveTo(v0.position.x, v0.position.y);
      this.path.lineTo(v1.position.x, v1.position.y);
      this.path.lineTo(v3.position.x, v3.position.y);
      this.path.lineTo(v2.position.x, v2.position.y);
      this.path.closePath();
    }
  }
};
var PrimitiveToVerticesConverter = class extends PrimitiveVisitor {
  constructor({ curveDetail = 1 } = {}) {
    super();
    __publicField(this, "contours", []);
    __publicField(this, "curveDetail");
    this.curveDetail = curveDetail;
  }
  lastContour() {
    return this.contours[this.contours.length - 1];
  }
  visitAnchor(anchor) {
    this.contours.push([]);
    const next = anchor._nextPrimitive;
    if (next == null ? void 0 : next.canOverrideAnchor) {
      this.lastContour().push(next._firstInterpolatedVertex);
    } else {
      this.lastContour().push(anchor.getEndVertex());
    }
  }
  visitLineSegment(lineSegment) {
    this.lastContour().push(lineSegment.getEndVertex());
  }
  visitBezierSegment(bezierSegment) {
    const contour = this.lastContour();
    const numPoints = Math.max(
      1,
      Math.ceil(bezierSegment.hullLength() * this.curveDetail)
    );
    const vertexArrays = [
      bezierSegment.getStartVertex(),
      ...bezierSegment.vertices
    ].map((v) => bezierSegment._shape.vertexToArray(v));
    for (let i = 0; i < numPoints; i++) {
      const t = (i + 1) / numPoints;
      contour.push(
        bezierSegment._shape.arrayToVertex(
          bezierSegment.order === 3 ? bezierSegment._shape.evaluateCubicBezier(vertexArrays, t) : bezierSegment._shape.evaluateQuadraticBezier(vertexArrays, t)
        )
      );
    }
  }
  visitSplineSegment(splineSegment) {
    const shape2 = splineSegment._shape;
    const contour = this.lastContour();
    const arrayVertices = splineSegment.getControlPoints().map(
      (v) => shape2.vertexToArray(v)
    );
    let bezierArrays = shape2.catmullRomToBezier(
      arrayVertices,
      splineSegment._splineProperties.tightness
    );
    let startVertex = shape2.vertexToArray(splineSegment._firstInterpolatedVertex);
    for (const array2 of bezierArrays) {
      const bezierControls = [startVertex, ...array2];
      const numPoints = Math.max(
        1,
        Math.ceil(
          polylineLength(bezierControls.map((v) => shape2.arrayToVertex(v))) * this.curveDetail
        )
      );
      for (let i = 0; i < numPoints; i++) {
        const t = (i + 1) / numPoints;
        contour.push(
          shape2.arrayToVertex(shape2.evaluateCubicBezier(bezierControls, t))
        );
      }
      startVertex = array2[2];
    }
  }
  visitPoint(point) {
    this.contours.push(point.vertices.slice());
  }
  visitLine(line) {
    this.contours.push(line.vertices.slice());
  }
  visitTriangle(triangle) {
    this.contours.push(triangle.vertices.slice());
  }
  visitQuad(quad) {
    this.contours.push(quad.vertices.slice());
  }
  visitTriangleFan(triangleFan) {
    this.contours.push(triangleFan.vertices.slice());
  }
  visitTriangleStrip(triangleStrip) {
    this.contours.push(triangleStrip.vertices.slice());
  }
  visitQuadStrip(quadStrip) {
    this.contours.push(quadStrip.vertices.slice());
  }
};
var PointAtLengthGetter = class extends PrimitiveVisitor {
  constructor() {
    super();
  }
};
function customShapes(p53, fn2) {
  p53.Shape = Shape;
  p53.Contour = Contour;
  p53.ShapePrimitive = ShapePrimitive;
  p53.Vertex = Vertex;
  p53.Anchor = Anchor;
  p53.Segment = Segment;
  p53.LineSegment = LineSegment;
  p53.BezierSegment = BezierSegment;
  p53.SplineSegment = SplineSegment;
  p53.Point = Point;
  p53.Line = Line;
  p53.Triangle = Triangle;
  p53.Quad = Quad;
  p53.TriangleFan = TriangleFan;
  p53.TriangleStrip = TriangleStrip;
  p53.QuadStrip = QuadStrip;
  p53.PrimitiveVisitor = PrimitiveVisitor;
  p53.PrimitiveToPath2DConverter = PrimitiveToPath2DConverter;
  p53.PrimitiveToVerticesConverter = PrimitiveToVerticesConverter;
  p53.PointAtLengthGetter = PointAtLengthGetter;
  fn2.bezierOrder = function(order) {
    return this._renderer.bezierOrder(order);
  };
  fn2.splineVertex = function(...args) {
    let x = 0, y = 0, z = 0, u = 0, v = 0;
    if (args.length === 2) {
      [x, y] = args;
    } else if (args.length === 4) {
      [x, y, u, v] = args;
    } else if (args.length === 3) {
      [x, y, z] = args;
    } else if (args.length === 5) {
      [x, y, z, u, v] = args;
    }
    this._renderer.splineVertex(x, y, z, u, v);
  };
  fn2.splineProperty = function(property, value) {
    return this._renderer.splineProperty(property, value);
  };
  fn2.splineProperties = function(values) {
    return this._renderer.splineProperties(values);
  };
  fn2.vertex = function(x, y) {
    let z, u, v;
    z = u = v = 0;
    if (arguments.length === 3) {
      z = arguments[2];
    } else if (arguments.length === 4) {
      u = arguments[2];
      v = arguments[3];
    } else if (arguments.length === 5) {
      z = arguments[2];
      u = arguments[3];
      v = arguments[4];
    }
    this._renderer.vertex(x, y, z, u, v);
    return;
  };
  fn2.beginContour = function(kind) {
    this._renderer.beginContour(kind);
  };
  fn2.endContour = function(mode = OPEN) {
    this._renderer.endContour(mode);
  };
}
if (typeof p5 !== "undefined") {
  customShapes(p5, p5.prototype);
}

// node_modules/p5/dist/core/States.js
var _modified;
var States = class {
  constructor(initialState) {
    __privateAdd(this, _modified, {});
    for (const key in initialState) {
      this[key] = initialState[key];
    }
  }
  setValue(key, value) {
    if (!(key in __privateGet(this, _modified))) {
      __privateGet(this, _modified)[key] = this[key];
    }
    this[key] = value;
  }
  getDiff() {
    const diff = __privateGet(this, _modified);
    __privateSet(this, _modified, {});
    return diff;
  }
  getModified() {
    return __privateGet(this, _modified);
  }
  applyDiff(prevModified) {
    for (const key in __privateGet(this, _modified)) {
      this[key] = __privateGet(this, _modified)[key];
    }
    __privateSet(this, _modified, prevModified);
  }
};
_modified = new WeakMap();

// node_modules/p5/dist/io/utilities.js
var fileSaver = __toESM(require_FileSaver());
function downloadFile(data3, fName, extension) {
  const fx = _checkFileExtension(fName, extension);
  const filename = fx[0];
  let saveData = data3;
  if (!(saveData instanceof Blob)) {
    saveData = new Blob([data3]);
  }
  fileSaver.saveAs(saveData, filename);
}
function _checkFileExtension(filename, extension) {
  if (!extension || extension === true || extension === "true") {
    extension = "";
  }
  if (!filename) {
    filename = "untitled";
  }
  let ext = "";
  if (filename && filename.includes(".")) {
    ext = filename.split(".").pop();
  }
  if (extension) {
    if (ext !== extension) {
      ext = extension;
      filename = `${filename}.${ext}`;
    }
  }
  return [filename, ext];
}

// node_modules/p5/dist/p5.Renderer-DoDzbpcT.js
var Image = class _Image {
  constructor(width, height) {
    this.width = width;
    this.height = height;
    this.canvas = document.createElement("canvas");
    this.canvas.width = this.width;
    this.canvas.height = this.height;
    this.drawingContext = this.canvas.getContext("2d");
    this._pixelsState = this;
    this._pixelDensity = 1;
    this.gifProperties = null;
    this._modified = false;
    this.pixels = [];
  }
  /**
   * Gets or sets the pixel density for high pixel density displays.
   *
   * By default, the density will be set to 1.
   *
   * Call this method with no arguments to get the default density, or pass
   * in a number to set the density. If a non-positive number is provided,
   * it defaults to 1.
   *
   * @param {Number} [density] A scaling factor for the number of pixels per
   * side
   * @returns {Number} The current density if called without arguments, or the instance for chaining if setting density.
   */
  pixelDensity(density) {
    if (typeof density !== "undefined") {
      if (density <= 0) {
        density = 1;
      }
      this._pixelDensity = density;
      this.width /= density;
      this.height /= density;
      return this;
    } else {
      return this._pixelDensity;
    }
  }
  /**
   * Helper function for animating GIF-based images with time
   */
  _animateGif(pInst) {
    const props = this.gifProperties;
    const curTime = pInst._lastRealFrameTime || window.performance.now();
    if (props.lastChangeTime === 0) {
      props.lastChangeTime = curTime;
    }
    if (props.playing) {
      props.timeDisplayed = curTime - props.lastChangeTime;
      const curDelay = props.frames[props.displayIndex].delay;
      if (props.timeDisplayed >= curDelay) {
        const skips = Math.floor(props.timeDisplayed / curDelay);
        props.timeDisplayed = 0;
        props.lastChangeTime = curTime;
        props.displayIndex += skips;
        props.loopCount = Math.floor(props.displayIndex / props.numFrames);
        if (props.loopLimit !== null && props.loopCount >= props.loopLimit) {
          props.playing = false;
        } else {
          const ind = props.displayIndex % props.numFrames;
          this.drawingContext.putImageData(props.frames[ind].image, 0, 0);
          props.displayIndex = ind;
          this.setModified(true);
        }
      }
    }
  }
  /**
   * Loads the current value of each pixel in the image into the `img.pixels`
   * array.
   *
   * `img.loadPixels()` must be called before reading or modifying pixel
   * values.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Image object.
   *   let img = createImage(66, 66);
   *
   *   // Load the image's pixels.
   *   img.loadPixels();
   *
   *   // Set the pixels to black.
   *   for (let x = 0; x < img.width; x += 1) {
   *     for (let y = 0; y < img.height; y += 1) {
   *       img.set(x, y, 0);
   *     }
   *   }
   *
   *   // Update the image.
   *   img.updatePixels();
   *
   *   // Display the image.
   *   image(img, 17, 17);
   *
   *   describe('A black square drawn in the middle of a gray square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Image object.
   *   let img = createImage(66, 66);
   *
   *   // Load the image's pixels.
   *   img.loadPixels();
   *
   *   for (let i = 0; i < img.pixels.length; i += 4) {
   *     // Red.
   *     img.pixels[i] = 0;
   *     // Green.
   *     img.pixels[i + 1] = 0;
   *     // Blue.
   *     img.pixels[i + 2] = 0;
   *     // Alpha.
   *     img.pixels[i + 3] = 255;
   *   }
   *
   *   // Update the image.
   *   img.updatePixels();
   *
   *   // Display the image.
   *   image(img, 17, 17);
   *
   *   describe('A black square drawn in the middle of a gray square.');
   * }
   * </code>
   * </div>
   */
  loadPixels() {
    const pixelsState = this._pixelsState;
    const pd = this._pixelDensity;
    const w = this.width * pd;
    const h = this.height * pd;
    const imageData = this.drawingContext.getImageData(0, 0, w, h);
    pixelsState.imageData = imageData;
    this.pixels = pixelsState.pixels = imageData.data;
    this.setModified(true);
  }
  /**
   * Updates the canvas with the RGBA values in the
   * <a href="#/p5.Image/pixels">img.pixels</a> array.
   *
   * `img.updatePixels()` only needs to be called after changing values in
   * the <a href="#/p5.Image/pixels">img.pixels</a> array. Such changes can be
   * made directly after calling
   * <a href="#/p5.Image/loadPixels">img.loadPixels()</a> or by calling
   * <a href="#/p5.Image/set">img.set()</a>.
   *
   * The optional parameters `x`, `y`, `width`, and `height` define a
   * subsection of the image to update. Doing so can improve performance in
   * some cases.
   *
   * If the image was loaded from a GIF, then calling `img.updatePixels()`
   * will update the pixels in current frame.
   *
   * @param {Integer} x x-coordinate of the upper-left corner
   *                    of the subsection to update.
   * @param {Integer} y y-coordinate of the upper-left corner
   *                    of the subsection to update.
   * @param {Integer} w width of the subsection to update.
   * @param {Integer} h height of the subsection to update.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Image object.
   *   let img = createImage(66, 66);
   *
   *   // Load the image's pixels.
   *   img.loadPixels();
   *
   *   // Set the pixels to black.
   *   for (let x = 0; x < img.width; x += 1) {
   *     for (let y = 0; y < img.height; y += 1) {
   *       img.set(x, y, 0);
   *     }
   *   }
   *
   *   // Update the image.
   *   img.updatePixels();
   *
   *   // Display the image.
   *   image(img, 17, 17);
   *
   *   describe('A black square drawn in the middle of a gray square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Image object.
   *   let img = createImage(66, 66);
   *
   *   // Load the image's pixels.
   *   img.loadPixels();
   *
   *   // Set the pixels to black.
   *   for (let i = 0; i < img.pixels.length; i += 4) {
   *     // Red.
   *     img.pixels[i] = 0;
   *     // Green.
   *     img.pixels[i + 1] = 0;
   *     // Blue.
   *     img.pixels[i + 2] = 0;
   *     // Alpha.
   *     img.pixels[i + 3] = 255;
   *   }
   *
   *   // Update the image.
   *   img.updatePixels();
   *
   *   // Display the image.
   *   image(img, 17, 17);
   *
   *   describe('A black square drawn in the middle of a gray square.');
   * }
   * </code>
   * </div>
   */
  updatePixels(x, y, w, h) {
    const pixelsState = this._pixelsState;
    const pd = this._pixelDensity;
    if (x === void 0 && y === void 0 && w === void 0 && h === void 0) {
      x = 0;
      y = 0;
      w = this.width;
      h = this.height;
    }
    x *= pd;
    y *= pd;
    w *= pd;
    h *= pd;
    if (this.gifProperties) {
      this.gifProperties.frames[this.gifProperties.displayIndex].image = pixelsState.imageData;
    }
    this.drawingContext.putImageData(pixelsState.imageData, x, y, 0, 0, w, h);
    this.setModified(true);
  }
  /**
   * Gets a pixel or a region of pixels from the image.
   *
   * `img.get()` is easy to use but it's not as fast as
   * <a href="#/p5.Image/pixels">img.pixels</a>. Use
   * <a href="#/p5.Image/pixels">img.pixels</a> to read many pixel values.
   *
   * The version of `img.get()` with no parameters returns the entire image.
   *
   * The version of `img.get()` with two parameters, as in `img.get(10, 20)`,
   * interprets them as coordinates. It returns an array with the
   * `[R, G, B, A]` values of the pixel at the given point.
   *
   * The version of `img.get()` with four parameters, as in
   * `img,get(10, 20, 50, 90)`, interprets them as
   * coordinates and dimensions. The first two parameters are the coordinates
   * of the upper-left corner of the subsection. The last two parameters are
   * the width and height of the subsection. It returns a subsection of the
   * canvas in a new <a href="#/p5.Image">p5.Image</a> object.
   *
   * Use `img.get()` instead of <a href="#/p5/get">get()</a> to work directly
   * with images.
   *
   * @param  {Number}               x x-coordinate of the pixel.
   * @param  {Number}               y y-coordinate of the pixel.
   * @param  {Number}               w width of the subsection to be returned.
   * @param  {Number}               h height of the subsection to be returned.
   * @return {p5.Image}             subsection as a <a href="#/p5.Image">p5.Image</a> object.
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Copy the image.
   *   let img2 = get();
   *
   *   // Display the copied image on the right.
   *   image(img2, 50, 0);
   *
   *   describe('Two identical mountain landscapes shown side-by-side.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Get a pixel's color.
   *   let c = img.get(50, 90);
   *
   *   // Style the square using the pixel's color.
   *   fill(c);
   *   noStroke();
   *
   *   // Draw the square.
   *   square(25, 25, 50);
   *
   *   describe('A mountain landscape with an olive green square in its center.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Copy half of the image.
   *   let img2 = img.get(0, 0, img.width / 2, img.height / 2);
   *
   *   // Display half of the image.
   *   image(img2, 50, 50);
   *
   *   describe('A mountain landscape drawn on top of another mountain landscape.');
   * }
   * </code>
   * </div>
   */
  /**
   * @return {p5.Image}      whole <a href="#/p5.Image">p5.Image</a>
   */
  /**
   * @param  {Number}        x
   * @param  {Number}        y
   * @return {Number[]}      color of the pixel at (x, y) in array format `[R, G, B, A]`.
   */
  get(x, y, w, h) {
    const pixelsState = this._pixelsState;
    const pd = this._pixelDensity;
    const canvas2 = this.canvas;
    if (typeof x === "undefined" && typeof y === "undefined") {
      x = y = 0;
      w = pixelsState.width;
      h = pixelsState.height;
    } else {
      x *= pd;
      y *= pd;
      if (typeof w === "undefined" && typeof h === "undefined") {
        if (x < 0 || y < 0 || x >= canvas2.width || y >= canvas2.height) {
          return [0, 0, 0, 0];
        }
        return this._getPixel(x, y);
      }
    }
    const region = new _Image(w * pd, h * pd);
    region.pixelDensity(pd);
    region.canvas.getContext("2d").drawImage(canvas2, x, y, w * pd, h * pd, 0, 0, w * pd, h * pd);
    return region;
  }
  _getPixel(x, y) {
    let imageData, index;
    imageData = this.drawingContext.getImageData(x, y, 1, 1).data;
    index = 0;
    return [
      imageData[index + 0],
      imageData[index + 1],
      imageData[index + 2],
      imageData[index + 3]
    ];
  }
  /**
   * Sets the color of one or more pixels within an image.
   *
   * `img.set()` is easy to use but it's not as fast as
   * <a href="#/p5.Image/pixels">img.pixels</a>. Use
   * <a href="#/p5.Image/pixels">img.pixels</a> to set many pixel values.
   *
   * `img.set()` interprets the first two parameters as x- and y-coordinates. It
   * interprets the last parameter as a grayscale value, a `[R, G, B, A]` pixel
   * array, a <a href="#/p5.Color">p5.Color</a> object, or another
   * <a href="#/p5.Image">p5.Image</a> object.
   *
   * <a href="#/p5.Image/updatePixels">img.updatePixels()</a> must be called
   * after using `img.set()` for changes to appear.
   *
   * @param {Number}              x x-coordinate of the pixel.
   * @param {Number}              y y-coordinate of the pixel.
   * @param {Number|Number[]|Object}   a grayscale value | pixel array |
   *                                   <a href="#/p5.Color">p5.Color</a> object |
   *                                   <a href="#/p5.Image">p5.Image</a> to copy.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Image object.
   *   let img = createImage(100, 100);
   *
   *   // Set four pixels to black.
   *   img.set(30, 20, 0);
   *   img.set(85, 20, 0);
   *   img.set(85, 75, 0);
   *   img.set(30, 75, 0);
   *
   *   // Update the image.
   *   img.updatePixels();
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('Four black dots arranged in a square drawn on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Image object.
   *   let img = createImage(100, 100);
   *
   *   // Create a p5.Color object.
   *   let black = color(0);
   *
   *   // Set four pixels to black.
   *   img.set(30, 20, black);
   *   img.set(85, 20, black);
   *   img.set(85, 75, black);
   *   img.set(30, 75, black);
   *
   *   // Update the image.
   *   img.updatePixels();
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('Four black dots arranged in a square drawn on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.Image object.
   *   let img = createImage(66, 66);
   *
   *   // Draw a color gradient.
   *   for (let x = 0; x < img.width; x += 1) {
   *     for (let y = 0; y < img.height; y += 1) {
   *       let c = map(x, 0, img.width, 0, 255);
   *       img.set(x, y, c);
   *     }
   *   }
   *
   *   // Update the image.
   *   img.updatePixels();
   *
   *   // Display the image.
   *   image(img, 17, 17);
   *
   *   describe('A square with a horiztonal color gradient from black to white drawn on a gray background.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Create a p5.Image object.
   *   let img2 = createImage(100, 100);
   *
   *   // Set the blank image's pixels using the landscape.
   *   img2.set(0, 0, img);
   *
   *   // Display the second image.
   *   image(img2, 0, 0);
   *
   *   describe('An image of a mountain landscape.');
   * }
   * </code>
   * </div>
   */
  set(x, y, imgOrCol) {
    x = Math.floor(x);
    y = Math.floor(y);
    const pixelsState = this._pixelsState;
    if (imgOrCol instanceof _Image) {
      this.drawingContext.save();
      this.drawingContext.setTransform(1, 0, 0, 1, 0, 0);
      this.drawingContext.scale(
        this._pixelDensity,
        this._pixelDensity
      );
      this.drawingContext.clearRect(x, y, imgOrCol.width, imgOrCol.height);
      this.drawingContext.drawImage(imgOrCol.canvas, x, y);
      this.drawingContext.restore();
    } else {
      let r = 0, g2 = 0, b3 = 0, a2 = 0;
      let idx = 4 * (y * this._pixelDensity * (this.width * this._pixelDensity) + x * this._pixelDensity);
      if (!pixelsState.imageData) {
        pixelsState.loadPixels();
      }
      if (typeof imgOrCol === "number") {
        if (idx < pixelsState.pixels.length) {
          r = imgOrCol;
          g2 = imgOrCol;
          b3 = imgOrCol;
          a2 = 255;
        }
      } else if (Array.isArray(imgOrCol)) {
        if (imgOrCol.length < 4) {
          throw new Error("pixel array must be of the form [R, G, B, A]");
        }
        if (idx < pixelsState.pixels.length) {
          r = imgOrCol[0];
          g2 = imgOrCol[1];
          b3 = imgOrCol[2];
          a2 = imgOrCol[3];
        }
      } else if (imgOrCol instanceof p5.Color) {
        if (idx < pixelsState.pixels.length) {
          [r, g2, b3, a2] = imgOrCol._getRGBA([255, 255, 255, 255]);
        }
      }
      for (let i = 0; i < this._pixelDensity; i++) {
        for (let j2 = 0; j2 < this._pixelDensity; j2++) {
          idx = 4 * ((y * this._pixelDensity + j2) * this.width * this._pixelDensity + (x * this._pixelDensity + i));
          pixelsState.pixels[idx] = r;
          pixelsState.pixels[idx + 1] = g2;
          pixelsState.pixels[idx + 2] = b3;
          pixelsState.pixels[idx + 3] = a2;
        }
      }
    }
    this.setModified(true);
  }
  /**
   * Resizes the image to a given width and height.
   *
   * The image's original aspect ratio can be kept by passing 0 for either
   * `width` or `height`. For example, calling `img.resize(50, 0)` on an image
   * that was 500 &times; 300 pixels will resize it to 50 &times; 30 pixels.
   *
   * @param {Number} width resized image width.
   * @param {Number} height resized image height.
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Resize the image.
   *   img.resize(50, 100);
   *
   *   // Display the resized image.
   *   image(img, 0, 0);
   *
   *   describe('Two images of a mountain landscape. One copy of the image is squeezed horizontally.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Resize the image, keeping the aspect ratio.
   *   img.resize(0, 30);
   *
   *   // Display the resized image.
   *   image(img, 0, 0);
   *
   *   describe('Two images of a mountain landscape. The small copy of the image covers the top-left corner of the larger image.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Resize the image, keeping the aspect ratio.
   *   img.resize(60, 0);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('Two images of a mountain landscape. The small copy of the image covers the top-left corner of the larger image.');
   * }
   * </code>
   * </div>
   */
  resize(width, height) {
    if (width === 0 && height === 0) {
      width = this.canvas.width;
      height = this.canvas.height;
    } else if (width === 0) {
      width = this.canvas.width * height / this.canvas.height;
    } else if (height === 0) {
      height = this.canvas.height * width / this.canvas.width;
    }
    width = Math.floor(width);
    height = Math.floor(height);
    const tempCanvas = document.createElement("canvas");
    tempCanvas.width = width;
    tempCanvas.height = height;
    if (this.gifProperties) {
      const props = this.gifProperties;
      const nearestNeighbor = (src, dst) => {
        let pos = 0;
        for (let y = 0; y < dst.height; y++) {
          for (let x = 0; x < dst.width; x++) {
            const srcX = Math.floor(x * src.width / dst.width);
            const srcY = Math.floor(y * src.height / dst.height);
            let srcPos = (srcY * src.width + srcX) * 4;
            dst.data[pos++] = src.data[srcPos++];
            dst.data[pos++] = src.data[srcPos++];
            dst.data[pos++] = src.data[srcPos++];
            dst.data[pos++] = src.data[srcPos++];
          }
        }
      };
      for (let i = 0; i < props.numFrames; i++) {
        const resizedImageData = this.drawingContext.createImageData(
          width,
          height
        );
        nearestNeighbor(props.frames[i].image, resizedImageData);
        props.frames[i].image = resizedImageData;
      }
    }
    tempCanvas.getContext("2d").drawImage(
      this.canvas,
      0,
      0,
      this.canvas.width,
      this.canvas.height,
      0,
      0,
      tempCanvas.width,
      tempCanvas.height
    );
    this.canvas.width = this.width = width;
    this.canvas.height = this.height = height;
    this.drawingContext.drawImage(
      tempCanvas,
      0,
      0,
      width,
      height,
      0,
      0,
      width,
      height
    );
    if (this.pixels.length > 0) {
      this.loadPixels();
    }
    this.setModified(true);
  }
  /**
   * Copies pixels from a source image to this image.
   *
   * The first parameter, `srcImage`, is an optional
   * <a href="#/p5.Image">p5.Image</a> object to copy. If a source image isn't
   * passed, then `img.copy()` can copy a region of this image to another
   * region.
   *
   * The next four parameters, `sx`, `sy`, `sw`, and `sh` determine the region
   * to copy from the source image. `(sx, sy)` is the top-left corner of the
   * region. `sw` and `sh` are the region's width and height.
   *
   * The next four parameters, `dx`, `dy`, `dw`, and `dh` determine the region
   * of this image to copy into. `(dx, dy)` is the top-left corner of the
   * region. `dw` and `dh` are the region's width and height.
   *
   * Calling `img.copy()` will scale pixels from the source region if it isn't
   * the same size as the destination region.
   *
   * @param  {p5.Image|p5.Element} srcImage source image.
   * @param  {Integer} sx x-coordinate of the source's upper-left corner.
   * @param  {Integer} sy y-coordinate of the source's upper-left corner.
   * @param  {Integer} sw source image width.
   * @param  {Integer} sh source image height.
   * @param  {Integer} dx x-coordinate of the destination's upper-left corner.
   * @param  {Integer} dy y-coordinate of the destination's upper-left corner.
   * @param  {Integer} dw destination image width.
   * @param  {Integer} dh destination image height.
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Copy one region of the image to another.
   *   img.copy(7, 22, 10, 10, 35, 25, 50, 50);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   // Outline the copied region.
   *   stroke(255);
   *   noFill();
   *   square(7, 22, 10);
   *
   *   describe('An image of a mountain landscape. A square region is outlined in white. A larger square contains a pixelated view of the outlined region.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let mountains;
   * let bricks;
   *
   * async function setup() {
   *   // Load the images.
   *   mountains = await loadImage('assets/rockies.jpg');
   *   bricks = await loadImage('assets/bricks.jpg');
   *   createCanvas(100, 100);
   *
   *   // Calculate the center of the bricks image.
   *   let x = bricks.width / 2;
   *   let y = bricks.height / 2;
   *
   *   // Copy the bricks to the mountains image.
   *   mountains.copy(bricks, 0, 0, x, y, 0, 0, x, y);
   *
   *   // Display the mountains image.
   *   image(mountains, 0, 0);
   *
   *   describe('An image of a brick wall drawn at the top-left of an image of a mountain landscape.');
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {Integer} sx
   * @param  {Integer} sy
   * @param  {Integer} sw
   * @param  {Integer} sh
   * @param  {Integer} dx
   * @param  {Integer} dy
   * @param  {Integer} dw
   * @param  {Integer} dh
   */
  copy(...args) {
    let srcImage, sx, sy, sw, sh, dx, dy, dw, dh;
    if (args.length === 9) {
      srcImage = args[0];
      sx = args[1];
      sy = args[2];
      sw = args[3];
      sh = args[4];
      dx = args[5];
      dy = args[6];
      dw = args[7];
      dh = args[8];
    } else if (args.length === 8) {
      srcImage = this;
      sx = args[0];
      sy = args[1];
      sw = args[2];
      sh = args[3];
      dx = args[4];
      dy = args[5];
      dw = args[6];
      dh = args[7];
    } else {
      throw new Error("Signature not supported");
    }
    this._copyHelper(this, srcImage, sx, sy, sw, sh, dx, dy, dw, dh);
  }
  _copyHelper(dstImage, srcImage, sx, sy, sw, sh, dx, dy, dw, dh) {
    const s = srcImage.canvas.width / srcImage.width;
    let sxMod = 0;
    let syMod = 0;
    if (srcImage._renderer && srcImage._renderer.isP3D) {
      sxMod = srcImage.width / 2;
      syMod = srcImage.height / 2;
    }
    if (dstImage._renderer && dstImage._renderer.isP3D) {
      dstImage.push();
      dstImage.resetMatrix();
      dstImage.noLights();
      dstImage.blendMode(dstImage.BLEND);
      dstImage.imageMode(dstImage.CORNER);
      dstImage._renderer.image(
        srcImage,
        sx + sxMod,
        sy + syMod,
        sw,
        sh,
        dx,
        dy,
        dw,
        dh
      );
      dstImage.pop();
    } else {
      dstImage.drawingContext.drawImage(
        srcImage.canvas,
        s * (sx + sxMod),
        s * (sy + syMod),
        s * sw,
        s * sh,
        dx,
        dy,
        dw,
        dh
      );
    }
  }
  /**
   * Masks part of the image with another.
   *
   * `img.mask()` uses another <a href="#/p5.Image">p5.Image</a> object's
   * alpha channel as the alpha channel for this image. Masks are cumulative
   * and can't be removed once applied. If the mask has a different
   * pixel density from this image, the mask will be scaled.
   *
   * @param {p5.Image} srcImage source image.
   *
   * @example
   * <div>
   * <code>
   * let photo;
   * let maskImage;
   *
   * async function setup() {
   *   // Load the images.
   *   photo = await loadImage('assets/rockies.jpg');
   *   maskImage = await loadImage('assets/mask2.png');
   *   createCanvas(100, 100);
   *
   *   // Apply the mask.
   *   photo.mask(maskImage);
   *
   *   // Display the image.
   *   image(photo, 0, 0);
   *
   *   describe('An image of a mountain landscape. The right side of the image has a faded patch of white.');
   * }
   * </code>
   * </div>
   */
  // TODO: - Accept an array of alpha values.
  mask(p5Image) {
    if (p5Image === void 0) {
      p5Image = this;
    }
    const currBlend = this.drawingContext.globalCompositeOperation;
    let imgScaleFactor = this._pixelDensity;
    let maskScaleFactor = 1;
    if (p5Image instanceof Renderer) {
      maskScaleFactor = p5Image._pInst._renderer._pixelDensity;
    }
    const copyArgs = [
      p5Image,
      0,
      0,
      maskScaleFactor * p5Image.width,
      maskScaleFactor * p5Image.height,
      0,
      0,
      imgScaleFactor * this.width,
      imgScaleFactor * this.height
    ];
    this.drawingContext.globalCompositeOperation = "destination-in";
    if (this.gifProperties) {
      for (let i = 0; i < this.gifProperties.frames.length; i++) {
        this.drawingContext.putImageData(
          this.gifProperties.frames[i].image,
          0,
          0
        );
        this.copy(...copyArgs);
        this.gifProperties.frames[i].image = this.drawingContext.getImageData(
          0,
          0,
          imgScaleFactor * this.width,
          imgScaleFactor * this.height
        );
      }
      this.drawingContext.putImageData(
        this.gifProperties.frames[this.gifProperties.displayIndex].image,
        0,
        0
      );
    } else {
      this.copy(...copyArgs);
    }
    this.drawingContext.globalCompositeOperation = currBlend;
    this.setModified(true);
  }
  /**
   * Applies an image filter to the image.
   *
   * The preset options are:
   *
   * `INVERT`
   * Inverts the colors in the image. No parameter is used.
   *
   * `GRAY`
   * Converts the image to grayscale. No parameter is used.
   *
   * `THRESHOLD`
   * Converts the image to black and white. Pixels with a grayscale value
   * above a given threshold are converted to white. The rest are converted to
   * black. The threshold must be between 0.0 (black) and 1.0 (white). If no
   * value is specified, 0.5 is used.
   *
   * `OPAQUE`
   * Sets the alpha channel to be entirely opaque. No parameter is used.
   *
   * `POSTERIZE`
   * Limits the number of colors in the image. Each color channel is limited to
   * the number of colors specified. Values between 2 and 255 are valid, but
   * results are most noticeable with lower values. The default value is 4.
   *
   * `BLUR`
   * Blurs the image. The level of blurring is specified by a blur radius. Larger
   * values increase the blur. The default value is 4. A gaussian blur is used
   * in `P2D` mode. A box blur is used in `WEBGL` mode.
   *
   * `ERODE`
   * Reduces the light areas. No parameter is used.
   *
   * `DILATE`
   * Increases the light areas. No parameter is used.
   *
   * @param  {(THRESHOLD|GRAY|OPAQUE|INVERT|POSTERIZE|ERODE|DILATE|BLUR)} filterType  either THRESHOLD, GRAY, OPAQUE, INVERT,
   *                                POSTERIZE, ERODE, DILATE or BLUR.
   * @param  {Number} [filterParam] parameter unique to each filter.
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the INVERT filter.
   *   img.filter(INVERT);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('A blue brick wall.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the GRAY filter.
   *   img.filter(GRAY);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('A brick wall drawn in grayscale.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the THRESHOLD filter.
   *   img.filter(THRESHOLD);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('A brick wall drawn in black and white.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the OPAQUE filter.
   *   img.filter(OPAQUE);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('A red brick wall.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the POSTERIZE filter.
   *   img.filter(POSTERIZE, 3);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('An image of a red brick wall drawn with a limited color palette.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the BLUR filter.
   *   img.filter(BLUR, 3);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('A blurry image of a red brick wall.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the DILATE filter.
   *   img.filter(DILATE);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('A red brick wall with bright lines between each brick.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/bricks.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Apply the ERODE filter.
   *   img.filter(ERODE);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('A red brick wall with faint lines between each brick.');
   * }
   * </code>
   * </div>
   */
  filter(operation, value) {
    Filters.apply(this.canvas, Filters[operation], value);
    this.setModified(true);
  }
  /**
   * Copies a region of pixels from another image into this one.
   *
    * The first parameter, `srcImage`, is the
   * <a href="#/p5.Image">p5.Image</a> object to blend.
   *
   * The next four parameters, `sx`, `sy`, `sw`, and `sh` determine the region
   * to blend from the source image. `(sx, sy)` is the top-left corner of the
   * region. `sw` and `sh` are the regions width and height.
   *
   * The next four parameters, `dx`, `dy`, `dw`, and `dh` determine the region
   * of the canvas to blend into. `(dx, dy)` is the top-left corner of the
   * region. `dw` and `dh` are the regions width and height.
   *
   * The tenth parameter, `blendMode`, sets the effect used to blend the images'
   * colors. The options are `BLEND`, `DARKEST`, `LIGHTEST`, `DIFFERENCE`,
   * `MULTIPLY`, `EXCLUSION`, `SCREEN`, `REPLACE`, `OVERLAY`, `HARD_LIGHT`,
   * `SOFT_LIGHT`, `DODGE`, `BURN`, `ADD`, or `NORMAL`.
   *
   * @param  {p5.Image} srcImage source image
   * @param  {Integer} sx x-coordinate of the source's upper-left corner.
   * @param  {Integer} sy y-coordinate of the source's upper-left corner.
   * @param  {Integer} sw source image width.
   * @param  {Integer} sh source image height.
   * @param  {Integer} dx x-coordinate of the destination's upper-left corner.
   * @param  {Integer} dy y-coordinate of the destination's upper-left corner.
   * @param  {Integer} dw destination image width.
   * @param  {Integer} dh destination image height.
   * @param  {(BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL)} blendMode the blend mode. either
   *     BLEND, DARKEST, LIGHTEST, DIFFERENCE,
   *     MULTIPLY, EXCLUSION, SCREEN, REPLACE, OVERLAY, HARD_LIGHT,
   *     SOFT_LIGHT, DODGE, BURN, ADD or NORMAL.
   *
   * Available blend modes are: normal | multiply | screen | overlay |
   *            darken | lighten | color-dodge | color-burn | hard-light |
   *            soft-light | difference | exclusion | hue | saturation |
   *            color | luminosity
   *
   * http://blogs.adobe.com/webplatform/2013/01/28/blending-features-in-canvas/
   *
   * @example
   * <div>
   * <code>
   * let mountains;
   * let bricks;
   *
   * async function setup() {
   *   // Load the images.
   *   mountains = await loadImage('assets/rockies.jpg');
   *   bricks = await loadImage('assets/bricks_third.jpg');
   *   createCanvas(100, 100);
   *
   *   // Blend the bricks image into the mountains.
   *   mountains.blend(bricks, 0, 0, 33, 100, 67, 0, 33, 100, ADD);
   *
   *   // Display the mountains image.
   *   image(mountains, 0, 0);
   *
   *   // Display the bricks image.
   *   image(bricks, 0, 0);
   *
   *   describe('A wall of bricks in front of a mountain landscape. The same wall of bricks appears faded on the right of the image.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let mountains;
   * let bricks;
   *
   * async function setup() {
   *   // Load the images.
   *   mountains = await loadImage('assets/rockies.jpg');
   *   bricks = await loadImage('assets/bricks_third.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Blend the bricks image into the mountains.
   *   mountains.blend(bricks, 0, 0, 33, 100, 67, 0, 33, 100, DARKEST);
   *
   *   // Display the mountains image.
   *   image(mountains, 0, 0);
   *
   *   // Display the bricks image.
   *   image(bricks, 0, 0);
   *
   *   describe('A wall of bricks in front of a mountain landscape. The same wall of bricks appears transparent on the right of the image.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let mountains;
   * let bricks;
   *
   * async function setup() {
   *   // Load the images.
   *   mountains = await loadImage('assets/rockies.jpg');
   *   bricks = await loadImage('assets/bricks_third.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Blend the bricks image into the mountains.
   *   mountains.blend(bricks, 0, 0, 33, 100, 67, 0, 33, 100, LIGHTEST);
   *
   *   // Display the mountains image.
   *   image(mountains, 0, 0);
   *
   *   // Display the bricks image.
   *   image(bricks, 0, 0);
   *
   *   describe('A wall of bricks in front of a mountain landscape. The same wall of bricks appears washed out on the right of the image.');
   * }
   * </code>
   * </div>
   */
  /**
   * @param  {Integer} sx
   * @param  {Integer} sy
   * @param  {Integer} sw
   * @param  {Integer} sh
   * @param  {Integer} dx
   * @param  {Integer} dy
   * @param  {Integer} dw
   * @param  {Integer} dh
   * @param  {(BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL)} blendMode
   */
  blend(...args) {
    const currBlend = this.drawingContext.globalCompositeOperation;
    const blendMode = args[args.length - 1];
    const copyArgs = Array.prototype.slice.call(args, 0, args.length - 1);
    this.drawingContext.globalCompositeOperation = blendMode;
    this.copy(...copyArgs);
    this.drawingContext.globalCompositeOperation = currBlend;
    this.setModified(true);
  }
  /**
   * helper method for web GL mode to indicate that an image has been
   * changed or unchanged since last upload. gl texture upload will
   * set this value to false after uploading the texture.
   * @param {Boolean} val sets whether or not the image has been
   * modified.
   * @private
   */
  setModified(val2) {
    this._modified = val2;
  }
  /**
   * helper method for web GL mode to figure out if the image
   * has been modified and might need to be re-uploaded to texture
   * memory between frames.
   * @private
   * @return {boolean} a boolean indicating whether or not the
   * image has been updated or modified since last texture upload.
   */
  isModified() {
    return this._modified;
  }
  /**
   * Saves the image to a file.
   *
   * By default, `img.save()` saves the image as a PNG image called
   * `untitled.png`.
   *
   * The first parameter, `filename`, is optional. It's a string that sets the
   * file's name. If a file extension is included, as in
   * `img.save('drawing.png')`, then the image will be saved using that
   * format.
   *
   * The second parameter, `extension`, is also optional. It sets the files format.
   * Either `'png'` or `'jpg'` can be used. For example, `img.save('drawing', 'jpg')`
   * saves the canvas to a file called `drawing.jpg`.
   *
   * Note: The browser will either save the file immediately or prompt the user
   * with a dialogue window.
   *
   * The image will only be downloaded as an animated GIF if it was loaded
   * from a GIF file. See <a href="#/p5/saveGif">saveGif()</a> to create new
   * GIFs.
   *
   * @param {String} filename filename. Defaults to 'untitled'.
   * @param  {String} [extension] file extension, either 'png' or 'jpg'.
   *                            Defaults to 'png'.
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   // Load the image.
   *   img = await loadImage('assets/rockies.jpg');
   *
   *   createCanvas(100, 100);
   *
   *   // Display the image.
   *   image(img, 0, 0);
   *
   *   describe('An image of a mountain landscape. The image is downloaded when the user presses the "s", "j", or "p" key.');
   * }
   *
   * // Save the image with different options when the user presses a key.
   * function keyPressed() {
   *   if (key === 's') {
   *     img.save();
   *   } else if (key === 'j') {
   *     img.save('rockies.jpg');
   *   } else if (key === 'p') {
   *     img.save('rockies', 'png');
   *   }
   * }
   * </code>
   * </div>
   */
  save(filename, extension) {
    if (this.gifProperties) {
      encodeAndDownloadGif(this, filename);
    } else {
      let htmlCanvas = this.canvas;
      extension = extension || _checkFileExtension(filename, extension)[1] || "png";
      let mimeType;
      switch (extension) {
        default:
          mimeType = "image/png";
          break;
        case "webp":
          mimeType = "image/webp";
          break;
        case "jpeg":
        case "jpg":
          mimeType = "image/jpeg";
          break;
      }
      htmlCanvas.toBlob((blob) => {
        downloadFile(blob, filename, extension);
      }, mimeType);
    }
  }
  async toBlob() {
    return new Promise((resolve) => {
      this.canvas.toBlob(resolve);
    });
  }
  // GIF Section
  /**
   * Restarts an animated GIF at its first frame.
   *
   * @example
   * <div>
   * <code>
   * let gif;
   *
   * async function setup() {
   *   // Load the image.
   *   gif = await loadImage('assets/arnott-wallace-wink-loop-once.gif');
   *
   *   createCanvas(100, 100);
   *
   *   describe('A cartoon face winks once and then freezes. Clicking resets the face and makes it wink again.');
   * }
   *
   * function draw() {
   *   background(255);
   *
   *   // Display the image.
   *   image(gif, 0, 0);
   * }
   *
   * // Reset the GIF when the user presses the mouse.
   * function mousePressed() {
   *   gif.reset();
   * }
   * </code>
   * </div>
   */
  reset() {
    if (this.gifProperties) {
      const props = this.gifProperties;
      props.playing = true;
      props.timeSinceStart = 0;
      props.timeDisplayed = 0;
      props.lastChangeTime = 0;
      props.loopCount = 0;
      props.displayIndex = 0;
      this.drawingContext.putImageData(props.frames[0].image, 0, 0);
    }
  }
  /**
   * Gets the index of the current frame in an animated GIF.
   *
   * @return {Number}       index of the GIF's current frame.
   *
   * @example
   * <div>
   * <code>
   * let gif;
   *
   * async function setup() {
   *   // Load the image.
   *   gif = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');
   *
   *   createCanvas(100, 100);
   *
   *   describe('A cartoon eye repeatedly looks around, then outwards. A number displayed in the bottom-left corner increases from 0 to 124, then repeats.');
   * }
   *
   * function draw() {
   *   // Get the index of the current GIF frame.
   *   let index = gif.getCurrentFrame();
   *
   *   // Display the image.
   *   image(gif, 0, 0);
   *
   *   // Display the current frame.
   *   text(index, 10, 90);
   * }
   * </code>
   * </div>
   */
  getCurrentFrame() {
    if (this.gifProperties) {
      const props = this.gifProperties;
      return props.displayIndex % props.numFrames;
    }
  }
  /**
   * Sets the current frame in an animated GIF.
   *
   * @param {Number} index index of the frame to display.
   *
   * @example
   * <div>
   * <code>
   * let gif;
   * let frameSlider;
   *
   * async function setup() {
   *   // Load the image.
   *   gif = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');
   *
   *   createCanvas(100, 100);
   *
   *   // Get the index of the last frame.
   *   let maxFrame = gif.numFrames() - 1;
   *
   *   // Create a slider to control which frame is drawn.
   *   frameSlider = createSlider(0, maxFrame);
   *   frameSlider.position(10, 80);
   *   frameSlider.size(80);
   *
   *   describe('A cartoon eye looks around when a slider is moved.');
   * }
   *
   * function draw() {
   *   // Get the slider's value.
   *   let index = frameSlider.value();
   *
   *   // Set the GIF's frame.
   *   gif.setFrame(index);
   *
   *   // Display the image.
   *   image(gif, 0, 0);
   * }
   * </code>
   * </div>
   */
  setFrame(index) {
    if (this.gifProperties) {
      const props = this.gifProperties;
      if (index < props.numFrames && index >= 0) {
        props.timeDisplayed = 0;
        props.lastChangeTime = 0;
        props.displayIndex = index;
        this.drawingContext.putImageData(props.frames[index].image, 0, 0);
      } else {
        console.log(
          "Cannot set GIF to a frame number that is higher than total number of frames or below zero."
        );
      }
    }
  }
  /**
   * Returns the number of frames in an animated GIF.
   *
   * @return {Number} number of frames in the GIF.
   *
   * @example
   * <div>
   * <code>
   * let gif;
   *
   * async function setup() {
   *   // Load the image.
   *   gif = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');
   *
   *   createCanvas(100, 100);
   *
   *   describe('A cartoon eye looks around. The text "n / 125" is shown at the bottom of the canvas.');
   * }
   *
   * function draw() {
   *   // Display the image.
   *   image(gif, 0, 0);
   *
   *   // Display the current state of playback.
   *   let total = gif.numFrames();
   *   let index = gif.getCurrentFrame();
   *   text(`${index} / ${total}`, 30, 90);
   * }
   * </code>
   * </div>
   */
  numFrames() {
    if (this.gifProperties) {
      return this.gifProperties.numFrames;
    }
  }
  /**
   * Plays an animated GIF that was paused with
   * <a href="#/p5.Image/pause">img.pause()</a>.
   *
   * @example
   * <div>
   * <code>
   * let gif;
   *
   * async function setup() {
   *   // Load the image.
   *   gif = await loadImage('assets/nancy-liang-wind-loop-forever.gif');
   *
   *   createCanvas(100, 100);
   *
   *   describe('A drawing of a child with hair blowing in the wind. The animation freezes when clicked and resumes when released.');
   * }
   *
   * function draw() {
   *   background(255);
   *   image(gif, 0, 0);
   * }
   *
   * // Pause the GIF when the user presses the mouse.
   * function mousePressed() {
   *   gif.pause();
   * }
   *
   * // Play the GIF when the user releases the mouse.
   * function mouseReleased() {
   *   gif.play();
   * }
   * </code>
   * </div>
   */
  play() {
    if (this.gifProperties) {
      this.gifProperties.playing = true;
    }
  }
  /**
   * Pauses an animated GIF.
   *
   * The GIF can be resumed by calling
   * <a href="#/p5.Image/play">img.play()</a>.
   *
   * @example
   * <div>
   * <code>
   * let gif;
   *
   * async function setup() {
   *   // Load the image.
   *   gif = await loadImage('assets/nancy-liang-wind-loop-forever.gif');
   *
   *   createCanvas(100, 100);
   *
   *   describe('A drawing of a child with hair blowing in the wind. The animation freezes when clicked and resumes when released.');
   * }
   *
   * function draw() {
   *   background(255);
   *
   *   // Display the image.
   *   image(gif, 0, 0);
   * }
   *
   * // Pause the GIF when the user presses the mouse.
   * function mousePressed() {
   *   gif.pause();
   * }
   *
   * // Play the GIF when the user presses the mouse.
   * function mouseReleased() {
   *   gif.play();
   * }
   * </code>
   * </div>
   */
  pause() {
    if (this.gifProperties) {
      this.gifProperties.playing = false;
    }
  }
  /**
   * Changes the delay between frames in an animated GIF.
   *
   * The first parameter, `delay`, is the length of the delay in milliseconds.
   *
   * The second parameter, `index`, is optional. If provided, only the frame
   * at `index` will have its delay modified. All other frames will keep
   * their default delay.
   *
   * @param {Number} d delay in milliseconds between switching frames.
   * @param {Number} [index] index of the frame that will have its delay modified.
   *
   * @example
   * <div>
   * <code>
   * let gifFast;
   * let gifSlow;
   *
   * async function setup() {
   *   // Load the images.
   *   gifFast = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');
   *   gifSlow = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');
   *
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Resize the images.
   *   gifFast.resize(50, 50);
   *   gifSlow.resize(50, 50);
   *
   *   // Set the delay lengths.
   *   gifFast.delay(10);
   *   gifSlow.delay(100);
   *
   *   describe('Two animated eyes looking around. The eye on the left moves faster than the eye on the right.');
   * }
   *
   * function draw() {
   *   // Display the images.
   *   image(gifFast, 0, 0);
   *   image(gifSlow, 50, 0);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let gif;
   *
   * async function setup() {
   *   // Load the image.
   *   gif = await loadImage('assets/arnott-wallace-eye-loop-forever.gif');
   *
   *   createCanvas(100, 100);
   *
   *   // Set the delay of frame 67.
   *   gif.delay(3000, 67);
   *
   *   describe('An animated eye looking around. It pauses for three seconds while it looks down.');
   * }
   *
   * function draw() {
   *   // Display the image.
   *   image(gif, 0, 0);
   * }
   * </code>
   * </div>
   */
  delay(d2, index) {
    if (this.gifProperties) {
      const props = this.gifProperties;
      if (index < props.numFrames && index >= 0) {
        props.frames[index].delay = d2;
      } else {
        for (const frame of props.frames) {
          frame.delay = d2;
        }
      }
    }
  }
};
function encodeAndDownloadGif(pImg, filename) {
  const props = pImg.gifProperties;
  let loopLimit = props.loopLimit;
  if (loopLimit === 1) {
    loopLimit = null;
  } else if (loopLimit === null) {
    loopLimit = 0;
  }
  const buffer = new Uint8Array(pImg.width * pImg.height * props.numFrames);
  const allFramesPixelColors = [];
  const paletteFreqsAndFrames = {};
  for (let i = 0; i < props.numFrames; i++) {
    const paletteSet = /* @__PURE__ */ new Set();
    const data3 = props.frames[i].image.data;
    const dataLength = data3.length;
    const pixelColors = new Uint32Array(pImg.width * pImg.height);
    for (let j2 = 0, k = 0; j2 < dataLength; j2 += 4, k++) {
      const r = data3[j2 + 0];
      const g2 = data3[j2 + 1];
      const b3 = data3[j2 + 2];
      const color3 = r << 16 | g2 << 8 | b3 << 0;
      paletteSet.add(color3);
      pixelColors[k] = color3;
    }
    const paletteStr = [...paletteSet].sort().toString();
    if (paletteFreqsAndFrames[paletteStr] === void 0) {
      paletteFreqsAndFrames[paletteStr] = { freq: 1, frames: [i] };
    } else {
      paletteFreqsAndFrames[paletteStr].freq += 1;
      paletteFreqsAndFrames[paletteStr].frames.push(i);
    }
    allFramesPixelColors.push(pixelColors);
  }
  let framesUsingGlobalPalette = [];
  const palettesSortedByFreq = Object.keys(paletteFreqsAndFrames).sort(function(a2, b3) {
    return paletteFreqsAndFrames[b3].freq - paletteFreqsAndFrames[a2].freq;
  });
  const globalPalette = palettesSortedByFreq[0].split(",").map((a2) => parseInt(a2));
  framesUsingGlobalPalette = framesUsingGlobalPalette.concat(
    paletteFreqsAndFrames[globalPalette].frames
  );
  const globalPaletteSet = new Set(globalPalette);
  for (let i = 1; i < palettesSortedByFreq.length; i++) {
    const palette = palettesSortedByFreq[i].split(",").map((a2) => parseInt(a2));
    const difference = palette.filter((x) => !globalPaletteSet.has(x));
    if (globalPalette.length + difference.length <= 256) {
      for (let j2 = 0; j2 < difference.length; j2++) {
        globalPalette.push(difference[j2]);
        globalPaletteSet.add(difference[j2]);
      }
      framesUsingGlobalPalette = framesUsingGlobalPalette.concat(
        paletteFreqsAndFrames[palettesSortedByFreq[i]].frames
      );
    }
  }
  framesUsingGlobalPalette = new Set(framesUsingGlobalPalette);
  const globalIndicesLookup = {};
  for (let i = 0; i < globalPalette.length; i++) {
    if (!globalIndicesLookup[globalPalette[i]]) {
      globalIndicesLookup[globalPalette[i]] = i;
    }
  }
  let powof2 = 1;
  while (powof2 < globalPalette.length) {
    powof2 <<= 1;
  }
  globalPalette.length = powof2;
  const opts = {
    loop: loopLimit,
    palette: new Uint32Array(globalPalette)
  };
  const gifWriter = new omggif.GifWriter(buffer, pImg.width, pImg.height, opts);
  let previousFrame = {};
  for (let i = 0; i < props.numFrames; i++) {
    const localPaletteRequired = !framesUsingGlobalPalette.has(i);
    const palette = localPaletteRequired ? [] : globalPalette;
    const pixelPaletteIndex = new Uint8Array(pImg.width * pImg.height);
    const colorIndicesLookup = {};
    const cannotBeTransparent = /* @__PURE__ */ new Set();
    allFramesPixelColors[i].forEach((color3, k) => {
      if (localPaletteRequired) {
        if (colorIndicesLookup[color3] === void 0) {
          colorIndicesLookup[color3] = palette.length;
          palette.push(color3);
        }
        pixelPaletteIndex[k] = colorIndicesLookup[color3];
      } else {
        pixelPaletteIndex[k] = globalIndicesLookup[color3];
      }
      if (i > 0) {
        if (allFramesPixelColors[i - 1][k] !== color3) {
          cannotBeTransparent.add(color3);
        }
      }
    });
    const frameOpts = {};
    const canBeTransparent = palette.filter((a2) => !cannotBeTransparent.has(a2));
    if (canBeTransparent.length > 0) {
      const transparent = canBeTransparent[0];
      const transparentIndex = localPaletteRequired ? colorIndicesLookup[transparent] : globalIndicesLookup[transparent];
      if (i > 0) {
        for (let k = 0; k < allFramesPixelColors[i].length; k++) {
          if (allFramesPixelColors[i - 1][k] === allFramesPixelColors[i][k]) {
            pixelPaletteIndex[k] = transparentIndex;
          }
        }
        frameOpts.transparent = transparentIndex;
        previousFrame.frameOpts.disposal = 1;
      }
    }
    frameOpts.delay = props.frames[i].delay / 10;
    if (localPaletteRequired) {
      let powof22 = 1;
      while (powof22 < palette.length) {
        powof22 <<= 1;
      }
      palette.length = powof22;
      frameOpts.palette = new Uint32Array(palette);
    }
    if (i > 0) {
      gifWriter.addFrame(
        0,
        0,
        pImg.width,
        pImg.height,
        previousFrame.pixelPaletteIndex,
        previousFrame.frameOpts
      );
    }
    previousFrame = {
      pixelPaletteIndex,
      frameOpts
    };
  }
  previousFrame.frameOpts.disposal = 1;
  gifWriter.addFrame(
    0,
    0,
    pImg.width,
    pImg.height,
    previousFrame.pixelPaletteIndex,
    previousFrame.frameOpts
  );
  const extension = "gif";
  const blob = new Blob([buffer.slice(0, gifWriter.end())], {
    type: "image/gif"
  });
  downloadFile(blob, filename, extension);
}
function image(p53, fn2) {
  p53.Image = Image;
}
if (typeof p5 !== "undefined") {
  image(p5, p5.prototype);
}
var ClonableObject = class _ClonableObject {
  constructor(obj = {}) {
    for (const key in obj) {
      this[key] = obj[key];
    }
  }
  clone() {
    return new _ClonableObject(this);
  }
};
var _Renderer = class _Renderer {
  constructor(pInst, w, h, isMainCanvas) {
    this._pInst = pInst;
    this._isMainCanvas = isMainCanvas;
    this.pixels = [];
    this._pixelDensity = Math.ceil(window.devicePixelRatio) || 1;
    this.width = w;
    this.height = h;
    this._events = {};
    if (isMainCanvas) {
      this._isMainCanvas = true;
    }
    this.states = new States(_Renderer.states);
    this.states.strokeColor = new Color([0, 0, 0]);
    this.states.fillColor = new Color([1, 1, 1]);
    this._pushPopStack = [];
    this._pushPopDepth = 0;
    this._clipping = false;
    this._clipInvert = false;
    this._currentShape = void 0;
  }
  get currentShape() {
    if (!this._currentShape) {
      this._currentShape = new Shape(this.getCommonVertexProperties());
    }
    return this._currentShape;
  }
  remove() {
  }
  pixelDensity(val2) {
    let returnValue;
    if (typeof val2 === "number") {
      if (val2 !== this._pixelDensity) {
        this._pixelDensity = val2;
      }
      returnValue = this;
      this.resize(this.width, this.height);
    } else {
      returnValue = this._pixelDensity;
    }
    return returnValue;
  }
  // Makes a shallow copy of the current states
  // and push it into the push pop stack
  push() {
    this._pushPopDepth++;
    this._pushPopStack.push(this.states.getDiff());
  }
  // Pop the previous states out of the push pop stack and
  // assign it back to the current state
  pop() {
    this._pushPopDepth--;
    const diff = this._pushPopStack.pop() || {};
    const modified = this.states.getModified();
    this.states.applyDiff(diff);
    this.updateShapeVertexProperties(modified);
    this.updateShapeProperties(modified);
  }
  bezierOrder(order) {
    if (order === void 0) {
      return this.states.bezierOrder;
    } else {
      this.states.setValue("bezierOrder", order);
      this.updateShapeProperties();
    }
  }
  bezierVertex(x, y, z = 0, u = 0, v = 0) {
    const position = new Vector(x, y, z);
    const textureCoordinates = this.getSupportedIndividualVertexProperties().textureCoordinates ? new Vector(u, v) : void 0;
    this.currentShape.bezierVertex(position, textureCoordinates);
  }
  splineProperty(key, value) {
    if (value === void 0) {
      return this.states.splineProperties[key];
    } else {
      this.states.setValue("splineProperties", this.states.splineProperties.clone());
      this.states.splineProperties[key] = value;
    }
    this.updateShapeProperties();
  }
  splineProperties(values) {
    if (values) {
      for (const key in values) {
        this.splineProperty(key, values[key]);
      }
    } else {
      return { ...this.states.splineProperties };
    }
  }
  splineVertex(x, y, z = 0, u = 0, v = 0) {
    const position = new Vector(x, y, z);
    const textureCoordinates = this.getSupportedIndividualVertexProperties().textureCoordinates ? new Vector(u, v) : void 0;
    this.currentShape.splineVertex(position, textureCoordinates);
  }
  curveDetail(d2) {
    if (d2 === void 0) {
      return this.states.curveDetail;
    } else {
      this.states.setValue("curveDetail", d2);
    }
  }
  beginShape(...args) {
    this.currentShape.reset();
    this.updateShapeVertexProperties();
    this.currentShape.beginShape(...args);
  }
  endShape(...args) {
    this.currentShape.endShape(...args);
    this.drawShape(this.currentShape);
  }
  beginContour(shapeKind) {
    this.currentShape.beginContour(shapeKind);
  }
  endContour(mode) {
    this.currentShape.endContour(mode);
  }
  drawShape(shape2, count) {
    throw new Error("Unimplemented");
  }
  vertex(x, y, z = 0, u = 0, v = 0) {
    const position = new Vector(x, y, z);
    const textureCoordinates = this.getSupportedIndividualVertexProperties().textureCoordinates ? new Vector(u, v) : void 0;
    this.currentShape.vertex(position, textureCoordinates);
  }
  bezier(x1, y1, x2, y2, x3, y3, x4, y4) {
    const oldOrder = this._pInst.bezierOrder();
    this._pInst.bezierOrder(oldOrder);
    this._pInst.beginShape();
    this._pInst.bezierVertex(x1, y1);
    this._pInst.bezierVertex(x2, y2);
    this._pInst.bezierVertex(x3, y3);
    this._pInst.bezierVertex(x4, y4);
    this._pInst.endShape();
    return this;
  }
  spline(...args) {
    if (args.length === 2 * 4) {
      const [x1, y1, x2, y2, x3, y3, x4, y4] = args;
      this._pInst.beginShape();
      this._pInst.splineVertex(x1, y1);
      this._pInst.splineVertex(x2, y2);
      this._pInst.splineVertex(x3, y3);
      this._pInst.splineVertex(x4, y4);
      this._pInst.endShape();
    } else if (args.length === 3 * 4) {
      const [x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4] = args;
      this._pInst.beginShape();
      this._pInst.splineVertex(x1, y1, z1);
      this._pInst.splineVertex(x2, y2, z2);
      this._pInst.splineVertex(x3, y3, z3);
      this._pInst.splineVertex(x4, y4, z4);
      this._pInst.endShape();
    }
    return this;
  }
  beginClip(options2 = {}) {
    if (this._clipping) {
      throw new Error("It looks like you're trying to clip while already in the middle of clipping. Did you forget to endClip()?");
    }
    this._clipping = true;
    this._clipInvert = options2.invert;
  }
  endClip() {
    if (!this._clipping) {
      throw new Error("It looks like you've called endClip() without beginClip(). Did you forget to call beginClip() first?");
    }
    this._clipping = false;
  }
  /**
   * Resize our canvas element.
   */
  resize(w, h) {
    this.width = w;
    this.height = h;
  }
  get(x, y, w, h) {
    const pd = this._pixelDensity;
    const canvas2 = this.canvas;
    if (typeof x === "undefined" && typeof y === "undefined") {
      x = y = 0;
      w = this.width;
      h = this.height;
    } else {
      x *= pd;
      y *= pd;
      if (typeof w === "undefined" && typeof h === "undefined") {
        if (x < 0 || y < 0 || x >= canvas2.width || y >= canvas2.height) {
          return [0, 0, 0, 0];
        }
        return this._getPixel(x, y);
      }
    }
    const region = new Image(w * pd, h * pd);
    region.pixelDensity(pd);
    region.canvas.getContext("2d").drawImage(canvas2, x, y, w * pd, h * pd, 0, 0, w * pd, h * pd);
    return region;
  }
  scale(x, y) {
  }
  fill(...args) {
    this.states.setValue("fillSet", true);
    this.states.setValue("fillColor", this._pInst.color(...args));
    this.updateShapeVertexProperties();
  }
  noFill() {
    this.states.setValue("fillColor", null);
  }
  strokeWeight(w) {
    if (w === void 0) {
      return this.states.strokeWeight;
    } else {
      this.states.setValue("strokeWeight", w);
    }
  }
  stroke(...args) {
    this.states.setValue("strokeSet", true);
    this.states.setValue("strokeColor", this._pInst.color(...args));
    this.updateShapeVertexProperties();
  }
  noStroke() {
    this.states.setValue("strokeColor", null);
  }
  getCommonVertexProperties() {
    return {};
  }
  getSupportedIndividualVertexProperties() {
    return {
      textureCoordinates: false
    };
  }
  updateShapeProperties(modified) {
    if (!modified || modified.bezierOrder || modified.splineProperties) {
      const shape2 = this.currentShape;
      shape2.bezierOrder(this.states.bezierOrder);
      shape2.splineProperty("ends", this.states.splineProperties.ends);
      shape2.splineProperty("tightness", this.states.splineProperties.tightness);
    }
  }
  updateShapeVertexProperties(modified) {
    const props = this.getCommonVertexProperties();
    if (!modified || Object.keys(modified).some((k) => k in props)) {
      const shape2 = this.currentShape;
      for (const key in props) {
        shape2[key](props[key]);
      }
    }
  }
  _applyDefaults() {
    return this;
  }
};
__publicField(_Renderer, "states", {
  strokeColor: null,
  strokeSet: false,
  fillColor: null,
  fillSet: false,
  tint: null,
  imageMode: CORNER,
  rectMode: CORNER,
  ellipseMode: CENTER,
  strokeWeight: 1,
  textFont: { family: "sans-serif" },
  textLeading: 15,
  leadingSet: false,
  textSize: 12,
  textAlign: LEFT,
  textBaseline: BASELINE,
  bezierOrder: 3,
  splineProperties: new ClonableObject({ ends: INCLUDE, tightness: 0 }),
  textWrap: WORD,
  // added v2.0
  fontStyle: NORMAL,
  // v1: textStyle
  fontStretch: NORMAL,
  fontWeight: NORMAL,
  lineHeight: NORMAL,
  fontVariant: NORMAL,
  direction: "inherit"
});
var Renderer = _Renderer;
function renderer(p53, fn2) {
  p53.Renderer = Renderer;
}

// node_modules/p5/dist/dom/p5.MediaElement.js
var MediaElement = class extends Element {
  constructor(elt, pInst) {
    super(elt, pInst);
    const self2 = this;
    this.elt.crossOrigin = "anonymous";
    this._prevTime = 0;
    this._cueIDCounter = 0;
    this._cues = [];
    this.pixels = [];
    this._pixelsState = this;
    this._pixelDensity = 1;
    this._modified = false;
    this._frameOnCanvas = -1;
    Object.defineProperty(self2, "src", {
      get() {
        const firstChildSrc = self2.elt.children[0].src;
        const srcVal = self2.elt.src === window.location.href ? "" : self2.elt.src;
        const ret = firstChildSrc === window.location.href ? srcVal : firstChildSrc;
        return ret;
      },
      set(newValue) {
        for (let i = 0; i < self2.elt.children.length; i++) {
          self2.elt.removeChild(self2.elt.children[i]);
        }
        const source = document.createElement("source");
        source.src = newValue;
        elt.appendChild(source);
        self2.elt.src = newValue;
        self2.modified = true;
      }
    });
    self2._onended = function() {
    };
    self2.elt.onended = function() {
      self2._onended(self2);
    };
  }
  /**
   * Plays audio or video from a media element.
   *
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let beat;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display a message.
   *   text('Click to play', 50, 50);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   beat = createAudio('assets/beat.mp3');
   *
   *   describe('The text "Click to play" written in black on a gray background. A beat plays when the user clicks the square.');
   * }
   *
   * // Play the beat when the user presses the mouse.
   * function mousePressed() {
   *   beat.play();
   * }
   * </code>
   * </div>
   */
  play() {
    if (this.elt.currentTime === this.elt.duration) {
      this.elt.currentTime = 0;
    }
    let promise2;
    if (this.elt.readyState > 1) {
      promise2 = this.elt.play();
    } else {
      this.elt.load();
      promise2 = this.elt.play();
    }
    if (promise2 && promise2.catch) {
      promise2.catch((e2) => {
        if (e2.name === "NotAllowedError") {
          if (typeof IS_MINIFIED === "undefined") {
            p5._friendlyAutoplayError(this.src);
          } else {
            console.error(e2);
          }
        } else {
          console.error("Media play method encountered an unexpected error", e2);
        }
      });
    }
    return this;
  }
  /**
   * Stops a media element and sets its current time to 0.
   *
   * Calling `media.play()` will restart playing audio/video from the beginning.
   *
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let beat;
   * let isStopped = true;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   beat = createAudio('assets/beat.mp3');
   *
   *   describe('The text "Click to start" written in black on a gray background. The beat starts or stops when the user presses the mouse.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display different instructions based on playback.
   *   if (isStopped === true) {
   *     text('Click to start', 50, 50);
   *   } else {
   *     text('Click to stop', 50, 50);
   *   }
   * }
   *
   * // Adjust playback when the user presses the mouse.
   * function mousePressed() {
   *   if (isStopped === true) {
   *     // If the beat is stopped, play it.
   *     beat.play();
   *     isStopped = false;
   *   } else {
   *     // If the beat is playing, stop it.
   *     beat.stop();
   *     isStopped = true;
   *   }
   * }
   * </code>
   * </div>
   */
  stop() {
    this.elt.pause();
    this.elt.currentTime = 0;
    return this;
  }
  /**
   * Pauses a media element.
   *
   * Calling `media.play()` will resume playing audio/video from the moment it paused.
   *
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let beat;
   * let isPaused = true;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   beat = createAudio('assets/beat.mp3');
   *
   *   describe('The text "Click to play" written in black on a gray background. The beat plays or pauses when the user clicks the square.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display different instructions based on playback.
   *   if (isPaused === true) {
   *     text('Click to play', 50, 50);
   *   } else {
   *     text('Click to pause', 50, 50);
   *   }
   * }
   *
   * // Adjust playback when the user presses the mouse.
   * function mousePressed() {
   *   if (isPaused === true) {
   *     // If the beat is paused,
   *     // play it.
   *     beat.play();
   *     isPaused = false;
   *   } else {
   *     // If the beat is playing,
   *     // pause it.
   *     beat.pause();
   *     isPaused = true;
   *   }
   * }
   * </code>
   * </div>
   */
  pause() {
    this.elt.pause();
    return this;
  }
  /**
   * Plays the audio/video repeatedly in a loop.
   *
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let beat;
   * let isLooping = false;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   beat = createAudio('assets/beat.mp3');
   *
   *   describe('The text "Click to loop" written in black on a gray background. A beat plays repeatedly in a loop when the user clicks. The beat stops when the user clicks again.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display different instructions based on playback.
   *   if (isLooping === true) {
   *     text('Click to stop', 50, 50);
   *   } else {
   *     text('Click to loop', 50, 50);
   *   }
   * }
   *
   * // Adjust playback when the user presses the mouse.
   * function mousePressed() {
   *   if (isLooping === true) {
   *     // If the beat is looping, stop it.
   *     beat.stop();
   *     isLooping = false;
   *   } else {
   *     // If the beat is stopped, loop it.
   *     beat.loop();
   *     isLooping = true;
   *   }
   * }
   * </code>
   * </div>
   */
  loop() {
    this.elt.setAttribute("loop", true);
    this.play();
    return this;
  }
  /**
   * Stops the audio/video from playing in a loop.
   *
   * The media will stop when it finishes playing.
   *
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let beat;
   * let isPlaying = false;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   beat = createAudio('assets/beat.mp3');
   *
   *   describe('The text "Click to play" written in black on a gray background. A beat plays when the user clicks. The beat stops when the user clicks again.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display different instructions based on playback.
   *   if (isPlaying === true) {
   *     text('Click to stop', 50, 50);
   *   } else {
   *     text('Click to play', 50, 50);
   *   }
   * }
   *
   * // Adjust playback when the user presses the mouse.
   * function mousePressed() {
   *   if (isPlaying === true) {
   *     // If the beat is playing, stop it.
   *     beat.stop();
   *     isPlaying = false;
   *   } else {
   *     // If the beat is stopped, play it.
   *     beat.play();
   *     isPlaying = true;
   *   }
   * }
   * </code>
   * </div>
   */
  noLoop() {
    this.elt.removeAttribute("loop");
    return this;
  }
  /**
   * Sets up logic to check that autoplay succeeded.
   *
   * @private
   */
  _setupAutoplayFailDetection() {
    const timeout = setTimeout(() => {
      if (typeof IS_MINIFIED === "undefined") {
        p5._friendlyAutoplayError(this.src);
      } else {
        console.error(e);
      }
    }, 500);
    this.elt.addEventListener("play", () => clearTimeout(timeout), {
      passive: true,
      once: true
    });
  }
  /**
   * Sets the audio/video to play once it's loaded.
   *
   * The parameter, `shouldAutoplay`, is optional. Calling
   * `media.autoplay()` without an argument causes the media to play
   * automatically. If `true` is passed, as in `media.autoplay(true)`, the
   * media will automatically play. If `false` is passed, as in
   * `media.autoPlay(false)`, it won't play automatically.
   *
   * @param {Boolean} [shouldAutoplay] whether the element should autoplay.
   * @chainable
   *
   * @example
   * <div class='notest'>
   * <code>
   * let video;
   *
   * function setup() {
   *   noCanvas();
   *
   *   // Call handleVideo() once the video loads.
   *   video = createVideo('assets/fingers.mov', handleVideo);
   *
   *   describe('A video of fingers walking on a treadmill.');
   * }
   *
   * // Set the video's size and play it.
   * function handleVideo() {
   *   video.size(100, 100);
   *   video.autoplay();
   * }
   * </code>
   * </div>
   *
   * <div class='notest'>
   * <code>
   * function setup() {
   *   noCanvas();
   *
   *   // Load a video, but don't play it automatically.
   *   let video = createVideo('assets/fingers.mov', handleVideo);
   *
   *   // Play the video when the user clicks on it.
   *   video.mousePressed(handlePress);
   *
   *   describe('An image of fingers on a treadmill. They start walking when the user double-clicks on them.');
   * }
   * </code>
   * </div>
   *
   * // Set the video's size and playback mode.
   * function handleVideo() {
   *   video.size(100, 100);
   *   video.autoplay(false);
   * }
   *
   * // Play the video.
   * function handleClick() {
   *   video.play();
   * }
   */
  autoplay(val2) {
    const oldVal = this.elt.getAttribute("autoplay");
    this.elt.setAttribute("autoplay", val2);
    if (val2 && !oldVal) {
      const setupAutoplayFailDetection = () => this._setupAutoplayFailDetection();
      if (this.elt.readyState === 4) {
        setupAutoplayFailDetection();
      } else {
        this.elt.addEventListener("canplay", setupAutoplayFailDetection, {
          passive: true,
          once: true
        });
      }
    }
    return this;
  }
  /**
   * Sets the audio/video volume.
   *
   * Calling `media.volume()` without an argument returns the current volume
   * as a number in the range 0 (off) to 1 (maximum).
   *
   * The parameter, `val`, is optional. It's a number that sets the volume
   * from 0 (off) to 1 (maximum). For example, calling `media.volume(0.5)`
   * sets the volume to half of its maximum.
   *
   * @return {Number} current volume.
   *
   * @example
   * <div>
   * <code>
   * let dragon;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   dragon = createAudio('assets/lucky_dragons.mp3');
   *
   *   // Show the default media controls.
   *   dragon.showControls();
   *
   *   describe('The text "Volume: V" on a gray square with media controls beneath it. The number "V" oscillates between 0 and 1 as the music plays.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Produce a number between 0 and 1.
   *   let n = 0.5 * sin(frameCount * 0.01) + 0.5;
   *
   *   // Use n to set the volume.
   *   dragon.volume(n);
   *
   *   // Get the current volume and display it.
   *   let v = dragon.volume();
   *
   *   // Round v to 1 decimal place for display.
   *   v = round(v, 1);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the volume.
   *   text(`Volume: ${v}`, 50, 50);
   * }
   * </code>
   * </div>
   */
  /**
   * @param {Number}            val volume between 0.0 and 1.0.
   * @chainable
   */
  volume(val2) {
    if (typeof val2 === "undefined") {
      return this.elt.volume;
    } else {
      this.elt.volume = val2;
    }
  }
  /**
   * Sets the audio/video playback speed.
   *
   * The parameter, `val`, is optional. It's a number that sets the playback
   * speed. 1 plays the media at normal speed, 0.5 plays it at half speed, 2
   * plays it at double speed, and so on. -1 plays the media at normal speed
   * in reverse.
   *
   * Calling `media.speed()` returns the current speed as a number.
   *
   * Note: Not all browsers support backward playback. Even if they do,
   * playback might not be smooth.
   *
   * @return {Number} current playback speed.
   *
   * @example
   * <div>
   * <code>
   * let dragon;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   dragon = createAudio('assets/lucky_dragons.mp3');
   *
   *   // Show the default media controls.
   *   dragon.showControls();
   *
   *   describe('The text "Speed: S" on a gray square with media controls beneath it. The number "S" oscillates between 0 and 1 as the music plays.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Produce a number between 0 and 2.
   *   let n = sin(frameCount * 0.01) + 1;
   *
   *   // Use n to set the playback speed.
   *   dragon.speed(n);
   *
   *   // Get the current speed and display it.
   *   let s = dragon.speed();
   *
   *   // Round s to 1 decimal place for display.
   *   s = round(s, 1);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the speed.
   *   text(`Speed: ${s}`, 50, 50);
   * }
   * </code>
   */
  /**
   * @param {Number} speed  speed multiplier for playback.
   * @chainable
   */
  speed(val2) {
    if (typeof val2 === "undefined") {
      return this.presetPlaybackRate || this.elt.playbackRate;
    } else {
      if (this.loadedmetadata) {
        this.elt.playbackRate = val2;
      } else {
        this.presetPlaybackRate = val2;
      }
    }
  }
  /**
   * Sets the media element's playback time.
   *
   * The parameter, `time`, is optional. It's a number that specifies the
   * time, in seconds, to jump to when playback begins.
   *
   * Calling `media.time()` without an argument returns the number of seconds
   * the audio/video has played.
   *
   * Note: Time resets to 0 when looping media restarts.
   *
   * @return {Number} current time (in seconds).
   *
   * @example
   * <div>
   * <code>
   * let dragon;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   dragon = createAudio('assets/lucky_dragons.mp3');
   *
   *   // Show the default media controls.
   *   dragon.showControls();
   *
   *   describe('The text "S seconds" on a gray square with media controls beneath it. The number "S" increases as the song plays.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Get the current playback time.
   *   let s = dragon.time();
   *
   *   // Round s to 1 decimal place for display.
   *   s = round(s, 1);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the playback time.
   *   text(`${s} seconds`, 50, 50);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let dragon;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   dragon = createAudio('assets/lucky_dragons.mp3');
   *
   *   // Show the default media controls.
   *   dragon.showControls();
   *
   *   // Jump to 2 seconds to start.
   *   dragon.time(2);
   *
   *   describe('The text "S seconds" on a gray square with media controls beneath it. The number "S" increases as the song plays.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Get the current playback time.
   *   let s = dragon.time();
   *
   *   // Round s to 1 decimal place for display.
   *   s = round(s, 1);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the playback time.
   *   text(`${s} seconds`, 50, 50);
   * }
   * </code>
   * </div>
   */
  /**
   * @param {Number} time time to jump to (in seconds).
   * @chainable
   */
  time(val2) {
    if (typeof val2 === "undefined") {
      return this.elt.currentTime;
    } else {
      this.elt.currentTime = val2;
      return this;
    }
  }
  /**
   * Returns the audio/video's duration in seconds.
   *
   * @return {Number} duration (in seconds).
   *
   * @example
   * <div>
   * <code>
   * let dragon;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   dragon = createAudio('assets/lucky_dragons.mp3');
   *
   *   // Show the default media controls.
   *   dragon.showControls();
   *
   *   describe('The text "S seconds left" on a gray square with media controls beneath it. The number "S" decreases as the song plays.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Calculate the time remaining.
   *   let s = dragon.duration() - dragon.time();
   *
   *   // Round s to 1 decimal place for display.
   *   s = round(s, 1);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display the time remaining.
   *   text(`${s} seconds left`, 50, 50);
   * }
   * </code>
   * </div>
   */
  duration() {
    return this.elt.duration;
  }
  _ensureCanvas() {
    if (!this.canvas) {
      this.canvas = document.createElement("canvas");
      this.drawingContext = this.canvas.getContext("2d");
      this.setModified(true);
    }
    const needsRedraw = this._frameOnCanvas !== this._pInst.frameCount;
    if (this.loadedmetadata && needsRedraw) {
      if (this.canvas.width !== this.elt.width) {
        this.canvas.width = this.elt.width;
        this.canvas.height = this.elt.height;
        this.width = this.canvas.width;
        this.height = this.canvas.height;
      }
      this.drawingContext.clearRect(
        0,
        0,
        this.canvas.width,
        this.canvas.height
      );
      if (this.flipped === true) {
        this.drawingContext.save();
        this.drawingContext.scale(-1, 1);
        this.drawingContext.translate(-this.canvas.width, 0);
      }
      this.drawingContext.drawImage(
        this.elt,
        0,
        0,
        this.canvas.width,
        this.canvas.height
      );
      if (this.flipped === true) {
        this.drawingContext.restore();
      }
      this.setModified(true);
      this._frameOnCanvas = this._pInst.frameCount;
    }
  }
  loadPixels(...args) {
    this._ensureCanvas();
    return p5.Renderer2D.prototype.loadPixels.apply(this, args);
  }
  updatePixels(x, y, w, h) {
    if (this.loadedmetadata) {
      this._ensureCanvas();
      p5.Renderer2D.prototype.updatePixels.call(this, x, y, w, h);
    }
    this.setModified(true);
    return this;
  }
  get(...args) {
    this._ensureCanvas();
    return p5.Renderer2D.prototype.get.apply(this, args);
  }
  _getPixel(...args) {
    this.loadPixels();
    return p5.Renderer2D.prototype._getPixel.apply(this, args);
  }
  set(x, y, imgOrCol) {
    if (this.loadedmetadata) {
      this._ensureCanvas();
      p5.Renderer2D.prototype.set.call(this, x, y, imgOrCol);
      this.setModified(true);
    }
  }
  copy(...args) {
    this._ensureCanvas();
    p5.prototype.copy.apply(this, args);
  }
  mask(...args) {
    this.loadPixels();
    this.setModified(true);
    p5.Image.prototype.mask.apply(this, args);
  }
  /**
   * helper method for web GL mode to figure out if the element
   * has been modified and might need to be re-uploaded to texture
   * memory between frames.
   * @private
   * @return {boolean} a boolean indicating whether or not the
   * image has been updated or modified since last texture upload.
   */
  isModified() {
    return this._modified;
  }
  /**
   * helper method for web GL mode to indicate that an element has been
   * changed or unchanged since last upload. gl texture upload will
   * set this value to false after uploading the texture; or might set
   * it to true if metadata has become available but there is no actual
   * texture data available yet..
   * @param {Boolean} val sets whether or not the element has been
   * modified.
   * @private
   */
  setModified(value) {
    this._modified = value;
  }
  /**
   * Calls a function when the audio/video reaches the end of its playback.
   *
   * The element is passed as an argument to the callback function.
   *
   * Note: The function won't be called if the media is looping.
   *
   * @param  {Function} callback function to call when playback ends.
   *                             The `p5.MediaElement` is passed as
   *                             the argument.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let beat;
   * let isPlaying = false;
   * let isDone = false;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   beat = createAudio('assets/beat.mp3');
   *
   *   // Call handleEnd() when the beat finishes.
   *   beat.onended(handleEnd);
   *
   *   describe('The text "Click to play" written in black on a gray square. A beat plays when the user clicks. The text "Done!" appears when the beat finishes playing.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *
   *   // Display different messages based on playback.
   *   if (isDone === true) {
   *     text('Done!', 50, 50);
   *   } else if (isPlaying === false) {
   *     text('Click to play', 50, 50);
   *   } else {
   *     text('Playing...', 50, 50);
   *   }
   * }
   *
   * // Play the beat when the user presses the mouse.
   * function mousePressed() {
   *   if (isPlaying === false) {
   *     isPlaying = true;
   *     beat.play();
   *   }
   * }
   *
   * // Set isDone when playback ends.
   * function handleEnd() {
   *   isDone = false;
   * }
   * </code>
   * </div>
   */
  onended(callback) {
    this._onended = callback;
    return this;
  }
  /*** CONNECT TO WEB AUDIO API / p5.sound.js ***/
  /**
   * Sends the element's audio to an output.
   *
   * The parameter, `audioNode`, can be an `AudioNode` or an object from the
   * `p5.sound` library.
   *
   * If no element is provided, as in `myElement.connect()`, the element
   * connects to the main output. All connections are removed by the
   * `.disconnect()` method.
   *
   * Note: This method is meant to be used with the p5.sound.js addon library.
   *
   * @param  {AudioNode|Object} audioNode AudioNode from the Web Audio API,
   * or an object from the p5.sound library
   */
  connect(obj) {
    let audioContext, mainOutput;
    if (typeof fn.getAudioContext === "function") {
      audioContext = fn.getAudioContext();
      mainOutput = p5.soundOut.input;
    } else {
      try {
        audioContext = obj.context;
        mainOutput = audioContext.destination;
      } catch (e2) {
        throw "connect() is meant to be used with Web Audio API or p5.sound.js";
      }
    }
    if (!this.audioSourceNode) {
      this.audioSourceNode = audioContext.createMediaElementSource(this.elt);
      this.audioSourceNode.connect(mainOutput);
    }
    if (obj) {
      if (obj.input) {
        this.audioSourceNode.connect(obj.input);
      } else {
        this.audioSourceNode.connect(obj);
      }
    } else {
      this.audioSourceNode.connect(mainOutput);
    }
  }
  /**
   * Disconnect all Web Audio routing, including to the main output.
   *
   * This is useful if you want to re-route the output through audio effects,
   * for example.
   *
   */
  disconnect() {
    if (this.audioSourceNode) {
      this.audioSourceNode.disconnect();
    } else {
      throw "nothing to disconnect";
    }
  }
  /*** SHOW / HIDE CONTROLS ***/
  /**
   * Show the default
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement" target="_blank">HTMLMediaElement</a>
   * controls.
   *
   * Note: The controls vary between web browsers.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background('cornflowerblue');
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(50);
   *
   *   // Display a dragon.
   *   text('🐉', 50, 50);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   let dragon = createAudio('assets/lucky_dragons.mp3');
   *
   *   // Show the default media controls.
   *   dragon.showControls();
   *
   *   describe('A dragon emoji, 🐉, drawn in the center of a blue square. A song plays in the background. Audio controls are displayed beneath the canvas.');
   * }
   * </code>
   * </div>
   */
  showControls() {
    this.elt.style["text-align"] = "inherit";
    this.elt.controls = true;
  }
  /**
   * Hide the default
   * <a href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement" target="_blank">HTMLMediaElement</a>
   * controls.
   *
   * @example
   * <div>
   * <code>
   * let dragon;
   * let isHidden = false;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   dragon = createAudio('assets/lucky_dragons.mp3');
   *
   *   // Show the default media controls.
   *   dragon.showControls();
   *
   *   describe('The text "Double-click to hide controls" written in the middle of a gray square. A song plays in the background. Audio controls are displayed beneath the canvas. The controls appear/disappear when the user double-clicks the square.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *
   *   // Display a different message when controls are hidden or shown.
   *   if (isHidden === true) {
   *     text('Double-click to show controls', 10, 20, 80, 80);
   *   } else {
   *     text('Double-click to hide controls', 10, 20, 80, 80);
   *   }
   * }
   *
   * // Show/hide controls based on a double-click.
   * function doubleClicked() {
   *   if (isHidden === true) {
   *     dragon.showControls();
   *     isHidden = false;
   *   } else {
   *     dragon.hideControls();
   *     isHidden = true;
   *   }
   * }
   * </code>
   * </div>
   */
  hideControls() {
    this.elt.controls = false;
  }
  /**
   * Schedules a function to call when the audio/video reaches a specific time
   * during its playback.
   *
   * The first parameter, `time`, is the time, in seconds, when the function
   * should run. This value is passed to `callback` as its first argument.
   *
   * The second parameter, `callback`, is the function to call at the specified
   * cue time.
   *
   * The third parameter, `value`, is optional and can be any type of value.
   * `value` is passed to `callback`.
   *
   * Calling `media.addCue()` returns an ID as a string. This is useful for
   * removing the cue later.
   *
   * @param {Number}   time     cue time to run the callback function.
   * @param {Function} callback function to call at the cue time.
   * @param {Object} [value]    object to pass as the argument to
   *                            `callback`.
   * @return {Number} id ID of this cue,
   *                     useful for `media.removeCue(id)`.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   let beat = createAudio('assets/beat.mp3');
   *
   *   // Play the beat in a loop.
   *   beat.loop();
   *
   *   // Schedule a few events.
   *   beat.addCue(0, changeBackground, 'red');
   *   beat.addCue(2, changeBackground, 'deeppink');
   *   beat.addCue(4, changeBackground, 'orchid');
   *   beat.addCue(6, changeBackground, 'lavender');
   *
   *   describe('A red square with a beat playing in the background. Its color changes every 2 seconds while the audio plays.');
   * }
   *
   * // Change the background color.
   * function changeBackground(c) {
   *   background(c);
   * }
   * </code>
   * </div>
   */
  addCue(time3, callback, val2) {
    const id = this._cueIDCounter++;
    const cue = new Cue(callback, time3, id, val2);
    this._cues.push(cue);
    if (!this.elt.ontimeupdate) {
      this.elt.ontimeupdate = this._onTimeUpdate.bind(this);
    }
    return id;
  }
  /**
   * Removes a callback based on its ID.
   *
   * @param  {Number} id ID of the cue, created by `media.addCue()`.
   *
   * @example
   * <div>
   * <code>
   * let lavenderID;
   * let isRemoved = false;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   let beat = createAudio('assets/beat.mp3');
   *
   *   // Play the beat in a loop.
   *   beat.loop();
   *
   *   // Schedule a few events.
   *   beat.addCue(0, changeBackground, 'red');
   *   beat.addCue(2, changeBackground, 'deeppink');
   *   beat.addCue(4, changeBackground, 'orchid');
   *
   *   // Record the ID of the "lavender" callback.
   *   lavenderID = beat.addCue(6, changeBackground, 'lavender');
   *
   *   describe('The text "Double-click to remove lavender." written on a red square. The color changes every 2 seconds while the audio plays. The lavender option is removed when the user double-clicks the square.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Display different instructions based on the available callbacks.
   *   if (isRemoved === false) {
   *     text('Double-click to remove lavender.', 10, 10, 80, 80);
   *   } else {
   *     text('No more lavender.', 10, 10, 80, 80);
   *   }
   * }
   *
   * // Change the background color.
   * function changeBackground(c) {
   *   background(c);
   * }
   *
   * // Remove the lavender color-change cue when the user double-clicks.
   * function doubleClicked() {
   *   if (isRemoved === false) {
   *     beat.removeCue(lavenderID);
   *     isRemoved = true;
   *   }
   * }
   * </code>
   * </div>
   */
  removeCue(id) {
    for (let i = 0; i < this._cues.length; i++) {
      if (this._cues[i].id === id) {
        console.log(id);
        this._cues.splice(i, 1);
      }
    }
    if (this._cues.length === 0) {
      this.elt.ontimeupdate = null;
    }
  }
  /**
   * Removes all functions scheduled with `media.addCue()`.
   *
   * @example
   * <div>
   * <code>
   * let isChanging = true;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   background(200);
   *
   *   // Create a p5.MediaElement using createAudio().
   *   let beat = createAudio('assets/beat.mp3');
   *
   *   // Play the beat in a loop.
   *   beat.loop();
   *
   *   // Schedule a few events.
   *   beat.addCue(0, changeBackground, 'red');
   *   beat.addCue(2, changeBackground, 'deeppink');
   *   beat.addCue(4, changeBackground, 'orchid');
   *   beat.addCue(6, changeBackground, 'lavender');
   *
   *   describe('The text "Double-click to stop changing." written on a square. The color changes every 2 seconds while the audio plays. The color stops changing when the user double-clicks the square.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Display different instructions based on the available callbacks.
   *   if (isChanging === true) {
   *     text('Double-click to stop changing.', 10, 10, 80, 80);
   *   } else {
   *     text('No more changes.', 10, 10, 80, 80);
   *   }
   * }
   *
   * // Change the background color.
   * function changeBackground(c) {
   *   background(c);
   * }
   *
   * // Remove cued functions and stop changing colors when the user
   * // double-clicks.
   * function doubleClicked() {
   *   if (isChanging === true) {
   *     beat.clearCues();
   *     isChanging = false;
   *   }
   * }
   * </code>
   * </div>
   */
  clearCues() {
    this._cues = [];
    this.elt.ontimeupdate = null;
  }
  // private method that checks for cues to be fired if events
  // have been scheduled using addCue(callback, time).
  _onTimeUpdate() {
    const playbackTime = this.time();
    for (let i = 0; i < this._cues.length; i++) {
      const callbackTime = this._cues[i].time;
      const val2 = this._cues[i].val;
      if (this._prevTime < callbackTime && callbackTime <= playbackTime) {
        this._cues[i].callback(val2);
      }
    }
    this._prevTime = playbackTime;
  }
};
var Cue = class {
  constructor(callback, time3, id, val2) {
    this.callback = callback;
    this.time = time3;
    this.id = id;
    this.val = val2;
  }
};
function media(p53, fn2) {
  function addElement(elt, pInst, media2) {
    const node = pInst._userNode ? pInst._userNode : document.body;
    node.appendChild(elt);
    const c4 = media2 ? new MediaElement(elt, pInst) : new Element(elt, pInst);
    pInst._elements.push(c4);
    return c4;
  }
  function createMedia(pInst, type3, src, callback) {
    const elt = document.createElement(type3);
    src = src || "";
    if (typeof src === "string") {
      src = [src];
    }
    for (const mediaSource of src) {
      const sourceEl = document.createElement("source");
      sourceEl.setAttribute("src", mediaSource);
      elt.appendChild(sourceEl);
    }
    const mediaEl = addElement(elt, pInst, true);
    mediaEl.loadedmetadata = false;
    elt.addEventListener("loadedmetadata", () => {
      mediaEl.width = elt.videoWidth;
      mediaEl.height = elt.videoHeight;
      if (mediaEl.elt.width === 0) mediaEl.elt.width = elt.videoWidth;
      if (mediaEl.elt.height === 0) mediaEl.elt.height = elt.videoHeight;
      if (mediaEl.presetPlaybackRate) {
        mediaEl.elt.playbackRate = mediaEl.presetPlaybackRate;
        delete mediaEl.presetPlaybackRate;
      }
      mediaEl.loadedmetadata = true;
    });
    if (typeof callback === "function") {
      const callbackHandler = () => {
        callback(mediaEl);
        elt.removeEventListener("canplaythrough", callbackHandler);
      };
      elt.addEventListener("canplaythrough", callbackHandler);
    }
    return mediaEl;
  }
  fn2.createVideo = function(src, callback) {
    return createMedia(this, "video", src, callback);
  };
  fn2.createAudio = function(src, callback) {
    return createMedia(this, "audio", src, callback);
  };
  fn2.VIDEO = "video";
  fn2.AUDIO = "audio";
  if (navigator.mediaDevices === void 0) {
    navigator.mediaDevices = {};
  }
  if (navigator.mediaDevices.getUserMedia === void 0) {
    navigator.mediaDevices.getUserMedia = function(constraints) {
      const getUserMedia = navigator.webkitGetUserMedia || navigator.mozGetUserMedia;
      if (!getUserMedia) {
        return Promise.reject(
          new Error("getUserMedia is not implemented in this browser")
        );
      }
      return new Promise(function(resolve, reject) {
        getUserMedia.call(navigator, constraints, resolve, reject);
      });
    };
  }
  fn2.createCapture = function(...args) {
    if (!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia)) {
      throw new DOMException("getUserMedia not supported in this browser");
    }
    let useVideo = true;
    let useAudio = true;
    let constraints;
    let callback;
    let flipped = false;
    for (const arg of args) {
      if (arg === fn2.VIDEO) useAudio = false;
      else if (arg === fn2.AUDIO) useVideo = false;
      else if (typeof arg === "object") {
        if (arg.flipped !== void 0) {
          flipped = arg.flipped;
          delete arg.flipped;
        }
        constraints = Object.assign({}, constraints, arg);
      } else if (typeof arg === "function") {
        callback = arg;
      }
    }
    const videoConstraints = { video: useVideo, audio: useAudio };
    constraints = Object.assign({}, videoConstraints, constraints);
    const domElement = document.createElement("video");
    domElement.setAttribute("playsinline", "");
    navigator.mediaDevices.getUserMedia(constraints).then(function(stream) {
      try {
        if ("srcObject" in domElement) {
          domElement.srcObject = stream;
        } else {
          domElement.src = window.URL.createObjectURL(stream);
        }
      } catch (err2) {
        domElement.src = stream;
      }
    }).catch((e2) => {
      if (e2.name === "NotFoundError")
        p53._friendlyError("No webcam found on this device", "createCapture");
      if (e2.name === "NotAllowedError")
        p53._friendlyError("Access to the camera was denied", "createCapture");
      console.error(e2);
    });
    const videoEl = addElement(domElement, this, true);
    videoEl.loadedmetadata = false;
    domElement.addEventListener("loadedmetadata", function() {
      domElement.play();
      if (domElement.width) {
        videoEl.width = domElement.width;
        videoEl.height = domElement.height;
        if (flipped) {
          videoEl.elt.style.transform = "scaleX(-1)";
        }
      } else {
        videoEl.width = videoEl.elt.width = domElement.videoWidth;
        videoEl.height = videoEl.elt.height = domElement.videoHeight;
      }
      videoEl.loadedmetadata = true;
      if (callback) callback(domElement.srcObject);
    });
    videoEl.flipped = flipped;
    return videoEl;
  };
  p53.MediaElement = MediaElement;
}
if (typeof p5 !== "undefined") {
  media(p5, p5.prototype);
}

// node_modules/p5/dist/core/helpers.js
function modeAdjust(a2, b3, c4, d2, mode) {
  let bbox;
  if (mode === CORNER) {
    bbox = {
      x: a2,
      y: b3,
      w: Math.abs(c4),
      h: Math.abs(d2)
    };
  } else if (mode === CORNERS) {
    bbox = {
      x: Math.min(a2, c4),
      y: Math.min(b3, d2),
      w: Math.abs(c4 - a2),
      h: Math.abs(d2 - b3)
    };
  } else if (mode === RADIUS) {
    c4 = Math.abs(c4);
    d2 = Math.abs(d2);
    bbox = {
      x: a2 - c4,
      y: b3 - d2,
      w: 2 * c4,
      h: 2 * d2
    };
  } else if (mode === CENTER) {
    c4 = Math.abs(c4);
    d2 = Math.abs(d2);
    bbox = {
      x: a2 - c4 * 0.5,
      y: b3 - d2 * 0.5,
      w: c4,
      h: d2
    };
  }
  return bbox;
}
var canvas = { modeAdjust };

// node_modules/p5/dist/shape/2d_primitives.js
function primitives(p53, fn2) {
  fn2._normalizeArcAngles = (start, stop, width, height, correctForScaling) => {
    const epsilon = 1e-5;
    let separation;
    start = start - TWO_PI * Math.floor(start / TWO_PI);
    stop = stop - TWO_PI * Math.floor(stop / TWO_PI);
    separation = Math.min(
      Math.abs(start - stop),
      TWO_PI - Math.abs(start - stop)
    );
    if (correctForScaling) {
      if (start <= HALF_PI) {
        start = Math.atan(width / height * Math.tan(start));
      } else if (start > HALF_PI && start <= 3 * HALF_PI) {
        start = Math.atan(width / height * Math.tan(start)) + PI;
      } else {
        start = Math.atan(width / height * Math.tan(start)) + TWO_PI;
      }
      if (stop <= HALF_PI) {
        stop = Math.atan(width / height * Math.tan(stop));
      } else if (stop > HALF_PI && stop <= 3 * HALF_PI) {
        stop = Math.atan(width / height * Math.tan(stop)) + PI;
      } else {
        stop = Math.atan(width / height * Math.tan(stop)) + TWO_PI;
      }
    }
    if (start > stop) {
      stop += TWO_PI;
    }
    return {
      start,
      stop,
      correspondToSamePoint: separation < epsilon
    };
  };
  fn2.arc = function(x, y, w, h, start, stop, mode, detail) {
    if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) {
      return this;
    }
    if (start === stop) {
      return this;
    }
    start = this._toRadians(start);
    stop = this._toRadians(stop);
    const vals = canvas.modeAdjust(x, y, w, h, this._renderer.states.ellipseMode);
    const angles = this._normalizeArcAngles(start, stop, vals.w, vals.h, true);
    if (angles.correspondToSamePoint) {
      this._renderer.ellipse([vals.x, vals.y, vals.w, vals.h, detail]);
    } else {
      this._renderer.arc(
        vals.x,
        vals.y,
        vals.w,
        vals.h,
        angles.start,
        // [0, TWO_PI)
        angles.stop,
        // [start, start + TWO_PI)
        mode,
        detail
      );
      if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
        this._accsOutput("arc", [
          vals.x,
          vals.y,
          vals.w,
          vals.h,
          angles.start,
          angles.stop,
          mode
        ]);
      }
    }
    return this;
  };
  fn2.ellipse = function(x, y, w, h, detailX) {
    return this._renderEllipse(...arguments);
  };
  fn2.circle = function(...args) {
    const argss = args.slice(0, 2);
    argss.push(args[2], args[2]);
    return this._renderEllipse(...argss);
  };
  fn2._renderEllipse = function(x, y, w, h, detailX) {
    if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) {
      return this;
    }
    if (typeof h === "undefined") {
      h = w;
    }
    const vals = canvas.modeAdjust(x, y, w, h, this._renderer.states.ellipseMode);
    this._renderer.ellipse([vals.x, vals.y, vals.w, vals.h, detailX]);
    if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
      this._accsOutput("ellipse", [vals.x, vals.y, vals.w, vals.h]);
    }
    return this;
  };
  fn2.line = function(...args) {
    if (this._renderer.states.strokeColor) {
      this._renderer.line(...args);
    }
    if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
      this._accsOutput("line", args);
    }
    return this;
  };
  fn2.point = function(...args) {
    if (this._renderer.states.strokeColor) {
      if (args.length === 1 && args[0] instanceof p53.Vector) {
        this._renderer.point.call(
          this._renderer,
          args[0].x,
          args[0].y,
          args[0].z
        );
      } else {
        this._renderer.point(...args);
        if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
          this._accsOutput("point", args);
        }
      }
    }
    return this;
  };
  fn2.quad = function(...args) {
    if (this._renderer.states.strokeColor || this._renderer.states.fillColor) {
      if (this._renderer.isP3D && args.length < 12) {
        this._renderer.quad.call(
          this._renderer,
          args[0],
          args[1],
          0,
          args[2],
          args[3],
          0,
          args[4],
          args[5],
          0,
          args[6],
          args[7],
          0,
          args[8],
          args[9]
        );
      } else {
        this._renderer.quad(...args);
        if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
          this._accsOutput("quadrilateral", args);
        }
      }
    }
    return this;
  };
  fn2.rect = function(...args) {
    return this._renderRect(...args);
  };
  fn2.square = function(x, y, s, tl, tr, br, bl) {
    return this._renderRect.call(this, x, y, s, s, tl, tr, br, bl);
  };
  fn2._renderRect = function() {
    if (this._renderer.states.strokeColor || this._renderer.states.fillColor) {
      if (arguments.length === 3) {
        arguments[3] = arguments[2];
      }
      const vals = canvas.modeAdjust(
        arguments[0],
        arguments[1],
        arguments[2],
        arguments[3],
        this._renderer.states.rectMode
      );
      if (this._renderer.states.rectMode === CORNER) {
        vals.w = arguments[2];
        vals.h = arguments[3];
      }
      const args = [vals.x, vals.y, vals.w, vals.h];
      for (let i = 4; i < arguments.length; i++) {
        args[i] = arguments[i];
      }
      this._renderer.rect(args);
      if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
        this._accsOutput("rectangle", [vals.x, vals.y, vals.w, vals.h]);
      }
    }
    return this;
  };
  fn2.triangle = function(...args) {
    if (this._renderer.states.strokeColor || this._renderer.states.fillColor) {
      this._renderer.triangle(args);
    }
    if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
      this._accsOutput("triangle", args);
    }
    return this;
  };
}
if (typeof p5 !== "undefined") {
  primitives(p5, p5.prototype);
}

// node_modules/p5/dist/shape/attributes.js
function attributes(p53, fn2) {
  fn2.ellipseMode = function(m3) {
    if (m3 === CORNER || m3 === CORNERS || m3 === RADIUS || m3 === CENTER) {
      this._renderer.states.setValue("ellipseMode", m3);
    }
    return this;
  };
  fn2.noSmooth = function() {
    if (!this._renderer.isP3D) {
      if ("imageSmoothingEnabled" in this.drawingContext) {
        this.drawingContext.imageSmoothingEnabled = false;
      }
    } else {
      this.setAttributes("antialias", false);
    }
    return this;
  };
  fn2.rectMode = function(m3) {
    if (m3 === CORNER || m3 === CORNERS || m3 === RADIUS || m3 === CENTER) {
      this._renderer.states.setValue("rectMode", m3);
    }
    return this;
  };
  fn2.smooth = function() {
    if (!this._renderer.isP3D) {
      if ("imageSmoothingEnabled" in this.drawingContext) {
        this.drawingContext.imageSmoothingEnabled = true;
      }
    } else {
      this.setAttributes("antialias", true);
    }
    return this;
  };
  fn2.strokeCap = function(cap) {
    if (cap === ROUND || cap === SQUARE || cap === PROJECT) {
      this._renderer.strokeCap(cap);
    }
    return this;
  };
  fn2.strokeJoin = function(join) {
    if (join === ROUND || join === BEVEL || join === MITER) {
      this._renderer.strokeJoin(join);
    }
    return this;
  };
  fn2.strokeWeight = function(w) {
    this._renderer.strokeWeight(w);
    return this;
  };
}
if (typeof p5 !== "undefined") {
  attributes(p5, p5.prototype);
}

// node_modules/p5/dist/shape/curves.js
function curves(p53, fn2) {
  fn2.bezier = function(...args) {
    if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) {
      return this;
    }
    this._renderer.bezier(...args);
    return this;
  };
  fn2.bezierPoint = function(a2, b3, c4, d2, t) {
    const adjustedT = 1 - t;
    return Math.pow(adjustedT, 3) * a2 + 3 * Math.pow(adjustedT, 2) * t * b3 + 3 * adjustedT * Math.pow(t, 2) * c4 + Math.pow(t, 3) * d2;
  };
  fn2.bezierTangent = function(a2, b3, c4, d2, t) {
    const adjustedT = 1 - t;
    return 3 * d2 * Math.pow(t, 2) - 3 * c4 * Math.pow(t, 2) + 6 * c4 * adjustedT * t - 6 * b3 * adjustedT * t + 3 * b3 * Math.pow(adjustedT, 2) - 3 * a2 * Math.pow(adjustedT, 2);
  };
  fn2.spline = function(...args) {
    if (!this._renderer.states.strokeColor && !this._renderer.states.fillColor) {
      return this;
    }
    this._renderer.spline(...args);
    return this;
  };
  fn2.splinePoint = function(a2, b3, c4, d2, t) {
    const s = this._renderer.states.splineProperties.tightness, t3 = t * t * t, t2 = t * t, f1 = (s - 1) / 2 * t3 + (1 - s) * t2 + (s - 1) / 2 * t, f2 = (s + 3) / 2 * t3 + (-5 - s) / 2 * t2 + 1, f3 = (-3 - s) / 2 * t3 + (s + 2) * t2 + (1 - s) / 2 * t, f4 = (1 - s) / 2 * t3 + (s - 1) / 2 * t2;
    return a2 * f1 + b3 * f2 + c4 * f3 + d2 * f4;
  };
  fn2.splineTangent = function(a2, b3, c4, d2, t) {
    const s = this._renderer.states.splineProperties.tightness, tt3 = t * t * 3, t2 = t * 2, f1 = (s - 1) / 2 * tt3 + (1 - s) * t2 + (s - 1) / 2, f2 = (s + 3) / 2 * tt3 + (-5 - s) / 2 * t2, f3 = (-3 - s) / 2 * tt3 + (s + 2) * t2 + (1 - s) / 2, f4 = (1 - s) / 2 * tt3 + (s - 1) / 2 * t2;
    return a2 * f1 + b3 * f2 + c4 * f3 + d2 * f4;
  };
}
if (typeof p5 !== "undefined") {
  curves(p5, p5.prototype);
}

// node_modules/p5/dist/shape/vertex.js
function vertex(p53, fn2) {
  fn2.beginShape = function(kind) {
    this._renderer.beginShape(...arguments);
  };
  fn2.bezierVertex = function(...args) {
    this._renderer.bezierVertex(...args);
  };
  fn2.endShape = function(mode, count = 1) {
    if (count < 1) {
      console.log("🌸 p5.js says: You can not have less than one instance");
      count = 1;
    }
    this._renderer.endShape(mode, count);
  };
  fn2.normal = function(x, y, z) {
    this._assert3d("normal");
    this._renderer.normal(...arguments);
    return this;
  };
  fn2.vertexProperty = function(attributeName, data3) {
    this._renderer.vertexProperty(attributeName, data3);
  };
}
if (typeof p5 !== "undefined") {
  vertex(p5, p5.prototype);
}

// node_modules/p5/dist/color/setting.js
function setting(p53, fn2) {
  fn2.beginClip = function(options2 = {}) {
    this._renderer.beginClip(options2);
  };
  fn2.endClip = function() {
    this._renderer.endClip();
  };
  fn2.clip = function(callback, options2) {
    this._renderer.beginClip(options2);
    callback();
    this._renderer.endClip(options2);
  };
  fn2.background = function(...args) {
    this._renderer.background(...args);
    return this;
  };
  fn2.clear = function(...args) {
    const _r = args[0] || 0;
    const _g = args[1] || 0;
    const _b2 = args[2] || 0;
    const _a2 = args[3] || 0;
    this._renderer.clear(_r, _g, _b2, _a2);
    return this;
  };
  fn2.colorMode = function(mode, max1, max2, max3, maxA) {
    if ([
      RGB,
      RGBHDR,
      HSB,
      HSL,
      HWB,
      LAB,
      LCH,
      OKLAB,
      OKLCH
    ].includes(mode)) {
      this._renderer.states.setValue("colorMode", mode);
      this._renderer.states.setValue("colorMaxes", this._renderer.states.colorMaxes.clone());
      const maxes = this._renderer.states.colorMaxes[mode];
      if (arguments.length === 2) {
        maxes[0] = max1;
        maxes[1] = max1;
        maxes[2] = max1;
        maxes[3] = max1;
      } else if (arguments.length === 4) {
        maxes[0] = max1;
        maxes[1] = max2;
        maxes[2] = max3;
      } else if (arguments.length === 5) {
        maxes[0] = max1;
        maxes[1] = max2;
        maxes[2] = max3;
        maxes[3] = maxA;
      }
    }
    return this._renderer.states.colorMode;
  };
  fn2.fill = function(...args) {
    this._renderer.fill(...args);
    return this;
  };
  fn2.noFill = function() {
    this._renderer.noFill();
    return this;
  };
  fn2.noStroke = function() {
    this._renderer.states.setValue("strokeColor", null);
    return this;
  };
  fn2.stroke = function(...args) {
    this._renderer.stroke(...args);
    return this;
  };
  fn2.erase = function(opacityFill = 255, opacityStroke = 255) {
    this._renderer.erase(opacityFill, opacityStroke);
    return this;
  };
  fn2.noErase = function() {
    this._renderer.noErase();
    return this;
  };
  fn2.blendMode = function(mode) {
    if (mode === NORMAL) {
      console.warn(
        "NORMAL has been deprecated for use in blendMode. defaulting to BLEND instead."
      );
      mode = BLEND;
    }
    this._renderer.blendMode(mode);
  };
}
if (typeof p5 !== "undefined") {
  setting(p5, p5.prototype);
}

// node_modules/p5/dist/rendering-BELwvfI6.js
var omggif2 = __toESM(require_omggif());

// node_modules/p5/dist/io/csv.js
function parse2(csv, options2, reviver = (v) => v) {
  const ctx = /* @__PURE__ */ Object.create(null);
  ctx.options = options2 || {};
  ctx.reviver = reviver;
  ctx.value = "";
  ctx.entry = [];
  ctx.output = [];
  ctx.col = 1;
  ctx.row = 1;
  ctx.options.delimiter = ctx.options.delimiter === void 0 ? '"' : options2.delimiter;
  if (ctx.options.delimiter.length > 1 || ctx.options.delimiter.length === 0)
    throw Error(`CSVError: delimiter must be one character [${ctx.options.separator}]`);
  ctx.options.separator = ctx.options.separator === void 0 ? "," : options2.separator;
  if (ctx.options.separator.length > 1 || ctx.options.separator.length === 0)
    throw Error(`CSVError: separator must be one character [${ctx.options.separator}]`);
  const lexer = new RegExp(`${escapeRegExp(ctx.options.delimiter)}|${escapeRegExp(ctx.options.separator)}|\r
|
|\r|[^${escapeRegExp(ctx.options.delimiter)}${escapeRegExp(ctx.options.separator)}\r
]+`, "y");
  const isNewline = /^(\r\n|\n|\r)$/;
  let matches = [];
  let match = "";
  let state = 0;
  while ((matches = lexer.exec(csv)) !== null) {
    match = matches[0];
    switch (state) {
      case 0:
        switch (true) {
          case match === ctx.options.delimiter:
            state = 3;
            break;
          case match === ctx.options.separator:
            state = 0;
            valueEnd(ctx);
            break;
          case isNewline.test(match):
            state = 0;
            valueEnd(ctx);
            entryEnd(ctx);
            break;
          default:
            ctx.value += match;
            state = 2;
            break;
        }
        break;
      case 2:
        switch (true) {
          case match === ctx.options.separator:
            state = 0;
            valueEnd(ctx);
            break;
          case isNewline.test(match):
            state = 0;
            valueEnd(ctx);
            entryEnd(ctx);
            break;
          default:
            state = 4;
            throw Error(`CSVError: Illegal state [row:${ctx.row}, col:${ctx.col}]`);
        }
        break;
      case 3:
        switch (true) {
          case match === ctx.options.delimiter:
            state = 4;
            break;
          default:
            state = 3;
            ctx.value += match;
            break;
        }
        break;
      case 4:
        switch (true) {
          case match === ctx.options.delimiter:
            state = 3;
            ctx.value += match;
            break;
          case match === ctx.options.separator:
            state = 0;
            valueEnd(ctx);
            break;
          case isNewline.test(match):
            state = 0;
            valueEnd(ctx);
            entryEnd(ctx);
            break;
          default:
            throw Error(`CSVError: Illegal state [row:${ctx.row}, col:${ctx.col}]`);
        }
        break;
    }
  }
  if (ctx.entry.length !== 0) {
    valueEnd(ctx);
    entryEnd(ctx);
  }
  return ctx.output;
}
function stringify(array2, options2 = {}, replacer = (v) => v) {
  const ctx = /* @__PURE__ */ Object.create(null);
  ctx.options = options2;
  ctx.options.eof = ctx.options.eof !== void 0 ? ctx.options.eof : true;
  ctx.row = 1;
  ctx.col = 1;
  ctx.output = "";
  ctx.options.delimiter = ctx.options.delimiter === void 0 ? '"' : options2.delimiter;
  if (ctx.options.delimiter.length > 1 || ctx.options.delimiter.length === 0)
    throw Error(`CSVError: delimiter must be one character [${ctx.options.separator}]`);
  ctx.options.separator = ctx.options.separator === void 0 ? "," : options2.separator;
  if (ctx.options.separator.length > 1 || ctx.options.separator.length === 0)
    throw Error(`CSVError: separator must be one character [${ctx.options.separator}]`);
  const needsDelimiters = new RegExp(`${escapeRegExp(ctx.options.delimiter)}|${escapeRegExp(ctx.options.separator)}|\r
|
|\r`);
  array2.forEach((row, rIdx) => {
    let entry = "";
    ctx.col = 1;
    row.forEach((col, cIdx) => {
      if (typeof col === "string") {
        col = col.replace(new RegExp(ctx.options.delimiter, "g"), `${ctx.options.delimiter}${ctx.options.delimiter}`);
        col = needsDelimiters.test(col) ? `${ctx.options.delimiter}${col}${ctx.options.delimiter}` : col;
      }
      entry += replacer(col, ctx.row, ctx.col);
      if (cIdx !== row.length - 1) {
        entry += ctx.options.separator;
      }
      ctx.col++;
    });
    switch (true) {
      case ctx.options.eof:
      case (!ctx.options.eof && rIdx !== array2.length - 1):
        ctx.output += `${entry}
`;
        break;
      default:
        ctx.output += `${entry}`;
        break;
    }
    ctx.row++;
  });
  return ctx.output;
}
function valueEnd(ctx) {
  const value = ctx.options.typed ? inferType(ctx.value) : ctx.value;
  ctx.entry.push(ctx.reviver(value, ctx.row, ctx.col));
  ctx.value = "";
  ctx.col++;
}
function entryEnd(ctx) {
  ctx.output.push(ctx.entry);
  ctx.entry = [];
  ctx.row++;
  ctx.col = 1;
}
function inferType(value) {
  const isNumber = /.\./;
  switch (true) {
    case value === "true":
    case value === "false":
      return value === "true";
    case isNumber.test(value):
      return parseFloat(value);
    case isFinite(value):
      return parseInt(value);
    default:
      return value;
  }
}
function escapeRegExp(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}

// node_modules/gifenc/dist/gifenc.esm.js
var X = { signature: "GIF", version: "89a", trailer: 59, extensionIntroducer: 33, applicationExtensionLabel: 255, graphicControlExtensionLabel: 249, imageSeparator: 44, signatureSize: 3, versionSize: 3, globalColorTableFlagMask: 128, colorResolutionMask: 112, sortFlagMask: 8, globalColorTableSizeMask: 7, applicationIdentifierSize: 8, applicationAuthCodeSize: 3, disposalMethodMask: 28, userInputFlagMask: 2, transparentColorFlagMask: 1, localColorTableFlagMask: 128, interlaceFlagMask: 64, idSortFlagMask: 32, localColorTableSizeMask: 7 };
function F(t = 256) {
  let e2 = 0, s = new Uint8Array(t);
  return { get buffer() {
    return s.buffer;
  }, reset() {
    e2 = 0;
  }, bytesView() {
    return s.subarray(0, e2);
  }, bytes() {
    return s.slice(0, e2);
  }, writeByte(r) {
    n3(e2 + 1), s[e2] = r, e2++;
  }, writeBytes(r, o = 0, i = r.length) {
    n3(e2 + i);
    for (let c4 = 0; c4 < i; c4++) s[e2++] = r[c4 + o];
  }, writeBytesView(r, o = 0, i = r.byteLength) {
    n3(e2 + i), s.set(r.subarray(o, o + i), e2), e2 += i;
  } };
  function n3(r) {
    var o = s.length;
    if (o >= r) return;
    var i = 1024 * 1024;
    r = Math.max(r, o * (o < i ? 2 : 1.125) >>> 0), o != 0 && (r = Math.max(r, 256));
    let c4 = s;
    s = new Uint8Array(r), e2 > 0 && s.set(c4.subarray(0, e2), 0);
  }
}
var O = 12;
var J = 5003;
var lt = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535];
function at(t, e2, s, n3, r = F(512), o = new Uint8Array(256), i = new Int32Array(J), c4 = new Int32Array(J)) {
  let x = i.length, a2 = Math.max(2, n3);
  o.fill(0), c4.fill(0), i.fill(-1);
  let l = 0, f = 0, g2 = a2 + 1, h = g2, b3 = false, w = h, _23 = (1 << w) - 1, u = 1 << g2 - 1, k = u + 1, B = u + 2, p2 = 0, A = s[0], z = 0;
  for (let y = x; y < 65536; y *= 2) ++z;
  z = 8 - z, r.writeByte(a2), I(u);
  let d2 = s.length;
  for (let y = 1; y < d2; y++) {
    t: {
      let m3 = s[y], v = (m3 << O) + A, M = m3 << z ^ A;
      if (i[M] === v) {
        A = c4[M];
        break t;
      }
      let V = M === 0 ? 1 : x - M;
      for (; i[M] >= 0; ) if (M -= V, M < 0 && (M += x), i[M] === v) {
        A = c4[M];
        break t;
      }
      I(A), A = m3, B < 1 << O ? (c4[M] = B++, i[M] = v) : (i.fill(-1), B = u + 2, b3 = true, I(u));
    }
  }
  return I(A), I(k), r.writeByte(0), r.bytesView();
  function I(y) {
    for (l &= lt[f], f > 0 ? l |= y << f : l = y, f += w; f >= 8; ) o[p2++] = l & 255, p2 >= 254 && (r.writeByte(p2), r.writeBytesView(o, 0, p2), p2 = 0), l >>= 8, f -= 8;
    if ((B > _23 || b3) && (b3 ? (w = h, _23 = (1 << w) - 1, b3 = false) : (++w, _23 = w === O ? 1 << w : (1 << w) - 1)), y == k) {
      for (; f > 0; ) o[p2++] = l & 255, p2 >= 254 && (r.writeByte(p2), r.writeBytesView(o, 0, p2), p2 = 0), l >>= 8, f -= 8;
      p2 > 0 && (r.writeByte(p2), r.writeBytesView(o, 0, p2), p2 = 0);
    }
  }
}
var $ = at;
function D(t, e2, s) {
  return t << 8 & 63488 | e2 << 2 & 992 | s >> 3;
}
function G(t, e2, s, n3) {
  return t >> 4 | e2 & 240 | (s & 240) << 4 | (n3 & 240) << 8;
}
function j(t, e2, s) {
  return t >> 4 << 8 | e2 & 240 | s >> 4;
}
function R(t, e2, s) {
  return t < e2 ? e2 : t > s ? s : t;
}
function T(t) {
  return t * t;
}
function tt(t, e2, s) {
  var n3 = 0, r = 1e100;
  let o = t[e2], i = o.cnt, c4 = o.ac, x = o.rc, a2 = o.gc, l = o.bc;
  for (var f = o.fw; f != 0; f = t[f].fw) {
    let h = t[f], b3 = h.cnt, w = i * b3 / (i + b3);
    if (!(w >= r)) {
      var g2 = 0;
      s && (g2 += w * T(h.ac - c4), g2 >= r) || (g2 += w * T(h.rc - x), !(g2 >= r) && (g2 += w * T(h.gc - a2), !(g2 >= r) && (g2 += w * T(h.bc - l), !(g2 >= r) && (r = g2, n3 = f))));
    }
  }
  o.err = r, o.nn = n3;
}
function Q() {
  return { ac: 0, rc: 0, gc: 0, bc: 0, cnt: 0, nn: 0, fw: 0, bk: 0, tm: 0, mtm: 0, err: 0 };
}
function ut(t, e2) {
  let s = e2 === "rgb444" ? 4096 : 65536, n3 = new Array(s), r = t.length;
  if (e2 === "rgba4444") for (let o = 0; o < r; ++o) {
    let i = t[o], c4 = i >> 24 & 255, x = i >> 16 & 255, a2 = i >> 8 & 255, l = i & 255, f = G(l, a2, x, c4), g2 = f in n3 ? n3[f] : n3[f] = Q();
    g2.rc += l, g2.gc += a2, g2.bc += x, g2.ac += c4, g2.cnt++;
  }
  else if (e2 === "rgb444") for (let o = 0; o < r; ++o) {
    let i = t[o], c4 = i >> 16 & 255, x = i >> 8 & 255, a2 = i & 255, l = j(a2, x, c4), f = l in n3 ? n3[l] : n3[l] = Q();
    f.rc += a2, f.gc += x, f.bc += c4, f.cnt++;
  }
  else for (let o = 0; o < r; ++o) {
    let i = t[o], c4 = i >> 16 & 255, x = i >> 8 & 255, a2 = i & 255, l = D(a2, x, c4), f = l in n3 ? n3[l] : n3[l] = Q();
    f.rc += a2, f.gc += x, f.bc += c4, f.cnt++;
  }
  return n3;
}
function H(t, e2, s = {}) {
  let { format: n3 = "rgb565", clearAlpha: r = true, clearAlphaColor: o = 0, clearAlphaThreshold: i = 0, oneBitAlpha: c4 = false } = s;
  if (!t || !t.buffer) throw new Error("quantize() expected RGBA Uint8Array data");
  if (!(t instanceof Uint8Array) && !(t instanceof Uint8ClampedArray)) throw new Error("quantize() expected RGBA Uint8Array data");
  let x = new Uint32Array(t.buffer), a2 = s.useSqrt !== false, l = n3 === "rgba4444", f = ut(x, n3), g2 = f.length, h = g2 - 1, b3 = new Uint32Array(g2 + 1);
  for (var w = 0, u = 0; u < g2; ++u) {
    let C = f[u];
    if (C != null) {
      var _23 = 1 / C.cnt;
      l && (C.ac *= _23), C.rc *= _23, C.gc *= _23, C.bc *= _23, f[w++] = C;
    }
  }
  T(e2) / w < 0.022 && (a2 = false);
  for (var u = 0; u < w - 1; ++u) f[u].fw = u + 1, f[u + 1].bk = u, a2 && (f[u].cnt = Math.sqrt(f[u].cnt));
  a2 && (f[u].cnt = Math.sqrt(f[u].cnt));
  var k, B, p2;
  for (u = 0; u < w; ++u) {
    tt(f, u, false);
    var A = f[u].err;
    for (B = ++b3[0]; B > 1 && (p2 = B >> 1, !(f[k = b3[p2]].err <= A)); B = p2) b3[B] = k;
    b3[B] = u;
  }
  var z = w - e2;
  for (u = 0; u < z; ) {
    for (var d2; ; ) {
      var I = b3[1];
      if (d2 = f[I], d2.tm >= d2.mtm && f[d2.nn].mtm <= d2.tm) break;
      d2.mtm == h ? I = b3[1] = b3[b3[0]--] : (tt(f, I, false), d2.tm = u);
      var A = f[I].err;
      for (B = 1; (p2 = B + B) <= b3[0] && (p2 < b3[0] && f[b3[p2]].err > f[b3[p2 + 1]].err && p2++, !(A <= f[k = b3[p2]].err)); B = p2) b3[B] = k;
      b3[B] = I;
    }
    var y = f[d2.nn], m3 = d2.cnt, v = y.cnt, _23 = 1 / (m3 + v);
    l && (d2.ac = _23 * (m3 * d2.ac + v * y.ac)), d2.rc = _23 * (m3 * d2.rc + v * y.rc), d2.gc = _23 * (m3 * d2.gc + v * y.gc), d2.bc = _23 * (m3 * d2.bc + v * y.bc), d2.cnt += y.cnt, d2.mtm = ++u, f[y.bk].fw = y.fw, f[y.fw].bk = y.bk, y.mtm = h;
  }
  let M = [];
  var V = 0;
  for (u = 0; ; ++V) {
    let L = R(Math.round(f[u].rc), 0, 255), C = R(Math.round(f[u].gc), 0, 255), Y = R(Math.round(f[u].bc), 0, 255), E = 255;
    if (l) {
      if (E = R(Math.round(f[u].ac), 0, 255), c4) {
        let st = typeof c4 == "number" ? c4 : 127;
        E = E <= st ? 0 : 255;
      }
      r && E <= i && (L = C = Y = o, E = 0);
    }
    let K = l ? [L, C, Y, E] : [L, C, Y];
    if (xt(M, K) || M.push(K), (u = f[u].fw) == 0) break;
  }
  return M;
}
function xt(t, e2) {
  for (let s = 0; s < t.length; s++) {
    let n3 = t[s], r = n3[0] === e2[0] && n3[1] === e2[1] && n3[2] === e2[2], o = n3.length >= 4 && e2.length >= 4 ? n3[3] === e2[3] : true;
    if (r && o) return true;
  }
  return false;
}
function U(t, e2) {
  var s = 0, n3;
  for (n3 = 0; n3 < t.length; n3++) {
    let r = t[n3] - e2[n3];
    s += r * r;
  }
  return s;
}
function W(t, e2, s = U) {
  let n3 = Infinity, r = -1;
  for (let o = 0; o < t.length; o++) {
    let i = t[o], c4 = s(e2, i);
    c4 < n3 && (n3 = c4, r = o);
  }
  return r;
}
function ct(t = {}) {
  let { initialCapacity: e2 = 4096, auto: s = true } = t, n3 = F(e2), r = 5003, o = new Uint8Array(256), i = new Int32Array(r), c4 = new Int32Array(r), x = false;
  return { reset() {
    n3.reset(), x = false;
  }, finish() {
    n3.writeByte(X.trailer);
  }, bytes() {
    return n3.bytes();
  }, bytesView() {
    return n3.bytesView();
  }, get buffer() {
    return n3.buffer;
  }, get stream() {
    return n3;
  }, writeHeader: a2, writeFrame(l, f, g2, h = {}) {
    let { transparent: b3 = false, transparentIndex: w = 0, delay: _23 = 0, palette: u = null, repeat: k = 0, colorDepth: B = 8, dispose: p2 = -1 } = h, A = false;
    if (s ? x || (A = true, a2(), x = true) : A = Boolean(h.first), f = Math.max(0, Math.floor(f)), g2 = Math.max(0, Math.floor(g2)), A) {
      if (!u) throw new Error("First frame must include a { palette } option");
      pt(n3, f, g2, u, B), it(n3, u), k >= 0 && dt(n3, k);
    }
    let z = Math.round(_23 / 10);
    wt(n3, p2, z, b3, w);
    let d2 = Boolean(u) && !A;
    ht(n3, f, g2, d2 ? u : null), d2 && it(n3, u), yt(n3, l, f, g2, B, o, i, c4);
  } };
  function a2() {
    ft(n3, "GIF89a");
  }
}
function wt(t, e2, s, n3, r) {
  t.writeByte(33), t.writeByte(249), t.writeByte(4), r < 0 && (r = 0, n3 = false);
  var o, i;
  n3 ? (o = 1, i = 2) : (o = 0, i = 0), e2 >= 0 && (i = e2 & 7), i <<= 2;
  let c4 = 0;
  t.writeByte(0 | i | c4 | o), S(t, s), t.writeByte(r || 0), t.writeByte(0);
}
function pt(t, e2, s, n3, r = 8) {
  let o = 1, i = 0, c4 = Z(n3.length) - 1, x = o << 7 | r - 1 << 4 | i << 3 | c4, a2 = 0, l = 0;
  S(t, e2), S(t, s), t.writeBytes([x, a2, l]);
}
function dt(t, e2) {
  t.writeByte(33), t.writeByte(255), t.writeByte(11), ft(t, "NETSCAPE2.0"), t.writeByte(3), t.writeByte(1), S(t, e2), t.writeByte(0);
}
function it(t, e2) {
  let s = 1 << Z(e2.length);
  for (let n3 = 0; n3 < s; n3++) {
    let r = [0, 0, 0];
    n3 < e2.length && (r = e2[n3]), t.writeByte(r[0]), t.writeByte(r[1]), t.writeByte(r[2]);
  }
}
function ht(t, e2, s, n3) {
  if (t.writeByte(44), S(t, 0), S(t, 0), S(t, e2), S(t, s), n3) {
    let r = 0, o = 0, i = Z(n3.length) - 1;
    t.writeByte(128 | r | o | 0 | i);
  } else t.writeByte(0);
}
function yt(t, e2, s, n3, r = 8, o, i, c4) {
  $(s, n3, e2, r, t, o, i, c4);
}
function S(t, e2) {
  t.writeByte(e2 & 255), t.writeByte(e2 >> 8 & 255);
}
function ft(t, e2) {
  for (var s = 0; s < e2.length; s++) t.writeByte(e2.charCodeAt(s));
}
function Z(t) {
  return Math.max(Math.ceil(Math.log2(t)), 1);
}

// node_modules/p5/dist/image/pixels.js
function pixels(p53, fn2) {
  fn2.blend = function(...args) {
    if (this._renderer) {
      this._renderer.blend(...args);
    } else {
      p53.Renderer2D.prototype.blend.apply(this, args);
    }
  };
  fn2.copy = function(...args) {
    let srcImage, sx, sy, sw, sh, dx, dy, dw, dh;
    if (args.length === 9) {
      srcImage = args[0];
      sx = args[1];
      sy = args[2];
      sw = args[3];
      sh = args[4];
      dx = args[5];
      dy = args[6];
      dw = args[7];
      dh = args[8];
    } else if (args.length === 8) {
      srcImage = this;
      sx = args[0];
      sy = args[1];
      sw = args[2];
      sh = args[3];
      dx = args[4];
      dy = args[5];
      dw = args[6];
      dh = args[7];
    } else {
      throw new Error("Signature not supported");
    }
    fn2._copyHelper(this, srcImage, sx, sy, sw, sh, dx, dy, dw, dh);
  };
  fn2._copyHelper = (dstImage, srcImage, sx, sy, sw, sh, dx, dy, dw, dh) => {
    const s = srcImage.canvas.width / srcImage.width;
    let sxMod = 0;
    let syMod = 0;
    if (srcImage._renderer && srcImage._renderer.isP3D) {
      sxMod = srcImage.width / 2;
      syMod = srcImage.height / 2;
    }
    if (dstImage._renderer && dstImage._renderer.isP3D) {
      dstImage.push();
      dstImage.resetMatrix();
      dstImage.noLights();
      dstImage.blendMode(dstImage.BLEND);
      dstImage.imageMode(dstImage.CORNER);
      dstImage._renderer.image(
        srcImage,
        sx + sxMod,
        sy + syMod,
        sw,
        sh,
        dx,
        dy,
        dw,
        dh
      );
      dstImage.pop();
    } else {
      dstImage.drawingContext.drawImage(
        srcImage.canvas,
        s * (sx + sxMod),
        s * (sy + syMod),
        s * sw,
        s * sh,
        dx,
        dy,
        dw,
        dh
      );
    }
  };
  fn2.getFilterGraphicsLayer = function() {
    return this._renderer.getFilterGraphicsLayer();
  };
  fn2.filter = function(...args) {
    let { shader: shader2, operation, value, useWebGL } = parseFilterArgs(...args);
    if (this._renderer.isP3D && shader2) {
      this._renderer.filter(shader2);
      return;
    }
    if (!useWebGL && !this._renderer.isP3D) {
      if (this.canvas !== void 0) {
        Filters.apply(this.canvas, Filters[operation], value);
      } else {
        Filters.apply(this.elt, Filters[operation], value);
      }
      return;
    }
    if (!useWebGL && this._renderer.isP3D) {
      console.warn("filter() with useWebGL=false is not supported in WEBGL");
    }
    if (this._renderer.isP3D) {
      this._renderer.filter(operation, value);
    } else {
      if (shader2) {
        this._renderer.filterRenderer.setOperation(operation, value, shader2);
      } else {
        this._renderer.filterRenderer.setOperation(operation, value);
      }
      this._renderer.filterRenderer.applyFilter();
    }
  };
  function parseFilterArgs(...args) {
    let result = {
      shader: void 0,
      operation: void 0,
      value: void 0,
      useWebGL: true
    };
    if (args[0] instanceof p53.Shader) {
      result.shader = args[0];
      return result;
    } else {
      result.operation = args[0];
    }
    if (args.length > 1 && typeof args[1] === "number") {
      result.value = args[1];
    }
    if (args[args.length - 1] === false) {
      result.useWebGL = false;
    }
    return result;
  }
  fn2.get = function(x, y, w, h) {
    return this._renderer.get(...arguments);
  };
  fn2.loadPixels = function(...args) {
    this._renderer.loadPixels();
  };
  fn2.set = function(x, y, imgOrCol) {
    this._renderer.set(x, y, imgOrCol);
  };
  fn2.updatePixels = function(x, y, w, h) {
    if (this.pixels.length === 0) {
      return;
    }
    this._renderer.updatePixels(x, y, w, h);
  };
}
if (typeof p5 !== "undefined") {
  pixels(p5, p5.prototype);
}

// node_modules/p5/dist/math/Matrices/MatrixInterface.js
var GLMAT_ARRAY_TYPE = Array;
var isMatrixArray = (x) => Array.isArray(x);
if (typeof Float32Array !== "undefined") {
  GLMAT_ARRAY_TYPE = Float32Array;
  isMatrixArray = (x) => Array.isArray(x) || x instanceof Float32Array;
}
var _matrix;
var _MatrixInterface = class _MatrixInterface {
  constructor(...args) {
    // Private field to store the matrix
    __privateAdd(this, _matrix, null);
    if (this.constructor === _MatrixInterface) {
      throw new Error("Class is of abstract type and can't be instantiated");
    }
    const methods = [
      "add",
      "setElement",
      "reset",
      "set",
      "get",
      "copy",
      "clone",
      "diagonal",
      "row",
      "column",
      "transpose",
      "mult",
      "multiplyVec",
      "invert",
      "createSubMatrix3x3",
      "inverseTranspose4x4",
      "apply",
      "scale",
      "rotate4x4",
      "translate",
      "rotateX",
      "rotateY",
      "rotateZ",
      "perspective",
      "ortho",
      "multiplyVec4",
      "multiplyPoint",
      "multiplyAndNormalizePoint",
      "multiplyDirection",
      "multiplyVec3"
    ];
    methods.forEach((method) => {
      if (this[method] === void 0) {
        throw new Error(`${method}() method must be implemented`);
      }
    });
  }
};
_matrix = new WeakMap();
var MatrixInterface = _MatrixInterface;

// node_modules/p5/dist/math/Matrices/Matrix.js
var isPerfectSquare = (arr2) => {
  const sqDimention = Math.sqrt(Array.from(arr2).length);
  if (sqDimention % 1 !== 0) {
    throw new Error("Array length must be a perfect square.");
  }
  return true;
};
var GLMAT_ARRAY_TYPE2 = Array;
var isMatrixArray2 = (x) => Array.isArray(x);
if (typeof Float32Array !== "undefined") {
  GLMAT_ARRAY_TYPE2 = Float32Array;
  isMatrixArray2 = (x) => Array.isArray(x) || x instanceof Float32Array;
}
var _sqDimention, _Matrix_instances, createIdentityMatrix_fn, mult4x4_fn, multNxN_fn, mult3x3_fn, transposeNxN_fn, transpose4x4_fn, transpose3x3_fn, invert4x4_fn, invert3x3_fn, determinant4x4_fn;
var _Matrix = class _Matrix extends MatrixInterface {
  constructor(...args) {
    super(...args);
    __privateAdd(this, _Matrix_instances);
    __publicField(this, "matrix");
    __privateAdd(this, _sqDimention);
    if (isMatrixArray2(args[0]) && isPerfectSquare(args[0])) {
      const sqDimention = Math.sqrt(Array.from(args[0]).length);
      __privateSet(this, _sqDimention, sqDimention);
      this.matrix = GLMAT_ARRAY_TYPE2.from(args[0]);
    } else if (typeof args[0] === "number") {
      __privateSet(this, _sqDimention, Number(args[0]));
      this.matrix = __privateMethod(this, _Matrix_instances, createIdentityMatrix_fn).call(this, args[0]);
    }
    return this;
  }
  /**
   * Returns the 3x3 matrix if the dimensions are 3x3, otherwise returns `undefined`.
   *
   * This method returns the matrix if its dimensions are 3x3.
   * If the matrix is not 3x3, it returns `undefined`.
   *
   * @returns {Array|undefined} The 3x3 matrix or `undefined` if the matrix is not 3x3.
   */
  get mat3() {
    if (__privateGet(this, _sqDimention) === 3) {
      return this.matrix;
    } else {
      return void 0;
    }
  }
  /**
   * Returns the 4x4 matrix if the dimensions are 4x4, otherwise returns `undefined`.
   *
   * This method returns the matrix if its dimensions are 4x4.
   * If the matrix is not 4x4, it returns `undefined`.
   *
   * @returns {Array|undefined} The 4x4 matrix or `undefined` if the matrix is not 4x4.
   */
  get mat4() {
    if (__privateGet(this, _sqDimention) === 4) {
      return this.matrix;
    } else {
      return void 0;
    }
  }
  /**
   * Adds the corresponding elements of the given matrix to this matrix, if the dimentions are the same.
   *
   * @param {Matrix} matrix - The matrix to add to this matrix. It must have the same dimensions as this matrix.
   * @returns {Matrix} The resulting matrix after addition.
   * @throws {Error} If the matrices do not have the same dimensions.
   *
   * @example
   * const matrix1 = new p5.Matrix([1, 2, 3]);
   * const matrix2 = new p5.Matrix([4, 5, 6]);
   * matrix1.add(matrix2); // matrix1 is now [5, 7, 9]
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix1 = new p5.Matrix([1, 2, 3, 4]);
   *   const matrix2 = new p5.Matrix([5, 6, 7, 8]);
   *   matrix1.add(matrix2);
   *   console.log(matrix1.matrix); // Output: [6, 8, 10, 12]
   * }
   * </code></div>
   */
  add(matrix2) {
    if (this.matrix.length !== matrix2.matrix.length) {
      throw new Error("Matrices must be of the same dimension to add.");
    }
    for (let i = 0; i < this.matrix.length; i++) {
      this.matrix[i] += matrix2.matrix[i];
    }
    return this;
  }
  /**
   * Sets the value of a specific element in the matrix in column-major order.
   *
   * A matrix is stored in column-major order, meaning elements are arranged column by column.
   * This function allows you to update or change the value of a specific element
   * in the matrix by specifying its index in the column-major order and the new value.
   *
   * Parameters:
   * - `index` (number): The position in the matrix where the value should be set.
   *   Indices start from 0 and follow column-major order.
   * - `value` (any): The new value you want to assign to the specified element.
   *
   * Example:
   * If you have the following 3x3 matrix stored in column-major order:
   * ```
   * [
   *   1, 4, 7,  // Column 1
   *   2, 5, 8,  // Column 2
   *   3, 6, 9   // Column 3
   * ]
   * ```
   * Calling `setElement(4, 10)` will update the element at index 4
   * (which corresponds to row 2, column 2 in row-major order) to `10`.
   * The updated matrix will look like this:
   * ```
   * [
   *   1, 4, 7,
   *   2, 10, 8,
   *   3, 6, 9
   * ]
   * ```
   *
   * This function is useful for modifying specific parts of the matrix without
   * having to recreate the entire structure.
   *
   * @param {Number} index - The position in the matrix where the value should be set.
   *                         Must be a non-negative integer less than the length of the matrix.
   * @param {Number} value - The new value to be assigned to the specified position in the matrix.
   * @returns {Matrix} The current instance of the Matrix, allowing for method chaining.
   *
   * @example
   * // Assuming matrix is an instance of Matrix with initial values [1, 2, 3, 4] matrix.setElement(2, 99);
   * // Now the matrix values are [1, 2, 99, 4]
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix([1, 2, 3, 4]);
   *   matrix.setElement(2, 99);
   *   console.log(matrix.matrix); // Output: [1, 2, 99, 4]
   * }
   * </code></div>
   */
  setElement(index, value) {
    if (index >= 0 && index < this.matrix.length) {
      this.matrix[index] = value;
    }
    return this;
  }
  /**
   * Resets the current matrix to an identity matrix.
   *
   * This method replaces the current matrix with an identity matrix of the same dimensions.
   * An identity matrix is a square matrix with ones on the main diagonal and zeros elsewhere.
   * This is useful for resetting transformations or starting fresh with a clean matrix.
   *
   * @returns {Matrix} The current instance of the Matrix class, allowing for method chaining.
   *
   * @example
   * // Resetting a 4x4 matrix to an identity matrix
   * const matrix = new p5.Matrix(4);
   * matrix.scale(2, 2, 2); // Apply some transformations
   * console.log(matrix.matrix); // Output: Transformed matrix
   * matrix.reset(); // Reset to identity matrix
   * console.log(matrix.matrix); // Output: Identity matrix
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4);
   *   matrix.scale(2, 2, 2); // Apply scaling transformation
   *   console.log("Before reset:", matrix.matrix);
   *   matrix.reset(); // Reset to identity matrix
   *   console.log("After reset:", matrix.matrix);
   * }
   * </code></div>
   */
  reset() {
    this.matrix = __privateMethod(this, _Matrix_instances, createIdentityMatrix_fn).call(this, __privateGet(this, _sqDimention));
    return this;
  }
  /**
   * Replace the entire contents of a NxN matrix.
   *
   * This method allows you to replace the values of the current matrix with
   * those from another matrix, an array, or individual arguments. The input
   * can be a `Matrix` instance, an array of numbers, or individual numbers
   * that match the dimensions of the current matrix. The values are copied
   * without referencing the source object, ensuring that the original input
   * remains unchanged.
   *
   * If the input dimensions do not match the current matrix, an error will
   * be thrown to ensure consistency.
   *
   * @param {Matrix|Float32Array|Number[]} [inMatrix] - The input matrix, array,
   * or individual numbers to replace the current matrix values.
   * @returns {Matrix} The current instance of the Matrix class, allowing for
   * method chaining.
   *
   * @example
   * // Replacing the contents of a matrix with another matrix
   * const matrix1 = new p5.Matrix([1, 2, 3, 4]);
   * const matrix2 = new p5.Matrix([5, 6, 7, 8]);
   * matrix1.set(matrix2);
   * console.log(matrix1.matrix); // Output: [5, 6, 7, 8]
   *
   * // Replacing the contents of a matrix with an array
   * const matrix = new p5.Matrix([1, 2, 3, 4]);
   * matrix.set([9, 10, 11, 12]);
   * console.log(matrix.matrix); // Output: [9, 10, 11, 12]
   *
   * // Replacing the contents of a matrix with individual numbers
   * const matrix = new p5.Matrix(4); // Creates a 4x4 identity matrix
   * matrix.set(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16);
   * console.log(matrix.matrix); // Output: [1, 2, 3, ..., 16]
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix([1, 2, 3, 4]);
   *   console.log("Before set:", matrix.matrix);
   *   matrix.set([5, 6, 7, 8]);
   *   console.log("After set:", matrix.matrix); // Output: [5, 6, 7, 8]
   * }
   * </code></div>
   */
  set(inMatrix) {
    let refArray = GLMAT_ARRAY_TYPE2.from([...arguments]);
    if (inMatrix instanceof _Matrix) {
      refArray = GLMAT_ARRAY_TYPE2.from(inMatrix.matrix);
    } else if (isMatrixArray2(inMatrix)) {
      refArray = GLMAT_ARRAY_TYPE2.from(inMatrix);
    }
    if (refArray.length !== this.matrix.length) {
      p5._friendlyError(
        `Expected same dimensions values but received different ${refArray.length}.`,
        "p5.Matrix.set"
      );
      return this;
    }
    this.matrix = refArray;
    return this;
  }
  /**
   * Gets a copy of the matrix, returns a p5.Matrix object.
   *
   * This method creates a new instance of the `Matrix` class and copies the
   * current matrix values into it. The returned matrix is independent of the
   * original, meaning changes to the copy will not affect the original matrix.
   *
   * This is useful when you need to preserve the current state of a matrix
   * while performing operations on a duplicate.
   *
   * @return {p5.Matrix} A new instance of the `Matrix` class containing the
   *                     same values as the original matrix.
   *
   * @example
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const originalMatrix = new p5.Matrix([1, 2, 3, 4]);
   *   const copiedMatrix = originalMatrix.get();
   *   console.log("Original Matrix:", originalMatrix.matrix); // Output: [1, 2, 3, 4]
   *   console.log("Copied Matrix:", copiedMatrix.matrix); // Output: [1, 2, 3, 4]
   *
   *   // Modify the copied matrix
   *   copiedMatrix.setElement(2, 99);
   *   console.log("Modified Copied Matrix:", copiedMatrix.matrix); // Output: [1, 2, 99, 4]
   *   console.log("Original Matrix remains unchanged:", originalMatrix.matrix); // Output: [1, 2, 3, 4]
   * }
   * </code></div>
   */
  get() {
    return new _Matrix(this.matrix);
  }
  /**
   * Return a copy of this matrix.
   * If this matrix is 4x4, a 4x4 matrix with exactly the same entries will be
   * generated. The same is true if this matrix is 3x3 or any NxN matrix.
   *
   * This method is useful when you need to preserve the current state of a matrix
   * while performing operations on a duplicate. The returned matrix is independent
   * of the original, meaning changes to the copy will not affect the original matrix.
   *
   * @return {p5.Matrix}   The result matrix.
   *
   * @example
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const originalMatrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   const copiedMatrix = originalMatrix.copy();
   *   console.log("Original Matrix:", originalMatrix.matrix);
   *   console.log("Copied Matrix:", copiedMatrix.matrix);
   *
   *   // Modify the copied matrix
   *   copiedMatrix.setElement(4, 99);
   *   console.log("Modified Copied Matrix:", copiedMatrix.matrix);
   *   console.log("Original Matrix remains unchanged:", originalMatrix.matrix);
   * }
   * </code></div>
   */
  copy() {
    return new _Matrix(this.matrix);
  }
  /**
   * Creates a copy of the current matrix instance.
   * This method is useful when you need a duplicate of the matrix
   * without modifying the original one.
   *
   * @returns {Matrix} A new matrix instance that is a copy of the current matrix.
   *
   * @example
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const originalMatrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   const clonedMatrix = originalMatrix.clone();
   *   console.log("Original Matrix:", originalMatrix.matrix);
   *   console.log("Cloned Matrix:", clonedMatrix.matrix);
   *
   *   // Modify the cloned matrix
   *   clonedMatrix.setElement(4, 99);
   *   console.log("Modified Cloned Matrix:", clonedMatrix.matrix);
   *   console.log("Original Matrix remains unchanged:", originalMatrix.matrix);
   * }
   * </code></div>
   */
  clone() {
    return this.copy();
  }
  /**
   * Returns the diagonal elements of the matrix in the form of an array.
   * A NxN matrix will return an array of length N.
   *
   * This method extracts the diagonal elements of the matrix, which are the
   * elements where the row index equals the column index. For example, in a
   * 3x3 matrix:
   * ```
   * [
   *   1, 2, 3,
   *   4, 5, 6,
   *   7, 8, 9
   * ]
   * ```
   * The diagonal elements are [1, 5, 9].
   *
   * This is useful for operations that require the main diagonal of a matrix,
   * such as calculating the trace of a matrix or verifying if a matrix is diagonal.
   *
   * @return {Number[]} An array obtained by arranging the diagonal elements
   *                    of the matrix in ascending order of index.
   *
   * @example
   * // Extracting the diagonal elements of a matrix
   * const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   * const diagonal = matrix.diagonal(); // [1, 5, 9]
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   const diagonal = matrix.diagonal();
   *   console.log("Diagonal elements:", diagonal); // Output: [1, 5, 9]
   * }
   * </code></div>
   */
  diagonal() {
    const diagonal = [];
    for (let i = 0; i < __privateGet(this, _sqDimention); i++) {
      diagonal.push(this.matrix[i * (__privateGet(this, _sqDimention) + 1)]);
    }
    return diagonal;
  }
  /**
   * This function is only for 3x3 matrices A function that returns a row vector of a NxN matrix.
   *
   * This method extracts a specific row from the matrix and returns it as a `p5.Vector`.
   * The row is determined by the `columnIndex` parameter, which specifies the column
   * index of the matrix. This is useful for operations that require working with
   * individual rows of a matrix, such as row transformations or dot products.
   *
   * @param {Number} columnIndex - The index of the column to extract as a row vector.
   *                               Must be a non-negative integer less than the matrix dimension.
   * @return {p5.Vector} A `p5.Vector` representing the extracted row of the matrix.
   *
   * @example
   * // Extracting a row vector from a 3x3 matrix
   * const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   * const rowVector = matrix.row(1); // Returns a vector [2, 5, 8]
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   const rowVector = matrix.row(1); // Extract the second row (index 1)
   *   console.log("Row Vector:", rowVector.toString()); // Output: Row Vector: [2, 5, 8]
   * }
   * </code></div>
   */
  row(columnIndex) {
    const columnVector = [];
    for (let i = 0; i < __privateGet(this, _sqDimention); i++) {
      columnVector.push(this.matrix[i * __privateGet(this, _sqDimention) + columnIndex]);
    }
    return new Vector(...columnVector);
  }
  /**
   * A function that returns a column vector of a NxN matrix.
   *
   * This method extracts a specific column from the matrix and returns it as a `p5.Vector`.
   * The column is determined by the `rowIndex` parameter, which specifies the row index
   * of the matrix. This is useful for operations that require working with individual
   * columns of a matrix, such as column transformations or dot products.
   *
   * @param {Number} rowIndex - The index of the row to extract as a column vector.
   *                             Must be a non-negative integer less than the matrix dimension.
   * @return {p5.Vector} A `p5.Vector` representing the extracted column of the matrix.
   *
   * @example
   * // Extracting a column vector from a 3x3 matrix
   * const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   * const columnVector = matrix.column(1); // Returns a vector [4, 5, 6]
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   const columnVector = matrix.column(1); // Extract the second column (index 1)
   *   console.log("Column Vector:", columnVector.toString()); // Output: Column Vector: [4, 5, 6]
   * }
   * </code></div>
   */
  column(rowIndex) {
    const rowVector = [];
    for (let i = 0; i < __privateGet(this, _sqDimention); i++) {
      rowVector.push(this.matrix[rowIndex * __privateGet(this, _sqDimention) + i]);
    }
    return new Vector(...rowVector);
  }
  /**
   * Transposes the given matrix `a` based on the square dimension of the matrix.
   *
   * This method rearranges the elements of the matrix such that the rows become columns
   * and the columns become rows. It handles matrices of different dimensions (4x4, 3x3, NxN)
   * by delegating to specific transpose methods for each case.
   *
   * If no argument is provided, the method transposes the current matrix instance.
   * If an argument is provided, it transposes the given matrix `a` and updates the current matrix.
   *
   * @param {Array} [a] - The matrix to be transposed. It should be a 2D array where each sub-array represents a row.
   *                      If omitted, the current matrix instance is transposed.
   * @returns {Matrix} - The current instance of the Matrix class, allowing for method chaining.
   *
   * @example
   * // Transposing a 3x3 matrix
   * const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   * matrix.transpose();
   * console.log(matrix.matrix); // Output: [1, 4, 7, 2, 5, 8, 3, 6, 9]
   *
   * // Transposing a 4x4 matrix
   * const matrix4x4 = new p5.Matrix(4);
   * matrix4x4.transpose();
   * console.log(matrix4x4.matrix); // Output: Transposed 4x4 identity matrix
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   console.log("Before transpose:", matrix.matrix);
   *   matrix.transpose();
   *   console.log("After transpose:", matrix.matrix); // Output: [1, 4, 7, 2, 5, 8, 3, 6, 9]
   * }
   * </code></div>
   */
  transpose(a2) {
    if (__privateGet(this, _sqDimention) === 4) {
      return __privateMethod(this, _Matrix_instances, transpose4x4_fn).call(this, a2);
    } else if (__privateGet(this, _sqDimention) === 3) {
      return __privateMethod(this, _Matrix_instances, transpose3x3_fn).call(this, a2);
    } else {
      return __privateMethod(this, _Matrix_instances, transposeNxN_fn).call(this, a2);
    }
  }
  /**
   * Multiplies the current matrix with another matrix or matrix-like array.
   *
   * This method supports several types of input:
   * - Another Matrix instance
   * - A matrix-like array (must be a perfect square, e.g., 4x4 or 3x3)
   * - Multiple arguments that form a perfect square matrix
   *
   * If the input is the same as the current matrix, a copy is made to avoid modifying the original matrix.
   *
   * The method determines the appropriate multiplication strategy based on the dimensions of the current matrix
   * and the input matrix. It supports 3x3, 4x4, and NxN matrices.
   *
   * @param {Matrix|Array|...number} multMatrix - The matrix or matrix-like array to multiply with.
   * @returns {Matrix|undefined} The resulting matrix after multiplication, or undefined if the input is invalid.
   * @chainable
   *
   * @example
   * // Multiplying two 3x3 matrices
   * const matrix1 = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   * const matrix2 = new p5.Matrix([9, 8, 7, 6, 5, 4, 3, 2, 1]);
   * matrix1.mult(matrix2);
   * console.log(matrix1.matrix); // Output: [30, 24, 18, 84, 69, 54, 138, 114, 90]
   *
   * // Multiplying a 4x4 matrix with another 4x4 matrix
   * const matrix4x4_1 = new p5.Matrix(4); // Identity matrix
   * const matrix4x4_2 = new p5.Matrix([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 2, 3, 1]);
   * matrix4x4_1.mult(matrix4x4_2);
   * console.log(matrix4x4_1.matrix); // Output: [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 2, 3, 1]
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix1 = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   const matrix2 = new p5.Matrix([9, 8, 7, 6, 5, 4, 3, 2, 1]);
   *   console.log("Before multiplication:", matrix1.matrix);
   *   matrix1.mult(matrix2);
   *   console.log("After multiplication:", matrix1.matrix); // Output: [30, 24, 18, 84, 69, 54, 138, 114, 90]
   * }
   * </code></div>
   */
  mult(multMatrix) {
    let _src;
    if (multMatrix === this || multMatrix === this.matrix) {
      _src = this.copy().matrix;
    } else if (multMatrix instanceof _Matrix) {
      _src = multMatrix.matrix;
    } else if (isMatrixArray2(multMatrix) && isPerfectSquare(multMatrix)) {
      _src = multMatrix;
    } else if (isPerfectSquare(arguments)) {
      _src = Array.from(arguments);
    } else ;
    if (__privateGet(this, _sqDimention) === 4 && _src.length === 16) {
      return __privateMethod(this, _Matrix_instances, mult4x4_fn).call(this, _src);
    } else if (__privateGet(this, _sqDimention) === 3 && _src.length === 9) {
      return __privateMethod(this, _Matrix_instances, mult3x3_fn).call(this, _src);
    } else {
      return __privateMethod(this, _Matrix_instances, multNxN_fn).call(this, _src);
    }
  }
  /**
   * Takes a vector and returns the vector resulting from multiplying to that vector by this matrix from left. This function is only for 3x3 matrices.
   *
   * This method applies the current 3x3 matrix to a given vector, effectively
   * transforming the vector using the matrix. The resulting vector is returned
   * as a new vector or stored in the provided target vector.
   *
   * @param {p5.Vector} multVector - The vector to which this matrix applies.
   * @param {p5.Vector} [target] - The vector to receive the result. If not provided,
   *                               a copy of the input vector will be created and returned.
   * @return {p5.Vector} - The transformed vector after applying the matrix.
   *
   * @example
   * // Multiplying a 3x3 matrix with a vector
   * const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   * const vector = new p5.Vector(1, 2, 3);
   * const result = matrix.multiplyVec(vector);
   * console.log(result.toString()); // Output: Transformed vector
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   const vector = new p5.Vector(1, 2, 3);
   *   const result = matrix.multiplyVec(vector);
   *   console.log("Original Vector:", vector.toString()); // Output : Original Vector: [1, 2, 3]
   *   console.log("Transformed Vector:", result.toString()); // Output : Transformed Vector: [30, 36, 42]
   * }
   * </code></div>
   */
  multiplyVec(multVector, target) {
    if (target === void 0) {
      target = multVector.copy();
    }
    for (let i = 0; i < __privateGet(this, _sqDimention); i++) {
      target.values[i] = this.row(i).dot(multVector);
    }
    return target;
  }
  /**
   * Inverts a given matrix.
   *
   * This method inverts a matrix based on its dimensions. Currently, it supports
   * 3x3 and 4x4 matrices. If the matrix dimension is greater than 4, an error is thrown.
   *
   * For 4x4 matrices, it uses a specialized algorithm to compute the inverse.
   * For 3x3 matrices, it uses a different algorithm optimized for smaller matrices.
   *
   * If the matrix is singular (non-invertible), the method will return `null`.
   *
   * @param {Array} a - The matrix to be inverted. It should be a 2D array representing the matrix.
   * @returns {Array|null} - The inverted matrix, or `null` if the matrix is singular.
   * @throws {Error} - Throws an error if the matrix dimension is greater than 4.
   *
   * @example
   * // Inverting a 3x3 matrix
   * const matrix = new p5.Matrix([1, 2, 3, 0, 1, 4, 5, 6, 0]);
   * const invertedMatrix = matrix.invert();
   * console.log(invertedMatrix.matrix); // Output: Inverted 3x3 matrix
   *
   * // Inverting a 4x4 matrix
   * const matrix4x4 = new p5.Matrix(4); // Identity matrix
   * matrix4x4.scale(2, 2, 2);
   * const invertedMatrix4x4 = matrix4x4.invert();
   * console.log(invertedMatrix4x4.matrix); // Output: Inverted 4x4 matrix
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix([1, 2, 3, 0, 1, 4, 5, 6, 0]);
   *   console.log("Original Matrix:", matrix.matrix);
   *   const invertedMatrix = matrix.invert();
   *   if (invertedMatrix) {
   *     console.log("Inverted Matrix:", invertedMatrix.matrix);
   *   } else {
   *     console.log("Matrix is singular and cannot be inverted.");
   *   }
   * }
   * </code></div>
   */
  invert(a2) {
    if (__privateGet(this, _sqDimention) === 4) {
      return __privateMethod(this, _Matrix_instances, invert4x4_fn).call(this, a2);
    } else if (__privateGet(this, _sqDimention) === 3) {
      return __privateMethod(this, _Matrix_instances, invert3x3_fn).call(this, a2);
    } else {
      throw new Error(
        "Invert is not implemented for N>4 at the moment, we are working on it"
      );
    }
  }
  /**
   * Creates a 3x3 matrix whose entries are the top left 3x3 part and returns it. This function is only for 4x4 matrices.
   *
   * This method extracts the top-left 3x3 portion of a 4x4 matrix and creates a new
   * 3x3 matrix from it. This is particularly useful in 3D graphics for operations
   * that require only the rotational or scaling components of a transformation matrix.
   *
   * If the current matrix is not 4x4, an error is thrown to ensure the method is used
   * correctly. The resulting 3x3 matrix is independent of the original matrix, meaning
   * changes to the new matrix will not affect the original.
   *
   * @return {p5.Matrix} A new 3x3 matrix containing the top-left portion of the original 4x4 matrix.
   * @throws {Error} If the current matrix is not 4x4.
   *
   * @example
   * // Extracting a 3x3 submatrix from a 4x4 matrix
   * const matrix4x4 = new p5.Matrix(4); // Creates a 4x4 identity matrix
   * matrix4x4.scale(2, 2, 2); // Apply scaling transformation
   * const subMatrix3x3 = matrix4x4.createSubMatrix3x3();
   * console.log("Original 4x4 Matrix:", matrix4x4.matrix);
   * console.log("Extracted 3x3 Submatrix:", subMatrix3x3.matrix);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix4x4 = new p5.Matrix(4); // Creates a 4x4 identity matrix
   *   matrix4x4.scale(2, 2, 2); // Apply scaling transformation
   *   console.log("Original 4x4 Matrix:", matrix4x4.matrix);
   *
   *   const subMatrix3x3 = matrix4x4.createSubMatrix3x3();
   *   console.log("Extracted 3x3 Submatrix:", subMatrix3x3.matrix);
   * }
   * </code></div>
   */
  createSubMatrix3x3() {
    if (__privateGet(this, _sqDimention) === 4) {
      const result = new _Matrix(3);
      result.mat3[0] = this.matrix[0];
      result.mat3[1] = this.matrix[1];
      result.mat3[2] = this.matrix[2];
      result.mat3[3] = this.matrix[4];
      result.mat3[4] = this.matrix[5];
      result.mat3[5] = this.matrix[6];
      result.mat3[6] = this.matrix[8];
      result.mat3[7] = this.matrix[9];
      result.mat3[8] = this.matrix[10];
      return result;
    } else {
      throw new Error("Matrix dimension must be 4 to create a 3x3 submatrix.");
    }
  }
  /**
   * Converts a 4×4 matrix to its 3×3 inverse transpose transform.
   * This is commonly used in MVMatrix to NMatrix conversions, particularly
   * in 3D graphics for transforming normal vectors.
   *
   * This method extracts the top-left 3×3 portion of a 4×4 matrix, inverts it,
   * and then transposes the result. If the matrix is singular (non-invertible),
   * the resulting matrix will be zeroed out.
   *
   * @param  {p5.Matrix} mat4 - The 4×4 matrix to be converted.
   * @returns {Matrix} The current instance of the Matrix class, allowing for method chaining.
   * @throws {Error} If the current matrix is not 3×3.
   *
   * @example
   * // Converting a 4×4 matrix to its 3×3 inverse transpose
   * const mat4 = new p5.Matrix(4); // Create a 4×4 identity matrix
   * mat4.scale(2, 2, 2); // Apply scaling transformation
   * const mat3 = new p5.Matrix(3); // Create a 3×3 matrix
   * mat3.inverseTranspose4x4(mat4);
   * console.log("Converted 3×3 Matrix:", mat3.matrix);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const mat4 = new p5.Matrix(4); // Create a 4×4 identity matrix
   *   mat4.scale(2, 2, 2); // Apply scaling transformation
   *   console.log("Original 4×4 Matrix:", mat4.matrix);
   *
   *   const mat3 = new p5.Matrix(3); // Create a 3×3 matrix
   *   mat3.inverseTranspose4x4(mat4);
   *   console.log("Converted 3×3 Matrix:", mat3.matrix);
   * }
   * </code></div>
   */
  inverseTranspose4x4({ mat4 }) {
    if (__privateGet(this, _sqDimention) !== 3) {
      throw new Error("This function only works with 3×3 matrices.");
    } else {
      this.matrix[0] = mat4[0];
      this.matrix[1] = mat4[1];
      this.matrix[2] = mat4[2];
      this.matrix[3] = mat4[4];
      this.matrix[4] = mat4[5];
      this.matrix[5] = mat4[6];
      this.matrix[6] = mat4[8];
      this.matrix[7] = mat4[9];
      this.matrix[8] = mat4[10];
    }
    const inverse = this.invert();
    if (inverse) {
      inverse.transpose(this.matrix);
    } else {
      for (let i = 0; i < 9; i++) {
        this.matrix[i] = 0;
      }
    }
    return this;
  }
  /**
   * Applies a transformation matrix to the current matrix.
   *
   * This method multiplies the current matrix by another matrix, which can be provided
   * in several forms: another Matrix instance, an array representing a matrix, or as
   * individual arguments representing the elements of a 4x4 matrix.
   *
   * This operation is useful for combining transformations such as translation, rotation,
   * scaling, and perspective projection into a single matrix. By applying a transformation
   * matrix, you can modify the current matrix to represent a new transformation.
   *
   * @param {Matrix|Array|number} multMatrix - The matrix to multiply with. This can be:
   *   - An instance of the Matrix class.
   *   - An array of 16 numbers representing a 4x4 matrix.
   *   - 16 individual numbers representing the elements of a 4x4 matrix.
   * @returns {Matrix} The current matrix after applying the transformation.
   *
   * @example
   * <div class="norender"><code>
   * function setup() {
   *
   * // Assuming `matrix` is an instance of Matrix
   * const anotherMatrix = new p5.Matrix(4);
   * const anotherMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
   * matrix.apply(anotherMatrix);
   *
   * // Applying a transformation using an array
   * const matrixArray = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
   * matrix.apply(matrixArray);
   *
   * // Applying a transformation using individual arguments
   * matrix.apply(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
   *
   *
   *   // Create a 4x4 identity matrix
   *   const matrix = new p5.Matrix(4);
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Create a scaling transformation matrix
   *   const scalingMatrix = new p5.Matrix([2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 2, 0, 0, 0, 0, 1]);
   *
   *   // Apply the scaling transformation
   *   matrix.apply(scalingMatrix);
   *   console.log("After Scaling Transformation:", matrix.matrix);
   *
   *   // Apply a translation transformation using an array
   *   const translationMatrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 5, 5, 5, 1];
   *   matrix.apply(translationMatrix);
   *   console.log("After Translation Transformation:", matrix.matrix);
   * }
   * </code></div>
   */
  apply(multMatrix) {
    let _src;
    if (multMatrix === this || multMatrix === this.matrix) {
      _src = this.copy().matrix;
    } else if (multMatrix instanceof _Matrix) {
      _src = multMatrix.matrix;
    } else if (isMatrixArray2(multMatrix)) {
      _src = multMatrix;
    } else if (arguments.length === 16) {
      _src = arguments;
    } else {
      return;
    }
    const mat4 = this.matrix;
    const m0 = mat4[0];
    const m4 = mat4[4];
    const m8 = mat4[8];
    const m122 = mat4[12];
    mat4[0] = _src[0] * m0 + _src[1] * m4 + _src[2] * m8 + _src[3] * m122;
    mat4[4] = _src[4] * m0 + _src[5] * m4 + _src[6] * m8 + _src[7] * m122;
    mat4[8] = _src[8] * m0 + _src[9] * m4 + _src[10] * m8 + _src[11] * m122;
    mat4[12] = _src[12] * m0 + _src[13] * m4 + _src[14] * m8 + _src[15] * m122;
    const m13 = mat4[1];
    const m5 = mat4[5];
    const m9 = mat4[9];
    const m132 = mat4[13];
    mat4[1] = _src[0] * m13 + _src[1] * m5 + _src[2] * m9 + _src[3] * m132;
    mat4[5] = _src[4] * m13 + _src[5] * m5 + _src[6] * m9 + _src[7] * m132;
    mat4[9] = _src[8] * m13 + _src[9] * m5 + _src[10] * m9 + _src[11] * m132;
    mat4[13] = _src[12] * m13 + _src[13] * m5 + _src[14] * m9 + _src[15] * m132;
    const m22 = mat4[2];
    const m6 = mat4[6];
    const m10 = mat4[10];
    const m14 = mat4[14];
    mat4[2] = _src[0] * m22 + _src[1] * m6 + _src[2] * m10 + _src[3] * m14;
    mat4[6] = _src[4] * m22 + _src[5] * m6 + _src[6] * m10 + _src[7] * m14;
    mat4[10] = _src[8] * m22 + _src[9] * m6 + _src[10] * m10 + _src[11] * m14;
    mat4[14] = _src[12] * m22 + _src[13] * m6 + _src[14] * m10 + _src[15] * m14;
    const m3 = mat4[3];
    const m7 = mat4[7];
    const m11 = mat4[11];
    const m15 = mat4[15];
    mat4[3] = _src[0] * m3 + _src[1] * m7 + _src[2] * m11 + _src[3] * m15;
    mat4[7] = _src[4] * m3 + _src[5] * m7 + _src[6] * m11 + _src[7] * m15;
    mat4[11] = _src[8] * m3 + _src[9] * m7 + _src[10] * m11 + _src[11] * m15;
    mat4[15] = _src[12] * m3 + _src[13] * m7 + _src[14] * m11 + _src[15] * m15;
    return this;
  }
  /**
   * Scales a p5.Matrix by scalars or a vector.
   *
   * This method applies a scaling transformation to the current matrix.
   * Scaling is a transformation that enlarges or shrinks objects by a scale factor
   * along the x, y, and z axes. The scale factors can be provided as individual
   * numbers, an array, or a `p5.Vector`.
   *
   * If a `p5.Vector` or an array is provided, the x, y, and z components are extracted
   * from it. If the z component is not provided, it defaults to 1 (no scaling along the z-axis).
   *
   * @param {p5.Vector|Float32Array|Number[]} s - The vector or scalars to scale by.
   *                                              Can be a `p5.Vector`, an array, or individual numbers.
   * @returns {Matrix} The current instance of the Matrix class, allowing for method chaining.
   *
   * @example
   * // Scaling a matrix by individual scalars
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * matrix.scale(2, 3, 4); // Scale by 2 along x, 3 along y, and 4 along z
   * console.log(matrix.matrix);
   *
   * // Scaling a matrix by a p5.Vector
   * const scaleVector = new p5.Vector(2, 3, 4);
   * matrix.scale(scaleVector);
   * console.log(matrix.matrix);
   *
   * // Scaling a matrix by an array
   * const scaleArray = [2, 3, 4];
   * matrix.scale(scaleArray);
   * console.log(matrix.matrix);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Scale the matrix by individual scalars
   *   matrix.scale(2, 3, 4);
   *   console.log("Scaled Matrix (2, 3, 4):", matrix.matrix);
   *
   *   // Scale the matrix by a p5.Vector
   *   const scaleVector = new p5.Vector(1.5, 2.5, 3.5);
   *   matrix.scale(scaleVector);
   *   console.log("Scaled Matrix (Vector):", matrix.matrix);
   *
   *   // Scale the matrix by an array
   *   const scaleArray = [0.5, 0.5, 0.5];
   *   matrix.scale(scaleArray);
   *   console.log("Scaled Matrix (Array):", matrix.matrix);
   * }
   * </code></div>
   */
  scale(x, y, z) {
    if (x instanceof Vector) {
      y = x.y;
      z = x.z;
      x = x.x;
    } else if (x instanceof Array) {
      y = x[1];
      z = x[2];
      x = x[0];
    }
    this.matrix[0] *= x;
    this.matrix[1] *= x;
    this.matrix[2] *= x;
    this.matrix[3] *= x;
    this.matrix[4] *= y;
    this.matrix[5] *= y;
    this.matrix[6] *= y;
    this.matrix[7] *= y;
    this.matrix[8] *= z;
    this.matrix[9] *= z;
    this.matrix[10] *= z;
    this.matrix[11] *= z;
    return this;
  }
  /**
   * Rotate the Matrix around a specified axis by a given angle.
   *
   * This method applies a rotation transformation to the matrix, modifying its orientation
   * in 3D space. The rotation is performed around the provided axis, which can be defined
   * as a `p5.Vector` or an array of numbers representing the x, y, and z components of the axis.
   * Rotate our Matrix around an axis by the given angle.
   * @param  {Number} a The angle of rotation in radians.
   *                    Angles in radians are a measure of rotation, where 2π radians
   *                    represent a full circle (360 degrees). For example:
   *                    - π/2 radians = 90 degrees (quarter turn)
   *                    - π radians = 180 degrees (half turn)
   *                    - 2π radians = 360 degrees (full turn)
   *                    Use `Math.PI` for π or `p5`'s `PI` constant if using p5.js.
   * @param  {p5.Vector|Number[]} axis The axis or axes to rotate around.
   *                                   This defines the direction of the rotation.
   *                                   - If using a `p5.Vector`, it should represent
   *                                     the x, y, and z components of the axis.
   *                                   - If using an array, it should be in the form
   *                                     [x, y, z], where x, y, and z are numbers.
   *                                   For example:
   *                                   - [1, 0, 0] rotates around the x-axis.
   *                                   - [0, 1, 0] rotates around the y-axis.
   *                                   - [0, 0, 1] rotates around the z-axis.   *
   * @chainable
   * inspired by Toji's gl-matrix lib, mat4 rotation
   *
   * @example
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix.slice().toString()); // [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]
   *
   *   // Translate the matrix by a 3D vector
   *   matrix.rotate4x4(Math.PI, [1,0,0]);
   *   console.log("After rotation of PI degrees on vector [1,0,0]:", matrix.matrix.slice().toString()); // [1,0,0,0,0,-1,1.2246468525851679e-16,0,0,-1.2246468525851679e-16,-1,0,0,0,0,1]
   * }
   * </code></div>
   */
  rotate4x4(a2, x, y, z) {
    if (x instanceof Vector) {
      y = x.y;
      z = x.z;
      x = x.x;
    } else if (x instanceof Array) {
      y = x[1];
      z = x[2];
      x = x[0];
    }
    const len = Math.sqrt(x * x + y * y + z * z);
    x *= 1 / len;
    y *= 1 / len;
    z *= 1 / len;
    const a00 = this.matrix[0];
    const a01 = this.matrix[1];
    const a02 = this.matrix[2];
    const a03 = this.matrix[3];
    const a10 = this.matrix[4];
    const a11 = this.matrix[5];
    const a12 = this.matrix[6];
    const a13 = this.matrix[7];
    const a20 = this.matrix[8];
    const a21 = this.matrix[9];
    const a22 = this.matrix[10];
    const a23 = this.matrix[11];
    const sA = Math.sin(a2);
    const cA = Math.cos(a2);
    const tA = 1 - cA;
    const b00 = x * x * tA + cA;
    const b01 = y * x * tA + z * sA;
    const b02 = z * x * tA - y * sA;
    const b10 = x * y * tA - z * sA;
    const b11 = y * y * tA + cA;
    const b12 = z * y * tA + x * sA;
    const b20 = x * z * tA + y * sA;
    const b21 = y * z * tA - x * sA;
    const b22 = z * z * tA + cA;
    this.matrix[0] = a00 * b00 + a10 * b01 + a20 * b02;
    this.matrix[1] = a01 * b00 + a11 * b01 + a21 * b02;
    this.matrix[2] = a02 * b00 + a12 * b01 + a22 * b02;
    this.matrix[3] = a03 * b00 + a13 * b01 + a23 * b02;
    this.matrix[4] = a00 * b10 + a10 * b11 + a20 * b12;
    this.matrix[5] = a01 * b10 + a11 * b11 + a21 * b12;
    this.matrix[6] = a02 * b10 + a12 * b11 + a22 * b12;
    this.matrix[7] = a03 * b10 + a13 * b11 + a23 * b12;
    this.matrix[8] = a00 * b20 + a10 * b21 + a20 * b22;
    this.matrix[9] = a01 * b20 + a11 * b21 + a21 * b22;
    this.matrix[10] = a02 * b20 + a12 * b21 + a22 * b22;
    this.matrix[11] = a03 * b20 + a13 * b21 + a23 * b22;
    return this;
  }
  /**
   * Translates the current matrix by a given vector.
   *
   * This method applies a translation transformation to the current matrix.
   * Translation moves the matrix by a specified amount along the x, y, and z axes.
   * The input vector can be a 2D or 3D vector. If the z-component is not provided,
   * it defaults to 0, meaning no translation along the z-axis.
   *
   * @param {Number[]} v - A vector representing the translation. It should be an array
   *                       with two or three elements: [x, y, z]. The z-component is optional.
   * @returns {Matrix} The current instance of the Matrix class, allowing for method chaining.
   *
   * @example
   * // Translating a matrix by a 3D vector
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * matrix.translate([10, 20, 30]); // Translate by 10 units along x, 20 along y, and 30 along z
   * console.log(matrix.matrix);
   *
   * // Translating a matrix by a 2D vector
   * matrix.translate([5, 15]); // Translate by 5 units along x and 15 along y
   * console.log(matrix.matrix);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix.slice().toString()); // [1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]
   *
   *   // Translate the matrix by a 3D vector
   *   matrix.translate([10, 20, 30]);
   *   console.log("After 3D Translation (10, 20, 30):", matrix.matrix.slice().toString()); // [1,0,0,0,0,1,0,0,0,0,1,0,10,20,30,1]
   *
   *   // Translate the matrix by a 2D vector
   *   matrix.translate([5, 15]);
   *   console.log("After 2D Translation (5, 15):", matrix.matrix.slice().toString()); // [1,0,0,0,0,1,0,0,0,0,1,0,15,35,30,1]
   * }
   * </code></div>
   */
  translate(v) {
    const x = v[0], y = v[1], z = v[2] || 0;
    this.matrix[12] += this.matrix[0] * x + this.matrix[4] * y + this.matrix[8] * z;
    this.matrix[13] += this.matrix[1] * x + this.matrix[5] * y + this.matrix[9] * z;
    this.matrix[14] += this.matrix[2] * x + this.matrix[6] * y + this.matrix[10] * z;
    this.matrix[15] += this.matrix[3] * x + this.matrix[7] * y + this.matrix[11] * z;
    return this;
  }
  /**
   * Rotates the matrix around the X-axis by a given angle.
   *
   * This method modifies the current matrix to apply a rotation transformation
   * around the X-axis. The rotation angle is specified in radians.
   *
   * Rotating around the X-axis means that the Y and Z coordinates of the matrix
   * are transformed while the X coordinates remain unchanged. This is commonly
   * used in 3D graphics to create animations or transformations along the X-axis.
   *
   * @param {Number} a - The angle in radians to rotate the matrix by.
   *
   * @example
   * // Rotating a matrix around the X-axis
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * matrix.rotateX(Math.PI / 4); // Rotate 45 degrees around the X-axis
   * console.log(matrix.matrix);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Rotate the matrix 45 degrees (PI/4 radians) around the X-axis
   *   matrix.rotateX(Math.PI / 4);
   *   console.log("After Rotation (X-axis, 45 degrees):", matrix.matrix);
   * }
   * </code></div>
   */
  rotateX(a2) {
    this.rotate4x4(a2, 1, 0, 0);
  }
  /**
   * Rotates the matrix around the Y-axis by a given angle.
   *
   * This method modifies the current matrix to apply a rotation transformation
   * around the Y-axis. The rotation is performed in 3D space, and the angle
   * is specified in radians. Rotating around the Y-axis means that the X and Z
   * coordinates of the matrix are transformed while the Y coordinates remain
   * unchanged. This is commonly used in 3D graphics to create animations or
   * transformations along the Y-axis.
   *
   * @param {Number} a - The angle in radians to rotate the matrix by. Positive
   * values rotate the matrix counterclockwise, and negative values rotate it
   * clockwise.
   *
   * @example
   * // Rotating a matrix around the Y-axis
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * matrix.rotateY(Math.PI / 4); // Rotate 45 degrees around the Y-axis
   * console.log(matrix.matrix);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Rotate the matrix 45 degrees (PI/4 radians) around the Y-axis
   *   matrix.rotateY(Math.PI / 4);
   *   console.log("After Rotation (Y-axis, 45 degrees):", matrix.matrix);
   * }
   * </code></div>
   */
  rotateY(a2) {
    this.rotate4x4(a2, 0, 1, 0);
  }
  /**
   * Rotates the matrix around the Z-axis by a given angle.
   *
   * This method modifies the current matrix to apply a rotation transformation
   * around the Z-axis. The rotation is performed in a 4x4 matrix context, which
   * is commonly used in 3D graphics to handle transformations. Rotating around
   * the Z-axis means that the X and Y coordinates of the matrix are transformed
   * while the Z coordinates remain unchanged.
   *
   * @param {Number} a - The angle in radians to rotate the matrix by. Positive
   * values rotate the matrix counterclockwise, and negative values rotate it
   * clockwise.
   *
   * @returns {Matrix} The current instance of the Matrix class, allowing for
   * method chaining.
   *
   * @example
   * // Rotating a matrix around the Z-axis
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * matrix.rotateZ(Math.PI / 4); // Rotate 45 degrees around the Z-axis
   * console.log(matrix.matrix);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Rotate the matrix 45 degrees (PI/4 radians) around the Z-axis
   *   matrix.rotateZ(Math.PI / 4);
   *   console.log("After Rotation (Z-axis, 45 degrees):", matrix.matrix);
   * }
   * </code></div>
   */
  rotateZ(a2) {
    this.rotate4x4(a2, 0, 0, 1);
  }
  /**
   * Sets the perspective projection matrix.
   *
   * This method modifies the current matrix to represent a perspective projection.
   * Perspective projection is commonly used in 3D graphics to simulate the effect
   * of objects appearing smaller as they move further away from the camera.
   *
   * The perspective matrix is defined by the field of view (fovy), aspect ratio,
   * and the near and far clipping planes. The near and far clipping planes define
   * the range of depth that will be rendered, with anything outside this range
   * being clipped.
   *
   * @param {Number} fovy - The field of view in the y direction, in radians.
   * @param {Number} aspect - The aspect ratio of the viewport (width / height).
   * @param {Number} near - The distance to the near clipping plane. Must be greater than 0.
   * @param {Number} far - The distance to the far clipping plane. Must be greater than the near value.
   * @returns {Matrix} The current instance of the Matrix class, allowing for method chaining.
   *
   * @example
   * // Setting a perspective projection matrix
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * matrix.perspective(Math.PI / 4, 1.5, 0.1, 100); // Set perspective projection
   * console.log(matrix.matrix);
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Set a perspective projection with a 45-degree field of view,
   *   // an aspect ratio of 1.5, and near/far clipping planes at 0.1 and 100.
   *   matrix.perspective(Math.PI / 4, 1.5, 0.1, 100);
   *   console.log("Perspective Matrix:", matrix.matrix);
   * }
   * </code></div>
   */
  perspective(fovy, aspect, near, far) {
    const f = 1 / Math.tan(fovy / 2), nf = 1 / (near - far);
    this.matrix[0] = f / aspect;
    this.matrix[1] = 0;
    this.matrix[2] = 0;
    this.matrix[3] = 0;
    this.matrix[4] = 0;
    this.matrix[5] = f;
    this.matrix[6] = 0;
    this.matrix[7] = 0;
    this.matrix[8] = 0;
    this.matrix[9] = 0;
    this.matrix[10] = (far + near) * nf;
    this.matrix[11] = -1;
    this.matrix[12] = 0;
    this.matrix[13] = 0;
    this.matrix[14] = 2 * far * near * nf;
    this.matrix[15] = 0;
    return this;
  }
  /**
   * Sets this matrix to an orthographic projection matrix.
   *
   * An orthographic projection matrix is used to create a 2D rendering
   * of a 3D scene by projecting points onto a plane without perspective
   * distortion. This method modifies the current matrix to represent
   * the orthographic projection defined by the given parameters.
   *
   * @param {number} left - The coordinate for the left vertical clipping plane.
   * @param {number} right - The coordinate for the right vertical clipping plane.
   * @param {number} bottom - The coordinate for the bottom horizontal clipping plane.
   * @param {number} top - The coordinate for the top horizontal clipping plane.
   * @param {number} near - The distance to the near depth clipping plane. Must be positive.
   * @param {number} far - The distance to the far depth clipping plane. Must be positive.
   * @chainable
   * @returns {Matrix} The current matrix instance, updated with the orthographic projection.
   *
   * @example
   * <div class="norender"><code>
   * // Example using p5.js to demonstrate orthographic projection
   * function setup() {
   *  let orthoMatrix = new p5.Matrix(4);
   *  console.log(orthoMatrix.matrix.toString()) // Output: 1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1
   *  orthoMatrix.ortho(-200, 200, -200, 200, 0.1, 1000);
   *  console.log(orthoMatrix.matrix.toString()) // Output: [24 0.004999999888241291,0,0,0,0,0.004999999888241291,0,0,0,0,-0.0020002000965178013,0,0,0,-1.0002000331878662,1]
   *  applyMatrix(
   *     orthoMatrix.mat4[0], orthoMatrix.mat4[1], orthoMatrix.mat4[2], orthoMatrix.mat4[3],
   *     orthoMatrix.mat4[4], orthoMatrix.mat4[5], orthoMatrix.mat4[6], orthoMatrix.mat4[7],
   *     orthoMatrix.mat4[8], orthoMatrix.mat4[9], orthoMatrix.mat4[10], orthoMatrix.mat4[11],
   *     orthoMatrix.mat4[12], orthoMatrix.mat4[13], orthoMatrix.mat4[14], orthoMatrix.mat4[15]
   *  );
   *  console.log(orthoMatrix.matrix.toString()) // Output: [31 0.004999999888241291,0,0,0,0,0.004999999888241291,0,0,0,0,-0.0020002000965178013,0,0,0,-1.0002000331878662,1]
   *   }
   * </code></div>
   *
   */
  ortho(left, right, bottom, top, near, far) {
    const lr = 1 / (left - right), bt = 1 / (bottom - top), nf = 1 / (near - far);
    this.matrix[0] = -2 * lr;
    this.matrix[1] = 0;
    this.matrix[2] = 0;
    this.matrix[3] = 0;
    this.matrix[4] = 0;
    this.matrix[5] = -2 * bt;
    this.matrix[6] = 0;
    this.matrix[7] = 0;
    this.matrix[8] = 0;
    this.matrix[9] = 0;
    this.matrix[10] = 2 * nf;
    this.matrix[11] = 0;
    this.matrix[12] = (left + right) * lr;
    this.matrix[13] = (top + bottom) * bt;
    this.matrix[14] = (far + near) * nf;
    this.matrix[15] = 1;
    return this;
  }
  /**
   * Applies a matrix to a vector with x, y, z, w components and returns the result as an array.
   *
   * This method multiplies the current matrix by a 4D vector (x, y, z, w) and computes the resulting vector.
   * It is commonly used in 3D graphics for transformations such as translation, rotation, scaling, and perspective projection.
   *
   * The resulting vector is returned as an array of four numbers, representing the transformed x, y, z, and w components.
   *
   * @param {Number} x - The x component of the vector.
   * @param {Number} y - The y component of the vector.
   * @param {Number} z - The z component of the vector.
   * @param {Number} w - The w component of the vector.
   * @returns {Number[]} An array containing the transformed [x, y, z, w] components.
   *
   * @example
   * // Applying a matrix to a 4D vector
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * const result = matrix.multiplyVec4(1, 2, 3, 1); // Transform the vector [1, 2, 3, 1]
   * console.log(result); // Output: [1, 2, 3, 1] (unchanged for identity matrix)
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Apply the matrix to a 4D vector
   *   const result = matrix.multiplyVec4(1, 2, 3, 1);
   *   console.log("Transformed Vector:", result); // Output: [1, 2, 3, 1]
   *
   *   // Modify the matrix (e.g., apply a translation)
   *   matrix.translate([5, 5, 5]);
   *   console.log("Modified Matrix:", matrix.matrix);
   *
   *   // Apply the modified matrix to the same vector
   *   const transformedResult = matrix.multiplyVec4(1, 2, 3, 1);
   *   console.log("Transformed Vector after Translation:", transformedResult); // Output: [6, 7, 8, 1]
   * }
   * </code></div>
   */
  multiplyVec4(x, y, z, w) {
    const result = new Array(4);
    const m3 = this.matrix;
    result[0] = m3[0] * x + m3[4] * y + m3[8] * z + m3[12] * w;
    result[1] = m3[1] * x + m3[5] * y + m3[9] * z + m3[13] * w;
    result[2] = m3[2] * x + m3[6] * y + m3[10] * z + m3[14] * w;
    result[3] = m3[3] * x + m3[7] * y + m3[11] * z + m3[15] * w;
    return result;
  }
  /**
   * Applies a matrix to a vector. The fourth component is set to 1.
   * Returns a vector consisting of the first
   * through third components of the result.
   *
   * This method multiplies the current matrix by a 4D vector (x, y, z, 1),
   * effectively transforming the vector using the matrix. The resulting
   * vector is returned as a new `p5.Vector` instance.
   *
   * This is useful for applying transformations such as translation,
   * rotation, scaling, or perspective projection to a point in 3D space.
   *
   * @param {p5.Vector} vector - The input vector to transform. It should
   *                              have x, y, and z components.
   * @return {p5.Vector} A new `p5.Vector` instance representing the transformed point.
   *
   * @example
   * // Applying a matrix to a 3D point
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * const point = new p5.Vector(1, 2, 3); // Define a 3D point
   * const transformedPoint = matrix.multiplyPoint(point);
   * console.log(transformedPoint.toString()); // Output: [1, 2, 3] (unchanged for identity matrix)
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Define a 3D point
   *   const point = new p5.Vector(1, 2, 3);
   *   console.log("Original Point:", point.toString());
   *
   *   // Apply the matrix to the point
   *   const transformedPoint = matrix.multiplyPoint(point);
   *   console.log("Transformed Point:", transformedPoint.toString());
   *
   *   // Modify the matrix (e.g., apply a translation)
   *   matrix.translate([5, 5, 5]);
   *   console.log("Modified Matrix:", matrix.matrix);
   *
   *   // Apply the modified matrix to the same point
   *   const translatedPoint = matrix.multiplyPoint(point);
   *   console.log("Translated Point:", translatedPoint.toString()); // Output: [6, 7, 8]
   * }
   * </code></div>
   */
  multiplyPoint({ x, y, z }) {
    const array2 = this.multiplyVec4(x, y, z, 1);
    return new Vector(array2[0], array2[1], array2[2]);
  }
  /**
   * Applies a matrix to a vector.
   * The fourth component is set to 1.
   * Returns the result of dividing the 1st to 3rd components
   * of the result by the 4th component as a vector.
   *
   * This method multiplies the current matrix by a 4D vector (x, y, z, 1),
   * effectively transforming the vector using the matrix. The resulting
   * vector is normalized by dividing its x, y, and z components by the w component.
   * This is useful for applying transformations such as perspective projection
   * to a point in 3D space.
   *
   * @param {p5.Vector} vector - The input vector to transform. It should
   *                              have x, y, and z components.
   * @return {p5.Vector} A new `p5.Vector` instance representing the transformed and normalized point.
   *
   * @example
   * // Applying a matrix to a 3D point and normalizing it
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * const point = new p5.Vector(1, 2, 3); // Define a 3D point
   * const transformedPoint = matrix.multiplyAndNormalizePoint(point);
   * console.log(transformedPoint.toString()); // Output: [1, 2, 3] (unchanged for identity matrix)
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Define a 3D point
   *   const point = new p5.Vector(1, 2, 3);
   *   console.log("Original Point:", point.toString());
   *
   *   // Apply the matrix to the point and normalize it
   *   const transformedPoint = matrix.multiplyAndNormalizePoint(point);
   *   console.log("Transformed and Normalized Point:", transformedPoint.toString());
   *
   *   // Modify the matrix (e.g., apply a perspective transformation)
   *   matrix.perspective(Math.PI / 4, 1.5, 0.1, 100);
   *   console.log("Modified Matrix (Perspective):", matrix.matrix);
   *
   *   // Apply the modified matrix to the same point
   *   const perspectivePoint = matrix.multiplyAndNormalizePoint(point);
   *   console.log("Point after Perspective Transformation:", perspectivePoint.toString());
   * }
   * </code></div>
   */
  multiplyAndNormalizePoint({ x, y, z }) {
    const array2 = this.multiplyVec4(x, y, z, 1);
    array2[0] /= array2[3];
    array2[1] /= array2[3];
    array2[2] /= array2[3];
    return new Vector(array2[0], array2[1], array2[2]);
  }
  /**
   * Applies a matrix to a vector.
   * The fourth component is set to 0.
   * Returns a vector consisting of the first
   * through third components of the result.
   *
   * This method multiplies the current matrix by a 4D vector (x, y, z, 0),
   * effectively transforming the direction vector using the matrix. The resulting
   * vector is returned as a new `p5.Vector` instance. This is particularly useful
   * for transforming direction vectors (e.g., normals) without applying translation.
   *
   * @param {p5.Vector} vector - The input vector to transform. It should
   *                              have x, y, and z components.
   * @return {p5.Vector} A new `p5.Vector` instance representing the transformed direction.
   *
   * @example
   * // Applying a matrix to a direction vector
   * const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   * const direction = new p5.Vector(1, 0, 0); // Define a direction vector
   * const transformedDirection = matrix.multiplyDirection(direction);
   * console.log(transformedDirection.toString()); // Output: [1, 0, 0] (unchanged for identity matrix)
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   const matrix = new p5.Matrix(4); // Create a 4x4 identity matrix
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Define a direction vector
   *   const direction = new p5.Vector(1, 0, 0);
   *   console.log("Original Direction:", direction.toString());
   *
   *   // Apply the matrix to the direction vector
   *   const transformedDirection = matrix.multiplyDirection(direction);
   *   console.log("Transformed Direction:", transformedDirection.toString());
   *
   *   // Modify the matrix (e.g., apply a rotation)
   *   matrix.rotateY(Math.PI / 4); // Rotate 45 degrees around the Y-axis
   *   console.log("Modified Matrix (Rotation):", matrix.matrix);
   *
   *   // Apply the modified matrix to the same direction vector
   *   const rotatedDirection = matrix.multiplyDirection(direction);
   *   console.log("Rotated Direction:", rotatedDirection.toString()); // Output: Rotated vector
   * }
   * </code></div>
   */
  multiplyDirection({ x, y, z }) {
    const array2 = this.multiplyVec4(x, y, z, 0);
    return new Vector(array2[0], array2[1], array2[2]);
  }
  /**
   * Takes a vector and returns the vector resulting from multiplying. This function is only for 3x3 matrices.
   * that vector by this matrix from the left.
   *
   * This method applies the current 3x3 matrix to a given vector, effectively
   * transforming the vector using the matrix. The resulting vector is returned
   * as a new vector or stored in the provided target vector.
   *
   * This is useful for operations such as transforming points or directions
   * in 2D or 3D space using a 3x3 transformation matrix.
   *
   * @param {p5.Vector} multVector - The vector to which this matrix applies.
   * @param {p5.Vector} [target] - The vector to receive the result. If not provided,
   *                               a copy of the input vector will be created and returned.
   * @return {p5.Vector} - The transformed vector after applying the matrix.
   *
   * @example
   * // Multiplying a 3x3 matrix with a vector
   * const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   * const vector = new p5.Vector(1, 2, 3);
   * const result = matrix.multiplyVec3(vector);
   * console.log(result.toString()); // Output: Transformed vector
   *
   * // p5.js script example
   * <div class="norender"><code>
   * function setup() {
   *
   *   // Create a 3x3 matrix
   *   const matrix = new p5.Matrix([1, 2, 3, 4, 5, 6, 7, 8, 9]);
   *   console.log("Original Matrix:", matrix.matrix);
   *
   *   // Define a vector
   *   const vector = new p5.Vector(1, 2, 3);
   *   console.log("Original Vector:", vector.toString()); // Output: [1, 2, 3]
   *
   *   // Apply the matrix to the vector
   *   const transformedVector = matrix.multiplyVec3(vector);
   *   console.log("Transformed Vector:", transformedVector.toString()); // Output: [30, 36, 42]
   *
   *   // Modify the matrix (e.g., apply a scaling transformation)
   *   matrix.scale(2, 2, 2);
   *   console.log("Modified Matrix (Scaling):", matrix.matrix); // Output: [2, 4, 6, 8, 10, 12, 14, 16, 18]
   *
   *   // Apply the modified matrix to the same vector
   *   const scaledVector = matrix.multiplyVec3(vector);
   *   console.log("Scaled Vector:", scaledVector.toString()); // Output: [60, 72, 84]
   * }
   * </code></div>
   */
  multiplyVec3(multVector, target) {
    if (target === void 0) {
      target = multVector.copy();
    }
    target.x = this.row(0).dot(multVector);
    target.y = this.row(1).dot(multVector);
    target.z = this.row(2).dot(multVector);
    return target;
  }
  /**
   * PRIVATE
   */
  // matrix methods adapted from:
  // https://developer.mozilla.org/en-US/docs/Web/WebGL/
  // gluPerspective
  //
  // function _makePerspective(fovy, aspect, znear, zfar){
  //    const ymax = znear * Math.tan(fovy * Math.PI / 360.0);
  //    const ymin = -ymax;
  //    const xmin = ymin * aspect;
  //    const xmax = ymax * aspect;
  //    return _makeFrustum(xmin, xmax, ymin, ymax, znear, zfar);
  //  }
  ////
  //// glFrustum
  ////
  //function _makeFrustum(left, right, bottom, top, znear, zfar){
  //  const X = 2*znear/(right-left);
  //  const Y = 2*znear/(top-bottom);
  //  const A = (right+left)/(right-left);
  //  const B = (top+bottom)/(top-bottom);
  //  const C = -(zfar+znear)/(zfar-znear);
  //  const D = -2*zfar*znear/(zfar-znear);
  //  const frustrumMatrix =[
  //  X, 0, A, 0,
  //  0, Y, B, 0,
  //  0, 0, C, D,
  //  0, 0, -1, 0
  //];
  //return frustrumMatrix;
  // }
  // function _setMVPMatrices(){
  ////an identity matrix
  ////@TODO use the p5.Matrix class to abstract away our MV matrices and
  ///other math
  //const _mvMatrix =
  //[
  //  1.0,0.0,0.0,0.0,
  //  0.0,1.0,0.0,0.0,
  //  0.0,0.0,1.0,0.0,
  //  0.0,0.0,0.0,1.0
  //];
};
_sqDimention = new WeakMap();
_Matrix_instances = new WeakSet();
// ====================
// PRIVATE
/**
 * Creates identity matrix
 * This method updates the current matrix with the result of the multiplication.
 *
 * @private
 */
createIdentityMatrix_fn = function(dimension) {
  if (dimension === 3)
    return new GLMAT_ARRAY_TYPE2([1, 0, 0, 0, 1, 0, 0, 0, 1]);
  if (dimension === 4)
    return new GLMAT_ARRAY_TYPE2([
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ]);
  const identityMatrix = new GLMAT_ARRAY_TYPE2(dimension * dimension).fill(0);
  for (let i = 0; i < dimension; i++) {
    identityMatrix[i * dimension + i] = 1;
  }
  return identityMatrix;
};
/**
 * Multiplies the current 4x4 matrix with another 4x4 matrix.
 * This method updates the current matrix with the result of the multiplication.
 *
 * @private
 * @param {number[]} _src - A 16-element array representing the 4x4 matrix to multiply with.
 *
 * @returns {this} The current instance with the updated matrix.
 *
 * @example
 * // Assuming `matrix` is an instance of the Matrix class
 * const srcMatrix = [
 *   1, 0, 0, 0,
 *   0, 1, 0, 0,
 *   0, 0, 1, 0,
 *   0, 0, 0, 1
 * ];
 * matrix.#mult4x4(srcMatrix);
 */
mult4x4_fn = function(_src) {
  let b0 = this.matrix[0], b1 = this.matrix[1], b22 = this.matrix[2], b3 = this.matrix[3];
  this.matrix[0] = b0 * _src[0] + b1 * _src[4] + b22 * _src[8] + b3 * _src[12];
  this.matrix[1] = b0 * _src[1] + b1 * _src[5] + b22 * _src[9] + b3 * _src[13];
  this.matrix[2] = b0 * _src[2] + b1 * _src[6] + b22 * _src[10] + b3 * _src[14];
  this.matrix[3] = b0 * _src[3] + b1 * _src[7] + b22 * _src[11] + b3 * _src[15];
  b0 = this.matrix[4];
  b1 = this.matrix[5];
  b22 = this.matrix[6];
  b3 = this.matrix[7];
  this.matrix[4] = b0 * _src[0] + b1 * _src[4] + b22 * _src[8] + b3 * _src[12];
  this.matrix[5] = b0 * _src[1] + b1 * _src[5] + b22 * _src[9] + b3 * _src[13];
  this.matrix[6] = b0 * _src[2] + b1 * _src[6] + b22 * _src[10] + b3 * _src[14];
  this.matrix[7] = b0 * _src[3] + b1 * _src[7] + b22 * _src[11] + b3 * _src[15];
  b0 = this.matrix[8];
  b1 = this.matrix[9];
  b22 = this.matrix[10];
  b3 = this.matrix[11];
  this.matrix[8] = b0 * _src[0] + b1 * _src[4] + b22 * _src[8] + b3 * _src[12];
  this.matrix[9] = b0 * _src[1] + b1 * _src[5] + b22 * _src[9] + b3 * _src[13];
  this.matrix[10] = b0 * _src[2] + b1 * _src[6] + b22 * _src[10] + b3 * _src[14];
  this.matrix[11] = b0 * _src[3] + b1 * _src[7] + b22 * _src[11] + b3 * _src[15];
  b0 = this.matrix[12];
  b1 = this.matrix[13];
  b22 = this.matrix[14];
  b3 = this.matrix[15];
  this.matrix[12] = b0 * _src[0] + b1 * _src[4] + b22 * _src[8] + b3 * _src[12];
  this.matrix[13] = b0 * _src[1] + b1 * _src[5] + b22 * _src[9] + b3 * _src[13];
  this.matrix[14] = b0 * _src[2] + b1 * _src[6] + b22 * _src[10] + b3 * _src[14];
  this.matrix[15] = b0 * _src[3] + b1 * _src[7] + b22 * _src[11] + b3 * _src[15];
  return this;
};
/**
 * @param {p5.Matrix|Float32Array|Number[]} multMatrix The matrix
 *                                                we want to multiply by
 * @private
 * @chainable
 */
multNxN_fn = function(multMatrix) {
  if (multMatrix.length !== this.matrix.length) {
    throw new Error("Matrices must be of the same dimension to multiply.");
  }
  const result = new GLMAT_ARRAY_TYPE2(this.matrix.length).fill(0);
  for (let i = 0; i < __privateGet(this, _sqDimention); i++) {
    for (let j2 = 0; j2 < __privateGet(this, _sqDimention); j2++) {
      for (let k = 0; k < __privateGet(this, _sqDimention); k++) {
        result[i * __privateGet(this, _sqDimention) + j2] += this.matrix[i * __privateGet(this, _sqDimention) + k] * multMatrix[k * __privateGet(this, _sqDimention) + j2];
      }
    }
  }
  this.matrix = result;
  return this;
};
/**
 * This function is only for 3x3 matrices.
 * multiply two mat3s. It is an operation to multiply the 3x3 matrix of
 * the argument from the right. Arguments can be a 3x3 p5.Matrix,
 * a Float32Array of length 9, or a javascript array of length 9.
 * In addition, it can also be done by enumerating 9 numbers.
 *
 * @param {p5.Matrix|Float32Array|Number[]} multMatrix The matrix
 *                                                we want to multiply by
 * @private
 * @chainable
 */
mult3x3_fn = function(_src) {
  let b0 = this.mat3[0];
  let b1 = this.mat3[1];
  let b22 = this.mat3[2];
  this.mat3[0] = b0 * _src[0] + b1 * _src[3] + b22 * _src[6];
  this.mat3[1] = b0 * _src[1] + b1 * _src[4] + b22 * _src[7];
  this.mat3[2] = b0 * _src[2] + b1 * _src[5] + b22 * _src[8];
  b0 = this.mat3[3];
  b1 = this.mat3[4];
  b22 = this.mat3[5];
  this.mat3[3] = b0 * _src[0] + b1 * _src[3] + b22 * _src[6];
  this.mat3[4] = b0 * _src[1] + b1 * _src[4] + b22 * _src[7];
  this.mat3[5] = b0 * _src[2] + b1 * _src[5] + b22 * _src[8];
  b0 = this.mat3[6];
  b1 = this.mat3[7];
  b22 = this.mat3[8];
  this.mat3[6] = b0 * _src[0] + b1 * _src[3] + b22 * _src[6];
  this.mat3[7] = b0 * _src[1] + b1 * _src[4] + b22 * _src[7];
  this.mat3[8] = b0 * _src[2] + b1 * _src[5] + b22 * _src[8];
  return this;
};
/**
 * Transposes a square matrix in place.
 * This method swaps the rows and columns of the matrix, effectively flipping it over its diagonal.
 *
 * @private
 * @returns {Matrix} The current instance of the Matrix, with the transposed values.
 */
transposeNxN_fn = function() {
  const n3 = __privateGet(this, _sqDimention);
  for (let i = 0; i < n3; i++) {
    for (let j2 = 0; j2 < n3; j2++) {
      this.matrix[i * n3 + j2] = this.matrix[j2 * n3 + i];
    }
  }
  return this;
};
/**
 * transpose according to a given matrix
 * @param  {p5.Matrix|Float32Array|Number[]} a  the matrix to be
 *                                               based on to transpose
 * @private
 * @chainable
 */
transpose4x4_fn = function(a2) {
  console.log("====> 4x4");
  let a01, a02, a03, a12, a13, a23;
  if (a2 instanceof _Matrix) {
    a01 = a2.matrix[1];
    a02 = a2.matrix[2];
    a03 = a2.matrix[3];
    a12 = a2.matrix[6];
    a13 = a2.matrix[7];
    a23 = a2.matrix[11];
    this.matrix[0] = a2.matrix[0];
    this.matrix[1] = a2.matrix[4];
    this.matrix[2] = a2.matrix[8];
    this.matrix[3] = a2.matrix[12];
    this.matrix[4] = a01;
    this.matrix[5] = a2.matrix[5];
    this.matrix[6] = a2.matrix[9];
    this.matrix[7] = a2.matrix[13];
    this.matrix[8] = a02;
    this.matrix[9] = a12;
    this.matrix[10] = a2.matrix[10];
    this.matrix[11] = a2.matrix[14];
    this.matrix[12] = a03;
    this.matrix[13] = a13;
    this.matrix[14] = a23;
    this.matrix[15] = a2.matrix[15];
  } else if (isMatrixArray2(a2)) {
    a01 = a2[1];
    a02 = a2[2];
    a03 = a2[3];
    a12 = a2[6];
    a13 = a2[7];
    a23 = a2[11];
    this.matrix[0] = a2[0];
    this.matrix[1] = a2[4];
    this.matrix[2] = a2[8];
    this.matrix[3] = a2[12];
    this.matrix[4] = a01;
    this.matrix[5] = a2[5];
    this.matrix[6] = a2[9];
    this.matrix[7] = a2[13];
    this.matrix[8] = a02;
    this.matrix[9] = a12;
    this.matrix[10] = a2[10];
    this.matrix[11] = a2[14];
    this.matrix[12] = a03;
    this.matrix[13] = a13;
    this.matrix[14] = a23;
    this.matrix[15] = a2[15];
  }
  return this;
};
/**
 * This function is only for 3x3 matrices.
 * transposes a 3×3 p5.Matrix by a mat3
 * If there is an array of arguments, the matrix obtained by transposing
 * the 3x3 matrix generated based on that array is set.
 * If no arguments, it transposes itself and returns it.
 *
 * @param  {Number[]} mat3 1-dimensional array
 * @private
 * @chainable
 */
transpose3x3_fn = function(mat3) {
  if (mat3 === void 0) {
    mat3 = this.mat3;
  }
  const a01 = mat3[1];
  const a02 = mat3[2];
  const a12 = mat3[5];
  this.mat3[0] = mat3[0];
  this.mat3[1] = mat3[3];
  this.mat3[2] = mat3[6];
  this.mat3[3] = a01;
  this.mat3[4] = mat3[4];
  this.mat3[5] = mat3[7];
  this.mat3[6] = a02;
  this.mat3[7] = a12;
  this.mat3[8] = mat3[8];
  return this;
};
/**
 * Only 4x4 becasuse determinant is only 4x4 currently
 * invert  matrix according to a give matrix
 * @param  {p5.Matrix|Float32Array|Number[]} a   the matrix to be
 *                                                based on to invert
 * @private
 * @chainable
 */
invert4x4_fn = function(a2) {
  let a00, a01, a02, a03, a10, a11, a12, a13;
  let a20, a21, a22, a23, a30, a31, a32, a33;
  if (a2 instanceof _Matrix) {
    a00 = a2.matrix[0];
    a01 = a2.matrix[1];
    a02 = a2.matrix[2];
    a03 = a2.matrix[3];
    a10 = a2.matrix[4];
    a11 = a2.matrix[5];
    a12 = a2.matrix[6];
    a13 = a2.matrix[7];
    a20 = a2.matrix[8];
    a21 = a2.matrix[9];
    a22 = a2.matrix[10];
    a23 = a2.matrix[11];
    a30 = a2.matrix[12];
    a31 = a2.matrix[13];
    a32 = a2.matrix[14];
    a33 = a2.matrix[15];
  } else if (isMatrixArray2(a2)) {
    a00 = a2[0];
    a01 = a2[1];
    a02 = a2[2];
    a03 = a2[3];
    a10 = a2[4];
    a11 = a2[5];
    a12 = a2[6];
    a13 = a2[7];
    a20 = a2[8];
    a21 = a2[9];
    a22 = a2[10];
    a23 = a2[11];
    a30 = a2[12];
    a31 = a2[13];
    a32 = a2[14];
    a33 = a2[15];
  }
  const b00 = a00 * a11 - a01 * a10;
  const b01 = a00 * a12 - a02 * a10;
  const b02 = a00 * a13 - a03 * a10;
  const b03 = a01 * a12 - a02 * a11;
  const b04 = a01 * a13 - a03 * a11;
  const b05 = a02 * a13 - a03 * a12;
  const b06 = a20 * a31 - a21 * a30;
  const b07 = a20 * a32 - a22 * a30;
  const b08 = a20 * a33 - a23 * a30;
  const b09 = a21 * a32 - a22 * a31;
  const b10 = a21 * a33 - a23 * a31;
  const b11 = a22 * a33 - a23 * a32;
  let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
  if (!det) {
    return null;
  }
  det = 1 / det;
  this.matrix[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  this.matrix[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  this.matrix[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  this.matrix[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  this.matrix[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  this.matrix[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  this.matrix[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  this.matrix[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  this.matrix[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  this.matrix[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  this.matrix[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  this.matrix[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  this.matrix[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  this.matrix[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  this.matrix[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  this.matrix[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return this;
};
/**
 * Inverts a 3×3 matrix
 * @chainable
 * @private
 */
invert3x3_fn = function() {
  const a00 = this.mat3[0];
  const a01 = this.mat3[1];
  const a02 = this.mat3[2];
  const a10 = this.mat3[3];
  const a11 = this.mat3[4];
  const a12 = this.mat3[5];
  const a20 = this.mat3[6];
  const a21 = this.mat3[7];
  const a22 = this.mat3[8];
  const b01 = a22 * a11 - a12 * a21;
  const b11 = -a22 * a10 + a12 * a20;
  const b21 = a21 * a10 - a11 * a20;
  let det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  this.mat3[0] = b01 * det;
  this.mat3[1] = (-a22 * a01 + a02 * a21) * det;
  this.mat3[2] = (a12 * a01 - a02 * a11) * det;
  this.mat3[3] = b11 * det;
  this.mat3[4] = (a22 * a00 - a02 * a20) * det;
  this.mat3[5] = (-a12 * a00 + a02 * a10) * det;
  this.mat3[6] = b21 * det;
  this.mat3[7] = (-a21 * a00 + a01 * a20) * det;
  this.mat3[8] = (a11 * a00 - a01 * a10) * det;
  return this;
};
/**
 * inspired by Toji's mat4 determinant
 * @return {Number} Determinant of our 4×4 matrix
 * @private
 */
determinant4x4_fn = function() {
  if (__privateGet(this, _sqDimention) !== 4) {
    throw new Error(
      "Determinant is only implemented for 4x4 matrices. We are working on it."
    );
  }
  const d00 = this.matrix[0] * this.matrix[5] - this.matrix[1] * this.matrix[4], d01 = this.matrix[0] * this.matrix[6] - this.matrix[2] * this.matrix[4], d02 = this.matrix[0] * this.matrix[7] - this.matrix[3] * this.matrix[4], d03 = this.matrix[1] * this.matrix[6] - this.matrix[2] * this.matrix[5], d04 = this.matrix[1] * this.matrix[7] - this.matrix[3] * this.matrix[5], d05 = this.matrix[2] * this.matrix[7] - this.matrix[3] * this.matrix[6], d06 = this.matrix[8] * this.matrix[13] - this.matrix[9] * this.matrix[12], d07 = this.matrix[8] * this.matrix[14] - this.matrix[10] * this.matrix[12], d08 = this.matrix[8] * this.matrix[15] - this.matrix[11] * this.matrix[12], d09 = this.matrix[9] * this.matrix[14] - this.matrix[10] * this.matrix[13], d10 = this.matrix[9] * this.matrix[15] - this.matrix[11] * this.matrix[13], d11 = this.matrix[10] * this.matrix[15] - this.matrix[11] * this.matrix[14];
  return d00 * d11 - d01 * d10 + d02 * d09 + d03 * d08 - d04 * d07 + d05 * d06;
};
var Matrix = _Matrix;

// node_modules/p5/dist/math/p5.Matrix.js
function matrix(p53, fn2) {
  p53.Matrix = Matrix;
}
if (typeof p5 !== "undefined") {
  matrix(p5, p5.prototype);
}

// node_modules/p5/dist/webgl/p5.DataArray.js
var DataArray = class {
  constructor(initialLength = 128) {
    this.length = 0;
    this.data = new Float32Array(initialLength);
    this.initialLength = initialLength;
  }
  /**
   * Returns a Float32Array window sized to the exact length of the data
   */
  dataArray() {
    return this.subArray(0, this.length);
  }
  /**
   * A "soft" clear, which keeps the underlying storage size the same, but
   * empties the contents of its dataArray()
   */
  clear() {
    this.length = 0;
  }
  /**
   * Can be used to scale a DataArray back down to fit its contents.
   */
  rescale() {
    if (this.length < this.data.length / 2) {
      const targetLength = 1 << Math.ceil(Math.log2(this.length));
      const newData = new Float32Array(targetLength);
      newData.set(this.data.subarray(0, this.length), 0);
      this.data = newData;
    }
  }
  /**
   * A full reset, which allocates a new underlying Float32Array at its initial
   * length
   */
  reset() {
    this.clear();
    this.data = new Float32Array(this.initialLength);
  }
  /**
   * Adds values to the DataArray, expanding its internal storage to
   * accommodate the new items.
   */
  push(...values) {
    this.ensureLength(this.length + values.length);
    this.data.set(values, this.length);
    this.length += values.length;
  }
  /**
   * Returns a copy of the data from the index `from`, inclusive, to the index
   * `to`, exclusive
   */
  slice(from, to2) {
    return this.data.slice(from, Math.min(to2, this.length));
  }
  /**
   * Returns a mutable Float32Array window from the index `from`, inclusive, to
   * the index `to`, exclusive
   */
  subArray(from, to2) {
    return this.data.subarray(from, Math.min(to2, this.length));
  }
  /**
   * Expand capacity of the internal storage until it can fit a target size
   */
  ensureLength(target) {
    while (this.data.length < target) {
      const newData = new Float32Array(this.data.length * 2);
      newData.set(this.data, 0);
      this.data = newData;
    }
  }
};
function dataArray(p53, fn2) {
  p53.DataArray = DataArray;
}
if (typeof p5 !== "undefined") {
  dataArray(p5, p5.prototype);
}

// node_modules/p5/dist/webgl/p5.Geometry.js
var import_file_saver = __toESM(require_FileSaver());
var Geometry = class _Geometry {
  constructor(detailX, detailY, callback, renderer2) {
    this.renderer = renderer2;
    this.vertices = [];
    this.boundingBoxCache = null;
    this.lineVertices = new DataArray();
    this.lineTangentsIn = new DataArray();
    this.lineTangentsOut = new DataArray();
    this.lineSides = new DataArray();
    this.vertexNormals = [];
    this.faces = [];
    this.uvs = [];
    this.edges = [];
    this.vertexColors = [];
    this.vertexStrokeColors = [];
    this.userVertexProperties = {};
    this.lineVertexColors = new DataArray();
    this.detailX = detailX !== void 0 ? detailX : 1;
    this.detailY = detailY !== void 0 ? detailY : 1;
    this.dirtyFlags = {};
    this._hasFillTransparency = void 0;
    this._hasStrokeTransparency = void 0;
    this.gid = `_p5_Geometry_${_Geometry.nextId}`;
    _Geometry.nextId++;
    if (callback instanceof Function) {
      callback.call(this);
    }
  }
  /**
  * Calculates the position and size of the smallest box that contains the geometry.
  *
  * A bounding box is the smallest rectangular prism that contains the entire
  * geometry. It's defined by the box's minimum and maximum coordinates along
  * each axis, as well as the size (length) and offset (center).
  *
  * Calling `myGeometry.calculateBoundingBox()` returns an object with four
  * properties that describe the bounding box:
  *
  * ```js
  * // Get myGeometry's bounding box.
  * let bbox = myGeometry.calculateBoundingBox();
  *
  * // Print the bounding box to the console.
  * console.log(bbox);
  *
  * // {
  * //  // The minimum coordinate along each axis.
  * //  min: { x: -1, y: -2, z: -3 },
  * //
  * //  // The maximum coordinate along each axis.
  * //  max: { x: 1, y: 2, z: 3},
  * //
  * //  // The size (length) along each axis.
  * //  size: { x: 2, y: 4, z: 6},
  * //
  * //  // The offset (center) along each axis.
  * //  offset: { x: 0, y: 0, z: 0}
  * // }
  * ```
  *
  * @returns {Object} bounding box of the geometry.
  *
  * @example
  * <div>
  * <code>
  * // Click and drag the mouse to view the scene from different angles.
  *
  * let particles;
  *
  * function setup() {
  *   createCanvas(100, 100, WEBGL);
  *
  *   // Create a new p5.Geometry object with random spheres.
  *   particles = buildGeometry(createParticles);
  *
  *   describe('Ten white spheres placed randomly against a gray background. A box encloses the spheres.');
  * }
  *
  * function draw() {
  *   background(50);
  *
  *   // Enable orbiting with the mouse.
  *   orbitControl();
  *
  *   // Turn on the lights.
  *   lights();
  *
  *   // Style the particles.
  *   noStroke();
  *   fill(255);
  *
  *   // Draw the particles.
  *   model(particles);
  *
  *   // Calculate the bounding box.
  *   let bbox = particles.calculateBoundingBox();
  *
  *   // Translate to the bounding box's center.
  *   translate(bbox.offset.x, bbox.offset.y, bbox.offset.z);
  *
  *   // Style the bounding box.
  *   stroke(255);
  *   noFill();
  *
  *   // Draw the bounding box.
  *   box(bbox.size.x, bbox.size.y, bbox.size.z);
  * }
  *
  * function createParticles() {
  *   for (let i = 0; i < 10; i += 1) {
  *     // Calculate random coordinates.
  *     let x = randomGaussian(0, 15);
  *     let y = randomGaussian(0, 15);
  *     let z = randomGaussian(0, 15);
  *
  *     push();
  *     // Translate to the particle's coordinates.
  *     translate(x, y, z);
  *     // Draw the particle.
  *     sphere(3);
  *     pop();
  *   }
  * }
  * </code>
  * </div>
  */
  calculateBoundingBox() {
    if (this.boundingBoxCache) {
      return this.boundingBoxCache;
    }
    let minVertex = new Vector(
      Number.MAX_VALUE,
      Number.MAX_VALUE,
      Number.MAX_VALUE
    );
    let maxVertex = new Vector(
      Number.MIN_VALUE,
      Number.MIN_VALUE,
      Number.MIN_VALUE
    );
    for (let i = 0; i < this.vertices.length; i++) {
      let vertex2 = this.vertices[i];
      minVertex.x = Math.min(minVertex.x, vertex2.x);
      minVertex.y = Math.min(minVertex.y, vertex2.y);
      minVertex.z = Math.min(minVertex.z, vertex2.z);
      maxVertex.x = Math.max(maxVertex.x, vertex2.x);
      maxVertex.y = Math.max(maxVertex.y, vertex2.y);
      maxVertex.z = Math.max(maxVertex.z, vertex2.z);
    }
    let size = new Vector(
      maxVertex.x - minVertex.x,
      maxVertex.y - minVertex.y,
      maxVertex.z - minVertex.z
    );
    let offset2 = new Vector(
      (minVertex.x + maxVertex.x) / 2,
      (minVertex.y + maxVertex.y) / 2,
      (minVertex.z + maxVertex.z) / 2
    );
    this.boundingBoxCache = {
      min: minVertex,
      max: maxVertex,
      size,
      offset: offset2
    };
    return this.boundingBoxCache;
  }
  reset() {
    this._hasFillTransparency = void 0;
    this._hasStrokeTransparency = void 0;
    this.lineVertices.clear();
    this.lineTangentsIn.clear();
    this.lineTangentsOut.clear();
    this.lineSides.clear();
    this.vertices.length = 0;
    this.edges.length = 0;
    this.vertexColors.length = 0;
    this.vertexStrokeColors.length = 0;
    this.lineVertexColors.clear();
    this.vertexNormals.length = 0;
    this.uvs.length = 0;
    for (const propName in this.userVertexProperties) {
      this.userVertexProperties[propName].delete();
    }
    this.userVertexProperties = {};
    this.dirtyFlags = {};
  }
  hasFillTransparency() {
    if (this._hasFillTransparency === void 0) {
      this._hasFillTransparency = false;
      for (let i = 0; i < this.vertexColors.length; i += 4) {
        if (this.vertexColors[i + 3] < 1) {
          this._hasFillTransparency = true;
          break;
        }
      }
    }
    return this._hasFillTransparency;
  }
  hasStrokeTransparency() {
    if (this._hasStrokeTransparency === void 0) {
      this._hasStrokeTransparency = false;
      for (let i = 0; i < this.lineVertexColors.length; i += 4) {
        if (this.lineVertexColors[i + 3] < 1) {
          this._hasStrokeTransparency = true;
          break;
        }
      }
    }
    return this._hasStrokeTransparency;
  }
  /**
   * Removes the geometry’s internal colors.
   *
   * `p5.Geometry` objects can be created with "internal colors" assigned to
   * vertices or the entire shape. When a geometry has internal colors,
   * <a href="#/p5/fill">fill()</a> has no effect. Calling
   * `myGeometry.clearColors()` allows the
   * <a href="#/p5/fill">fill()</a> function to apply color to the geometry.
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Create a p5.Geometry object.
   *   // Set its internal color to red.
   *   let myGeometry = buildGeometry(function() {
   *     fill(255, 0, 0);
   *     plane(20);
   *   });
   *
   *   // Style the shape.
   *   noStroke();
   *
   *   // Draw the p5.Geometry object (center).
   *   model(myGeometry);
   *
   *   // Translate the origin to the bottom-right.
   *   translate(25, 25, 0);
   *
   *   // Try to fill the geometry with green.
   *   fill(0, 255, 0);
   *
   *   // Draw the geometry again (bottom-right).
   *   model(myGeometry);
   *
   *   // Clear the geometry's colors.
   *   myGeometry.clearColors();
   *
   *   // Fill the geometry with blue.
   *   fill(0, 0, 255);
   *
   *   // Translate the origin up.
   *   translate(0, -50, 0);
   *
   *   // Draw the geometry again (top-right).
   *   model(myGeometry);
   *
   *   describe(
   *     'Three squares drawn against a gray background. Red squares are at the center and the bottom-right. A blue square is at the top-right.'
   *   );
   * }
   * </code>
   * </div>
   */
  clearColors() {
    this.vertexColors = [];
    return this;
  }
  /**
   * The `saveObj()` function exports `p5.Geometry` objects as
   * 3D models in the Wavefront .obj file format.
   * This way, you can use the 3D shapes you create in p5.js in other software
   * for rendering, animation, 3D printing, or more.
   *
   * The exported .obj file will include the faces and vertices of the `p5.Geometry`,
   * as well as its texture coordinates and normals, if it has them.
   *
   * @method saveObj
   * @param {String} [fileName='model.obj'] The name of the file to save the model as.
   *                                        If not specified, the default file name will be 'model.obj'.
   * @example
   * <div>
   * <code>
   * let myModel;
   * let saveBtn;
   * function setup() {
   *   createCanvas(200, 200, WEBGL);
   *   myModel = buildGeometry(function()) {
   *     for (let i = 0; i < 5; i++) {
   *       push();
   *       translate(
   *         random(-75, 75),
   *         random(-75, 75),
   *         random(-75, 75)
   *       );
   *       sphere(random(5, 50));
   *       pop();
   *     }
   *   });
   *
   *   saveBtn = createButton('Save .obj');
   *   saveBtn.mousePressed(() => myModel.saveObj());
   *
   *   describe('A few spheres rotating in space');
   * }
   *
   * function draw() {
   *   background(0);
   *   noStroke();
   *   lights();
   *   rotateX(millis() * 0.001);
   *   rotateY(millis() * 0.002);
   *   model(myModel);
   * }
   * </code>
   * </div>
   */
  saveObj(fileName = "model.obj") {
    let objStr = "";
    this.vertices.forEach((v) => {
      objStr += `v ${v.x} ${v.y} ${v.z}
`;
    });
    if (this.uvs && this.uvs.length > 0) {
      for (let i = 0; i < this.uvs.length; i += 2) {
        objStr += `vt ${this.uvs[i]} ${this.uvs[i + 1]}
`;
      }
    }
    if (this.vertexNormals && this.vertexNormals.length > 0) {
      this.vertexNormals.forEach((n3) => {
        objStr += `vn ${n3.x} ${n3.y} ${n3.z}
`;
      });
    }
    this.faces.forEach((face) => {
      let faceStr = "f";
      face.forEach((index) => {
        faceStr += " ";
        faceStr += index + 1;
        if (this.vertexNormals.length > 0 || this.uvs.length > 0) {
          faceStr += "/";
          if (this.uvs.length > 0) {
            faceStr += index + 1;
          }
          faceStr += "/";
          if (this.vertexNormals.length > 0) {
            faceStr += index + 1;
          }
        }
      });
      objStr += faceStr + "\n";
    });
    const blob = new Blob([objStr], { type: "text/plain" });
    downloadFile(blob, fileName, "obj");
  }
  /**
   * The `saveStl()` function exports `p5.Geometry` objects as
   * 3D models in the STL stereolithography file format.
   * This way, you can use the 3D shapes you create in p5.js in other software
   * for rendering, animation, 3D printing, or more.
   *
   * The exported .stl file will include the faces, vertices, and normals of the `p5.Geometry`.
   *
   * By default, this method saves a text-based .stl file. Alternatively, you can save a more compact
   * but less human-readable binary .stl file by passing `{ binary: true }` as a second parameter.
   *
   * @method saveStl
   * @param {String} [fileName='model.stl'] The name of the file to save the model as.
   *                                        If not specified, the default file name will be 'model.stl'.
   * @param {Object} [options] Optional settings. Options can include a boolean `binary` property, which
   * controls whether or not a binary .stl file is saved. It defaults to false.
   * @example
   * <div>
   * <code>
   * let myModel;
   * let saveBtn1;
   * let saveBtn2;
   * function setup() {
   *   createCanvas(200, 200, WEBGL);
   *   myModel = buildGeometry(function() {
   *     for (let i = 0; i < 5; i++) {
   *       push();
   *       translate(
   *         random(-75, 75),
   *         random(-75, 75),
   *         random(-75, 75)
   *       );
   *       sphere(random(5, 50));
   *       pop();
   *     }
   *   });
   *
   *   saveBtn1 = createButton('Save .stl');
   *   saveBtn1.mousePressed(function() {
   *     myModel.saveStl();
   *   });
   *   saveBtn2 = createButton('Save binary .stl');
   *   saveBtn2.mousePressed(function() {
   *     myModel.saveStl('model.stl', { binary: true });
   *   });
   *
   *   describe('A few spheres rotating in space');
   * }
   *
   * function draw() {
   *   background(0);
   *   noStroke();
   *   lights();
   *   rotateX(millis() * 0.001);
   *   rotateY(millis() * 0.002);
   *   model(myModel);
   * }
   * </code>
   * </div>
   */
  saveStl(fileName = "model.stl", { binary = false } = {}) {
    let modelOutput;
    let name = fileName.substring(0, fileName.lastIndexOf("."));
    let faceNormals = [];
    for (let f of this.faces) {
      const U2 = Vector.sub(this.vertices[f[1]], this.vertices[f[0]]);
      const V = Vector.sub(this.vertices[f[2]], this.vertices[f[0]]);
      const nx = U2.y * V.z - U2.z * V.y;
      const ny = U2.z * V.x - U2.x * V.z;
      const nz = U2.x * V.y - U2.y * V.x;
      faceNormals.push(new Vector(nx, ny, nz).normalize());
    }
    if (binary) {
      let offset2 = 80;
      const bufferLength = this.faces.length * 2 + this.faces.length * 3 * 4 * 4 + 80 + 4;
      const arrayBuffer = new ArrayBuffer(bufferLength);
      modelOutput = new DataView(arrayBuffer);
      modelOutput.setUint32(offset2, this.faces.length, true);
      offset2 += 4;
      for (const [key, f] of Object.entries(this.faces)) {
        const norm = faceNormals[key];
        modelOutput.setFloat32(offset2, norm.x, true);
        offset2 += 4;
        modelOutput.setFloat32(offset2, norm.y, true);
        offset2 += 4;
        modelOutput.setFloat32(offset2, norm.z, true);
        offset2 += 4;
        for (let vertexIndex of f) {
          const vert = this.vertices[vertexIndex];
          modelOutput.setFloat32(offset2, vert.x, true);
          offset2 += 4;
          modelOutput.setFloat32(offset2, vert.y, true);
          offset2 += 4;
          modelOutput.setFloat32(offset2, vert.z, true);
          offset2 += 4;
        }
        modelOutput.setUint16(offset2, 0, true);
        offset2 += 2;
      }
    } else {
      modelOutput = "solid " + name + "\n";
      for (const [key, f] of Object.entries(this.faces)) {
        const norm = faceNormals[key];
        modelOutput += " facet norm " + norm.x + " " + norm.y + " " + norm.z + "\n";
        modelOutput += "  outer loop\n";
        for (let vertexIndex of f) {
          const vert = this.vertices[vertexIndex];
          modelOutput += "   vertex " + vert.x + " " + vert.y + " " + vert.z + "\n";
        }
        modelOutput += "  endloop\n";
        modelOutput += " endfacet\n";
      }
      modelOutput += "endsolid " + name + "\n";
    }
    const blob = new Blob([modelOutput], { type: "text/plain" });
    downloadFile(blob, fileName, "stl");
  }
  /**
   * Flips the geometry’s texture u-coordinates.
   *
   * In order for <a href="#/p5/texture">texture()</a> to work, the geometry
   * needs a way to map the points on its surface to the pixels in a rectangular
   * image that's used as a texture. The geometry's vertex at coordinates
   * `(x, y, z)` maps to the texture image's pixel at coordinates `(u, v)`.
   *
   * The <a href="#/p5.Geometry/uvs">myGeometry.uvs</a> array stores the
   * `(u, v)` coordinates for each vertex in the order it was added to the
   * geometry. Calling `myGeometry.flipU()` flips a geometry's u-coordinates
   * so that the texture appears mirrored horizontally.
   *
   * For example, a plane's four vertices are added clockwise starting from the
   * top-left corner. Here's how calling `myGeometry.flipU()` would change a
   * plane's texture coordinates:
   *
   * ```js
   * // Print the original texture coordinates.
   * // Output: [0, 0, 1, 0, 0, 1, 1, 1]
   * console.log(myGeometry.uvs);
   *
   * // Flip the u-coordinates.
   * myGeometry.flipU();
   *
   * // Print the flipped texture coordinates.
   * // Output: [1, 0, 0, 0, 1, 1, 0, 1]
   * console.log(myGeometry.uvs);
   *
   * // Notice the swaps:
   * // Top vertices: [0, 0, 1, 0] --> [1, 0, 0, 0]
   * // Bottom vertices: [0, 1, 1, 1] --> [1, 1, 0, 1]
   * ```
   *
   * @for p5.Geometry
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   img = await loadImage('assets/laDefense.jpg');
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Create p5.Geometry objects.
   *   let geom1 = buildGeometry(createShape);
   *   let geom2 = buildGeometry(createShape);
   *
   *   // Flip geom2's U texture coordinates.
   *   geom2.flipU();
   *
   *   // Left (original).
   *   push();
   *   translate(-25, 0, 0);
   *   texture(img);
   *   noStroke();
   *   model(geom1);
   *   pop();
   *
   *   // Right (flipped).
   *   push();
   *   translate(25, 0, 0);
   *   texture(img);
   *   noStroke();
   *   model(geom2);
   *   pop();
   *
   *   describe(
   *     'Two photos of a ceiling on a gray background. The photos are mirror images of each other.'
   *   );
   * }
   *
   * function createShape() {
   *   plane(40);
   * }
   * </code>
   * </div>
   */
  flipU() {
    this.uvs = this.uvs.flat().map((val2, index) => {
      if (index % 2 === 0) {
        return 1 - val2;
      } else {
        return val2;
      }
    });
  }
  /**
   * Flips the geometry’s texture v-coordinates.
   *
   * In order for <a href="#/p5/texture">texture()</a> to work, the geometry
   * needs a way to map the points on its surface to the pixels in a rectangular
   * image that's used as a texture. The geometry's vertex at coordinates
   * `(x, y, z)` maps to the texture image's pixel at coordinates `(u, v)`.
   *
   * The <a href="#/p5.Geometry/uvs">myGeometry.uvs</a> array stores the
   * `(u, v)` coordinates for each vertex in the order it was added to the
   * geometry. Calling `myGeometry.flipV()` flips a geometry's v-coordinates
   * so that the texture appears mirrored vertically.
   *
   * For example, a plane's four vertices are added clockwise starting from the
   * top-left corner. Here's how calling `myGeometry.flipV()` would change a
   * plane's texture coordinates:
   *
   * ```js
   * // Print the original texture coordinates.
   * // Output: [0, 0, 1, 0, 0, 1, 1, 1]
   * console.log(myGeometry.uvs);
   *
   * // Flip the v-coordinates.
   * myGeometry.flipV();
   *
   * // Print the flipped texture coordinates.
   * // Output: [0, 1, 1, 1, 0, 0, 1, 0]
   * console.log(myGeometry.uvs);
   *
   * // Notice the swaps:
   * // Left vertices: [0, 0] <--> [1, 0]
   * // Right vertices: [1, 0] <--> [1, 1]
   * ```
   *
   * @method flipV
   * @for p5.Geometry
   *
   * @example
   * <div>
   * <code>
   * let img;
   *
   * async function setup() {
   *   img = await loadImage('assets/laDefense.jpg');
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Create p5.Geometry objects.
   *   let geom1 = buildGeometry(createShape);
   *   let geom2 = buildGeometry(createShape);
   *
   *   // Flip geom2's V texture coordinates.
   *   geom2.flipV();
   *
   *   // Left (original).
   *   push();
   *   translate(-25, 0, 0);
   *   texture(img);
   *   noStroke();
   *   model(geom1);
   *   pop();
   *
   *   // Right (flipped).
   *   push();
   *   translate(25, 0, 0);
   *   texture(img);
   *   noStroke();
   *   model(geom2);
   *   pop();
   *
   *   describe(
   *     'Two photos of a ceiling on a gray background. The photos are mirror images of each other.'
   *   );
   * }
   *
   * function createShape() {
   *   plane(40);
   * }
   * </code>
   * </div>
   */
  flipV() {
    this.uvs = this.uvs.flat().map((val2, index) => {
      if (index % 2 === 0) {
        return val2;
      } else {
        return 1 - val2;
      }
    });
  }
  /**
   * Computes the geometry's faces using its vertices.
   *
   * All 3D shapes are made by connecting sets of points called *vertices*. A
   * geometry's surface is formed by connecting vertices to form triangles that
   * are stitched together. Each triangular patch on the geometry's surface is
   * called a *face*. `myGeometry.computeFaces()` performs the math needed to
   * define each face based on the distances between vertices.
   *
   * The geometry's vertices are stored as <a href="#/p5.Vector">p5.Vector</a>
   * objects in the <a href="#/p5.Geometry/vertices">myGeometry.vertices</a>
   * array. The geometry's first vertex is the
   * <a href="#/p5.Vector">p5.Vector</a> object at `myGeometry.vertices[0]`,
   * its second vertex is `myGeometry.vertices[1]`, its third vertex is
   * `myGeometry.vertices[2]`, and so on.
   *
   * Calling `myGeometry.computeFaces()` fills the
   * <a href="#/p5.Geometry/faces">myGeometry.faces</a> array with three-element
   * arrays that list the vertices that form each face. For example, a geometry
   * made from a rectangle has two faces because a rectangle is made by joining
   * two triangles. <a href="#/p5.Geometry/faces">myGeometry.faces</a> for a
   * rectangle would be the two-dimensional array
   * `[[0, 1, 2], [2, 1, 3]]`. The first face, `myGeometry.faces[0]`, is the
   * array `[0, 1, 2]` because it's formed by connecting
   * `myGeometry.vertices[0]`, `myGeometry.vertices[1]`,and
   * `myGeometry.vertices[2]`. The second face, `myGeometry.faces[1]`, is the
   * array `[2, 1, 3]` because it's formed by connecting
   * `myGeometry.vertices[2]`, `myGeometry.vertices[1]`, and
   * `myGeometry.vertices[3]`.
   *
   * Note: `myGeometry.computeFaces()` only works when geometries have four or more vertices.
   *
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = new p5.Geometry();
   *
   *   // Create p5.Vector objects to position the vertices.
   *   let v0 = createVector(-40, 0, 0);
   *   let v1 = createVector(0, -40, 0);
   *   let v2 = createVector(0, 40, 0);
   *   let v3 = createVector(40, 0, 0);
   *
   *   // Add the vertices to myGeometry's vertices array.
   *   myGeometry.vertices.push(v0, v1, v2, v3);
   *
   *   // Compute myGeometry's faces array.
   *   myGeometry.computeFaces();
   *
   *   describe('A red square drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Style the shape.
   *   noStroke();
   *   fill(255, 0, 0);
   *
   *   // Draw the p5.Geometry object.
   *   model(myGeometry);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object using a callback function.
   *   myGeometry = new p5.Geometry(1, 1, createShape);
   *
   *   describe('A red square drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Style the shape.
   *   noStroke();
   *   fill(255, 0, 0);
   *
   *   // Draw the p5.Geometry object.
   *   model(myGeometry);
   * }
   *
   * function createShape() {
   *   // Create p5.Vector objects to position the vertices.
   *   let v0 = createVector(-40, 0, 0);
   *   let v1 = createVector(0, -40, 0);
   *   let v2 = createVector(0, 40, 0);
   *   let v3 = createVector(40, 0, 0);
   *
   *   // Add the vertices to the p5.Geometry object's vertices array.
   *   this.vertices.push(v0, v1, v2, v3);
   *
   *   // Compute the faces array.
   *   this.computeFaces();
   * }
   * </code>
   * </div>
   */
  computeFaces() {
    this.faces.length = 0;
    const sliceCount = this.detailX + 1;
    let a2, b3, c4, d2;
    for (let i = 0; i < this.detailY; i++) {
      for (let j2 = 0; j2 < this.detailX; j2++) {
        a2 = i * sliceCount + j2;
        b3 = i * sliceCount + j2 + 1;
        c4 = (i + 1) * sliceCount + j2 + 1;
        d2 = (i + 1) * sliceCount + j2;
        this.faces.push([a2, b3, d2]);
        this.faces.push([d2, b3, c4]);
      }
    }
    return this;
  }
  _getFaceNormal(faceId) {
    const face = this.faces[faceId];
    const vA = this.vertices[face[0]];
    const vB = this.vertices[face[1]];
    const vC = this.vertices[face[2]];
    const ab = Vector.sub(vB, vA);
    const ac = Vector.sub(vC, vA);
    const n3 = Vector.cross(ab, ac);
    const ln = Vector.mag(n3);
    let sinAlpha = ln / (Vector.mag(ab) * Vector.mag(ac));
    if (sinAlpha === 0 || isNaN(sinAlpha)) {
      console.warn(
        "p5.Geometry.prototype._getFaceNormal:",
        "face has colinear sides or a repeated vertex"
      );
      return n3;
    }
    if (sinAlpha > 1) sinAlpha = 1;
    return n3.mult(Math.asin(sinAlpha) / ln);
  }
  /**
   * Calculates the normal vector for each vertex on the geometry.
   *
   * All 3D shapes are made by connecting sets of points called *vertices*. A
   * geometry's surface is formed by connecting vertices to create triangles
   * that are stitched together. Each triangular patch on the geometry's
   * surface is called a *face*. `myGeometry.computeNormals()` performs the
   * math needed to orient each face. Orientation is important for lighting
   * and other effects.
   *
   * A face's orientation is defined by its *normal vector* which points out
   * of the face and is normal (perpendicular) to the surface. Calling
   * `myGeometry.computeNormals()` first calculates each face's normal vector.
   * Then it calculates the normal vector for each vertex by averaging the
   * normal vectors of the faces surrounding the vertex. The vertex normals
   * are stored as <a href="#/p5.Vector">p5.Vector</a> objects in the
   * <a href="#/p5.Geometry/vertexNormals">myGeometry.vertexNormals</a> array.
   *
   * The first parameter, `shadingType`, is optional. Passing the constant
   * `FLAT`, as in `myGeometry.computeNormals(FLAT)`, provides neighboring
   * faces with their own copies of the vertices they share. Surfaces appear
   * tiled with flat shading. Passing the constant `SMOOTH`, as in
   * `myGeometry.computeNormals(SMOOTH)`, makes neighboring faces reuse their
   * shared vertices. Surfaces appear smoother with smooth shading. By
   * default, `shadingType` is `FLAT`.
   *
   * The second parameter, `options`, is also optional. If an object with a
   * `roundToPrecision` property is passed, as in
   * `myGeometry.computeNormals(SMOOTH, { roundToPrecision: 5 })`, it sets the
   * number of decimal places to use for calculations. By default,
   * `roundToPrecision` uses 3 decimal places.
   *
   * @param {(FLAT|SMOOTH)} [shadingType=FLAT] shading type. either FLAT or SMOOTH. Defaults to `FLAT`.
   * @param {Object} [options] shading options.
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = buildGeometry(function() {
   *     torus();
   *   });
   *
   *   // Compute the vertex normals.
   *   myGeometry.computeNormals();
   *
   *   describe(
   *     "A white torus drawn on a dark gray background. Red lines extend outward from the torus' vertices."
   *   );
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Rotate the coordinate system.
   *   rotateX(1);
   *
   *   // Style the helix.
   *   stroke(0);
   *
   *   // Display the helix.
   *   model(myGeometry);
   *
   *   // Style the normal vectors.
   *   stroke(255, 0, 0);
   *
   *   // Iterate over the vertices and vertexNormals arrays.
   *   for (let i = 0; i < myGeometry.vertices.length; i += 1) {
   *
   *     // Get the vertex p5.Vector object.
   *     let v = myGeometry.vertices[i];
   *
   *     // Get the vertex normal p5.Vector object.
   *     let n = myGeometry.vertexNormals[i];
   *
   *     // Calculate a point along the vertex normal.
   *     let p = p5.Vector.mult(n, 5);
   *
   *     // Draw the vertex normal as a red line.
   *     push();
   *     translate(v);
   *     line(0, 0, 0, p.x, p.y, p.z);
   *     pop();
   *   }
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object using a callback function.
   *   myGeometry = new p5.Geometry();
   *
   *   // Create p5.Vector objects to position the vertices.
   *   let v0 = createVector(-40, 0, 0);
   *   let v1 = createVector(0, -40, 0);
   *   let v2 = createVector(0, 40, 0);
   *   let v3 = createVector(40, 0, 0);
   *
   *   // Add the vertices to the p5.Geometry object's vertices array.
   *   myGeometry.vertices.push(v0, v1, v2, v3);
   *
   *   // Compute the faces array.
   *   myGeometry.computeFaces();
   *
   *   // Compute the surface normals.
   *   myGeometry.computeNormals();
   *
   *   describe('A red square drawn on a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Add a white point light.
   *   pointLight(255, 255, 255, 0, 0, 10);
   *
   *   // Style the p5.Geometry object.
   *   noStroke();
   *   fill(255, 0, 0);
   *
   *   // Draw the p5.Geometry object.
   *   model(myGeometry);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = buildGeometry(createShape);
   *
   *   // Compute normals using default (FLAT) shading.
   *   myGeometry.computeNormals(FLAT);
   *
   *   describe('A white, helical structure drawn on a dark gray background. Its faces appear faceted.');
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Rotate the coordinate system.
   *   rotateX(1);
   *
   *   // Style the helix.
   *   noStroke();
   *
   *   // Display the helix.
   *   model(myGeometry);
   * }
   *
   * function createShape() {
   *   // Create a helical shape.
   *   beginShape();
   *   for (let i = 0; i < TWO_PI * 3; i += 0.5) {
   *     let x = 30 * cos(i);
   *     let y = 30 * sin(i);
   *     let z = map(i, 0, TWO_PI * 3, -40, 40);
   *     vertex(x, y, z);
   *   }
   *   endShape();
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = buildGeometry(createShape);
   *
   *   // Compute normals using smooth shading.
   *   myGeometry.computeNormals(SMOOTH);
   *
   *   describe('A white, helical structure drawn on a dark gray background.');
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Rotate the coordinate system.
   *   rotateX(1);
   *
   *   // Style the helix.
   *   noStroke();
   *
   *   // Display the helix.
   *   model(myGeometry);
   * }
   *
   * function createShape() {
   *   // Create a helical shape.
   *   beginShape();
   *   for (let i = 0; i < TWO_PI * 3; i += 0.5) {
   *     let x = 30 * cos(i);
   *     let y = 30 * sin(i);
   *     let z = map(i, 0, TWO_PI * 3, -40, 40);
   *     vertex(x, y, z);
   *   }
   *   endShape();
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and drag the mouse to view the scene from different angles.
   *
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Geometry object.
   *   myGeometry = buildGeometry(createShape);
   *
   *   // Create an options object.
   *   let options = { roundToPrecision: 5 };
   *
   *   // Compute normals using smooth shading.
   *   myGeometry.computeNormals(SMOOTH, options);
   *
   *   describe('A white, helical structure drawn on a dark gray background.');
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Enable orbiting with the mouse.
   *   orbitControl();
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Rotate the coordinate system.
   *   rotateX(1);
   *
   *   // Style the helix.
   *   noStroke();
   *
   *   // Display the helix.
   *   model(myGeometry);
   * }
   *
   * function createShape() {
   *   // Create a helical shape.
   *   beginShape();
   *   for (let i = 0; i < TWO_PI * 3; i += 0.5) {
   *     let x = 30 * cos(i);
   *     let y = 30 * sin(i);
   *     let z = map(i, 0, TWO_PI * 3, -40, 40);
   *     vertex(x, y, z);
   *   }
   *   endShape();
   * }
   * </code>
   * </div>
   */
  computeNormals(shadingType = FLAT, { roundToPrecision = 3 } = {}) {
    const vertexNormals = this.vertexNormals;
    let vertices = this.vertices;
    const faces = this.faces;
    let iv;
    if (shadingType === SMOOTH) {
      const vertexIndices = {};
      const uniqueVertices = [];
      const power = Math.pow(10, roundToPrecision);
      const rounded = (val2) => Math.round(val2 * power) / power;
      const getKey = (vert) => `${rounded(vert.x)},${rounded(vert.y)},${rounded(vert.z)}`;
      for (let i = 0; i < vertices.length; i++) {
        const vertex2 = vertices[i];
        const key = getKey(vertex2);
        if (vertexIndices[key] === void 0) {
          vertexIndices[key] = uniqueVertices.length;
          uniqueVertices.push(vertex2);
        }
      }
      faces.forEach((face) => {
        for (let fv = 0; fv < 3; ++fv) {
          const originalVertexIndex = face[fv];
          const originalVertex = vertices[originalVertexIndex];
          const key = getKey(originalVertex);
          face[fv] = vertexIndices[key];
        }
      });
      this.edges.forEach((edge) => {
        for (let ev = 0; ev < 2; ++ev) {
          const originalVertexIndex = edge[ev];
          const originalVertex = vertices[originalVertexIndex];
          const key = getKey(originalVertex);
          edge[ev] = vertexIndices[key];
        }
      });
      this.vertices = vertices = uniqueVertices;
    }
    vertexNormals.length = 0;
    for (iv = 0; iv < vertices.length; ++iv) {
      vertexNormals.push(new Vector());
    }
    faces.forEach((face, f) => {
      const faceNormal = this._getFaceNormal(f);
      for (let fv = 0; fv < 3; ++fv) {
        const vertexIndex = face[fv];
        vertexNormals[vertexIndex].add(faceNormal);
      }
    });
    for (iv = 0; iv < vertices.length; ++iv) {
      vertexNormals[iv].normalize();
    }
    return this;
  }
  /**
   * Averages the vertex normals. Used in curved
   * surfaces
   * @private
   * @chainable
   */
  averageNormals() {
    for (let i = 0; i <= this.detailY; i++) {
      const offset2 = this.detailX + 1;
      let temp = Vector.add(
        this.vertexNormals[i * offset2],
        this.vertexNormals[i * offset2 + this.detailX]
      );
      temp = Vector.div(temp, 2);
      this.vertexNormals[i * offset2] = temp;
      this.vertexNormals[i * offset2 + this.detailX] = temp;
    }
    return this;
  }
  /**
   * Averages pole normals.  Used in spherical primitives
   * @private
   * @chainable
   */
  averagePoleNormals() {
    let sum = new Vector(0, 0, 0);
    for (let i = 0; i < this.detailX; i++) {
      sum.add(this.vertexNormals[i]);
    }
    sum = Vector.div(sum, this.detailX);
    for (let i = 0; i < this.detailX; i++) {
      this.vertexNormals[i] = sum;
    }
    sum = new Vector(0, 0, 0);
    for (let i = this.vertices.length - 1; i > this.vertices.length - 1 - this.detailX; i--) {
      sum.add(this.vertexNormals[i]);
    }
    sum = Vector.div(sum, this.detailX);
    for (let i = this.vertices.length - 1; i > this.vertices.length - 1 - this.detailX; i--) {
      this.vertexNormals[i] = sum;
    }
    return this;
  }
  /**
   * Create a 2D array for establishing stroke connections
   * @private
   * @chainable
   */
  _makeTriangleEdges() {
    this.edges.length = 0;
    for (let j2 = 0; j2 < this.faces.length; j2++) {
      this.edges.push([this.faces[j2][0], this.faces[j2][1]]);
      this.edges.push([this.faces[j2][1], this.faces[j2][2]]);
      this.edges.push([this.faces[j2][2], this.faces[j2][0]]);
    }
    return this;
  }
  /**
   * @example
   * <div>
   * <code>
   * let tetrahedron;
   * function setup() {
   *   createCanvas(200, 200, WEBGL);
   *   describe('A rotating tetrahedron');
   *
   *   tetrahedron = new p5.Geometry();
   *
   *   // Give each geometry a unique gid
   *   tetrahedron.gid = 'tetrahedron';
   *
   *   // Add four points of the tetrahedron
   *
   *   let radius = 50;
   *   // A 2D triangle:
   *   tetrahedron.vertices.push(createVector(radius, 0, 0));
   *   tetrahedron.vertices.push(createVector(radius, 0, 0).rotate(TWO_PI / 3));
   *   tetrahedron.vertices.push(createVector(radius, 0, 0).rotate(TWO_PI * 2 / 3));
   *   // Add a tip in the z axis:
   *   tetrahedron.vertices.push(createVector(0, 0, radius));
   *
   *   // Create the four faces by connecting the sets of three points
   *   tetrahedron.faces.push([0, 1, 2]);
   *   tetrahedron.faces.push([0, 1, 3]);
   *   tetrahedron.faces.push([0, 2, 3]);
   *   tetrahedron.faces.push([1, 2, 3]);
   *   tetrahedron.makeEdgesFromFaces();
   * }
   * function draw() {
   *   background(200);
   *   strokeWeight(2);
   *   orbitControl();
   *   rotateY(millis() * 0.001);
   *   model(tetrahedron);
   * }
   * </code>
   * </div>
   */
  makeEdgesFromFaces() {
    this._makeTriangleEdges();
  }
  /**
   * Converts each line segment into the vertices and vertex attributes needed
   * to turn the line into a polygon on screen. This will include:
   * - Two triangles line segment to create a rectangle
   * - Two triangles per endpoint to create a stroke cap rectangle. A fragment
   *   shader is responsible for displaying the appropriate cap style within
   *   that rectangle.
   * - Four triangles per join between adjacent line segments, creating a quad on
   *   either side of the join, perpendicular to the lines. A vertex shader will
   *   discard the quad in the "elbow" of the join, and a fragment shader will
   *   display the appropriate join style within the remaining quad.
   *
   * @private
   * @chainable
   */
  _edgesToVertices() {
    var _a2;
    this.lineVertices.clear();
    this.lineTangentsIn.clear();
    this.lineTangentsOut.clear();
    this.lineSides.clear();
    const potentialCaps = /* @__PURE__ */ new Map();
    const connected = /* @__PURE__ */ new Set();
    let lastValidDir;
    for (let i = 0; i < this.edges.length; i++) {
      const prevEdge = this.edges[i - 1];
      const currEdge = this.edges[i];
      const begin = this.vertices[currEdge[0]];
      const end = this.vertices[currEdge[1]];
      const prevColor = this.vertexStrokeColors.length > 0 && prevEdge ? this.vertexStrokeColors.slice(
        prevEdge[1] * 4,
        (prevEdge[1] + 1) * 4
      ) : [0, 0, 0, 0];
      const fromColor = this.vertexStrokeColors.length > 0 ? this.vertexStrokeColors.slice(
        currEdge[0] * 4,
        (currEdge[0] + 1) * 4
      ) : [0, 0, 0, 0];
      const toColor = this.vertexStrokeColors.length > 0 ? this.vertexStrokeColors.slice(
        currEdge[1] * 4,
        (currEdge[1] + 1) * 4
      ) : [0, 0, 0, 0];
      const dir = end.copy().sub(begin).normalize();
      const dirOK = dir.magSq() > 0;
      if (dirOK) {
        this._addSegment(begin, end, fromColor, toColor, dir);
      }
      if (!((_a2 = this.renderer) == null ? void 0 : _a2._simpleLines)) {
        if (i > 0 && prevEdge[1] === currEdge[0]) {
          if (!connected.has(currEdge[0])) {
            connected.add(currEdge[0]);
            potentialCaps.delete(currEdge[0]);
            if (lastValidDir && dirOK && dir.dot(lastValidDir) < 1 - 1e-8) {
              this._addJoin(begin, lastValidDir, dir, fromColor);
            }
          }
        } else {
          if (dirOK && !connected.has(currEdge[0])) {
            const existingCap = potentialCaps.get(currEdge[0]);
            if (existingCap) {
              this._addJoin(
                begin,
                existingCap.dir,
                dir,
                fromColor
              );
              potentialCaps.delete(currEdge[0]);
              connected.add(currEdge[0]);
            } else {
              potentialCaps.set(currEdge[0], {
                point: begin,
                dir: dir.copy().mult(-1),
                color: fromColor
              });
            }
          }
          if (lastValidDir && !connected.has(prevEdge[1])) {
            const existingCap = potentialCaps.get(prevEdge[1]);
            if (existingCap) {
              this._addJoin(
                this.vertices[prevEdge[1]],
                lastValidDir,
                existingCap.dir.copy().mult(-1),
                prevColor
              );
              potentialCaps.delete(prevEdge[1]);
              connected.add(prevEdge[1]);
            } else {
              potentialCaps.set(prevEdge[1], {
                point: this.vertices[prevEdge[1]],
                dir: lastValidDir,
                color: prevColor
              });
            }
            lastValidDir = void 0;
          }
        }
        if (i === this.edges.length - 1 && !connected.has(currEdge[1])) {
          const existingCap = potentialCaps.get(currEdge[1]);
          if (existingCap) {
            this._addJoin(
              end,
              dir,
              existingCap.dir.copy().mult(-1),
              toColor
            );
            potentialCaps.delete(currEdge[1]);
            connected.add(currEdge[1]);
          } else {
            potentialCaps.set(currEdge[1], {
              point: end,
              dir,
              color: toColor
            });
          }
        }
        if (dirOK) {
          lastValidDir = dir;
        }
      }
    }
    for (const { point, dir, color: color3 } of potentialCaps.values()) {
      this._addCap(point, dir, color3);
    }
    return this;
  }
  /**
   * Adds the vertices and vertex attributes for two triangles making a rectangle
   * for a straight line segment. A vertex shader is responsible for picking
   * proper coordinates on the screen given the centerline positions, the tangent,
   * and the side of the centerline each vertex belongs to. Sides follow the
   * following scheme:
   *
   *  -1            -1
   *   o-------------o
   *   |             |
   *   o-------------o
   *   1             1
   *
   * @private
   * @chainable
   */
  _addSegment(begin, end, fromColor, toColor, dir) {
    var _a2;
    const a2 = begin.array();
    const b3 = end.array();
    const dirArr = dir.array();
    this.lineSides.push(1, 1, -1, 1, -1, -1);
    for (const tangents of [this.lineTangentsIn, this.lineTangentsOut]) {
      for (let i = 0; i < 6; i++) {
        tangents.push(...dirArr);
      }
    }
    this.lineVertices.push(...a2, ...b3, ...a2, ...b3, ...b3, ...a2);
    if (!((_a2 = this.renderer) == null ? void 0 : _a2._simpleLines)) {
      this.lineVertexColors.push(
        ...fromColor,
        ...toColor,
        ...fromColor,
        ...toColor,
        ...toColor,
        ...fromColor
      );
    }
    return this;
  }
  /**
   * Adds the vertices and vertex attributes for two triangles representing the
   * stroke cap of a line. A fragment shader is responsible for displaying the
   * appropriate cap style within the rectangle they make.
   *
   * The lineSides buffer will include the following values for the points on
   * the cap rectangle:
   *
   *           -1  -2
   * -----------o---o
   *            |   |
   * -----------o---o
   *            1   2
   * @private
   * @chainable
   */
  _addCap(point, tangent, color3) {
    const ptArray = point.array();
    const tanInArray = tangent.array();
    const tanOutArray = [0, 0, 0];
    for (let i = 0; i < 6; i++) {
      this.lineVertices.push(...ptArray);
      this.lineTangentsIn.push(...tanInArray);
      this.lineTangentsOut.push(...tanOutArray);
      this.lineVertexColors.push(...color3);
    }
    this.lineSides.push(-1, 2, -2, 1, 2, -1);
    return this;
  }
  /**
   * Adds the vertices and vertex attributes for four triangles representing a
   * join between two adjacent line segments. This creates a quad on either side
   * of the shared vertex of the two line segments, with each quad perpendicular
   * to the lines. A vertex shader will discard all but the quad in the "elbow" of
   * the join, and a fragment shader will display the appropriate join style
   * within the remaining quad.
   *
   * The lineSides buffer will include the following values for the points on
   * the join rectangles:
   *
   *            -1     -2
   * -------------o----o
   *              |    |
   *       1 o----o----o -3
   *         |    | 0  |
   * --------o----o    |
   *        2|    3    |
   *         |         |
   *         |         |
   * @private
   * @chainable
   */
  _addJoin(point, fromTangent, toTangent, color3) {
    const ptArray = point.array();
    const tanInArray = fromTangent.array();
    const tanOutArray = toTangent.array();
    for (let i = 0; i < 12; i++) {
      this.lineVertices.push(...ptArray);
      this.lineTangentsIn.push(...tanInArray);
      this.lineTangentsOut.push(...tanOutArray);
      this.lineVertexColors.push(...color3);
    }
    this.lineSides.push(-1, -3, -2, -1, 0, -3);
    this.lineSides.push(3, 1, 2, 3, 0, 1);
    return this;
  }
  /**
   * Transforms the geometry's vertices to fit snugly within a 100×100×100 box
   * centered at the origin.
   *
   * Calling `myGeometry.normalize()` translates the geometry's vertices so that
   * they're centered at the origin `(0, 0, 0)`. Then it scales the vertices so
   * that they fill a 100×100×100 box. As a result, small geometries will grow
   * and large geometries will shrink.
   *
   * Note: `myGeometry.normalize()` only works when called in the
   * <a href="#/p5/setup">setup()</a> function.
   *
   * @chainable
   *
   * @example
   * <div>
   * <code>
   * let myGeometry;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a very small torus.
   *   myGeometry = buildGeometry(function() {;
   *     torus(1, 0.25);
   *   });
   *
   *   // Normalize the torus so its vertices fill
   *   // the range [-100, 100].
   *   myGeometry.normalize();
   *
   *   describe('A white torus rotates slowly against a dark gray background.');
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Turn on the lights.
   *   lights();
   *
   *   // Rotate around the y-axis.
   *   rotateY(frameCount * 0.01);
   *
   *   // Style the torus.
   *   noStroke();
   *
   *   // Draw the torus.
   *   model(myGeometry);
   * }
   * </code>
   * </div>
   */
  normalize() {
    if (this.vertices.length > 0) {
      const maxPosition = this.vertices[0].copy();
      const minPosition = this.vertices[0].copy();
      for (let i = 0; i < this.vertices.length; i++) {
        maxPosition.x = Math.max(maxPosition.x, this.vertices[i].x);
        minPosition.x = Math.min(minPosition.x, this.vertices[i].x);
        maxPosition.y = Math.max(maxPosition.y, this.vertices[i].y);
        minPosition.y = Math.min(minPosition.y, this.vertices[i].y);
        maxPosition.z = Math.max(maxPosition.z, this.vertices[i].z);
        minPosition.z = Math.min(minPosition.z, this.vertices[i].z);
      }
      const center = Vector.lerp(maxPosition, minPosition, 0.5);
      const dist = Vector.sub(maxPosition, minPosition);
      const longestDist = Math.max(Math.max(dist.x, dist.y), dist.z);
      const scale2 = 200 / longestDist;
      for (let i = 0; i < this.vertices.length; i++) {
        this.vertices[i].sub(center);
        this.vertices[i].mult(scale2);
      }
    }
    return this;
  }
  /** Sets the shader's vertex property or attribute variables.
   *
   * A vertex property, or vertex attribute, is a variable belonging to a vertex in a shader. p5.js provides some
   * default properties, such as `aPosition`, `aNormal`, `aVertexColor`, etc. These are
   * set using <a href="#/p5/vertex">vertex()</a>, <a href="#/p5/normal">normal()</a>
   * and <a href="#/p5/fill">fill()</a> respectively. Custom properties can also
   * be defined within <a href="#/p5/beginShape">beginShape()</a> and
   * <a href="#/p5/endShape">endShape()</a>.
   *
   * The first parameter, `propertyName`, is a string with the property's name.
   * This is the same variable name which should be declared in the shader, as in
   * `in vec3 aProperty`, similar to .`setUniform()`.
   *
   * The second parameter, `data`, is the value assigned to the shader variable. This value
   * will be pushed directly onto the Geometry object. There should be the same number
   * of custom property values as vertices, this method should be invoked once for each
   * vertex.
   *
   * The `data` can be a Number or an array of numbers. Tn the shader program the type
   * can be declared according to the WebGL specification. Common types include `float`,
   * `vec2`, `vec3`, `vec4` or matrices.
   *
   * See also the global <a href="#/p5/vertexProperty">vertexProperty()</a> function.
   *
   * @example
   * <div>
   * <code>
   * let geo;
   *
   * function cartesianToSpherical(x, y, z) {
   *   let r = sqrt(pow(x, 2) + pow(y, 2) + pow(z, 2));
   *   let theta = acos(z / r);
   *   let phi = atan2(y, x);
   *   return { theta, phi };
   * }
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Modify the material shader to display roughness.
   *   const myShader = baseMaterialShader().modify({
   *     vertexDeclarations:`in float aRoughness;
   *                         out float vRoughness;`,
   *     fragmentDeclarations: 'in float vRoughness;',
   *     'void afterVertex': `() {
   *         vRoughness = aRoughness;
   *     }`,
   *     'vec4 combineColors': `(ColorComponents components) {
   *             vec4 color = vec4(0.);
   *             color.rgb += components.diffuse * components.baseColor * (1.0-vRoughness);
   *             color.rgb += components.ambient * components.ambientColor;
   *             color.rgb += components.specular * components.specularColor * (1.0-vRoughness);
   *             color.a = components.opacity;
   *             return color;
   *     }`
   *   });
   *
   *   // Create the Geometry object.
   *   geo = buildGeometry(function() {
   *     fill('hotpink');
   *     sphere(45, 50, 50);
   *   });
   *
   *   // Set the roughness value for every vertex.
   *   for (let v of geo.vertices){
   *
   *     // convert coordinates to spherical coordinates
   *     let spherical = cartesianToSpherical(v.x, v.y, v.z);
   *
   *     // Set the custom roughness vertex property.
   *     let roughness = noise(spherical.theta*5, spherical.phi*5);
   *     geo.vertexProperty('aRoughness', roughness);
   *   }
   *
   *   // Use the custom shader.
   *   shader(myShader);
   *
   *   describe('A rough pink sphere rotating on a blue background.');
   * }
   *
   * function draw() {
   *   // Set some styles and lighting
   *   background('lightblue');
   *   noStroke();
   *
   *   specularMaterial(255,125,100);
   *   shininess(2);
   *
   *   directionalLight('white', -1, 1, -1);
   *   ambientLight(320);
   *
   *   rotateY(millis()*0.001);
   *
   *   // Draw the geometry
   *   model(geo);
   * }
   * </code>
   * </div>
   *
   * @param {String} propertyName the name of the vertex property.
   * @param {Number|Number[]} data the data tied to the vertex property.
   * @param {Number} [size] optional size of each unit of data.
   */
  vertexProperty(propertyName, data3, size) {
    let prop;
    if (!this.userVertexProperties[propertyName]) {
      prop = this.userVertexProperties[propertyName] = this._userVertexPropertyHelper(propertyName, data3, size);
    }
    prop = this.userVertexProperties[propertyName];
    if (size) {
      prop.pushDirect(data3);
    } else {
      prop.setCurrentData(data3);
      prop.pushCurrentData();
    }
  }
  _userVertexPropertyHelper(propertyName, data3, size) {
    const geometryInstance = this;
    const prop = this.userVertexProperties[propertyName] = {
      name: propertyName,
      dataSize: size ? size : data3.length ? data3.length : 1,
      geometry: geometryInstance,
      // Getters
      getName() {
        return this.name;
      },
      getCurrentData() {
        if (this.currentData === void 0) {
          this.currentData = new Array(this.getDataSize()).fill(0);
        }
        return this.currentData;
      },
      getDataSize() {
        return this.dataSize;
      },
      getSrcName() {
        const src = this.name.concat("Src");
        return src;
      },
      getDstName() {
        const dst = this.name.concat("Buffer");
        return dst;
      },
      getSrcArray() {
        const srcName = this.getSrcName();
        return this.geometry[srcName];
      },
      //Setters
      setCurrentData(data4) {
        data4.length ? data4.length : 1;
        this.currentData = data4;
      },
      // Utilities
      pushCurrentData() {
        const data4 = this.getCurrentData();
        this.pushDirect(data4);
      },
      pushDirect(data4) {
        if (data4.length) {
          this.getSrcArray().push(...data4);
        } else {
          this.getSrcArray().push(data4);
        }
      },
      resetSrcArray() {
        this.geometry[this.getSrcName()] = [];
      },
      delete() {
        const srcName = this.getSrcName();
        delete this.geometry[srcName];
        delete this;
      }
    };
    this[prop.getSrcName()] = [];
    return this.userVertexProperties[propertyName];
  }
};
Geometry.nextId = 0;
function geometry(p53, fn2) {
  p53.Geometry = Geometry;
}
if (typeof p5 !== "undefined") {
  geometry(p5, p5.prototype);
}

// node_modules/p5/dist/webgl/GeometryBuilder.js
var import_file_saver2 = __toESM(require_FileSaver());
var GeometryBuilder = class _GeometryBuilder {
  constructor(renderer2) {
    this.renderer = renderer2;
    renderer2._pInst.push();
    this.identityMatrix = new Matrix(4);
    renderer2.states.setValue("uModelMatrix", new Matrix(4));
    this.geometry = new Geometry(void 0, void 0, void 0, this.renderer);
    this.geometry.gid = `_p5_GeometryBuilder_${_GeometryBuilder.nextGeometryId}`;
    _GeometryBuilder.nextGeometryId++;
    this.hasTransform = false;
  }
  /**
   * @private
   * Applies the current transformation matrix to each vertex.
   */
  transformVertices(vertices) {
    if (!this.hasTransform) return vertices;
    return vertices.map((v) => this.renderer.states.uModelMatrix.multiplyPoint(v));
  }
  /**
   * @private
   * Applies the current normal matrix to each normal.
   */
  transformNormals(normals) {
    if (!this.hasTransform) return normals;
    return normals.map(
      (v) => this.renderer.scratchMat3.multiplyVec(v)
      // this is a vec3
    );
  }
  /**
   * @private
   * Adds a p5.Geometry to the builder's combined geometry, flattening
   * transformations.
   */
  addGeometry(input) {
    this.hasTransform = !this.renderer.states.uModelMatrix.mat4.every((v, i) => v === this.identityMatrix.mat4[i]);
    if (this.hasTransform) {
      this.renderer.scratchMat3.inverseTranspose4x4(this.renderer.states.uModelMatrix);
    }
    let startIdx = this.geometry.vertices.length;
    this.geometry.vertices.push(...this.transformVertices(input.vertices));
    this.geometry.vertexNormals.push(
      ...this.transformNormals(input.vertexNormals)
    );
    this.geometry.uvs.push(...input.uvs);
    const inputUserVertexProps = input.userVertexProperties;
    const builtUserVertexProps = this.geometry.userVertexProperties;
    const numPreviousVertices = this.geometry.vertices.length - input.vertices.length;
    for (const propName in builtUserVertexProps) {
      if (propName in inputUserVertexProps) {
        continue;
      }
      const prop = builtUserVertexProps[propName];
      const size = prop.getDataSize();
      const numMissingValues = size * input.vertices.length;
      const missingValues = Array(numMissingValues).fill(0);
      prop.pushDirect(missingValues);
    }
    for (const propName in inputUserVertexProps) {
      const prop = inputUserVertexProps[propName];
      const data3 = prop.getSrcArray();
      const size = prop.getDataSize();
      if (numPreviousVertices > 0 && !(propName in builtUserVertexProps)) {
        const numMissingValues = size * numPreviousVertices;
        const missingValues = Array(numMissingValues).fill(0);
        this.geometry.vertexProperty(propName, missingValues, size);
      }
      this.geometry.vertexProperty(propName, data3, size);
    }
    if (this.renderer.states.fillColor) {
      this.geometry.faces.push(
        ...input.faces.map((f) => f.map((idx) => idx + startIdx))
      );
    }
    if (this.renderer.states.strokeColor) {
      this.geometry.edges.push(
        ...input.edges.map((edge) => edge.map((idx) => idx + startIdx))
      );
    }
    const vertexColors = [...input.vertexColors];
    while (vertexColors.length < input.vertices.length * 4) {
      vertexColors.push(...this.renderer.states.curFillColor);
    }
    this.geometry.vertexColors.push(...vertexColors);
  }
  /**
   * Adds geometry from the renderer's immediate mode into the builder's
   * combined geometry.
   */
  addImmediate(geometry2, shapeMode, { validateFaces = false } = {}) {
    const faces = [];
    if (this.renderer.states.fillColor) {
      if (shapeMode === TRIANGLE_STRIP || shapeMode === QUAD_STRIP) {
        for (let i = 2; i < geometry2.vertices.length; i++) {
          if (i % 2 === 0) {
            faces.push([i, i - 1, i - 2]);
          } else {
            faces.push([i, i - 2, i - 1]);
          }
        }
      } else if (shapeMode === TRIANGLE_FAN) {
        for (let i = 2; i < geometry2.vertices.length; i++) {
          faces.push([0, i - 1, i]);
        }
      } else {
        for (let i = 0; i < geometry2.vertices.length; i += 3) {
          if (!validateFaces || geometry2.vertices[i].copy().sub(geometry2.vertices[i + 1]).cross(geometry2.vertices[i].copy().sub(geometry2.vertices[i + 2])).magSq() > 0) {
            faces.push([i, i + 1, i + 2]);
          }
        }
      }
    }
    this.addGeometry(Object.assign({}, geometry2, { faces }));
  }
  /**
   * Adds geometry from the renderer's retained mode into the builder's
   * combined geometry.
   */
  addRetained(geometry2) {
    this.addGeometry(geometry2);
  }
  /**
   * Cleans up the state of the renderer and returns the combined geometry that
   * was built.
   * @returns p5.Geometry The flattened, combined geometry
   */
  finish() {
    this.renderer._pInst.pop();
    return this.geometry;
  }
};
GeometryBuilder.nextGeometryId = 0;

// node_modules/p5/dist/webgl/p5.Quat.js
var Quat = class _Quat {
  constructor(w, x, y, z) {
    this.w = w;
    this.vec = new Vector(x, y, z);
  }
  /**
     * Returns a Quaternion for the
     * axis angle representation of the rotation
     *
     * @method fromAxisAngle
     * @param {Number} [angle] Angle with which the points needs to be rotated
     * @param {Number} [x] x component of the axis vector
     * @param {Number} [y] y component of the axis vector
     * @param {Number} [z] z component of the axis vector
     * @chainable
    */
  static fromAxisAngle(angle, x, y, z) {
    const w = Math.cos(angle / 2);
    const vec = new Vector(x, y, z).normalize().mult(Math.sin(angle / 2));
    return new _Quat(w, vec.x, vec.y, vec.z);
  }
  conjugate() {
    return new _Quat(this.w, -this.vec.x, -this.vec.y, -this.vec.z);
  }
  /**
     * Multiplies a quaternion with other quaternion.
     * @method mult
     * @param  {p5.Quat} [quat] quaternion to multiply with the quaternion calling the method.
     * @chainable
     */
  multiply(quat2) {
    return new _Quat(
      this.w * quat2.w - this.vec.x * quat2.vec.x - this.vec.y * quat2.vec.y - this.vec.z - quat2.vec.z,
      this.w * quat2.vec.x + this.vec.x * quat2.w + this.vec.y * quat2.vec.z - this.vec.z * quat2.vec.y,
      this.w * quat2.vec.y - this.vec.x * quat2.vec.z + this.vec.y * quat2.w + this.vec.z * quat2.vec.x,
      this.w * quat2.vec.z + this.vec.x * quat2.vec.y - this.vec.y * quat2.vec.x + this.vec.z * quat2.w
    );
  }
  /**
   * This is similar to quaternion multiplication
   * but when multipying vector with quaternion
   * the multiplication can be simplified to the below formula.
   * This was taken from the below stackexchange link
   * https://gamedev.stackexchange.com/questions/28395/rotating-vector3-by-a-quaternion/50545#50545
   * @param {p5.Vector} [p] vector to rotate on the axis quaternion
   */
  rotateVector(p2) {
    return Vector.mult(p2, this.w * this.w - this.vec.dot(this.vec)).add(Vector.mult(this.vec, 2 * p2.dot(this.vec))).add(Vector.mult(this.vec, 2 * this.w).cross(p2)).clampToZero();
  }
  /**
     * Rotates the Quaternion by the quaternion passed
     * which contains the axis of roation and angle of rotation
     *
     * @method rotateBy
     * @param {p5.Quat} [axesQuat] axis quaternion which contains
     *  the axis of rotation and angle of rotation
     * @chainable
     */
  rotateBy(axesQuat) {
    return axesQuat.multiply(this).multiply(axesQuat.conjugate()).vec.clampToZero();
  }
};
function quat(p53, fn2) {
  p53.Quat = Quat;
}
if (typeof p5 !== "undefined") {
  quat(p5, p5.prototype);
}

// node_modules/p5/dist/webgl/p5.RenderBuffer.js
var RenderBuffer = class {
  constructor(size, src, dst, attr, renderer2, map3) {
    this.size = size;
    this.src = src;
    this.dst = dst;
    this.attr = attr;
    this._renderer = renderer2;
    this.map = map3;
  }
  /**
   * Enables and binds the buffers used by shader when the appropriate data exists in geometry.
   * Must always be done prior to drawing geometry in WebGL.
   * @param {p5.Geometry} geometry Geometry that is going to be drawn
   * @param {p5.Shader} shader Active shader
   * @private
   */
  _prepareBuffer(geometry2, shader2) {
    const attributes2 = shader2.attributes;
    const gl = this._renderer.GL;
    const glBuffers = this._renderer._getOrMakeCachedBuffers(geometry2);
    const attr = attributes2[this.attr];
    if (!attr) {
      return;
    }
    let buffer = glBuffers[this.dst];
    const src = geometry2[this.src];
    if (src && src.length > 0) {
      const createBuffer = !buffer;
      if (createBuffer) {
        glBuffers[this.dst] = buffer = gl.createBuffer();
      }
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
      if (createBuffer || geometry2.dirtyFlags[this.src] !== false) {
        const map3 = this.map;
        const values = map3 ? map3(src) : src;
        this._renderer._bindBuffer(buffer, gl.ARRAY_BUFFER, values);
        geometry2.dirtyFlags[this.src] = false;
      }
      shader2.enableAttrib(attr, this.size);
    } else {
      const loc = attr.location;
      if (loc === -1 || !this._renderer.registerEnabled.has(loc)) {
        return;
      }
      gl.disableVertexAttribArray(loc);
      this._renderer.registerEnabled.delete(loc);
    }
  }
};
function renderBuffer(p53, fn2) {
  p53.RenderBuffer = RenderBuffer;
}
if (typeof p5 !== "undefined") {
  renderBuffer(p5, p5.prototype);
}

// node_modules/p5/dist/webgl/ShapeBuilder.js
var import_libtess = __toESM(require_libtess_min());
var import_file_saver3 = __toESM(require_FileSaver());
var INITIAL_BUFFER_STRIDES = {
  vertices: 1,
  vertexNormals: 1,
  vertexColors: 4,
  vertexStrokeColors: 4,
  uvs: 2
};
var INITIAL_VERTEX_SIZE = Object.values(INITIAL_BUFFER_STRIDES).reduce((acc, next) => acc + next);
var ShapeBuilder = class {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.shapeMode = PATH;
    this.geometry = new Geometry(void 0, void 0, void 0, this.renderer);
    this.geometry.gid = "__IMMEDIATE_MODE_GEOMETRY__";
    this.contourIndices = [];
    this._useUserVertexProperties = void 0;
    this._bezierVertex = [];
    this._quadraticVertex = [];
    this._curveVertex = [];
    this.isProcessingVertices = false;
    this._tessy = this._initTessy();
    this.tessyVertexSize = INITIAL_VERTEX_SIZE;
    this.bufferStrides = { ...INITIAL_BUFFER_STRIDES };
  }
  constructFromContours(shape2, contours) {
    if (this._useUserVertexProperties) {
      this._resetUserVertexProperties();
    }
    this.geometry.reset();
    this.contourIndices = [];
    this.shapeMode = shape2.contours[0].kind;
    const shouldProcessEdges = !!this.renderer.states.strokeColor;
    const userVertexPropertyHelpers = {};
    if (shape2.userVertexProperties) {
      this._useUserVertexProperties = true;
      for (const key in shape2.userVertexProperties) {
        const name = shape2.vertexPropertyName(key);
        const prop = this.geometry._userVertexPropertyHelper(name, [], shape2.userVertexProperties[key]);
        userVertexPropertyHelpers[key] = prop;
        this.tessyVertexSize += prop.getDataSize();
        this.bufferStrides[prop.getSrcName()] = prop.getDataSize();
        this.renderer.buffers.user.push(
          new RenderBuffer(prop.getDataSize(), prop.getSrcName(), prop.getDstName(), name, this.renderer)
        );
      }
    } else {
      this._useUserVertexProperties = false;
    }
    for (const contour of contours) {
      this.contourIndices.push(this.geometry.vertices.length);
      for (const vertex2 of contour) {
        if (this.shapeMode === QUADS) {
          if (this.geometry.vertices.length % 6 === 3) {
            for (const key in this.bufferStrides) {
              const stride = this.bufferStrides[key];
              const buffer = this.geometry[key];
              buffer.push(
                ...buffer.slice(
                  buffer.length - 3 * stride,
                  buffer.length - 2 * stride
                ),
                ...buffer.slice(buffer.length - stride, buffer.length)
              );
            }
          }
        }
        this.geometry.vertices.push(vertex2.position);
        this.geometry.vertexNormals.push(vertex2.normal || new Vector(0, 0, 0));
        this.geometry.uvs.push(vertex2.textureCoordinates.x, vertex2.textureCoordinates.y);
        if (this.renderer.states.fillColor) {
          this.geometry.vertexColors.push(...vertex2.fill.array());
        } else {
          this.geometry.vertexColors.push(0, 0, 0, 0);
        }
        if (this.renderer.states.strokeColor) {
          this.geometry.vertexStrokeColors.push(...vertex2.stroke.array());
        } else {
          this.geometry.vertexStrokeColors.push(0, 0, 0, 0);
        }
        for (const key in userVertexPropertyHelpers) {
          const prop = userVertexPropertyHelpers[key];
          if (key in vertex2) {
            prop.setCurrentData(vertex2[key]);
          }
          prop.pushCurrentData();
        }
      }
    }
    if (shouldProcessEdges) {
      this.geometry.edges = this._calculateEdges(this.shapeMode, this.geometry.vertices);
    }
    if (shouldProcessEdges && !this.renderer.geometryBuilder) {
      this.geometry._edgesToVertices();
    }
    if (this.shapeMode === PATH) {
      this.isProcessingVertices = true;
      this._tesselateShape();
      this.isProcessingVertices = false;
    } else if (this.shapeMode === QUAD_STRIP) {
      this.shapeMode = TRIANGLE_STRIP;
    } else if (this.shapeMode === QUADS) {
      this.shapeMode = TRIANGLES;
    }
    if (this.renderer.states.textureMode === IMAGE && this.renderer.states._tex !== null && this.renderer.states._tex.width > 0 && this.renderer.states._tex.height > 0) {
      this.geometry.uvs = this.geometry.uvs.map((val2, i) => {
        if (i % 2 === 0) {
          return val2 / this.renderer.states._tex.width;
        } else {
          return val2 / this.renderer.states._tex.height;
        }
      });
    }
  }
  _resetUserVertexProperties() {
    const properties = this.geometry.userVertexProperties;
    for (const propName in properties) {
      const prop = properties[propName];
      delete this.bufferStrides[propName];
      prop.delete();
    }
    this._useUserVertexProperties = false;
    this.tessyVertexSize = INITIAL_VERTEX_SIZE;
    this.geometry.userVertexProperties = {};
  }
  /**
   * Called from _processVertices(). This function calculates the stroke vertices for custom shapes and
   * tesselates shapes when applicable.
   * @private
   * @returns  {Number[]} indices for custom shape vertices indicating edges.
   */
  _calculateEdges(shapeMode, verts) {
    const res = [];
    let i = 0;
    const contourIndices = this.contourIndices.slice();
    let contourStart = -1;
    switch (shapeMode) {
      case TRIANGLE_STRIP:
        for (i = 0; i < verts.length - 2; i++) {
          res.push([i, i + 1]);
          res.push([i, i + 2]);
        }
        res.push([i, i + 1]);
        break;
      case TRIANGLE_FAN:
        for (i = 1; i < verts.length - 1; i++) {
          res.push([0, i]);
          res.push([i, i + 1]);
        }
        res.push([0, verts.length - 1]);
        break;
      case TRIANGLES:
        for (i = 0; i < verts.length - 2; i = i + 3) {
          res.push([i, i + 1]);
          res.push([i + 1, i + 2]);
          res.push([i + 2, i]);
        }
        break;
      case LINES:
        for (i = 0; i < verts.length - 1; i = i + 2) {
          res.push([i, i + 1]);
        }
        break;
      case QUADS:
        for (i = 0; i < verts.length - 5; i += 6) {
          res.push([i, i + 1]);
          res.push([i + 1, i + 2]);
          res.push([i + 2, i + 5]);
          res.push([i + 5, i]);
        }
        break;
      case QUAD_STRIP:
        for (i = 0; i < verts.length - 2; i += 2) {
          res.push([i, i + 1]);
          res.push([i + 1, i + 3]);
          res.push([i, i + 2]);
        }
        res.push([i, i + 1]);
        break;
      default:
        for (i = 0; i < verts.length; i++) {
          if (i === contourIndices[0]) {
            contourStart = contourIndices.shift();
          } else if (verts[contourStart] && verts[i].equals(verts[contourStart])) {
            res.push([i - 1, contourStart]);
          } else {
            res.push([i - 1, i]);
          }
        }
        break;
    }
    return res;
  }
  /**
   * Called from _processVertices() when applicable. This function tesselates immediateMode.geometry.
   * @private
   */
  _tesselateShape() {
    this.shapeMode = TRIANGLES;
    const contours = [];
    for (let i = 0; i < this.geometry.vertices.length; i++) {
      if (this.contourIndices.length > 0 && this.contourIndices[0] === i) {
        this.contourIndices.shift();
        contours.push([]);
      }
      contours[contours.length - 1].push(
        this.geometry.vertices[i].x,
        this.geometry.vertices[i].y,
        this.geometry.vertices[i].z,
        this.geometry.uvs[i * 2],
        this.geometry.uvs[i * 2 + 1],
        this.geometry.vertexColors[i * 4],
        this.geometry.vertexColors[i * 4 + 1],
        this.geometry.vertexColors[i * 4 + 2],
        this.geometry.vertexColors[i * 4 + 3],
        this.geometry.vertexNormals[i].x,
        this.geometry.vertexNormals[i].y,
        this.geometry.vertexNormals[i].z
      );
      for (const propName in this.geometry.userVertexProperties) {
        const prop = this.geometry.userVertexProperties[propName];
        const start = i * prop.getDataSize();
        const end = start + prop.getDataSize();
        const vals = prop.getSrcArray().slice(start, end);
        contours[contours.length - 1].push(...vals);
      }
    }
    const polyTriangles = this._triangulate(contours);
    const originalVertices = this.geometry.vertices;
    this.geometry.vertices = [];
    this.geometry.vertexNormals = [];
    this.geometry.uvs = [];
    for (const propName in this.geometry.userVertexProperties) {
      const prop = this.geometry.userVertexProperties[propName];
      prop.resetSrcArray();
    }
    const colors = [];
    for (let j2 = 0, polyTriLength = polyTriangles.length; j2 < polyTriLength; j2 = j2 + this.tessyVertexSize) {
      colors.push(...polyTriangles.slice(j2 + 5, j2 + 9));
      this.geometry.vertexNormals.push(new Vector(...polyTriangles.slice(j2 + 9, j2 + 12)));
      {
        let offset2 = 12;
        for (const propName in this.geometry.userVertexProperties) {
          const prop = this.geometry.userVertexProperties[propName];
          const size = prop.getDataSize();
          const start = j2 + offset2;
          const end = start + size;
          prop.setCurrentData(polyTriangles.slice(start, end));
          prop.pushCurrentData();
          offset2 += size;
        }
      }
      this.geometry.vertices.push(new Vector(...polyTriangles.slice(j2, j2 + 3)));
      this.geometry.uvs.push(...polyTriangles.slice(j2 + 3, j2 + 5));
    }
    if (this.renderer.geometryBuilder) {
      const newIndex = /* @__PURE__ */ new Map();
      this.geometry.edges = this.geometry.edges.map((edge) => edge.map((origIdx) => {
        if (!newIndex.has(origIdx)) {
          const orig = originalVertices[origIdx];
          let newVertIndex = this.geometry.vertices.findIndex(
            (v) => orig.x === v.x && orig.y === v.y && orig.z === v.z
          );
          if (newVertIndex === -1) {
            let closestDist = Infinity;
            let closestIndex = 0;
            for (let i = 0; i < this.geometry.vertices.length; i++) {
              const vert = this.geometry.vertices[i];
              const dX = orig.x - vert.x;
              const dY = orig.y - vert.y;
              const dZ = orig.z - vert.z;
              const dist = dX * dX + dY * dY + dZ * dZ;
              if (dist < closestDist) {
                closestDist = dist;
                closestIndex = i;
              }
            }
            newVertIndex = closestIndex;
          }
          newIndex.set(origIdx, newVertIndex);
        }
        return newIndex.get(origIdx);
      }));
    }
    this.geometry.vertexColors = colors;
  }
  _initTessy() {
    function vertexCallback(data3, polyVertArray) {
      for (const element2 of data3) {
        polyVertArray.push(element2);
      }
    }
    function begincallback(type3) {
      if (type3 !== import_libtess.default.primitiveType.GL_TRIANGLES) {
        console.log(`expected TRIANGLES but got type: ${type3}`);
      }
    }
    function errorcallback(errno) {
      console.log("error callback");
      console.log(`error number: ${errno}`);
    }
    const combinecallback = (coords, data3, weight) => {
      const result = new Array(this.tessyVertexSize).fill(0);
      for (let i = 0; i < weight.length; i++) {
        for (let j2 = 0; j2 < result.length; j2++) {
          if (weight[i] === 0 || !data3[i]) continue;
          result[j2] += data3[i][j2] * weight[i];
        }
      }
      return result;
    };
    function edgeCallback(flag) {
    }
    const tessy = new import_libtess.default.GluTesselator();
    tessy.gluTessCallback(import_libtess.default.gluEnum.GLU_TESS_VERTEX_DATA, vertexCallback);
    tessy.gluTessCallback(import_libtess.default.gluEnum.GLU_TESS_BEGIN, begincallback);
    tessy.gluTessCallback(import_libtess.default.gluEnum.GLU_TESS_ERROR, errorcallback);
    tessy.gluTessCallback(import_libtess.default.gluEnum.GLU_TESS_COMBINE, combinecallback);
    tessy.gluTessCallback(import_libtess.default.gluEnum.GLU_TESS_EDGE_FLAG, edgeCallback);
    tessy.gluTessProperty(
      import_libtess.default.gluEnum.GLU_TESS_WINDING_RULE,
      import_libtess.default.windingRule.GLU_TESS_WINDING_NONZERO
    );
    return tessy;
  }
  /**
   * Runs vertices through libtess to convert them into triangles
   * @private
   */
  _triangulate(contours) {
    const z = contours[0] ? contours[0][2] : void 0;
    let allSameZ = true;
    for (const contour of contours) {
      for (let j2 = 0; j2 < contour.length; j2 += this.tessyVertexSize) {
        if (contour[j2 + 2] !== z) {
          allSameZ = false;
          break;
        }
      }
    }
    if (allSameZ) {
      this._tessy.gluTessNormal(0, 0, 1);
    } else {
      this._tessy.gluTessNormal(0, 0, 0);
    }
    const triangleVerts = [];
    this._tessy.gluTessBeginPolygon(triangleVerts);
    for (const contour of contours) {
      this._tessy.gluTessBeginContour();
      for (let j2 = 0; j2 < contour.length; j2 += this.tessyVertexSize) {
        const coords = contour.slice(
          j2,
          j2 + this.tessyVertexSize
        );
        this._tessy.gluTessVertex(coords, coords);
      }
      this._tessy.gluTessEndContour();
    }
    this._tessy.gluTessEndPolygon();
    return triangleVerts;
  }
};

// node_modules/p5/dist/webgl/GeometryBufferCache.js
var GeometryBufferCache = class {
  constructor(renderer2) {
    this.renderer = renderer2;
    this.cache = {};
  }
  numCached() {
    return Object.keys(this.cache).length;
  }
  isCached(gid) {
    return this.cache[gid] !== void 0;
  }
  getGeometryByID(gid) {
    var _a2;
    return (_a2 = this.cache[gid]) == null ? void 0 : _a2.geometry;
  }
  getCached(model) {
    return this.getCachedID(model.gid);
  }
  getCachedID(gid) {
    return this.cache[gid];
  }
  ensureCached(geometry2) {
    const gid = geometry2.gid;
    if (!gid) {
      throw new Error("The p5.Geometry you passed in has no gid property!");
    }
    if (this.isCached(geometry2.gid)) return this.getCached(geometry2);
    const gl = this.renderer.GL;
    this.freeBuffers(gid);
    if (Object.keys(this.cache).length > 1e3) {
      const key = Object.keys(this.cache)[0];
      this.freeBuffers(key);
    }
    const buffers = {};
    this.cache[gid] = buffers;
    buffers.geometry = geometry2;
    let indexBuffer = buffers.indexBuffer;
    if (geometry2.faces.length) {
      if (!indexBuffer) indexBuffer = buffers.indexBuffer = gl.createBuffer();
      const vals = geometry2.faces.flat();
      const hasVertexIndicesOverMaxUInt16 = vals.some((v) => v > 65535);
      let type3 = hasVertexIndicesOverMaxUInt16 ? Uint32Array : Uint16Array;
      this.renderer._bindBuffer(indexBuffer, gl.ELEMENT_ARRAY_BUFFER, vals, type3);
      buffers.indexBufferType = hasVertexIndicesOverMaxUInt16 ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT;
    } else {
      if (indexBuffer) {
        gl.deleteBuffer(indexBuffer);
        buffers.indexBuffer = null;
      }
    }
    return buffers;
  }
  freeBuffers(gid) {
    const buffers = this.cache[gid];
    if (!buffers) {
      return;
    }
    delete this.cache[gid];
    const gl = this.renderer.GL;
    if (buffers.indexBuffer) {
      gl.deleteBuffer(buffers.indexBuffer);
    }
    function freeBuffers(defs) {
      for (const def of defs) {
        if (buffers[def.dst]) {
          gl.deleteBuffer(buffers[def.dst]);
          buffers[def.dst] = null;
        }
      }
    }
    freeBuffers(this.renderer.buffers.stroke);
    freeBuffers(this.renderer.buffers.fill);
    freeBuffers(this.renderer.buffers.user);
  }
};

// node_modules/p5/dist/image/const.js
var filterParamDefaults = {
  [BLUR]: 3,
  [POSTERIZE]: 4,
  [THRESHOLD]: 0.5
};

// node_modules/p5/dist/math/trigonometry.js
function trigonometry(p53, fn2) {
  const DEGREES = fn2.DEGREES = "degrees";
  const RADIANS = fn2.RADIANS = "radians";
  fn2._angleMode = RADIANS;
  fn2.acos = function(ratio) {
    return this._fromRadians(Math.acos(ratio));
  };
  fn2.asin = function(ratio) {
    return this._fromRadians(Math.asin(ratio));
  };
  fn2.atan = function(ratio) {
    return this._fromRadians(Math.atan(ratio));
  };
  fn2.atan2 = function(y, x) {
    return this._fromRadians(Math.atan2(y, x));
  };
  fn2.cos = function(angle) {
    return Math.cos(this._toRadians(angle));
  };
  fn2.sin = function(angle) {
    return Math.sin(this._toRadians(angle));
  };
  fn2.tan = function(angle) {
    return Math.tan(this._toRadians(angle));
  };
  fn2.degrees = (angle) => angle * RAD_TO_DEG;
  fn2.radians = (angle) => angle * DEG_TO_RAD;
  fn2.angleMode = function(mode) {
    if (typeof mode === "undefined") {
      return this._angleMode;
    } else if (mode === DEGREES || mode === RADIANS) {
      const prevMode = this._angleMode;
      if (mode === prevMode) return;
      if (mode === RADIANS) {
        this.pRotationX = this.pRotationX * DEG_TO_RAD;
        this.pRotationY = this.pRotationY * DEG_TO_RAD;
        this.pRotationZ = this.pRotationZ * DEG_TO_RAD;
      } else {
        this.pRotationX = this.pRotationX * RAD_TO_DEG;
        this.pRotationY = this.pRotationY * RAD_TO_DEG;
        this.pRotationZ = this.pRotationZ * RAD_TO_DEG;
      }
      this._angleMode = mode;
    }
  };
  fn2._toRadians = function(angle) {
    if (this._angleMode === DEGREES) {
      return angle * DEG_TO_RAD;
    }
    return angle;
  };
  fn2._toDegrees = function(angle) {
    if (this._angleMode === RADIANS) {
      return angle * RAD_TO_DEG;
    }
    return angle;
  };
  fn2._fromRadians = function(angle) {
    if (this._angleMode === DEGREES) {
      return angle * RAD_TO_DEG;
    }
    return angle;
  };
  fn2._fromDegrees = function(angle) {
    if (this._angleMode === RADIANS) {
      return angle * DEG_TO_RAD;
    }
    return angle;
  };
}
if (typeof p5 !== "undefined") {
  trigonometry(p5, p5.prototype);
}

// node_modules/p5/dist/rendering-BELwvfI6.js
function image2(p53, fn2) {
  fn2.createImage = function(width, height) {
    return new p53.Image(width, height);
  };
  fn2.saveCanvas = function(...args) {
    let htmlCanvas, filename, extension, temporaryGraphics;
    if (args[0] instanceof HTMLCanvasElement) {
      htmlCanvas = args[0];
      args.shift();
    } else if (args[0] instanceof Element) {
      htmlCanvas = args[0].elt;
      args.shift();
    } else if (args[0] instanceof Framebuffer) {
      const framebuffer2 = args[0];
      temporaryGraphics = this.createGraphics(
        framebuffer2.width,
        framebuffer2.height
      );
      temporaryGraphics.pixelDensity(framebuffer2.pixelDensity());
      framebuffer2.loadPixels();
      temporaryGraphics.loadPixels();
      temporaryGraphics.pixels.set(framebuffer2.pixels);
      temporaryGraphics.updatePixels();
      htmlCanvas = temporaryGraphics._renderer.canvas;
      args.shift();
    } else {
      htmlCanvas = this._curElement && this._curElement.elt;
    }
    if (args.length >= 1) {
      filename = args[0];
    }
    if (args.length >= 2) {
      extension = args[1];
    }
    extension = extension || fn2._checkFileExtension(filename, extension)[1] || "png";
    let mimeType;
    switch (extension) {
      default:
        mimeType = "image/png";
        break;
      case "webp":
        mimeType = "image/webp";
        break;
      case "jpeg":
      case "jpg":
        mimeType = "image/jpeg";
        break;
    }
    htmlCanvas.toBlob((blob) => {
      fn2.downloadFile(blob, filename, extension);
      if (temporaryGraphics) temporaryGraphics.remove();
    }, mimeType);
  };
  fn2.encodeAndDownloadGif = function(pImg, filename) {
    const props = pImg.gifProperties;
    let loopLimit = props.loopLimit;
    if (loopLimit === 1) {
      loopLimit = null;
    } else if (loopLimit === null) {
      loopLimit = 0;
    }
    const buffer = new Uint8Array(pImg.width * pImg.height * props.numFrames);
    const allFramesPixelColors = [];
    const paletteFreqsAndFrames = {};
    for (let i = 0; i < props.numFrames; i++) {
      const paletteSet = /* @__PURE__ */ new Set();
      const data3 = props.frames[i].image.data;
      const dataLength = data3.length;
      const pixelColors = new Uint32Array(pImg.width * pImg.height);
      for (let j2 = 0, k = 0; j2 < dataLength; j2 += 4, k++) {
        const r = data3[j2 + 0];
        const g2 = data3[j2 + 1];
        const b3 = data3[j2 + 2];
        const color3 = r << 16 | g2 << 8 | b3 << 0;
        paletteSet.add(color3);
        pixelColors[k] = color3;
      }
      const paletteStr = [...paletteSet].sort().toString();
      if (paletteFreqsAndFrames[paletteStr] === void 0) {
        paletteFreqsAndFrames[paletteStr] = { freq: 1, frames: [i] };
      } else {
        paletteFreqsAndFrames[paletteStr].freq += 1;
        paletteFreqsAndFrames[paletteStr].frames.push(i);
      }
      allFramesPixelColors.push(pixelColors);
    }
    let framesUsingGlobalPalette = [];
    const palettesSortedByFreq = Object.keys(paletteFreqsAndFrames).sort(function(a2, b3) {
      return paletteFreqsAndFrames[b3].freq - paletteFreqsAndFrames[a2].freq;
    });
    const globalPalette = palettesSortedByFreq[0].split(",").map((a2) => parseInt(a2));
    framesUsingGlobalPalette = framesUsingGlobalPalette.concat(
      paletteFreqsAndFrames[globalPalette].frames
    );
    const globalPaletteSet = new Set(globalPalette);
    for (let i = 1; i < palettesSortedByFreq.length; i++) {
      const palette = palettesSortedByFreq[i].split(",").map((a2) => parseInt(a2));
      const difference = palette.filter((x) => !globalPaletteSet.has(x));
      if (globalPalette.length + difference.length <= 256) {
        for (let j2 = 0; j2 < difference.length; j2++) {
          globalPalette.push(difference[j2]);
          globalPaletteSet.add(difference[j2]);
        }
        framesUsingGlobalPalette = framesUsingGlobalPalette.concat(
          paletteFreqsAndFrames[palettesSortedByFreq[i]].frames
        );
      }
    }
    framesUsingGlobalPalette = new Set(framesUsingGlobalPalette);
    const globalIndicesLookup = {};
    for (let i = 0; i < globalPalette.length; i++) {
      if (!globalIndicesLookup[globalPalette[i]]) {
        globalIndicesLookup[globalPalette[i]] = i;
      }
    }
    let powof2 = 1;
    while (powof2 < globalPalette.length) {
      powof2 <<= 1;
    }
    globalPalette.length = powof2;
    const opts = {
      loop: loopLimit,
      palette: new Uint32Array(globalPalette)
    };
    const gifWriter = new omggif2.GifWriter(buffer, pImg.width, pImg.height, opts);
    let previousFrame = {};
    for (let i = 0; i < props.numFrames; i++) {
      const localPaletteRequired = !framesUsingGlobalPalette.has(i);
      const palette = localPaletteRequired ? [] : globalPalette;
      const pixelPaletteIndex = new Uint8Array(pImg.width * pImg.height);
      const colorIndicesLookup = {};
      const cannotBeTransparent = /* @__PURE__ */ new Set();
      allFramesPixelColors[i].forEach((color3, k) => {
        if (localPaletteRequired) {
          if (colorIndicesLookup[color3] === void 0) {
            colorIndicesLookup[color3] = palette.length;
            palette.push(color3);
          }
          pixelPaletteIndex[k] = colorIndicesLookup[color3];
        } else {
          pixelPaletteIndex[k] = globalIndicesLookup[color3];
        }
        if (i > 0) {
          if (allFramesPixelColors[i - 1][k] !== color3) {
            cannotBeTransparent.add(color3);
          }
        }
      });
      const frameOpts = {};
      const canBeTransparent = palette.filter((a2) => !cannotBeTransparent.has(a2));
      if (canBeTransparent.length > 0) {
        const transparent = canBeTransparent[0];
        const transparentIndex = localPaletteRequired ? colorIndicesLookup[transparent] : globalIndicesLookup[transparent];
        if (i > 0) {
          for (let k = 0; k < allFramesPixelColors[i].length; k++) {
            if (allFramesPixelColors[i - 1][k] === allFramesPixelColors[i][k]) {
              pixelPaletteIndex[k] = transparentIndex;
            }
          }
          frameOpts.transparent = transparentIndex;
          previousFrame.frameOpts.disposal = 1;
        }
      }
      frameOpts.delay = props.frames[i].delay / 10;
      if (localPaletteRequired) {
        let powof22 = 1;
        while (powof22 < palette.length) {
          powof22 <<= 1;
        }
        palette.length = powof22;
        frameOpts.palette = new Uint32Array(palette);
      }
      if (i > 0) {
        gifWriter.addFrame(
          0,
          0,
          pImg.width,
          pImg.height,
          previousFrame.pixelPaletteIndex,
          previousFrame.frameOpts
        );
      }
      previousFrame = {
        pixelPaletteIndex,
        frameOpts
      };
    }
    previousFrame.frameOpts.disposal = 1;
    gifWriter.addFrame(
      0,
      0,
      pImg.width,
      pImg.height,
      previousFrame.pixelPaletteIndex,
      previousFrame.frameOpts
    );
    const extension = "gif";
    const blob = new Blob([buffer.slice(0, gifWriter.end())], {
      type: "image/gif"
    });
    fn2.downloadFile(blob, filename, extension);
  };
  fn2.saveFrames = function(fName, ext, _duration, _fps, callback) {
    let duration3 = _duration || 3;
    duration3 = Math.max(Math.min(duration3, 15), 0);
    duration3 = duration3 * 1e3;
    let fps = _fps || 15;
    fps = Math.max(Math.min(fps, 22), 0);
    let count = 0;
    const makeFrame = fn2._makeFrame;
    const cnv = this._curElement.elt;
    let frames = [];
    const frameFactory = setInterval(() => {
      frames.push(makeFrame(fName + count, ext, cnv));
      count++;
    }, 1e3 / fps);
    setTimeout(() => {
      clearInterval(frameFactory);
      if (callback) {
        callback(frames);
      } else {
        for (const f of frames) {
          fn2.downloadFile(f.imageData, f.filename, f.ext);
        }
      }
      frames = [];
    }, duration3 + 0.01);
  };
  fn2._makeFrame = function(filename, extension, _cnv) {
    let cnv;
    if (this) {
      cnv = this._curElement.elt;
    } else {
      cnv = _cnv;
    }
    let mimeType;
    if (!extension) {
      extension = "png";
      mimeType = "image/png";
    } else {
      switch (extension.toLowerCase()) {
        case "png":
          mimeType = "image/png";
          break;
        case "jpeg":
          mimeType = "image/jpeg";
          break;
        case "jpg":
          mimeType = "image/jpeg";
          break;
        default:
          mimeType = "image/png";
          break;
      }
    }
    const downloadMime = "image/octet-stream";
    let imageData = cnv.toDataURL(mimeType);
    imageData = imageData.replace(mimeType, downloadMime);
    const thisFrame = {};
    thisFrame.imageData = imageData;
    thisFrame.filename = filename;
    thisFrame.ext = extension;
    return thisFrame;
  };
}
if (typeof p5 !== "undefined") {
  image2(p5, p5.prototype);
}
var HTTPError = class extends Error {
  constructor() {
    super(...arguments);
    __publicField(this, "status");
    __publicField(this, "response");
    __publicField(this, "ok");
  }
};
async function request(path2, type3) {
  try {
    const res = await fetch(path2);
    if (res.ok) {
      let data3;
      switch (type3) {
        case "json":
          data3 = await res.json();
          break;
        case "text":
          data3 = await res.text();
          break;
        case "arrayBuffer":
          data3 = await res.arrayBuffer();
          break;
        case "blob":
          data3 = await res.blob();
          break;
        case "bytes":
          if (res.bytes) {
            data3 = await res.bytes();
          } else {
            const d2 = await res.arrayBuffer();
            data3 = new Uint8Array(d2);
          }
          break;
        default:
          throw new Error("Unsupported response type");
      }
      return { data: data3, headers: res.headers };
    } else {
      const err2 = new HTTPError(res.statusText);
      err2.status = res.status;
      err2.response = res;
      err2.ok = false;
      throw err2;
    }
  } catch (err2) {
    if (err2 instanceof TypeError) {
      console.log("You may have encountered a CORS error");
    } else if (err2 instanceof HTTPError) {
      console.log("You have encountered a HTTP error");
    } else if (err2 instanceof SyntaxError) {
      console.log("There is an error parsing the response to requested data structure");
    }
    throw err2;
  }
}
function files(p53, fn2) {
  fn2.loadJSON = async function(path2, successCallback, errorCallback) {
    try {
      const { data: data3 } = await request(path2, "json");
      if (successCallback) return successCallback(data3);
      return data3;
    } catch (err2) {
      p53._friendlyFileLoadError(5, path2);
      if (errorCallback) {
        return errorCallback(err2);
      } else {
        throw err2;
      }
    }
  };
  fn2.loadStrings = async function(path2, successCallback, errorCallback) {
    try {
      let { data: data3 } = await request(path2, "text");
      data3 = data3.split(/\r?\n/);
      if (successCallback) return successCallback(data3);
      return data3;
    } catch (err2) {
      p53._friendlyFileLoadError(3, path2);
      if (errorCallback) {
        return errorCallback(err2);
      } else {
        throw err2;
      }
    }
  };
  fn2.loadTable = async function(path2, separator, header, successCallback, errorCallback) {
    if (typeof arguments[arguments.length - 1] === "function") {
      if (typeof arguments[arguments.length - 2] === "function") {
        successCallback = arguments[arguments.length - 2];
        errorCallback = arguments[arguments.length - 1];
      } else {
        successCallback = arguments[arguments.length - 1];
      }
    }
    if (typeof separator !== "string") separator = ",";
    if (typeof header === "function") header = false;
    try {
      let { data: data3 } = await request(path2, "text");
      let ret = new p53.Table();
      data3 = parse2(data3, {
        separator
      });
      if (header) {
        ret.columns = data3.shift();
      } else {
        ret.columns = Array(data3[0].length).fill(null);
      }
      data3.forEach((line) => {
        const row = new p53.TableRow(line);
        ret.addRow(row);
      });
      if (successCallback) {
        return successCallback(ret);
      } else {
        return ret;
      }
    } catch (err2) {
      p53._friendlyFileLoadError(2, path2);
      if (errorCallback) {
        return errorCallback(err2);
      } else {
        throw err2;
      }
    }
  };
  fn2.loadXML = async function(path2, successCallback, errorCallback) {
    try {
      const parser = new DOMParser();
      let { data: data3 } = await request(path2, "text");
      const parsedDOM = parser.parseFromString(data3, "application/xml");
      data3 = new p53.XML(parsedDOM);
      if (successCallback) return successCallback(data3);
      return data3;
    } catch (err2) {
      p53._friendlyFileLoadError(1, path2);
      if (errorCallback) {
        return errorCallback(err2);
      } else {
        throw err2;
      }
    }
  };
  fn2.loadBytes = async function(path2, successCallback, errorCallback) {
    try {
      let { data: data3 } = await request(path2, "arrayBuffer");
      data3 = new Uint8Array(data3);
      if (successCallback) return successCallback(data3);
      return data3;
    } catch (err2) {
      p53._friendlyFileLoadError(6, path2);
      if (errorCallback) {
        return errorCallback(err2);
      } else {
        throw err2;
      }
    }
  };
  fn2.loadBlob = async function(path2, successCallback, errorCallback) {
    try {
      const { data: data3 } = await request(path2, "blob");
      if (successCallback) return successCallback(data3);
      return data3;
    } catch (err2) {
      if (errorCallback) {
        return errorCallback(err2);
      } else {
        throw err2;
      }
    }
  };
  fn2.httpGet = async function(path2, datatype = "text", successCallback, errorCallback) {
    if (typeof datatype === "function") {
      errorCallback = successCallback;
      successCallback = datatype;
      datatype = "text";
    }
    return this.httpDo(path2, "GET", datatype, successCallback, errorCallback);
  };
  fn2.httpPost = async function(path2, data3, datatype = "text", successCallback, errorCallback) {
    if (typeof data3 === "function") {
      successCallback = data3;
      errorCallback = datatype;
      data3 = void 0;
      datatype = "text";
    } else if (typeof datatype === "function") {
      errorCallback = successCallback;
      successCallback = datatype;
      datatype = "text";
    }
    let reqData = data3;
    let contentType = "text/plain";
    if (data3 instanceof p53.XML) {
      reqData = data3.serialize();
      contentType = "application/xml";
    } else if (data3 instanceof p53.Image) {
      reqData = await data3.toBlob();
      contentType = "image/png";
    } else if (typeof data3 === "object") {
      reqData = JSON.stringify(data3);
      contentType = "application/json";
    }
    const requestOptions = {
      method: "POST",
      body: reqData,
      headers: {
        "Content-Type": contentType
      }
    };
    if (reqData) {
      requestOptions.body = reqData;
    }
    const req = new Request(path2, requestOptions);
    return this.httpDo(req, "POST", datatype, successCallback, errorCallback);
  };
  fn2.httpDo = async function(path2, method, datatype, successCallback, errorCallback) {
    if (typeof datatype === "function") {
      errorCallback = successCallback;
      successCallback = datatype;
      datatype = void 0;
    }
    if (!datatype) {
      const extension = typeof path2 === "string" ? path2.split(".").pop() : path2.url.split(".").pop();
      switch (extension) {
        case "json":
          datatype = "json";
          break;
        case "jpg":
        case "jpeg":
        case "png":
        case "webp":
        case "gif":
          datatype = "blob";
          break;
        case "xml":
        case "txt":
        default:
          datatype = "text";
      }
    }
    const req = new Request(path2, {
      method
    });
    try {
      const { data: data3 } = await request(req, datatype);
      if (successCallback) {
        return successCallback(data3);
      } else {
        return data3;
      }
    } catch (err2) {
      if (errorCallback) {
        return errorCallback(err2);
      } else {
        throw err2;
      }
    }
  };
  fn2._pWriters = [];
  fn2.createWriter = function(name, extension) {
    let newPW;
    for (const i in fn2._pWriters) {
      if (fn2._pWriters[i].name === name) {
        newPW = new p53.PrintWriter(name + this.millis(), extension);
        fn2._pWriters.push(newPW);
        return newPW;
      }
    }
    newPW = new p53.PrintWriter(name, extension);
    fn2._pWriters.push(newPW);
    return newPW;
  };
  p53.PrintWriter = function(filename, extension) {
    let self2 = this;
    this.name = filename;
    this.content = "";
    this.write = function(data3) {
      this.content += data3;
    };
    this.print = function(data3) {
      this.content += `${data3}
`;
    };
    this.clear = function() {
      this.content = "";
    };
    this.close = function() {
      const arr2 = [];
      arr2.push(this.content);
      fn2.writeFile(arr2, filename, extension);
      for (const i in fn2._pWriters) {
        if (fn2._pWriters[i].name === this.name) {
          fn2._pWriters.splice(i, 1);
        }
      }
      self2.clear();
      self2 = {};
    };
  };
  fn2.save = function(object2, _filename, _options) {
    const args = arguments;
    const cnv = this._curElement ? this._curElement.elt : this.elt;
    if (args.length === 0) {
      fn2.saveCanvas(cnv);
      return;
    } else if (args[0] instanceof Renderer || args[0] instanceof Graphics) {
      fn2.saveCanvas(args[0].canvas, args[1], args[2]);
      return;
    } else if (args.length === 1 && typeof args[0] === "string") {
      fn2.saveCanvas(cnv, args[0]);
    } else {
      const extension = _checkFileExtension(args[1], args[2])[1];
      switch (extension) {
        case "json":
          fn2.saveJSON(args[0], args[1], args[2]);
          return;
        case "txt":
          fn2.saveStrings(args[0], args[1], args[2]);
          return;
        default:
          if (args[0] instanceof Array) {
            fn2.saveStrings(args[0], args[1], args[2]);
          } else if (args[0] instanceof p53.Table) {
            fn2.saveTable(args[0], args[1], args[2]);
          } else if (args[0] instanceof p53.Image) {
            fn2.saveCanvas(args[0].canvas, args[1]);
          } else if (args[0] instanceof p53.SoundFile) {
            fn2.saveSound(args[0], args[1], args[2], args[3]);
          }
      }
    }
  };
  fn2.saveJSON = function(json2, filename, optimize) {
    let stringify2;
    if (optimize) {
      stringify2 = JSON.stringify(json2);
    } else {
      stringify2 = JSON.stringify(json2, void 0, 2);
    }
    this.saveStrings(stringify2.split("\n"), filename, "json");
  };
  fn2.saveStrings = function(list, filename, extension, isCRLF) {
    const ext = extension || "txt";
    const pWriter = new p53.PrintWriter(filename, ext);
    for (let item of list) {
      isCRLF ? pWriter.write(item + "\r\n") : pWriter.write(item + "\n");
    }
    pWriter.close();
    pWriter.clear();
  };
  function escapeHelper(content) {
    return content.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }
  fn2.saveTable = function(table2, filename, options2) {
    let ext;
    if (options2 === void 0) {
      ext = filename.substring(filename.lastIndexOf(".") + 1, filename.length);
      if (ext === filename) ext = "csv";
    } else {
      ext = options2;
    }
    const pWriter = this.createWriter(filename, ext);
    const header = table2.columns;
    let sep = ",";
    if (ext === "tsv") {
      sep = "	";
    }
    if (ext !== "html") {
      const output2 = table2.toString(sep);
      pWriter.write(output2);
    } else {
      pWriter.print("<html>");
      pWriter.print("<head>");
      let str = '  <meta http-equiv="content-type" content';
      str += '="text/html;charset=utf-8" />';
      pWriter.print(str);
      pWriter.print("</head>");
      pWriter.print("<body>");
      pWriter.print("  <table>");
      if (header[0] !== "0") {
        pWriter.print("    <tr>");
        for (let k = 0; k < header.length; k++) {
          const e2 = escapeHelper(header[k]);
          pWriter.print(`      <td>${e2}`);
          pWriter.print("      </td>");
        }
        pWriter.print("    </tr>");
      }
      for (let row = 0; row < table2.rows.length; row++) {
        pWriter.print("    <tr>");
        for (let col = 0; col < table2.columns.length; col++) {
          const entry = table2.rows[row].getString(col);
          const htmlEntry = escapeHelper(entry);
          pWriter.print(`      <td>${htmlEntry}`);
          pWriter.print("      </td>");
        }
        pWriter.print("    </tr>");
      }
      pWriter.print("  </table>");
      pWriter.print("</body>");
      pWriter.print("</html>");
    }
    pWriter.close();
    pWriter.clear();
  };
  fn2.writeFile = function(dataToDownload, filename, extension) {
    let type3 = "application/octet-stream";
    if (fn2._isSafari()) {
      type3 = "text/plain";
    }
    const blob = new Blob(dataToDownload, {
      type: type3
    });
    fn2.downloadFile(blob, filename, extension);
  };
  fn2.downloadFile = downloadFile;
  fn2._checkFileExtension = _checkFileExtension;
  fn2._isSafari = function() {
    return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
  };
}
if (typeof p5 !== "undefined") {
  files(p5, p5.prototype);
}
function loadingDisplaying(p53, fn2) {
  fn2.loadImage = async function(path2, successCallback, failureCallback) {
    try {
      let pImg = new p53.Image(1, 1, this);
      const req = new Request(path2, {
        method: "GET",
        mode: "cors"
      });
      const { data: data3, headers } = await request(req, "bytes");
      const contentType = headers.get("content-type");
      if (contentType === null) {
        console.warn(
          "The image you loaded does not have a Content-Type header. If you are using the online editor consider reuploading the asset."
        );
      }
      if (contentType && contentType.includes("image/gif")) {
        await _createGif(
          data3,
          pImg
        );
      } else {
        const blob = new Blob([data3]);
        const img = await createImageBitmap(blob);
        pImg.width = pImg.canvas.width = img.width;
        pImg.height = pImg.canvas.height = img.height;
        pImg.drawingContext.drawImage(img, 0, 0);
      }
      pImg.modified = true;
      if (successCallback) {
        return successCallback(pImg);
      } else {
        return pImg;
      }
    } catch (err2) {
      p53._friendlyFileLoadError(0, path2);
      if (typeof failureCallback === "function") {
        return failureCallback(err2);
      } else {
        throw err2;
      }
    }
  };
  fn2.saveGif = async function(fileName, duration3, options2 = {
    delay: 0,
    units: "seconds",
    silent: false,
    notificationDuration: 0,
    notificationID: "progressBar"
  }) {
    if (typeof fileName !== "string") {
      throw TypeError("fileName parameter must be a string");
    }
    if (typeof duration3 !== "number") {
      throw TypeError("Duration parameter must be a number");
    }
    const delay = options2 && options2.delay || 0;
    const units = options2 && options2.units || "seconds";
    const silent = options2 && options2.silent || false;
    const notificationDuration = options2 && options2.notificationDuration || 0;
    const notificationID = options2 && options2.notificationID || "progressBar";
    if (typeof delay !== "number") {
      throw TypeError("Delay parameter must be a number");
    }
    if (units !== "seconds" && units !== "frames") {
      throw TypeError('Units parameter must be either "frames" or "seconds"');
    }
    if (typeof silent !== "boolean") {
      throw TypeError("Silent parameter must be a boolean");
    }
    if (typeof notificationDuration !== "number") {
      throw TypeError("Notification duration parameter must be a number");
    }
    if (typeof notificationID !== "string") {
      throw TypeError("Notification ID parameter must be a string");
    }
    this._recording = true;
    let _frameRate = this._targetFrameRate;
    if (_frameRate === Infinity || _frameRate === void 0 || _frameRate === 0) {
      _frameRate = 60;
    }
    let gifFrameDelay = 1 / _frameRate * 1e3;
    gifFrameDelay = gifFrameDelay < 20 ? 20 : gifFrameDelay;
    const nFrames = units === "seconds" ? duration3 * _frameRate : duration3;
    const nFramesDelay = units === "seconds" ? delay * _frameRate : delay;
    const totalNumberOfFrames = nFrames + nFramesDelay;
    let frameIterator = nFramesDelay;
    this.frameCount = frameIterator;
    const lastPixelDensity = this._renderer._pixelDensity;
    this.pixelDensity(1);
    let frames = [];
    if (document.getElementById(notificationID) !== null)
      document.getElementById(notificationID).remove();
    let p2;
    if (!silent) {
      p2 = this.createP("");
      p2.id(notificationID);
      p2.style("font-size", "16px");
      p2.style("font-family", "Montserrat");
      p2.style("background-color", "#ffffffa0");
      p2.style("padding", "8px");
      p2.style("border-radius", "10px");
      p2.position(0, 0);
    }
    let pixels2;
    let gl;
    if (this._renderer instanceof p53.RendererGL) {
      gl = this.drawingContext;
      pixels2 = new Uint8Array(gl.drawingBufferWidth * gl.drawingBufferHeight * 4);
    }
    this.noLoop();
    await Promise.resolve();
    while (frameIterator < totalNumberOfFrames) {
      this.redraw();
      let data3 = void 0;
      if (this._renderer instanceof p53.RendererGL) {
        pixels2 = new Uint8Array(
          gl.drawingBufferWidth * gl.drawingBufferHeight * 4
        );
        gl.readPixels(
          0,
          0,
          gl.drawingBufferWidth,
          gl.drawingBufferHeight,
          gl.RGBA,
          gl.UNSIGNED_BYTE,
          pixels2
        );
        data3 = _flipPixels(pixels2, this.width, this.height);
      } else {
        data3 = this.drawingContext.getImageData(0, 0, this.width, this.height).data;
      }
      frames.push(data3);
      frameIterator++;
      if (!silent) {
        p2.html(
          "Saved frame <b>" + frames.length.toString() + "</b> out of " + nFrames.toString()
        );
      }
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
    if (!silent) p2.html("Frames processed, generating color palette...");
    this.loop();
    this.pixelDensity(lastPixelDensity);
    const gif = ct();
    const globalPalette = _generateGlobalPalette(frames);
    const paletteCache = {};
    const getIndexedFrame = (frame) => {
      const length = frame.length / 4;
      const index = new Uint8Array(length);
      for (let i = 0; i < length; i++) {
        const key = frame[i * 4] << 24 | frame[i * 4 + 1] << 16 | frame[i * 4 + 2] << 8 | frame[i * 4 + 3];
        if (paletteCache[key] === void 0) {
          paletteCache[key] = W(
            globalPalette,
            frame.slice(i * 4, (i + 1) * 4)
          );
        }
        index[i] = paletteCache[key];
      }
      return index;
    };
    const transparentIndex = globalPalette.length - 1;
    let prevIndexedFrame = [];
    for (let i = 0; i < frames.length; i++) {
      const indexedFrame = getIndexedFrame(frames[i]);
      const originalIndexedFrame = indexedFrame.slice();
      if (i === 0) {
        gif.writeFrame(indexedFrame, this.width, this.height, {
          palette: globalPalette,
          delay: gifFrameDelay,
          dispose: 1
        });
      } else {
        for (let i2 = 0; i2 < indexedFrame.length; i2++) {
          if (indexedFrame[i2] === prevIndexedFrame[i2]) {
            indexedFrame[i2] = transparentIndex;
          }
        }
        gif.writeFrame(indexedFrame, this.width, this.height, {
          delay: gifFrameDelay,
          transparent: true,
          transparentIndex,
          dispose: 1
        });
      }
      prevIndexedFrame = originalIndexedFrame;
      if (!silent) {
        p2.html(
          "Rendered frame <b>" + i.toString() + "</b> out of " + nFrames.toString()
        );
      }
      await new Promise((resolve) => setTimeout(resolve, 0));
    }
    gif.finish();
    const buffer = gif.bytesView();
    const extension = "gif";
    const blob = new Blob([buffer], {
      type: "image/gif"
    });
    frames = [];
    this._recording = false;
    this.loop();
    if (!silent) {
      p2.html("Done. Downloading your gif!🌸");
      if (notificationDuration > 0)
        setTimeout(() => p2.remove(), notificationDuration * 1e3);
    }
    fn2.downloadFile(blob, fileName, extension);
  };
  function _flipPixels(pixels2, width, height) {
    const halfHeight = parseInt(height / 2);
    const bytesPerRow = width * 4;
    const temp = new Uint8Array(width * 4);
    for (let y = 0; y < halfHeight; ++y) {
      const topOffset = y * bytesPerRow;
      const bottomOffset = (height - y - 1) * bytesPerRow;
      temp.set(pixels2.subarray(topOffset, topOffset + bytesPerRow));
      pixels2.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
      pixels2.set(temp, bottomOffset);
    }
    return pixels2;
  }
  function _generateGlobalPalette(frames) {
    let allColors = new Uint8Array(frames.length * frames[0].length);
    for (let f = 0; f < frames.length; f++) {
      allColors.set(frames[f], f * frames[0].length);
    }
    let colorPalette = H(allColors, 256, {
      format: "rgba4444",
      oneBitAlpha: true
    });
    if (colorPalette.length === 256) {
      colorPalette[colorPalette.length - 1] = [
        Math.random() * 255,
        Math.random() * 255,
        Math.random() * 255,
        0
      ];
    } else {
      colorPalette.push([
        Math.random() * 255,
        Math.random() * 255,
        Math.random() * 255,
        0
      ]);
    }
    return colorPalette;
  }
  async function _createGif(arrayBuffer, pImg) {
    const gifReader = new omggif2.GifReader(arrayBuffer);
    pImg.width = pImg.canvas.width = gifReader.width;
    pImg.height = pImg.canvas.height = gifReader.height;
    const frames = [];
    const numFrames = gifReader.numFrames();
    let framePixels = new Uint8ClampedArray(pImg.width * pImg.height * 4);
    const loadGIFFrameIntoImage = (frameNum, gifReader2) => {
      try {
        gifReader2.decodeAndBlitFrameRGBA(frameNum, framePixels);
      } catch (e2) {
        p53._friendlyFileLoadError(8, pImg.src);
        throw e2;
      }
    };
    for (let j2 = 0; j2 < numFrames; j2++) {
      const frameInfo = gifReader.frameInfo(j2);
      const prevFrameData = pImg.drawingContext.getImageData(
        0,
        0,
        pImg.width,
        pImg.height
      );
      framePixels = prevFrameData.data.slice();
      loadGIFFrameIntoImage(j2, gifReader);
      const imageData = new ImageData(framePixels, pImg.width, pImg.height);
      pImg.drawingContext.putImageData(imageData, 0, 0);
      let frameDelay = frameInfo.delay;
      if (frameDelay === 0) {
        frameDelay = 10;
      }
      frames.push({
        image: pImg.drawingContext.getImageData(0, 0, pImg.width, pImg.height),
        delay: frameDelay * 10
        //GIF stores delay in one-hundredth of a second, shift to ms
      });
      if (frameInfo.disposal === 2) {
        pImg.drawingContext.clearRect(
          frameInfo.x,
          frameInfo.y,
          frameInfo.width,
          frameInfo.height
        );
      } else if (frameInfo.disposal === 3) {
        pImg.drawingContext.putImageData(
          prevFrameData,
          0,
          0,
          frameInfo.x,
          frameInfo.y,
          frameInfo.width,
          frameInfo.height
        );
      }
    }
    let loopLimit = gifReader.loopCount();
    if (loopLimit === null) {
      loopLimit = 1;
    } else if (loopLimit === 0) {
      loopLimit = null;
    }
    pImg.drawingContext.putImageData(frames[0].image, 0, 0);
    if (frames.length > 1) {
      pImg.gifProperties = {
        displayIndex: 0,
        loopLimit,
        loopCount: 0,
        frames,
        numFrames,
        playing: true,
        timeDisplayed: 0,
        lastChangeTime: 0
      };
    }
    return pImg;
  }
  function _imageContain(xAlign, yAlign, dx, dy, dw, dh, sw, sh) {
    const r = Math.max(sw / dw, sh / dh);
    const [adjusted_dw, adjusted_dh] = [sw / r, sh / r];
    let x = dx;
    let y = dy;
    if (xAlign === CENTER) {
      x += (dw - adjusted_dw) / 2;
    } else if (xAlign === RIGHT) {
      x += dw - adjusted_dw;
    }
    if (yAlign === CENTER) {
      y += (dh - adjusted_dh) / 2;
    } else if (yAlign === BOTTOM) {
      y += dh - adjusted_dh;
    }
    return { x, y, w: adjusted_dw, h: adjusted_dh };
  }
  function _imageCover(xAlign, yAlign, dw, dh, sx, sy, sw, sh) {
    const r = Math.max(dw / sw, dh / sh);
    const [adjusted_sw, adjusted_sh] = [dw / r, dh / r];
    let x = sx;
    let y = sy;
    if (xAlign === CENTER) {
      x += (sw - adjusted_sw) / 2;
    } else if (xAlign === RIGHT) {
      x += sw - adjusted_sw;
    }
    if (yAlign === CENTER) {
      y += (sh - adjusted_sh) / 2;
    } else if (yAlign === BOTTOM) {
      y += sh - adjusted_sh;
    }
    return { x, y, w: adjusted_sw, h: adjusted_sh };
  }
  function _imageFit(fit, xAlign, yAlign, dx, dy, dw, dh, sx, sy, sw, sh) {
    if (fit === COVER) {
      const { x, y, w, h } = _imageCover(xAlign, yAlign, dw, dh, sx, sy, sw, sh);
      sx = x;
      sy = y;
      sw = w;
      sh = h;
    }
    if (fit === CONTAIN) {
      const { x, y, w, h } = _imageContain(
        xAlign,
        yAlign,
        dx,
        dy,
        dw,
        dh,
        sw,
        sh
      );
      dx = x;
      dy = y;
      dw = w;
      dh = h;
    }
    return { sx, sy, sw, sh, dx, dy, dw, dh };
  }
  function _sAssign(sVal, iVal) {
    if (sVal > 0 && sVal < iVal) {
      return sVal;
    } else {
      return iVal;
    }
  }
  fn2.image = function(img, dx, dy, dWidth, dHeight, sx, sy, sWidth, sHeight, fit, xAlign, yAlign) {
    let defW = img.width;
    let defH = img.height;
    yAlign = yAlign || CENTER;
    xAlign = xAlign || CENTER;
    if (img.elt) {
      defW = defW !== void 0 ? defW : img.elt.width;
      defH = defH !== void 0 ? defH : img.elt.height;
    }
    if (img.elt && img.elt.videoWidth && !img.canvas) {
      defW = defW !== void 0 ? defW : img.elt.videoWidth;
      defH = defH !== void 0 ? defH : img.elt.videoHeight;
    }
    let _dx = dx;
    let _dy = dy;
    let _dw = dWidth || defW;
    let _dh = dHeight || defH;
    let _sx = sx || 0;
    let _sy = sy || 0;
    let _sw = sWidth !== void 0 ? sWidth : defW;
    let _sh = sHeight !== void 0 ? sHeight : defH;
    _sw = _sAssign(_sw, defW);
    _sh = _sAssign(_sh, defH);
    let pd = 1;
    if (img.elt && !img.canvas && img.elt.style.width) {
      if (img.elt.videoWidth && !dWidth) {
        pd = img.elt.videoWidth;
      } else {
        pd = img.elt.width;
      }
      pd /= parseInt(img.elt.style.width, 10);
    }
    _sx *= pd;
    _sy *= pd;
    _sh *= pd;
    _sw *= pd;
    let vals = canvas.modeAdjust(_dx, _dy, _dw, _dh, this._renderer.states.imageMode);
    vals = _imageFit(
      fit,
      xAlign,
      yAlign,
      vals.x,
      vals.y,
      vals.w,
      vals.h,
      _sx,
      _sy,
      _sw,
      _sh
    );
    this._renderer.image(
      img,
      vals.sx,
      vals.sy,
      vals.sw,
      vals.sh,
      vals.dx,
      vals.dy,
      vals.dw,
      vals.dh
    );
  };
  fn2.tint = function(...args) {
    const c4 = this.color(...args);
    this._renderer.states.setValue("tint", c4._getRGBA([255, 255, 255, 255]));
  };
  fn2.noTint = function() {
    this._renderer.states.setValue("tint", null);
  };
  fn2.imageMode = function(m3) {
    if (m3 === CORNER || m3 === CORNERS || m3 === CENTER) {
      this._renderer.states.setValue("imageMode", m3);
    }
  };
}
if (typeof p5 !== "undefined") {
  loadingDisplaying(p5, p5.prototype);
}
var Camera = class _Camera {
  constructor(renderer2) {
    this._renderer = renderer2;
    this.cameraType = "default";
    this.useLinePerspective = true;
    this.cameraMatrix = new Matrix(4);
    this.projMatrix = new Matrix(4);
    this.yScale = 1;
  }
  /**
   * The camera’s x-coordinate.
   *
   * By default, the camera’s x-coordinate is set to 0 in "world" space.
   *
   * @property {Number} eyeX
   * @readonly
   *
   * @example
   * <div>
   * <code>
   * let cam;
   * let font;
   *
   * async function setup() {
   *   // Load a font and create a p5.Font object.
   *   font = await loadFont('assets/inconsolata.otf');
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Set the camera
   *   setCamera(cam);
   *
   *   // Place the camera at the top-center.
   *   cam.setPosition(0, -400, 800);
   *
   *   // Point the camera at the origin.
   *   cam.lookAt(0, 0, 0);
   *
   *   describe(
   *     'A white cube on a gray background. The text "eyeX: 0" is written in black beneath it.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the box.
   *   fill(255);
   *
   *   // Draw the box.
   *   box();
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *   textFont(font);
   *   fill(0);
   *
   *   // Display the value of eyeX, rounded to the nearest integer.
   *   text(`eyeX: ${round(cam.eyeX)}`, 0, 45);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let cam;
   * let font;
   *
   * async function setup() {
   *   // Load a font and create a p5.Font object.
   *   font = await loadFont('assets/inconsolata.otf');
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Place the camera at the top-center.
   *   cam.setPosition(0, -400, 800);
   *
   *   // Point the camera at the origin.
   *   cam.lookAt(0, 0, 0);
   *
   *   describe(
   *     'A white cube on a gray background. The cube appears to move left and right as the camera moves. The text "eyeX: X" is written in black beneath the cube. X oscillates between -25 and 25.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the box.
   *   fill(255);
   *
   *   // Draw the box.
   *   box();
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *   textFont(font);
   *   fill(0);
   *
   *   // Calculate the new x-coordinate.
   *   let x = 25 * sin(frameCount * 0.01);
   *
   *   // Set the camera's position.
   *   cam.setPosition(x, -400, 800);
   *
   *   // Display the value of eyeX, rounded to the nearest integer.
   *   text(`eyeX: ${round(cam.eyeX)}`, 0, 45);
   * }
   * </code>
   * </div>
   */
  /**
   * The camera’s y-coordinate.
   *
   * By default, the camera’s y-coordinate is set to 0 in "world" space.
   *
   * @property {Number} eyeY
   * @readonly
   *
   * @example
   * <div>
   * <code>
   * let cam;
   * let font;
   *
   * async function setup() {
   *   // Load a font and create a p5.Font object.
   *   font = await loadFont('assets/inconsolata.otf');
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Place the camera at the top-center.
   *   cam.setPosition(0, -400, 800);
   *
   *   // Point the camera at the origin.
   *   cam.lookAt(0, 0, 0);
   *
   *   // Set the camera.
   *   setCamera(cam);
   *
   *   describe(
   *     'A white cube on a gray background. The text "eyeY: -400" is written in black beneath it.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the box.
   *   fill(255);
   *
   *   // Draw the box.
   *   box();
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *   textFont(font);
   *   fill(0);
   *
   *   // Display the value of eyeY, rounded to the nearest integer.
   *   text(`eyeY: ${round(cam.eyeY)}`, 0, 45);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let cam;
   * let font;
   *
   * async function setup() {
   *   // Load a font and create a p5.Font object.
   *   font = await loadFont('assets/inconsolata.otf');
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Set the camera
   *   setCamera(cam);
   *
   *   // Place the camera at the top-center.
   *   cam.setPosition(0, -400, 800);
   *
   *   // Point the camera at the origin.
   *   cam.lookAt(0, 0, 0);
   *
   *   describe(
   *     'A white cube on a gray background. The cube appears to move up and down as the camera moves. The text "eyeY: Y" is written in black beneath the cube. Y oscillates between -374 and -425.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the box.
   *   fill(255);
   *
   *   // Draw the box.
   *   box();
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *   textFont(font);
   *   fill(0);
   *
   *   // Calculate the new y-coordinate.
   *   let y = 25 * sin(frameCount * 0.01) - 400;
   *
   *   // Set the camera's position.
   *   cam.setPosition(0, y, 800);
   *
   *   // Display the value of eyeY, rounded to the nearest integer.
   *   text(`eyeY: ${round(cam.eyeY)}`, 0, 45);
   * }
   * </code>
   * </div>
   */
  /**
   * The camera’s z-coordinate.
   *
   * By default, the camera’s z-coordinate is set to 800 in "world" space.
   *
   * @property {Number} eyeZ
   * @readonly
   *
   * @example
   * <div>
   * <code>
   * let cam;
   * let font;
   *
   * async function setup() {
   *   // Load a font and create a p5.Font object.
   *   font = await loadFont('assets/inconsolata.otf');
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Set the camera
   *   setCamera(cam);
   *
   *   // Place the camera at the top-center.
   *   cam.setPosition(0, -400, 800);
   *
   *   // Point the camera at the origin.
   *   cam.lookAt(0, 0, 0);
   *
   *   describe(
   *     'A white cube on a gray background. The text "eyeZ: 800" is written in black beneath it.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the box.
   *   fill(255);
   *
   *   // Draw the box.
   *   box();
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *   textFont(font);
   *   fill(0);
   *
   *   // Display the value of eyeZ, rounded to the nearest integer.
   *   text(`eyeZ: ${round(cam.eyeZ)}`, 0, 45);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let cam;
   * let font;
   *
   * async function setup() {
   *   // Load a font and create a p5.Font object.
   *   font = await loadFont('assets/inconsolata.otf');
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Set the camera
   *   setCamera(cam);
   *
   *   // Place the camera at the top-center.
   *   cam.setPosition(0, -400, 800);
   *
   *   // Point the camera at the origin.
   *   cam.lookAt(0, 0, 0);
   *
   *   describe(
   *     'A white cube on a gray background. The cube appears to move forward and back as the camera moves. The text "eyeZ: Z" is written in black beneath the cube. Z oscillates between 700 and 900.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the box.
   *   fill(255);
   *
   *   // Draw the box.
   *   box();
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *   textFont(font);
   *   fill(0);
   *
   *   // Calculate the new z-coordinate.
   *   let z = 100 * sin(frameCount * 0.01) + 800;
   *
   *   // Set the camera's position.
   *   cam.setPosition(0, -400, z);
   *
   *   // Display the value of eyeZ, rounded to the nearest integer.
   *   text(`eyeZ: ${round(cam.eyeZ)}`, 0, 45);
   * }
   * </code>
   * </div>
   */
  /**
   * The x-coordinate of the place where the camera looks.
   *
   * By default, the camera looks at the origin `(0, 0, 0)` in "world" space, so
   * `myCamera.centerX` is 0.
   *
   * @property {Number} centerX
   * @readonly
   *
   * @example
   * <div>
   * <code>
   * let cam;
   * let font;
   *
   * async function setup() {
   *   // Load a font and create a p5.Font object.
   *   font = await loadFont('assets/inconsolata.otf');
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Set the camera
   *   setCamera(cam);
   *
   *   // Place the camera at the top-center.
   *   cam.setPosition(0, -400, 800);
   *
   *   // Point the camera at (10, 20, -30).
   *   cam.lookAt(10, 20, -30);
   *
   *   describe(
   *     'A white cube on a gray background. The text "centerX: 10" is written in black beneath it.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the box.
   *   fill(255);
   *
   *   // Draw the box.
   *   box();
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *   textFont(font);
   *   fill(0);
   *
   *   // Display the value of centerX, rounded to the nearest integer.
   *   text(`centerX: ${round(cam.centerX)}`, 0, 45);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let cam;
   * let font;
   *
   * async function setup() {
   *   // Load a font and create a p5.Font object.
   *   font = await loadFont('assets/inconsolata.otf');
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Set the camera
   *   setCamera(cam);
   *
   *   // Place the camera at the top-right.
   *   cam.setPosition(100, -400, 800);
   *
   *   // Point the camera at (10, 20, -30).
   *   cam.lookAt(10, 20, -30);
   *
   *   describe(
   *     'A white cube on a gray background. The cube appears to move left and right as the camera shifts its focus. The text "centerX: X" is written in black beneath the cube. X oscillates between -15 and 35.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the box.
   *   fill(255);
   *
   *   // Draw the box.
   *   box();
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *   textFont(font);
   *   fill(0);
   *
   *   // Calculate the new x-coordinate.
   *   let x = 25 * sin(frameCount * 0.01) + 10;
   *
   *   // Point the camera.
   *   cam.lookAt(x, 20, -30);
   *
   *   // Display the value of centerX, rounded to the nearest integer.
   *   text(`centerX: ${round(cam.centerX)}`, 0, 45);
   * }
   * </code>
   * </div>
   */
  /**
   * The y-coordinate of the place where the camera looks.
   *
   * By default, the camera looks at the origin `(0, 0, 0)` in "world" space, so
   * `myCamera.centerY` is 0.
   *
   * @property {Number} centerY
   * @readonly
   *
   * @example
   * <div>
   * <code>
   * let cam;
   * let font;
   *
   * async function setup() {
   *   // Load a font and create a p5.Font object.
   *   font = await loadFont('assets/inconsolata.otf');
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Set the camera
   *   setCamera(cam);
   *
   *   // Place the camera at the top-center.
   *   cam.setPosition(0, -400, 800);
   *
   *   // Point the camera at (10, 20, -30).
   *   cam.lookAt(10, 20, -30);
   *
   *   describe(
   *     'A white cube on a gray background. The text "centerY: 20" is written in black beneath it.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the box.
   *   fill(255);
   *
   *   // Draw the box.
   *   box();
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *   textFont(font);
   *   fill(0);
   *
   *   // Display the value of centerY, rounded to the nearest integer.
   *   text(`centerY: ${round(cam.centerY)}`, 0, 45);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let cam;
   * let font;
   *
   * async function setup() {
   *   // Load a font and create a p5.Font object.
   *   font = await loadFont('assets/inconsolata.otf');
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Set the camera
   *   setCamera(cam);
   *
   *   // Place the camera at the top-right.
   *   cam.setPosition(100, -400, 800);
   *
   *   // Point the camera at (10, 20, -30).
   *   cam.lookAt(10, 20, -30);
   *
   *   describe(
   *     'A white cube on a gray background. The cube appears to move up and down as the camera shifts its focus. The text "centerY: Y" is written in black beneath the cube. Y oscillates between -5 and 45.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the box.
   *   fill(255);
   *
   *   // Draw the box.
   *   box();
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *   textFont(font);
   *   fill(0);
   *
   *   // Calculate the new y-coordinate.
   *   let y = 25 * sin(frameCount * 0.01) + 20;
   *
   *   // Point the camera.
   *   cam.lookAt(10, y, -30);
   *
   *   // Display the value of centerY, rounded to the nearest integer.
   *   text(`centerY: ${round(cam.centerY)}`, 0, 45);
   * }
   * </code>
   * </div>
   */
  /**
   * The y-coordinate of the place where the camera looks.
   *
   * By default, the camera looks at the origin `(0, 0, 0)` in "world" space, so
   * `myCamera.centerZ` is 0.
   *
   * @property {Number} centerZ
   * @readonly
   *
   * @example
   * <div>
   * <code>
   * let cam;
   * let font;
   *
   * async function setup() {
   *   // Load a font and create a p5.Font object.
   *   font = await loadFont('assets/inconsolata.otf');
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Set the camera
   *   setCamera(cam);
   *
   *   // Place the camera at the top-center.
   *   cam.setPosition(0, -400, 800);
   *
   *   // Point the camera at (10, 20, -30).
   *   cam.lookAt(10, 20, -30);
   *
   *   describe(
   *     'A white cube on a gray background. The text "centerZ: -30" is written in black beneath it.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the box.
   *   fill(255);
   *
   *   // Draw the box.
   *   box();
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *   textFont(font);
   *   fill(0);
   *
   *   // Display the value of centerZ, rounded to the nearest integer.
   *   text(`centerZ: ${round(cam.centerZ)}`, 0, 45);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let cam;
   * let font;
   *
   * async function setup() {
   *   // Load a font and create a p5.Font object.
   *   font = await loadFont('assets/inconsolata.otf');
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Place the camera at the top-right.
   *   cam.setPosition(100, -400, 800);
   *
   *   // Point the camera at (10, 20, -30).
   *   cam.lookAt(10, 20, -30);
   *
   *   describe(
   *     'A white cube on a gray background. The cube appears to move forward and back as the camera shifts its focus. The text "centerZ: Z" is written in black beneath the cube. Z oscillates between -55 and -25.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the box.
   *   fill(255);
   *
   *   // Draw the box.
   *   box();
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *   textFont(font);
   *   fill(0);
   *
   *   // Calculate the new z-coordinate.
   *   let z = 25 * sin(frameCount * 0.01) - 30;
   *
   *   // Point the camera.
   *   cam.lookAt(10, 20, z);
   *
   *   // Display the value of centerZ, rounded to the nearest integer.
   *   text(`centerZ: ${round(cam.centerZ)}`, 0, 45);
   * }
   * </code>
   * </div>
   */
  /**
   * The x-component of the camera's "up" vector.
   *
   * The camera's "up" vector orients its y-axis. By default, the "up" vector is
   * `(0, 1, 0)`, so its x-component is 0 in "local" space.
   *
   * @property {Number} upX
   * @readonly
   *
   * @example
   * <div>
   * <code>
   * let cam;
   * let font;
   *
   * async function setup() {
   *   // Load a font and create a p5.Font object.
   *   font = await loadFont('assets/inconsolata.otf');
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Set the camera
   *   setCamera(cam);
   *
   *   // Place the camera at the top-right: (100, -400, 800)
   *   // Point it at the origin: (0, 0, 0)
   *   // Set its "up" vector: (0, 1, 0).
   *   cam.camera(100, -400, 800, 0, 0, 0, 0, 1, 0);
   *
   *   describe(
   *     'A white cube on a gray background. The text "upX: 0" is written in black beneath it.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the box.
   *   fill(255);
   *
   *   // Draw the box.
   *   box();
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *   textFont(font);
   *   fill(0);
   *
   *   // Display the value of upX, rounded to the nearest tenth.
   *   text(`upX: ${round(cam.upX, 1)}`, 0, 45);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let cam;
   * let font;
   *
   * async function setup() {
   *   // Load a font and create a p5.Font object.
   *   font = await loadFont('assets/inconsolata.otf');
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Set the camera
   *   setCamera(cam);
   *
   *   // Place the camera at the top-right: (100, -400, 800)
   *   // Point it at the origin: (0, 0, 0)
   *   // Set its "up" vector: (0, 1, 0).
   *   cam.camera(100, -400, 800, 0, 0, 0, 0, 1, 0);
   *
   *   describe(
   *     'A white cube on a gray background. The cube appears to rock back and forth. The text "upX: X" is written in black beneath it. X oscillates between -1 and 1.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the box.
   *   fill(255);
   *
   *   // Draw the box.
   *   box();
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *   textFont(font);
   *   fill(0);
   *
   *   // Calculate the x-component.
   *   let x = sin(frameCount * 0.01);
   *
   *   // Update the camera's "up" vector.
   *   cam.camera(100, -400, 800, 0, 0, 0, x, 1, 0);
   *
   *   // Display the value of upX, rounded to the nearest tenth.
   *   text(`upX: ${round(cam.upX, 1)}`, 0, 45);
   * }
   * </code>
   * </div>
   */
  /**
   * The y-component of the camera's "up" vector.
   *
   * The camera's "up" vector orients its y-axis. By default, the "up" vector is
   * `(0, 1, 0)`, so its y-component is 1 in "local" space.
   *
   * @property {Number} upY
   * @readonly
   *
   * @example
   * <div>
   * <code>
   * let cam;
   * let font;
   *
   * async function setup() {
   *   // Load a font and create a p5.Font object.
   *   font = await loadFont('assets/inconsolata.otf');
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Set the camera
   *   setCamera(cam);
   *
   *   // Place the camera at the top-right: (100, -400, 800)
   *   // Point it at the origin: (0, 0, 0)
   *   // Set its "up" vector: (0, 1, 0).
   *   cam.camera(100, -400, 800, 0, 0, 0, 0, 1, 0);
   *
   *   describe(
   *     'A white cube on a gray background. The text "upY: 1" is written in black beneath it.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the box.
   *   fill(255);
   *
   *   // Draw the box.
   *   box();
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *   textFont(font);
   *   fill(0);
   *
   *   // Display the value of upY, rounded to the nearest tenth.
   *   text(`upY: ${round(cam.upY, 1)}`, 0, 45);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let cam;
   * let font;
   *
   * async function setup() {
   *   // Load a font and create a p5.Font object.
   *   font = await loadFont('assets/inconsolata.otf');
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Set the camera
   *   setCamera(cam);
   *
   *   // Place the camera at the top-right: (100, -400, 800)
   *   // Point it at the origin: (0, 0, 0)
   *   // Set its "up" vector: (0, 1, 0).
   *   cam.camera(100, -400, 800, 0, 0, 0, 0, 1, 0);
   *
   *   describe(
   *     'A white cube on a gray background. The cube flips upside-down periodically. The text "upY: Y" is written in black beneath it. Y oscillates between -1 and 1.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the box.
   *   fill(255);
   *
   *   // Draw the box.
   *   box();
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *   textFont(font);
   *   fill(0);
   *
   *   // Calculate the y-component.
   *   let y = sin(frameCount * 0.01);
   *
   *   // Update the camera's "up" vector.
   *   cam.camera(100, -400, 800, 0, 0, 0, 0, y, 0);
   *
   *   // Display the value of upY, rounded to the nearest tenth.
   *   text(`upY: ${round(cam.upY, 1)}`, 0, 45);
   * }
   * </code>
   * </div>
   */
  /**
   * The z-component of the camera's "up" vector.
   *
   * The camera's "up" vector orients its y-axis. By default, the "up" vector is
   * `(0, 1, 0)`, so its z-component is 0 in "local" space.
   *
   * @property {Number} upZ
   * @readonly
   *
   * @example
   * <div>
   * <code>
   * let cam;
   * let font;
   *
   * async function setup() {
   *   // Load a font and create a p5.Font object.
   *   font = await loadFont('assets/inconsolata.otf');
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Set the camera
   *   setCamera(cam);
   *
   *   // Place the camera at the top-right: (100, -400, 800)
   *   // Point it at the origin: (0, 0, 0)
   *   // Set its "up" vector: (0, 1, 0).
   *   cam.camera(100, -400, 800, 0, 0, 0, 0, 1, 0);
   *
   *   describe(
   *     'A white cube on a gray background. The text "upZ: 0" is written in black beneath it.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the box.
   *   fill(255);
   *
   *   // Draw the box.
   *   box();
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *   textFont(font);
   *   fill(0);
   *
   *   // Display the value of upZ, rounded to the nearest tenth.
   *   text(`upZ: ${round(cam.upZ, 1)}`, 0, 45);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let cam;
   * let font;
   *
   * async function setup() {
   *   // Load a font and create a p5.Font object.
   *   font = await loadFont('assets/inconsolata.otf');
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Set the camera
   *   setCamera(cam);
   *
   *   // Place the camera at the top-right: (100, -400, 800)
   *   // Point it at the origin: (0, 0, 0)
   *   // Set its "up" vector: (0, 1, 0).
   *   cam.camera(100, -400, 800, 0, 0, 0, 0, 1, 0);
   *
   *   describe(
   *     'A white cube on a gray background. The cube appears to rock back and forth. The text "upZ: Z" is written in black beneath it. Z oscillates between -1 and 1.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the box.
   *   fill(255);
   *
   *   // Draw the box.
   *   box();
   *
   *   // Style the text.
   *   textAlign(CENTER);
   *   textSize(16);
   *   textFont(font);
   *   fill(0);
   *
   *   // Calculate the z-component.
   *   let z = sin(frameCount * 0.01);
   *
   *   // Update the camera's "up" vector.
   *   cam.camera(100, -400, 800, 0, 0, 0, 0, 1, z);
   *
   *   // Display the value of upZ, rounded to the nearest tenth.
   *   text(`upZ: ${round(cam.upZ, 1)}`, 0, 45);
   * }
   * </code>
   * </div>
   */
  ////////////////////////////////////////////////////////////////////////////////
  // Camera Projection Methods
  ////////////////////////////////////////////////////////////////////////////////
  /**
   * Sets a perspective projection for the camera.
   *
   * In a perspective projection, shapes that are further from the camera appear
   * smaller than shapes that are near the camera. This technique, called
   * foreshortening, creates realistic 3D scenes. It’s applied by default in new
   * `p5.Camera` objects.
   *
   * `myCamera.perspective()` changes the camera’s perspective by changing its
   * viewing frustum. The frustum is the volume of space that’s visible to the
   * camera. The frustum’s shape is a pyramid with its top cut off. The camera
   * is placed where the top of the pyramid should be and points towards the
   * base of the pyramid. It views everything within the frustum.
   *
   * The first parameter, `fovy`, is the camera’s vertical field of view. It’s
   * an angle that describes how tall or narrow a view the camera has. For
   * example, calling `myCamera.perspective(0.5)` sets the camera’s vertical
   * field of view to 0.5 radians. By default, `fovy` is calculated based on the
   * sketch’s height and the camera’s default z-coordinate, which is 800. The
   * formula for the default `fovy` is `2 * atan(height / 2 / 800)`.
   *
   * The second parameter, `aspect`, is the camera’s aspect ratio. It’s a number
   * that describes the ratio of the top plane’s width to its height. For
   * example, calling `myCamera.perspective(0.5, 1.5)` sets the camera’s field
   * of view to 0.5 radians and aspect ratio to 1.5, which would make shapes
   * appear thinner on a square canvas. By default, `aspect` is set to
   * `width / height`.
   *
   * The third parameter, `near`, is the distance from the camera to the near
   * plane. For example, calling `myCamera.perspective(0.5, 1.5, 100)` sets the
   * camera’s field of view to 0.5 radians, its aspect ratio to 1.5, and places
   * the near plane 100 pixels from the camera. Any shapes drawn less than 100
   * pixels from the camera won’t be visible. By default, `near` is set to
   * `0.1 * 800`, which is 1/10th the default distance between the camera and
   * the origin.
   *
   * The fourth parameter, `far`, is the distance from the camera to the far
   * plane. For example, calling `myCamera.perspective(0.5, 1.5, 100, 10000)`
   * sets the camera’s field of view to 0.5 radians, its aspect ratio to 1.5,
   * places the near plane 100 pixels from the camera, and places the far plane
   * 10,000 pixels from the camera. Any shapes drawn more than 10,000 pixels
   * from the camera won’t be visible. By default, `far` is set to `10 * 800`,
   * which is 10 times the default distance between the camera and the origin.
   *
   * @for p5.Camera
   * @param  {Number} [fovy]   camera frustum vertical field of view. Defaults to
   *                           `2 * atan(height / 2 / 800)`.
   * @param  {Number} [aspect] camera frustum aspect ratio. Defaults to
   *                           `width / height`.
   * @param  {Number} [near]   distance from the camera to the near clipping plane.
   *                           Defaults to `0.1 * 800`.
   * @param  {Number} [far]    distance from the camera to the far clipping plane.
   *                           Defaults to `10 * 800`.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to toggle between cameras.
   *
   * let cam1;
   * let cam2;
   * let isDefaultCamera = true;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the first camera.
   *   // Keep its default settings.
   *   cam1 = createCamera();
   *
   *   // Create the second camera.
   *   cam2 = createCamera();
   *
   *   // Place it at the top-right.
   *   cam2.camera(400, -400, 800);
   *
   *   // Set its fovy to 0.2.
   *   // Set its aspect to 1.5.
   *   // Set its near to 600.
   *   // Set its far to 1200.
   *   cam2.perspective(0.2, 1.5, 600, 1200);
   *
   *   // Set the current camera to cam1.
   *   setCamera(cam1);
   *
   *   describe('A white cube on a gray background. The camera toggles between a frontal view and a skewed aerial view when the user double-clicks.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Draw the box.
   *   box();
   * }
   *
   * // Toggle the current camera when the user double-clicks.
   * function doubleClicked() {
   *   if (isDefaultCamera === true) {
   *     setCamera(cam2);
   *     isDefaultCamera = false;
   *   } else {
   *     setCamera(cam1);
   *     isDefaultCamera = true;
   *   }
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Double-click to toggle between cameras.
   *
   * let cam1;
   * let cam2;
   * let isDefaultCamera = true;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the first camera.
   *   // Keep its default settings.
   *   cam1 = createCamera();
   *
   *   // Create the second camera.
   *   cam2 = createCamera();
   *
   *   // Place it at the top-right.
   *   cam2.camera(400, -400, 800);
   *
   *   // Set its fovy to 0.2.
   *   // Set its aspect to 1.5.
   *   // Set its near to 600.
   *   // Set its far to 1200.
   *   cam2.perspective(0.2, 1.5, 600, 1200);
   *
   *   // Set the current camera to cam1.
   *   setCamera(cam1);
   *
   *   describe('A white cube moves left and right on a gray background. The camera toggles between a frontal and a skewed aerial view when the user double-clicks.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Translate the origin left and right.
   *   let x = 100 * sin(frameCount * 0.01);
   *   translate(x, 0, 0);
   *
   *   // Draw the box.
   *   box();
   * }
   *
   * // Toggle the current camera when the user double-clicks.
   * function doubleClicked() {
   *   if (isDefaultCamera === true) {
   *     setCamera(cam2);
   *     isDefaultCamera = false;
   *   } else {
   *     setCamera(cam1);
   *     isDefaultCamera = true;
   *   }
   * }
   * </code>
   * </div>
   */
  perspective(fovy, aspect, near, far) {
    this.cameraType = arguments.length > 0 ? "custom" : "default";
    if (typeof fovy === "undefined") {
      fovy = this.defaultCameraFOV;
      this.cameraFOV = fovy;
    } else {
      this.cameraFOV = this._renderer._pInst._toRadians(fovy);
    }
    if (typeof aspect === "undefined") {
      aspect = this.defaultAspectRatio;
    }
    if (typeof near === "undefined") {
      near = this.defaultCameraNear;
    }
    if (typeof far === "undefined") {
      far = this.defaultCameraFar;
    }
    if (near <= 1e-4) {
      near = 0.01;
      console.log(
        "Avoid perspective near plane values close to or below 0. Setting value to 0.01."
      );
    }
    if (far < near) {
      console.log(
        "Perspective far plane value is less than near plane value. Nothing will be shown."
      );
    }
    this.aspectRatio = aspect;
    this.cameraNear = near;
    this.cameraFar = far;
    this.projMatrix = new Matrix(4);
    const f = 1 / Math.tan(this.cameraFOV / 2);
    const nf = 1 / (this.cameraNear - this.cameraFar);
    this.projMatrix.set(
      f / aspect,
      0,
      0,
      0,
      0,
      -f * this.yScale,
      0,
      0,
      0,
      0,
      (far + near) * nf,
      -1,
      0,
      0,
      2 * far * near * nf,
      0
    );
    if (this._isActive()) {
      this._renderer.states.setValue("uPMatrix", this._renderer.states.uPMatrix.clone());
      this._renderer.states.uPMatrix.set(this.projMatrix);
    }
  }
  /**
   * Sets an orthographic projection for the camera.
   *
   * In an orthographic projection, shapes with the same size always appear the
   * same size, regardless of whether they are near or far from the camera.
   *
   * `myCamera.ortho()` changes the camera’s perspective by changing its viewing
   * frustum from a truncated pyramid to a rectangular prism. The frustum is the
   * volume of space that’s visible to the camera. The camera is placed in front
   * of the frustum and views everything within the frustum. `myCamera.ortho()`
   * has six optional parameters to define the viewing frustum.
   *
   * The first four parameters, `left`, `right`, `bottom`, and `top`, set the
   * coordinates of the frustum’s sides, bottom, and top. For example, calling
   * `myCamera.ortho(-100, 100, 200, -200)` creates a frustum that’s 200 pixels
   * wide and 400 pixels tall. By default, these dimensions are set based on
   * the sketch’s width and height, as in
   * `myCamera.ortho(-width / 2, width / 2, -height / 2, height / 2)`.
   *
   * The last two parameters, `near` and `far`, set the distance of the
   * frustum’s near and far plane from the camera. For example, calling
   * `myCamera.ortho(-100, 100, 200, -200, 50, 1000)` creates a frustum that’s
   * 200 pixels wide, 400 pixels tall, starts 50 pixels from the camera, and
   * ends 1,000 pixels from the camera. By default, `near` and `far` are set to
   * 0 and `max(width, height) + 800`, respectively.
   *
   * @for p5.Camera
   * @param  {Number} [left]   x-coordinate of the frustum’s left plane. Defaults to `-width / 2`.
   * @param  {Number} [right]  x-coordinate of the frustum’s right plane. Defaults to `width / 2`.
   * @param  {Number} [bottom] y-coordinate of the frustum’s bottom plane. Defaults to `height / 2`.
   * @param  {Number} [top]    y-coordinate of the frustum’s top plane. Defaults to `-height / 2`.
   * @param  {Number} [near]   z-coordinate of the frustum’s near plane. Defaults to 0.
   * @param  {Number} [far]    z-coordinate of the frustum’s far plane. Defaults to `max(width, height) + 800`.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to toggle between cameras.
   *
   * let cam1;
   * let cam2;
   * let isDefaultCamera = true;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the first camera.
   *   // Keep its default settings.
   *   cam1 = createCamera();
   *
   *   // Create the second camera.
   *   cam2 = createCamera();
   *
   *   // Apply an orthographic projection.
   *   cam2.ortho();
   *
   *   // Set the current camera to cam1.
   *   setCamera(cam1);
   *
   *   describe('A row of white cubes against a gray background. The camera toggles between a perspective and an orthographic projection when the user double-clicks.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Translate the origin toward the camera.
   *   translate(-10, 10, 500);
   *
   *   // Rotate the coordinate system.
   *   rotateY(-0.1);
   *   rotateX(-0.1);
   *
   *   // Draw the row of boxes.
   *   for (let i = 0; i < 6; i += 1) {
   *     translate(0, 0, -40);
   *     box(10);
   *   }
   * }
   *
   * // Toggle the current camera when the user double-clicks.
   * function doubleClicked() {
   *   if (isDefaultCamera === true) {
   *     setCamera(cam2);
   *     isDefaultCamera = false;
   *   } else {
   *     setCamera(cam1);
   *     isDefaultCamera = true;
   *   }
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Double-click to toggle between cameras.
   *
   * let cam1;
   * let cam2;
   * let isDefaultCamera = true;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the first camera.
   *   // Keep its default settings.
   *   cam1 = createCamera();
   *
   *   // Create the second camera.
   *   cam2 = createCamera();
   *
   *   // Apply an orthographic projection.
   *   cam2.ortho();
   *
   *   // Set the current camera to cam1.
   *   setCamera(cam1);
   *
   *   describe('A row of white cubes slither like a snake against a gray background. The camera toggles between a perspective and an orthographic projection when the user double-clicks.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Translate the origin toward the camera.
   *   translate(-10, 10, 500);
   *
   *   // Rotate the coordinate system.
   *   rotateY(-0.1);
   *   rotateX(-0.1);
   *
   *   // Draw the row of boxes.
   *   for (let i = 0; i < 6; i += 1) {
   *     push();
   *     // Calculate the box's coordinates.
   *     let x = 10 * sin(frameCount * 0.02 + i * 0.6);
   *     let z = -40 * i;
   *     // Translate the origin.
   *     translate(x, 0, z);
   *     // Draw the box.
   *     box(10);
   *     pop();
   *   }
   * }
   *
   * // Toggle the current camera when the user double-clicks.
   * function doubleClicked() {
   *   if (isDefaultCamera === true) {
   *     setCamera(cam2);
   *     isDefaultCamera = false;
   *   } else {
   *     setCamera(cam1);
   *     isDefaultCamera = true;
   *   }
   * }
   * </code>
   * </div>
   */
  ortho(left, right, bottom, top, near, far) {
    const source = this.fbo || this._renderer;
    if (left === void 0) left = -source.width / 2;
    if (right === void 0) right = +source.width / 2;
    if (bottom === void 0) bottom = -source.height / 2;
    if (top === void 0) top = +source.height / 2;
    if (near === void 0) near = 0;
    if (far === void 0) far = Math.max(source.width, source.height) + 800;
    this.cameraNear = near;
    this.cameraFar = far;
    const w = right - left;
    const h = top - bottom;
    const d2 = far - near;
    const x = 2 / w;
    const y = 2 / h * this.yScale;
    const z = -2 / d2;
    const tx = -(right + left) / w;
    const ty = -(top + bottom) / h;
    const tz = -(far + near) / d2;
    this.projMatrix = new Matrix(4);
    this.projMatrix.set(
      x,
      0,
      0,
      0,
      0,
      -y,
      0,
      0,
      0,
      0,
      z,
      0,
      tx,
      ty,
      tz,
      1
    );
    if (this._isActive()) {
      this._renderer.states.setValue("uPMatrix", this._renderer.states.uPMatrix.clone());
      this._renderer.states.uPMatrix.set(this.projMatrix);
    }
    this.cameraType = "custom";
  }
  /**
   * Sets the camera's frustum.
   *
   * In a frustum projection, shapes that are further from the camera appear
   * smaller than shapes that are near the camera. This technique, called
   * foreshortening, creates realistic 3D scenes.
   *
   * `myCamera.frustum()` changes the camera’s perspective by changing its
   * viewing frustum. The frustum is the volume of space that’s visible to the
   * camera. The frustum’s shape is a pyramid with its top cut off. The camera
   * is placed where the top of the pyramid should be and points towards the
   * base of the pyramid. It views everything within the frustum.
   *
   * The first four parameters, `left`, `right`, `bottom`, and `top`, set the
   * coordinates of the frustum’s sides, bottom, and top. For example, calling
   * `myCamera.frustum(-100, 100, 200, -200)` creates a frustum that’s 200
   * pixels wide and 400 pixels tall. By default, these coordinates are set
   * based on the sketch’s width and height, as in
   * `myCamera.frustum(-width / 20, width / 20, height / 20, -height / 20)`.
   *
   * The last two parameters, `near` and `far`, set the distance of the
   * frustum’s near and far plane from the camera. For example, calling
   * `myCamera.frustum(-100, 100, 200, -200, 50, 1000)` creates a frustum that’s
   * 200 pixels wide, 400 pixels tall, starts 50 pixels from the camera, and ends
   * 1,000 pixels from the camera. By default, near is set to `0.1 * 800`, which
   * is 1/10th the default distance between the camera and the origin. `far` is
   * set to `10 * 800`, which is 10 times the default distance between the
   * camera and the origin.
   *
   * @for p5.Camera
   * @param  {Number} [left]   x-coordinate of the frustum’s left plane. Defaults to `-width / 20`.
   * @param  {Number} [right]  x-coordinate of the frustum’s right plane. Defaults to `width / 20`.
   * @param  {Number} [bottom] y-coordinate of the frustum’s bottom plane. Defaults to `height / 20`.
   * @param  {Number} [top]    y-coordinate of the frustum’s top plane. Defaults to `-height / 20`.
   * @param  {Number} [near]   z-coordinate of the frustum’s near plane. Defaults to `0.1 * 800`.
   * @param  {Number} [far]    z-coordinate of the frustum’s far plane. Defaults to `10 * 800`.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to toggle between cameras.
   *
   * let cam1;
   * let cam2;
   * let isDefaultCamera = true;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the first camera.
   *   // Keep its default settings.
   *   cam1 = createCamera();
   *
   *   // Create the second camera.
   *   cam2 = createCamera();
   *
   *   // Adjust the frustum.
   *   // Center it.
   *   // Set its width and height to 20 pixels.
   *   // Place its near plane 300 pixels from the camera.
   *   // Place its far plane 350 pixels from the camera.
   *   cam2.frustum(-10, 10, -10, 10, 300, 350);
   *
   *   // Set the current camera to cam1.
   *   setCamera(cam1);
   *
   *   describe(
   *     'A row of white cubes against a gray background. The camera zooms in on one cube when the user double-clicks.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Translate the origin toward the camera.
   *   translate(-10, 10, 600);
   *
   *   // Rotate the coordinate system.
   *   rotateY(-0.1);
   *   rotateX(-0.1);
   *
   *   // Draw the row of boxes.
   *   for (let i = 0; i < 6; i += 1) {
   *     translate(0, 0, -40);
   *     box(10);
   *   }
   * }
   *
   * // Toggle the current camera when the user double-clicks.
   * function doubleClicked() {
   *   if (isDefaultCamera === true) {
   *     setCamera(cam2);
   *     isDefaultCamera = false;
   *   } else {
   *     setCamera(cam1);
   *     isDefaultCamera = true;
   *   }
   * }
   * </code>
   * </div>
   */
  frustum(left, right, bottom, top, near, far) {
    if (left === void 0) left = -this._renderer.width * 0.05;
    if (right === void 0) right = +this._renderer.width * 0.05;
    if (bottom === void 0) bottom = +this._renderer.height * 0.05;
    if (top === void 0) top = -this._renderer.height * 0.05;
    if (near === void 0) near = this.defaultCameraNear;
    if (far === void 0) far = this.defaultCameraFar;
    this.cameraNear = near;
    this.cameraFar = far;
    const w = right - left;
    const h = top - bottom;
    const d2 = far - near;
    const x = +(2 * near) / w;
    const y = +(2 * near) / h * this.yScale;
    const z = -(2 * far * near) / d2;
    const tx = (right + left) / w;
    const ty = (top + bottom) / h;
    const tz = -(far + near) / d2;
    this.projMatrix = new Matrix(4);
    this.projMatrix.set(
      x,
      0,
      0,
      0,
      0,
      -y,
      0,
      0,
      tx,
      ty,
      tz,
      -1,
      0,
      0,
      z,
      0
    );
    if (this._isActive()) {
      this._renderer.states.setValue("uPMatrix", this._renderer.states.uPMatrix.clone());
      this._renderer.states.uPMatrix.set(this.projMatrix);
    }
    this.cameraType = "custom";
  }
  ////////////////////////////////////////////////////////////////////////////////
  // Camera Orientation Methods
  ////////////////////////////////////////////////////////////////////////////////
  /**
   * Rotate camera view about arbitrary axis defined by x,y,z
   * based on http://learnwebgl.brown37.net/07_cameras/camera_rotating_motion.html
   * @private
   */
  _rotateView(a2, x, y, z) {
    let centerX = this.centerX;
    let centerY = this.centerY;
    let centerZ = this.centerZ;
    centerX -= this.eyeX;
    centerY -= this.eyeY;
    centerZ -= this.eyeZ;
    const rotation = new Matrix(4);
    rotation.rotate4x4(this._renderer._pInst._toRadians(a2), x, y, z);
    const rotatedCenter = [
      centerX * rotation.mat4[0] + centerY * rotation.mat4[4] + centerZ * rotation.mat4[8],
      centerX * rotation.mat4[1] + centerY * rotation.mat4[5] + centerZ * rotation.mat4[9],
      centerX * rotation.mat4[2] + centerY * rotation.mat4[6] + centerZ * rotation.mat4[10]
    ];
    rotatedCenter[0] += this.eyeX;
    rotatedCenter[1] += this.eyeY;
    rotatedCenter[2] += this.eyeZ;
    this.camera(
      this.eyeX,
      this.eyeY,
      this.eyeZ,
      rotatedCenter[0],
      rotatedCenter[1],
      rotatedCenter[2],
      this.upX,
      this.upY,
      this.upZ
    );
  }
  /**
   * Rotates the camera in a clockwise/counter-clockwise direction.
   *
   * Rolling rotates the camera without changing its orientation. The rotation
   * happens in the camera’s "local" space.
   *
   * The parameter, `angle`, is the angle the camera should rotate. Passing a
   * positive angle, as in `myCamera.roll(0.001)`, rotates the camera in counter-clockwise direction.
   * Passing a negative angle, as in `myCamera.roll(-0.001)`, rotates the
   * camera in clockwise direction.
   *
   * Note: Angles are interpreted based on the current
   * <a href="#/p5/angleMode">angleMode()</a>.
   *
   * @method roll
   * @param {Number} angle amount to rotate camera in current
   * <a href="#/p5/angleMode">angleMode</a> units.
   * @example
   * <div>
   * <code>
   * let cam;
   * let delta = 0.01;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *   normalMaterial();
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Set the camera
   *   setCamera(cam);
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Roll camera according to angle 'delta'
   *   cam.roll(delta);
   *
   *   translate(0, 0, 0);
   *   box(20);
   *   translate(0, 25, 0);
   *   box(20);
   *   translate(0, 26, 0);
   *   box(20);
   *   translate(0, 27, 0);
   *   box(20);
   *   translate(0, 28, 0);
   *   box(20);
   *   translate(0,29, 0);
   *   box(20);
   *   translate(0, 30, 0);
   *   box(20);
   * }
   * </code>
   * </div>
   *
   * @alt
   * camera view rotates in counter clockwise direction with vertically stacked boxes in front of it.
   */
  roll(amount) {
    const local = this._getLocalAxes();
    const axisQuaternion = Quat.fromAxisAngle(
      this._renderer._pInst._toRadians(amount),
      local.z[0],
      local.z[1],
      local.z[2]
    );
    const newUpVector = axisQuaternion.rotateVector(
      new Vector(this.upX, this.upY, this.upZ)
    );
    this.camera(
      this.eyeX,
      this.eyeY,
      this.eyeZ,
      this.centerX,
      this.centerY,
      this.centerZ,
      newUpVector.x,
      newUpVector.y,
      newUpVector.z
    );
  }
  /**
   * Rotates the camera left and right.
   *
   * Panning rotates the camera without changing its position. The rotation
   * happens in the camera’s "local" space.
   *
   * The parameter, `angle`, is the angle the camera should rotate. Passing a
   * positive angle, as in `myCamera.pan(0.001)`, rotates the camera to the
   * right. Passing a negative angle, as in `myCamera.pan(-0.001)`, rotates the
   * camera to the left.
   *
   * Note: Angles are interpreted based on the current
   * <a href="#/p5/angleMode">angleMode()</a>.
   *
   * @param {Number} angle amount to rotate in the current
   *                       <a href="#/p5/angleMode">angleMode()</a>.
   *
   * @example
   * <div>
   * <code>
   * let cam;
   * let delta = 0.001;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Set the camera
   *   setCamera(cam);
   *
   *   // Place the camera at the top-center.
   *   cam.setPosition(0, -400, 800);
   *
   *   // Point the camera at the origin.
   *   cam.lookAt(0, 0, 0);
   *
   *   describe(
   *     'A white cube on a gray background. The cube goes in and out of view as the camera pans left and right.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Pan with the camera.
   *   cam.pan(delta);
   *
   *   // Switch directions every 120 frames.
   *   if (frameCount % 120 === 0) {
   *     delta *= -1;
   *   }
   *
   *   // Draw the box.
   *   box();
   * }
   * </code>
   * </div>
   */
  pan(amount) {
    const local = this._getLocalAxes();
    this._rotateView(amount, local.y[0], local.y[1], local.y[2]);
  }
  /**
   * Rotates the camera up and down.
   *
   * Tilting rotates the camera without changing its position. The rotation
   * happens in the camera’s "local" space.
   *
   * The parameter, `angle`, is the angle the camera should rotate. Passing a
   * positive angle, as in `myCamera.tilt(0.001)`, rotates the camera down.
   * Passing a negative angle, as in `myCamera.tilt(-0.001)`, rotates the camera
   * up.
   *
   * Note: Angles are interpreted based on the current
   * <a href="#/p5/angleMode">angleMode()</a>.
   *
   * @param {Number} angle amount to rotate in the current
   *                       <a href="#/p5/angleMode">angleMode()</a>.
   *
   * @example
   * <div>
   * <code>
   * let cam;
   * let delta = 0.001;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Set the camera
   *   setCamera(cam);
   *
   *   // Place the camera at the top-center.
   *   cam.setPosition(0, -400, 800);
   *
   *   // Point the camera at the origin.
   *   cam.lookAt(0, 0, 0);
   *
   *   describe(
   *     'A white cube on a gray background. The cube goes in and out of view as the camera tilts up and down.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Pan with the camera.
   *   cam.tilt(delta);
   *
   *   // Switch directions every 120 frames.
   *   if (frameCount % 120 === 0) {
   *     delta *= -1;
   *   }
   *
   *   // Draw the box.
   *   box();
   * }
   * </code>
   * </div>
   */
  tilt(amount) {
    const local = this._getLocalAxes();
    this._rotateView(amount, local.x[0], local.x[1], local.x[2]);
  }
  /**
   * Points the camera at a location.
   *
   * `myCamera.lookAt()` changes the camera’s orientation without changing its
   * position.
   *
   * The parameters, `x`, `y`, and `z`, are the coordinates in "world" space
   * where the camera should point. For example, calling
   * `myCamera.lookAt(10, 20, 30)` points the camera at the coordinates
   * `(10, 20, 30)`.
   *
   * @for p5.Camera
   * @param {Number} x x-coordinate of the position where the camera should look in "world" space.
   * @param {Number} y y-coordinate of the position where the camera should look in "world" space.
   * @param {Number} z z-coordinate of the position where the camera should look in "world" space.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to look at a different cube.
   *
   * let cam;
   * let isLookingLeft = true;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Camera object.
   *   cam = createCamera();
   *
   *   // Set the camera
   *   setCamera(cam);
   *
   *   // Place the camera at the top-center.
   *   cam.setPosition(0, -400, 800);
   *
   *   // Point the camera at the origin.
   *   cam.lookAt(-30, 0, 0);
   *
   *   describe(
   *     'A red cube and a blue cube on a gray background. The camera switches focus between the cubes when the user double-clicks.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Draw the box on the left.
   *   push();
   *   // Translate the origin to the left.
   *   translate(-30, 0, 0);
   *   // Style the box.
   *   fill(255, 0, 0);
   *   // Draw the box.
   *   box(20);
   *   pop();
   *
   *   // Draw the box on the right.
   *   push();
   *   // Translate the origin to the right.
   *   translate(30, 0, 0);
   *   // Style the box.
   *   fill(0, 0, 255);
   *   // Draw the box.
   *   box(20);
   *   pop();
   * }
   *
   * // Change the camera's focus when the user double-clicks.
   * function doubleClicked() {
   *   if (isLookingLeft === true) {
   *     cam.lookAt(30, 0, 0);
   *     isLookingLeft = false;
   *   } else {
   *     cam.lookAt(-30, 0, 0);
   *     isLookingLeft = true;
   *   }
   * }
   * </code>
   * </div>
   */
  lookAt(x, y, z) {
    this.camera(
      this.eyeX,
      this.eyeY,
      this.eyeZ,
      x,
      y,
      z,
      this.upX,
      this.upY,
      this.upZ
    );
  }
  ////////////////////////////////////////////////////////////////////////////////
  // Camera Position Methods
  ////////////////////////////////////////////////////////////////////////////////
  /**
   * Sets the position and orientation of the camera.
   *
   * `myCamera.camera()` allows objects to be viewed from different angles. It
   * has nine parameters that are all optional.
   *
   * The first three parameters, `x`, `y`, and `z`, are the coordinates of the
   * camera’s position in "world" space. For example, calling
   * `myCamera.camera(0, 0, 0)` places the camera at the origin `(0, 0, 0)`. By
   * default, the camera is placed at `(0, 0, 800)`.
   *
   * The next three parameters, `centerX`, `centerY`, and `centerZ` are the
   * coordinates of the point where the camera faces in "world" space. For
   * example, calling `myCamera.camera(0, 0, 0, 10, 20, 30)` places the camera
   * at the origin `(0, 0, 0)` and points it at `(10, 20, 30)`. By default, the
   * camera points at the origin `(0, 0, 0)`.
   *
   * The last three parameters, `upX`, `upY`, and `upZ` are the components of
   * the "up" vector in "local" space. The "up" vector orients the camera’s
   * y-axis. For example, calling
   * `myCamera.camera(0, 0, 0, 10, 20, 30, 0, -1, 0)` places the camera at the
   * origin `(0, 0, 0)`, points it at `(10, 20, 30)`, and sets the "up" vector
   * to `(0, -1, 0)` which is like holding it upside-down. By default, the "up"
   * vector is `(0, 1, 0)`.
   *
   * @for p5.Camera
   * @param  {Number} [x]        x-coordinate of the camera. Defaults to 0.
   * @param  {Number} [y]        y-coordinate of the camera. Defaults to 0.
   * @param  {Number} [z]        z-coordinate of the camera. Defaults to 800.
   * @param  {Number} [centerX]  x-coordinate of the point the camera faces. Defaults to 0.
   * @param  {Number} [centerY]  y-coordinate of the point the camera faces. Defaults to 0.
   * @param  {Number} [centerZ]  z-coordinate of the point the camera faces. Defaults to 0.
   * @param  {Number} [upX]      x-component of the camera’s "up" vector. Defaults to 0.
   * @param  {Number} [upY]      x-component of the camera’s "up" vector. Defaults to 1.
   * @param  {Number} [upZ]      z-component of the camera’s "up" vector. Defaults to 0.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to toggle between cameras.
   *
   * let cam1;
   * let cam2;
   * let isDefaultCamera = true;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the first camera.
   *   // Keep its default settings.
   *   cam1 = createCamera();
   *
   *   // Create the second camera.
   *   cam2 = createCamera();
   *
   *   // Place it at the top-right: (1200, -600, 100)
   *   // Point it at the row of boxes: (-10, -10, 400)
   *   // Set its "up" vector to the default: (0, 1, 0)
   *   cam2.camera(1200, -600, 100, -10, -10, 400, 0, 1, 0);
   *
   *   // Set the current camera to cam1.
   *   setCamera(cam1);
   *
   *   describe(
   *     'A row of white cubes against a gray background. The camera toggles between a frontal and an aerial view when the user double-clicks.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Translate the origin toward the camera.
   *   translate(-10, 10, 500);
   *
   *   // Rotate the coordinate system.
   *   rotateY(-0.1);
   *   rotateX(-0.1);
   *
   *   // Draw the row of boxes.
   *   for (let i = 0; i < 6; i += 1) {
   *     translate(0, 0, -30);
   *     box(10);
   *   }
   * }
   *
   * // Toggle the current camera when the user double-clicks.
   * function doubleClicked() {
   *   if (isDefaultCamera === true) {
   *     setCamera(cam2);
   *     isDefaultCamera = false;
   *   } else {
   *     setCamera(cam1);
   *     isDefaultCamera = true;
   *   }
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Double-click to toggle between cameras.
   *
   * let cam1;
   * let cam2;
   * let isDefaultCamera = true;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the first camera.
   *   // Keep its default settings.
   *   cam1 = createCamera();
   *
   *   // Create the second camera.
   *   cam2 = createCamera();
   *
   *   // Place it at the right: (1200, 0, 100)
   *   // Point it at the row of boxes: (-10, -10, 400)
   *   // Set its "up" vector to the default: (0, 1, 0)
   *   cam2.camera(1200, 0, 100, -10, -10, 400, 0, 1, 0);
   *
   *   // Set the current camera to cam1.
   *   setCamera(cam1);
   *
   *   describe(
   *     'A row of white cubes against a gray background. The camera toggles between a static frontal view and an orbiting view when the user double-clicks.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Update cam2's position.
   *   let x = 1200 * cos(frameCount * 0.01);
   *   let y = -600 * sin(frameCount * 0.01);
   *   cam2.camera(x, y, 100, -10, -10, 400, 0, 1, 0);
   *
   *   // Translate the origin toward the camera.
   *   translate(-10, 10, 500);
   *
   *   // Rotate the coordinate system.
   *   rotateY(-0.1);
   *   rotateX(-0.1);
   *
   *   // Draw the row of boxes.
   *   for (let i = 0; i < 6; i += 1) {
   *     translate(0, 0, -30);
   *     box(10);
   *   }
   * }
   *
   * // Toggle the current camera when the user double-clicks.
   * function doubleClicked() {
   *   if (isDefaultCamera === true) {
   *     setCamera(cam2);
   *     isDefaultCamera = false;
   *   } else {
   *     setCamera(cam1);
   *     isDefaultCamera = true;
   *   }
   * }
   * </code>
   * </div>
   */
  camera(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {
    if (typeof eyeX === "undefined") {
      eyeX = this.defaultEyeX;
      eyeY = this.defaultEyeY;
      eyeZ = this.defaultEyeZ;
      centerX = eyeX;
      centerY = eyeY;
      centerZ = 0;
      upX = 0;
      upY = 1;
      upZ = 0;
    }
    this.eyeX = eyeX;
    this.eyeY = eyeY;
    this.eyeZ = eyeZ;
    if (typeof centerX !== "undefined") {
      this.centerX = centerX;
      this.centerY = centerY;
      this.centerZ = centerZ;
    }
    if (typeof upX !== "undefined") {
      this.upX = upX;
      this.upY = upY;
      this.upZ = upZ;
    }
    const local = this._getLocalAxes();
    this.cameraMatrix.set(
      local.x[0],
      local.y[0],
      local.z[0],
      0,
      local.x[1],
      local.y[1],
      local.z[1],
      0,
      local.x[2],
      local.y[2],
      local.z[2],
      0,
      0,
      0,
      0,
      1
    );
    const tx = -eyeX;
    const ty = -eyeY;
    const tz = -eyeZ;
    this.cameraMatrix.translate([tx, ty, tz]);
    if (this._isActive()) {
      this._renderer.states.setValue("uViewMatrix", this._renderer.states.uViewMatrix.clone());
      this._renderer.states.uViewMatrix.set(this.cameraMatrix);
    }
    return this;
  }
  /**
   * Moves the camera along its "local" axes without changing its orientation.
   *
   * The parameters, `x`, `y`, and `z`, are the distances the camera should
   * move. For example, calling `myCamera.move(10, 20, 30)` moves the camera 10
   * pixels to the right, 20 pixels down, and 30 pixels backward in its "local"
   * space.
   *
   * @param {Number} x distance to move along the camera’s "local" x-axis.
   * @param {Number} y distance to move along the camera’s "local" y-axis.
   * @param {Number} z distance to move along the camera’s "local" z-axis.
   * @example
   * <div>
   * <code>
   * // Click the canvas to begin detecting key presses.
   *
   * let cam;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the first camera.
   *   // Keep its default settings.
   *   cam = createCamera();
   *
   *   // Place the camera at the top-right.
   *   cam.setPosition(400, -400, 800);
   *
   *   // Point it at the origin.
   *   cam.lookAt(0, 0, 0);
   *
   *   // Set the camera.
   *   setCamera(cam);
   *
   *   describe(
   *     'A white cube drawn against a gray background. The cube appears to move when the user presses certain keys.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Move the camera along its "local" axes
   *   // when the user presses certain keys.
   *
   *   // Move horizontally.
   *   if (keyIsDown(LEFT_ARROW)) {
   *     cam.move(-1, 0, 0);
   *   }
   *   if (keyIsDown(RIGHT_ARROW)) {
   *     cam.move(1, 0, 0);
   *   }
   *
   *   // Move vertically.
   *   if (keyIsDown(UP_ARROW)) {
   *     cam.move(0, -1, 0);
   *   }
   *   if (keyIsDown(DOWN_ARROW)) {
   *     cam.move(0, 1, 0);
   *   }
   *
   *   // Move in/out of the screen.
   *   if (keyIsDown('i')) {
   *     cam.move(0, 0, -1);
   *   }
   *   if (keyIsDown('o')) {
   *     cam.move(0, 0, 1);
   *   }
   *
   *   // Draw the box.
   *   box();
   * }
   * </code>
   * </div>
   */
  move(x, y, z) {
    const local = this._getLocalAxes();
    const dx = [local.x[0] * x, local.x[1] * x, local.x[2] * x];
    const dy = [local.y[0] * y, local.y[1] * y, local.y[2] * y];
    const dz = [local.z[0] * z, local.z[1] * z, local.z[2] * z];
    this.camera(
      this.eyeX + dx[0] + dy[0] + dz[0],
      this.eyeY + dx[1] + dy[1] + dz[1],
      this.eyeZ + dx[2] + dy[2] + dz[2],
      this.centerX + dx[0] + dy[0] + dz[0],
      this.centerY + dx[1] + dy[1] + dz[1],
      this.centerZ + dx[2] + dy[2] + dz[2],
      this.upX,
      this.upY,
      this.upZ
    );
  }
  /**
   * Sets the camera’s position in "world" space without changing its
   * orientation.
   *
   * The parameters, `x`, `y`, and `z`, are the coordinates where the camera
   * should be placed. For example, calling `myCamera.setPosition(10, 20, 30)`
   * places the camera at coordinates `(10, 20, 30)` in "world" space.
   *
   * @param {Number} x x-coordinate in "world" space.
   * @param {Number} y y-coordinate in "world" space.
   * @param {Number} z z-coordinate in "world" space.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to toggle between cameras.
   *
   * let cam1;
   * let cam2;
   * let isDefaultCamera = true;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the first camera.
   *   // Keep its default settings.
   *   cam1 = createCamera();
   *
   *   // Create the second camera.
   *   cam2 = createCamera();
   *
   *   // Place it closer to the origin.
   *   cam2.setPosition(0, 0, 600);
   *
   *   // Set the current camera to cam1.
   *   setCamera(cam1);
   *
   *   describe(
   *     'A row of white cubes against a gray background. The camera toggles the amount of zoom when the user double-clicks.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Translate the origin toward the camera.
   *   translate(-10, 10, 500);
   *
   *   // Rotate the coordinate system.
   *   rotateY(-0.1);
   *   rotateX(-0.1);
   *
   *   // Draw the row of boxes.
   *   for (let i = 0; i < 6; i += 1) {
   *     translate(0, 0, -30);
   *     box(10);
   *   }
   * }
   *
   * // Toggle the current camera when the user double-clicks.
   * function doubleClicked() {
   *   if (isDefaultCamera === true) {
   *     setCamera(cam2);
   *     isDefaultCamera = false;
   *   } else {
   *     setCamera(cam1);
   *     isDefaultCamera = true;
   *   }
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Double-click to toggle between cameras.
   *
   * let cam1;
   * let cam2;
   * let isDefaultCamera = true;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the first camera.
   *   // Keep its default settings.
   *   cam1 = createCamera();
   *
   *   // Create the second camera.
   *   cam2 = createCamera();
   *
   *   // Place it closer to the origin.
   *   cam2.setPosition(0, 0, 600);
   *
   *   // Set the current camera to cam1.
   *   setCamera(cam1);
   *
   *   describe(
   *     'A row of white cubes against a gray background. The camera toggles between a static view and a view that zooms in and out when the user double-clicks.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Update cam2's z-coordinate.
   *   let z = 100 * sin(frameCount * 0.01) + 700;
   *   cam2.setPosition(0, 0, z);
   *
   *   // Translate the origin toward the camera.
   *   translate(-10, 10, 500);
   *
   *   // Rotate the coordinate system.
   *   rotateY(-0.1);
   *   rotateX(-0.1);
   *
   *   // Draw the row of boxes.
   *   for (let i = 0; i < 6; i += 1) {
   *     translate(0, 0, -30);
   *     box(10);
   *   }
   * }
   *
   * // Toggle the current camera when the user double-clicks.
   * function doubleClicked() {
   *   if (isDefaultCamera === true) {
   *     setCamera(cam2);
   *     isDefaultCamera = false;
   *   } else {
   *     setCamera(cam1);
   *     isDefaultCamera = true;
   *   }
   * }
   * </code>
   * </div>
   */
  setPosition(x, y, z) {
    const diffX = x - this.eyeX;
    const diffY = y - this.eyeY;
    const diffZ = z - this.eyeZ;
    this.camera(
      x,
      y,
      z,
      this.centerX + diffX,
      this.centerY + diffY,
      this.centerZ + diffZ,
      this.upX,
      this.upY,
      this.upZ
    );
  }
  /**
   * Sets the camera’s position, orientation, and projection by copying another
   * camera.
   *
   * The parameter, `cam`, is the `p5.Camera` object to copy. For example, calling
   * `cam2.set(cam1)` will set `cam2` using `cam1`’s configuration.
   *
   * @param {p5.Camera} cam camera to copy.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to "reset" the camera zoom.
   *
   * let cam1;
   * let cam2;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the first camera.
   *   cam1 = createCamera();
   *
   *   // Place the camera at the top-right.
   *   cam1.setPosition(400, -400, 800);
   *
   *   // Point it at the origin.
   *   cam1.lookAt(0, 0, 0);
   *
   *   // Create the second camera.
   *   cam2 = createCamera();
   *
   *   // Copy cam1's configuration.
   *   cam2.set(cam1);
   *
   *   // Set the camera.
   *   setCamera(cam2);
   *
   *   describe(
   *     'A white cube drawn against a gray background. The camera slowly moves forward. The camera resets when the user double-clicks.'
   *   );
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Update cam2's position.
   *   cam2.move(0, 0, -1);
   *
   *   // Draw the box.
   *   box();
   * }
   *
   * // "Reset" the camera when the user double-clicks.
   * function doubleClicked() {
   *   cam2.set(cam1);
   * }
   */
  set(cam) {
    const keyNamesOfThePropToCopy = [
      "eyeX",
      "eyeY",
      "eyeZ",
      "centerX",
      "centerY",
      "centerZ",
      "upX",
      "upY",
      "upZ",
      "cameraFOV",
      "aspectRatio",
      "cameraNear",
      "cameraFar",
      "cameraType",
      "yScale",
      "useLinePerspective"
    ];
    for (const keyName of keyNamesOfThePropToCopy) {
      this[keyName] = cam[keyName];
    }
    this.cameraMatrix = cam.cameraMatrix.copy();
    this.projMatrix = cam.projMatrix.copy();
    if (this._isActive()) {
      this._renderer.states.setValue("uModelMatrix", this._renderer.states.uModelMatrix.clone());
      this._renderer.states.setValue("uViewMatrix", this._renderer.states.uViewMatrix.clone());
      this._renderer.states.setValue("uPMatrix", this._renderer.states.uPMatrix.clone());
      this._renderer.states.uModelMatrix.reset();
      this._renderer.states.uViewMatrix.set(this.cameraMatrix);
      this._renderer.states.uPMatrix.set(this.projMatrix);
    }
  }
  /**
   * Sets the camera’s position and orientation to values that are in-between
   * those of two other cameras.
   *
   * `myCamera.slerp()` uses spherical linear interpolation to calculate a
   * position and orientation that’s in-between two other cameras. Doing so is
   * helpful for transitioning smoothly between two perspectives.
   *
   * The first two parameters, `cam0` and `cam1`, are the `p5.Camera` objects
   * that should be used to set the current camera.
   *
   * The third parameter, `amt`, is the amount to interpolate between `cam0` and
   * `cam1`. 0.0 keeps the camera’s position and orientation equal to `cam0`’s,
   * 0.5 sets them halfway between `cam0`’s and `cam1`’s , and 1.0 sets the
   * position and orientation equal to `cam1`’s.
   *
   * For example, calling `myCamera.slerp(cam0, cam1, 0.1)` sets cam’s position
   * and orientation very close to `cam0`’s. Calling
   * `myCamera.slerp(cam0, cam1, 0.9)` sets cam’s position and orientation very
   * close to `cam1`’s.
   *
   * Note: All of the cameras must use the same projection.
   *
   * @param {p5.Camera} cam0 first camera.
   * @param {p5.Camera} cam1 second camera.
   * @param {Number} amt amount of interpolation between 0.0 (`cam0`) and 1.0 (`cam1`).
   *
   * @example
   * <div>
   * <code>
   * let cam;
   * let cam0;
   * let cam1;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create the main camera.
   *   // Keep its default settings.
   *   cam = createCamera();
   *
   *   // Create the first camera.
   *   // Keep its default settings.
   *   cam0 = createCamera();
   *
   *   // Create the second camera.
   *   cam1 = createCamera();
   *
   *   // Place it at the top-right.
   *   cam1.setPosition(400, -400, 800);
   *
   *   // Point it at the origin.
   *   cam1.lookAt(0, 0, 0);
   *
   *   // Set the current camera to cam.
   *   setCamera(cam);
   *
   *   describe('A white cube drawn against a gray background. The camera slowly oscillates between a frontal view and an aerial view.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Calculate the amount to interpolate between cam0 and cam1.
   *   let amt = 0.5 * sin(frameCount * 0.01) + 0.5;
   *
   *   // Update the main camera's position and orientation.
   *   cam.slerp(cam0, cam1, amt);
   *
   *   box();
   * }
   * </code>
   * </div>
   */
  slerp(cam0, cam1, amt) {
    if (amt === 0) {
      this.set(cam0);
      return;
    } else if (amt === 1) {
      this.set(cam1);
      return;
    }
    if (this.projMatrix.mat4[15] !== 0) {
      this.projMatrix.setElement(
        0,
        cam0.projMatrix.mat4[0] * Math.pow(cam1.projMatrix.mat4[0] / cam0.projMatrix.mat4[0], amt)
      );
      this.projMatrix.setElement(
        5,
        cam0.projMatrix.mat4[5] * Math.pow(cam1.projMatrix.mat4[5] / cam0.projMatrix.mat4[5], amt)
      );
      if (this._isActive()) {
        this._renderer.states.setValue("uPMatrix", this._renderer.states.uPMatrix.clone());
        this._renderer.states.uPMatrix.mat4 = this.projMatrix.mat4.slice();
      }
    }
    const eye0 = new Vector(cam0.eyeX, cam0.eyeY, cam0.eyeZ);
    const eye1 = new Vector(cam1.eyeX, cam1.eyeY, cam1.eyeZ);
    const center0 = new Vector(cam0.centerX, cam0.centerY, cam0.centerZ);
    const center1 = new Vector(cam1.centerX, cam1.centerY, cam1.centerZ);
    const dist0 = Vector.dist(eye0, center0);
    const dist1 = Vector.dist(eye1, center1);
    const lerpedDist = dist0 * Math.pow(dist1 / dist0, amt);
    const eyeDiff = Vector.sub(eye0, eye1);
    const diffDiff = eye0.copy().sub(eye1).sub(center0).add(center1);
    const divider = diffDiff.magSq();
    let ratio = 1;
    if (divider > 1e-6) {
      ratio = Vector.dot(eyeDiff, diffDiff) / divider;
      ratio = Math.max(0, Math.min(ratio, 1));
    }
    const lerpedMedium = Vector.lerp(
      Vector.lerp(eye0, center0, ratio),
      Vector.lerp(eye1, center1, ratio),
      amt
    );
    const rotMat0 = cam0.cameraMatrix.createSubMatrix3x3();
    const rotMat1 = cam1.cameraMatrix.createSubMatrix3x3();
    const front0 = rotMat0.row(2);
    const front1 = rotMat1.row(2);
    const up0 = rotMat0.row(1);
    const up1 = rotMat1.row(1);
    const newFront = new Vector();
    const newUp = new Vector();
    const newEye = new Vector();
    const newCenter = new Vector();
    const deltaRot = rotMat1.mult(rotMat0.copy().transpose());
    const diag = deltaRot.diagonal();
    let cosTheta = 0.5 * (diag[0] + diag[1] + diag[2] - 1);
    if (1 - cosTheta < 1e-7) {
      newFront.set(Vector.lerp(front0, front1, amt)).normalize();
      newEye.set(newFront).mult(ratio * lerpedDist).add(lerpedMedium);
      newCenter.set(newFront).mult((ratio - 1) * lerpedDist).add(lerpedMedium);
      newUp.set(Vector.lerp(up0, up1, amt)).normalize();
      this.camera(
        newEye.x,
        newEye.y,
        newEye.z,
        newCenter.x,
        newCenter.y,
        newCenter.z,
        newUp.x,
        newUp.y,
        newUp.z
      );
      return;
    }
    let a2, b3, c4, sinTheta;
    let invOneMinusCosTheta = 1 / (1 - cosTheta);
    const maxDiag = Math.max(diag[0], diag[1], diag[2]);
    const offDiagSum13 = deltaRot.mat3[1] + deltaRot.mat3[3];
    const offDiagSum26 = deltaRot.mat3[2] + deltaRot.mat3[6];
    const offDiagSum57 = deltaRot.mat3[5] + deltaRot.mat3[7];
    if (maxDiag === diag[0]) {
      a2 = Math.sqrt((diag[0] - cosTheta) * invOneMinusCosTheta);
      invOneMinusCosTheta /= a2;
      b3 = 0.5 * offDiagSum13 * invOneMinusCosTheta;
      c4 = 0.5 * offDiagSum26 * invOneMinusCosTheta;
      sinTheta = 0.5 * (deltaRot.mat3[7] - deltaRot.mat3[5]) / a2;
    } else if (maxDiag === diag[1]) {
      b3 = Math.sqrt((diag[1] - cosTheta) * invOneMinusCosTheta);
      invOneMinusCosTheta /= b3;
      c4 = 0.5 * offDiagSum57 * invOneMinusCosTheta;
      a2 = 0.5 * offDiagSum13 * invOneMinusCosTheta;
      sinTheta = 0.5 * (deltaRot.mat3[2] - deltaRot.mat3[6]) / b3;
    } else {
      c4 = Math.sqrt((diag[2] - cosTheta) * invOneMinusCosTheta);
      invOneMinusCosTheta /= c4;
      a2 = 0.5 * offDiagSum26 * invOneMinusCosTheta;
      b3 = 0.5 * offDiagSum57 * invOneMinusCosTheta;
      sinTheta = 0.5 * (deltaRot.mat3[3] - deltaRot.mat3[1]) / c4;
    }
    const angle = amt * Math.atan2(sinTheta, cosTheta);
    const cosAngle = Math.cos(angle);
    const sinAngle = Math.sin(angle);
    const oneMinusCosAngle = 1 - cosAngle;
    const ab = a2 * b3;
    const bc = b3 * c4;
    const ca = c4 * a2;
    const lerpedRotMat = new Matrix([
      cosAngle + oneMinusCosAngle * a2 * a2,
      oneMinusCosAngle * ab + sinAngle * c4,
      oneMinusCosAngle * ca - sinAngle * b3,
      oneMinusCosAngle * ab - sinAngle * c4,
      cosAngle + oneMinusCosAngle * b3 * b3,
      oneMinusCosAngle * bc + sinAngle * a2,
      oneMinusCosAngle * ca + sinAngle * b3,
      oneMinusCosAngle * bc - sinAngle * a2,
      cosAngle + oneMinusCosAngle * c4 * c4
    ]);
    lerpedRotMat.multiplyVec(front0, newFront);
    newEye.set(newFront).mult(ratio * lerpedDist).add(lerpedMedium);
    newCenter.set(newFront).mult((ratio - 1) * lerpedDist).add(lerpedMedium);
    lerpedRotMat.multiplyVec(up0, newUp);
    this.camera(
      newEye.x,
      newEye.y,
      newEye.z,
      newCenter.x,
      newCenter.y,
      newCenter.z,
      newUp.x,
      newUp.y,
      newUp.z
    );
  }
  ////////////////////////////////////////////////////////////////////////////////
  // Camera Helper Methods
  ////////////////////////////////////////////////////////////////////////////////
  // @TODO: combine this function with _setDefaultCamera to compute these values
  // as-needed
  _computeCameraDefaultSettings() {
    this.defaultAspectRatio = this._renderer.width / this._renderer.height;
    this.defaultEyeX = 0;
    this.defaultEyeY = 0;
    this.defaultEyeZ = 800;
    this.defaultCameraFOV = 2 * Math.atan(this._renderer.height / 2 / this.defaultEyeZ);
    this.defaultCenterX = 0;
    this.defaultCenterY = 0;
    this.defaultCenterZ = 0;
    this.defaultCameraNear = this.defaultEyeZ * 0.1;
    this.defaultCameraFar = this.defaultEyeZ * 10;
  }
  //detect if user didn't set the camera
  //then call this function below
  _setDefaultCamera() {
    this.cameraFOV = this.defaultCameraFOV;
    this.aspectRatio = this.defaultAspectRatio;
    this.eyeX = this.defaultEyeX;
    this.eyeY = this.defaultEyeY;
    this.eyeZ = this.defaultEyeZ;
    this.centerX = this.defaultCenterX;
    this.centerY = this.defaultCenterY;
    this.centerZ = this.defaultCenterZ;
    this.upX = 0;
    this.upY = 1;
    this.upZ = 0;
    this.cameraNear = this.defaultCameraNear;
    this.cameraFar = this.defaultCameraFar;
    this.perspective();
    this.camera();
    this.cameraType = "default";
  }
  _resize() {
    if (this.cameraType === "default") {
      this._computeCameraDefaultSettings();
      this.cameraFOV = this.defaultCameraFOV;
      this.aspectRatio = this.defaultAspectRatio;
      this.perspective();
    }
  }
  /**
   * Returns a copy of a camera.
   * @private
   */
  copy() {
    const _cam = new _Camera(this._renderer);
    _cam.cameraFOV = this.cameraFOV;
    _cam.aspectRatio = this.aspectRatio;
    _cam.eyeX = this.eyeX;
    _cam.eyeY = this.eyeY;
    _cam.eyeZ = this.eyeZ;
    _cam.centerX = this.centerX;
    _cam.centerY = this.centerY;
    _cam.centerZ = this.centerZ;
    _cam.upX = this.upX;
    _cam.upY = this.upY;
    _cam.upZ = this.upZ;
    _cam.cameraNear = this.cameraNear;
    _cam.cameraFar = this.cameraFar;
    _cam.cameraType = this.cameraType;
    _cam.useLinePerspective = this.useLinePerspective;
    _cam.cameraMatrix = this.cameraMatrix.copy();
    _cam.projMatrix = this.projMatrix.copy();
    _cam.yScale = this.yScale;
    return _cam;
  }
  clone() {
    return this.copy();
  }
  /**
   * Returns a camera's local axes: left-right, up-down, and forward-backward,
   * as defined by vectors in world-space.
   * @private
   */
  _getLocalAxes() {
    let z0 = this.eyeX - this.centerX;
    let z1 = this.eyeY - this.centerY;
    let z2 = this.eyeZ - this.centerZ;
    const eyeDist = Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    if (eyeDist !== 0) {
      z0 /= eyeDist;
      z1 /= eyeDist;
      z2 /= eyeDist;
    }
    let y0 = this.upX;
    let y1 = this.upY;
    let y2 = this.upZ;
    let x0 = y1 * z2 - y2 * z1;
    let x1 = -y0 * z2 + y2 * z0;
    let x2 = y0 * z1 - y1 * z0;
    y0 = z1 * x2 - z2 * x1;
    y1 = -z0 * x2 + z2 * x0;
    y2 = z0 * x1 - z1 * x0;
    const xmag = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (xmag !== 0) {
      x0 /= xmag;
      x1 /= xmag;
      x2 /= xmag;
    }
    const ymag = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (ymag !== 0) {
      y0 /= ymag;
      y1 /= ymag;
      y2 /= ymag;
    }
    return {
      x: [x0, x1, x2],
      y: [y0, y1, y2],
      z: [z0, z1, z2]
    };
  }
  /**
   * Orbits the camera about center point. For use with orbitControl().
   * @private
   * @param {Number} dTheta change in spherical coordinate theta
   * @param {Number} dPhi change in spherical coordinate phi
   * @param {Number} dRadius change in radius
   */
  _orbit(dTheta, dPhi, dRadius) {
    const diffX = this.eyeX - this.centerX;
    const diffY = this.eyeY - this.centerY;
    const diffZ = this.eyeZ - this.centerZ;
    let camRadius = Math.hypot(diffX, diffY, diffZ);
    const front = new Vector(diffX, diffY, diffZ).normalize();
    const up = new Vector(this.upX, this.upY, this.upZ).normalize();
    const side = Vector.cross(up, front).normalize();
    const vertical = Vector.cross(side, up);
    camRadius *= Math.pow(10, dRadius);
    if (camRadius < this.cameraNear) {
      camRadius = this.cameraNear;
    }
    if (camRadius > this.cameraFar) {
      camRadius = this.cameraFar;
    }
    const camPhi = Math.acos(Math.max(-1, Math.min(1, Vector.dot(front, up)))) + dPhi;
    const camTheta = dTheta;
    if (camPhi <= 0 || camPhi >= Math.PI) {
      this.upX *= -1;
      this.upY *= -1;
      this.upZ *= -1;
    }
    up.mult(Math.cos(camPhi));
    vertical.mult(Math.cos(camTheta) * Math.sin(camPhi));
    side.mult(Math.sin(camTheta) * Math.sin(camPhi));
    front.set(up).add(vertical).add(side);
    this.eyeX = camRadius * front.x + this.centerX;
    this.eyeY = camRadius * front.y + this.centerY;
    this.eyeZ = camRadius * front.z + this.centerZ;
    this.camera(
      this.eyeX,
      this.eyeY,
      this.eyeZ,
      this.centerX,
      this.centerY,
      this.centerZ,
      this.upX,
      this.upY,
      this.upZ
    );
  }
  /**
   * Orbits the camera about center point. For use with orbitControl().
   * Unlike _orbit(), the direction of rotation always matches the direction of pointer movement.
   * @private
   * @param {Number} dx the x component of the rotation vector.
   * @param {Number} dy the y component of the rotation vector.
   * @param {Number} dRadius change in radius
   */
  _orbitFree(dx, dy, dRadius) {
    const diffX = this.eyeX - this.centerX;
    const diffY = this.eyeY - this.centerY;
    const diffZ = this.eyeZ - this.centerZ;
    let camRadius = Math.hypot(diffX, diffY, diffZ);
    const front = new Vector(diffX, diffY, diffZ).normalize();
    const up = new Vector(this.upX, this.upY, this.upZ);
    const side = Vector.cross(up, front).normalize();
    const down = Vector.cross(front, side);
    const directionAngle = Math.atan2(dy, dx);
    down.mult(Math.sin(directionAngle));
    side.mult(Math.cos(directionAngle)).add(down);
    const rotAngle = Math.sqrt(dx * dx + dy * dy);
    const axis = Vector.cross(front, side);
    camRadius *= Math.pow(10, dRadius);
    if (camRadius < this.cameraNear) {
      camRadius = this.cameraNear;
    }
    if (camRadius > this.cameraFar) {
      camRadius = this.cameraFar;
    }
    const c4 = Math.cos(rotAngle);
    const s = Math.sin(rotAngle);
    const dotFront = up.dot(front);
    const dotSide = up.dot(side);
    const ux = dotFront * c4 + dotSide * s;
    const uy = -dotFront * s + dotSide * c4;
    const uz = up.dot(axis);
    up.x = ux * front.x + uy * side.x + uz * axis.x;
    up.y = ux * front.y + uy * side.y + uz * axis.y;
    up.z = ux * front.z + uy * side.z + uz * axis.z;
    side.mult(-s);
    front.mult(c4).add(side).mult(camRadius);
    this.camera(
      front.x + this.centerX,
      front.y + this.centerY,
      front.z + this.centerZ,
      this.centerX,
      this.centerY,
      this.centerZ,
      up.x,
      up.y,
      up.z
    );
  }
  /**
   * Returns true if camera is currently attached to renderer.
   * @private
   */
  _isActive() {
    return this === this._renderer.states.curCamera;
  }
};
function camera(p53, fn2) {
  fn2.camera = function(...args) {
    this._assert3d("camera");
    this._renderer.camera(...args);
    return this;
  };
  fn2.perspective = function(...args) {
    this._assert3d("perspective");
    this._renderer.perspective(...args);
    return this;
  };
  fn2.linePerspective = function(enable) {
    if (!(this._renderer instanceof RendererGL)) {
      throw new Error("linePerspective() must be called in WebGL mode.");
    }
    return this._renderer.linePerspective(enable);
  };
  fn2.ortho = function(...args) {
    this._assert3d("ortho");
    this._renderer.ortho(...args);
    return this;
  };
  fn2.frustum = function(...args) {
    this._assert3d("frustum");
    this._renderer.frustum(...args);
    return this;
  };
  fn2.createCamera = function() {
    this._assert3d("createCamera");
    return this._renderer.createCamera();
  };
  fn2.setCamera = function(cam) {
    this._renderer.setCamera(cam);
  };
  p53.Camera = Camera;
  RendererGL.prototype.camera = function(...args) {
    this.states.curCamera.camera(...args);
  };
  RendererGL.prototype.perspective = function(...args) {
    this.states.curCamera.perspective(...args);
  };
  RendererGL.prototype.linePerspective = function(enable) {
    if (enable !== void 0) {
      this.states.curCamera.useLinePerspective = enable;
    } else {
      return this.states.curCamera.useLinePerspective;
    }
  };
  RendererGL.prototype.ortho = function(...args) {
    this.states.curCamera.ortho(...args);
  };
  RendererGL.prototype.frustum = function(...args) {
    this.states.curCamera.frustum(...args);
  };
  RendererGL.prototype.createCamera = function() {
    const _cam = new Camera(this);
    _cam._computeCameraDefaultSettings();
    _cam._setDefaultCamera();
    return _cam;
  };
  RendererGL.prototype.setCamera = function(cam) {
    this.states.setValue("curCamera", cam);
    this.states.setValue("uPMatrix", this.states.uPMatrix.clone());
    this.states.uPMatrix.set(cam.projMatrix);
    this.states.setValue("uViewMatrix", this.states.uViewMatrix.clone());
    this.states.uViewMatrix.set(cam.cameraMatrix);
  };
}
if (typeof p5 !== "undefined") {
  camera(p5, p5.prototype);
}
var Shader = class _Shader {
  constructor(renderer2, vertSrc, fragSrc, options2 = {}) {
    this._renderer = renderer2;
    this._vertSrc = vertSrc;
    this._fragSrc = fragSrc;
    this._vertShader = -1;
    this._fragShader = -1;
    this._glProgram = 0;
    this._loadedAttributes = false;
    this.attributes = {};
    this._loadedUniforms = false;
    this.uniforms = {};
    this._bound = false;
    this.samplers = [];
    this.hooks = {
      // These should be passed in by `.modify()` instead of being manually
      // passed in.
      // Stores uniforms + default values.
      uniforms: options2.uniforms || {},
      // Stores custom uniform + helper declarations as a string.
      declarations: options2.declarations,
      // Stores helper functions to prepend to shaders.
      helpers: options2.helpers || {},
      // Stores the hook implementations
      vertex: options2.vertex || {},
      fragment: options2.fragment || {},
      // Stores whether or not the hook implementation has been modified
      // from the default. This is supplied automatically by calling
      // yourShader.modify(...).
      modified: {
        vertex: options2.modified && options2.modified.vertex || {},
        fragment: options2.modified && options2.modified.fragment || {}
      }
    };
  }
  hookTypes(hookName) {
    let fullSrc = this._vertSrc;
    let body = this.hooks.vertex[hookName];
    if (!body) {
      body = this.hooks.fragment[hookName];
      fullSrc = this._fragSrc;
    }
    if (!body) {
      throw new Error(`Can't find hook ${hookName}!`);
    }
    const nameParts = hookName.split(/\s+/g);
    const functionName = nameParts.pop();
    const returnType = nameParts.pop();
    const returnQualifiers = [...nameParts];
    const parameterMatch = /\(([^\)]*)\)/.exec(body);
    if (!parameterMatch) {
      throw new Error(`Couldn't find function parameters in hook body:
${body}`);
    }
    const structProperties = (structName) => {
      const structDefMatch = new RegExp(`struct\\s+${structName}\\s*{([^}]*)}`).exec(fullSrc);
      if (!structDefMatch) return void 0;
      const properties = [];
      for (const defSrc of structDefMatch[1].split(";")) {
        const parts = defSrc.trim().split(/\s+|,/g);
        const typeName = parts.shift();
        const names = [...parts];
        const typeProperties = structProperties(typeName);
        for (const name of names) {
          properties.push({
            name,
            type: {
              typeName,
              qualifiers: [],
              properties: typeProperties
            }
          });
        }
      }
      return properties;
    };
    const parameters = parameterMatch[1].split(",").map((paramString) => {
      const parts = paramString.trim().split(/\s+/g);
      const name = parts.pop();
      const typeName = parts.pop();
      const qualifiers = [...parts];
      const properties = structProperties(typeName);
      return {
        name,
        type: {
          typeName,
          qualifiers,
          properties
        }
      };
    });
    return {
      name: functionName,
      returnType: {
        typeName: returnType,
        qualifiers: returnQualifiers,
        properties: structProperties(returnType)
      },
      parameters
    };
  }
  shaderSrc(src, shaderType) {
    const main = "void main";
    let [preMain, postMain] = src.split(main);
    let hooks2 = "";
    let defines = "";
    for (const key in this.hooks.uniforms) {
      hooks2 += `uniform ${key};
`;
    }
    if (this.hooks.declarations) {
      hooks2 += this.hooks.declarations + "\n";
    }
    if (this.hooks[shaderType].declarations) {
      hooks2 += this.hooks[shaderType].declarations + "\n";
    }
    for (const hookDef in this.hooks.helpers) {
      hooks2 += `${hookDef}${this.hooks.helpers[hookDef]}
`;
    }
    for (const hookDef in this.hooks[shaderType]) {
      if (hookDef === "declarations") continue;
      const [hookType, hookName] = hookDef.split(" ");
      if (this.hooks.modified[shaderType][hookDef]) {
        defines += "#define AUGMENTED_HOOK_" + hookName + "\n";
      }
      hooks2 += hookType + " HOOK_" + hookName + this.hooks[shaderType][hookDef] + "\n";
    }
    if (preMain.indexOf("#define HOOK_DEFINES") !== -1) {
      preMain = preMain.replace("#define HOOK_DEFINES", "\n" + defines + "\n");
      defines = "";
    }
    return preMain + "\n" + defines + hooks2 + main + postMain;
  }
  /**
   * Shaders are written in <a href="https://developer.mozilla.org/en-US/docs/Games/Techniques/3D_on_the_web/GLSL_Shaders">GLSL</a>, but
   * there are different versions of GLSL that it might be written in.
   *
   * Calling this method on a `p5.Shader` will return the GLSL version it uses, either `100 es` or `300 es`.
   * WebGL 1 shaders will only use `100 es`, and WebGL 2 shaders may use either.
   *
   * @returns {String} The GLSL version used by the shader.
   */
  version() {
    const match = /#version (.+)$/.exec(this.vertSrc());
    if (match) {
      return match[1];
    } else {
      return "100 es";
    }
  }
  vertSrc() {
    return this.shaderSrc(this._vertSrc, "vertex");
  }
  fragSrc() {
    return this.shaderSrc(this._fragSrc, "fragment");
  }
  /**
   * Logs the hooks available in this shader, and their current implementation.
   *
   * Each shader may let you override bits of its behavior. Each bit is called
   * a *hook.* A hook is either for the *vertex* shader, if it affects the
   * position of vertices, or in the *fragment* shader, if it affects the pixel
   * color. This method logs those values to the console, letting you know what
   * you are able to use in a call to
   * <a href="#/p5.Shader/modify">`modify()`</a>.
   *
   * For example, this shader will produce the following output:
   *
   * ```js
   * myShader = baseMaterialShader().modify({
   *   declarations: 'uniform float time;',
   *   'vec3 getWorldPosition': `(vec3 pos) {
   *     pos.y += 20. * sin(time * 0.001 + pos.x * 0.05);
   *     return pos;
   *   }`
   * });
   * myShader.inspectHooks();
   * ```
   *
   * ```
   * ==== Vertex shader hooks: ====
   * void beforeVertex() {}
   * vec3 getLocalPosition(vec3 position) { return position; }
   * [MODIFIED] vec3 getWorldPosition(vec3 pos) {
   *       pos.y += 20. * sin(time * 0.001 + pos.x * 0.05);
   *       return pos;
   *     }
   * vec3 getLocalNormal(vec3 normal) { return normal; }
   * vec3 getWorldNormal(vec3 normal) { return normal; }
   * vec2 getUV(vec2 uv) { return uv; }
   * vec4 getVertexColor(vec4 color) { return color; }
   * void afterVertex() {}
   *
   * ==== Fragment shader hooks: ====
   * void beforeFragment() {}
   * Inputs getPixelInputs(Inputs inputs) { return inputs; }
   * vec4 combineColors(ColorComponents components) {
   *                 vec4 color = vec4(0.);
   *                 color.rgb += components.diffuse * components.baseColor;
   *                 color.rgb += components.ambient * components.ambientColor;
   *                 color.rgb += components.specular * components.specularColor;
   *                 color.rgb += components.emissive;
   *                 color.a = components.opacity;
   *                 return color;
   *               }
   * vec4 getFinalColor(vec4 color) { return color; }
   * void afterFragment() {}
   * ```
   *
   * @beta
   */
  inspectHooks() {
    console.log("==== Vertex shader hooks: ====");
    for (const key in this.hooks.vertex) {
      console.log(
        (this.hooks.modified.vertex[key] ? "[MODIFIED] " : "") + key + this.hooks.vertex[key]
      );
    }
    console.log("");
    console.log("==== Fragment shader hooks: ====");
    for (const key in this.hooks.fragment) {
      console.log(
        (this.hooks.modified.fragment[key] ? "[MODIFIED] " : "") + key + this.hooks.fragment[key]
      );
    }
    console.log("");
    console.log("==== Helper functions: ====");
    for (const key in this.hooks.helpers) {
      console.log(key + this.hooks.helpers[key]);
    }
  }
  /**
   * Returns a new shader, based on the original, but with custom snippets
   * of shader code replacing default behaviour.
   *
   * Each shader may let you override bits of its behavior. Each bit is called
   * a *hook.* For example, a hook can let you adjust positions of vertices, or
   * the color of a pixel. You can inspect the different hooks available by calling
   * <a href="#/p5.Shader/inspectHooks">`yourShader.inspectHooks()`</a>. You can
   * also read the reference for the default material, normal material, color, line, and point shaders to
   * see what hooks they have available.
   *
   * `modify()` can be passed a function as a parameter. Inside, you can override hooks
   * by calling them as functions. Each hook will take in a callback that takes in inputs
   * and is expected to return an output. For example, here is a function that changes the
   * material color to red:
   *
   * ```js example
   * let myShader;
   *
   * function setup() {
   *   createCanvas(200, 200, WEBGL);
   *   myShader = baseMaterialShader().modify(() => {
   *     getPixelInputs((inputs) => {
   *       inputs.color = [inputs.texCoord, 0, 1];
   *       return inputs;
   *     });
   *   });
   * }
   *
   * function draw() {
   *   background(255);
   *   noStroke();
   *   shader(myShader); // Apply the custom shader
   *   plane(width, height); // Draw a plane with the shader applied
   * }
   * ```
   *
   * In addition to calling hooks, you can create uniforms, which are special variables
   * used to pass data from p5.js into the shader. They can be created by calling `uniform` + the
   * type of the data, such as `uniformFloat` for a number of `uniformVector2` for a two-component vector.
   * They take in a function that returns the data for the variable. You can then reference these
   * variables in your hooks, and their values will update every time you apply
   * the shader with the result of your function.
   *
   * ```js example
   * let myShader;
   *
   * function setup() {
   *   createCanvas(200, 200, WEBGL);
   *   myShader = baseMaterialShader().modify(() => {
   *     // Get the current time from p5.js
   *     let t = uniformFloat(() => millis());
   *
   *     getPixelInputs((inputs) => {
   *       inputs.color = [
   *         inputs.texCoord,
   *         sin(t * 0.01) / 2 + 0.5,
   *         1,
   *       ];
   *       return inputs;
   *     });
   *   });
   * }
   *
   * function draw() {
   *   background(255);
   *   noStroke(255);
   *   shader(myShader); // Apply the custom shader
   *   plane(width, height); // Draw a plane with the shader applied
   * }
   * ```
   *
   * p5.strands functions are special, since they get turned into a shader instead of being
   * run like the rest of your code. They only have access to p5.js functions, and variables
   * you declare inside the `modify` callback. If you need access to local variables, you
   * can pass them into `modify` with an optional second parameter, `variables`. If you are
   * using instance mode, you will need to pass your sketch object in this way.
   *
   * ```js example
   * new p5((sketch) => {
   *   let myShader;
   *
   *   sketch.setup = function() {
   *     sketch.createCanvas(200, 200, sketch.WEBGL);
   *     myShader = sketch.baseMaterialShader().modify(() => {
   *       sketch.getPixelInputs((inputs) => {
   *         inputs.color = [inputs.texCoord, 0, 1];
   *         return inputs;
   *       });
   *     }, { sketch });
   *   }
   *
   *   sketch.draw = function() {
   *     sketch.background(255);
   *     sketch.noStroke();
   *     sketch.shader(myShader); // Apply the custom shader
   *     sketch.plane(sketch.width, sketch.height); // Draw a plane with the shader applied
   *   }
   * });
   * ```
   *
   * You can also write GLSL directly in `modify` if you need direct access. To do so,
   * `modify()` takes one parameter, `hooks`, an object with the hooks you want
   * to override. Each key of the `hooks` object is the name
   * of a hook, and the value is a string with the GLSL code for your hook.
   *
   * If you supply functions that aren't existing hooks, they will get added at the start of
   * the shader as helper functions so that you can use them in your hooks.
   *
   * To add new <a href="#/p5.Shader/setUniform">uniforms</a> to your shader, you can pass in a `uniforms` object containing
   * the type and name of the uniform as the key, and a default value or function returning
   * a default value as its value. These will be automatically set when the shader is set
   * with `shader(yourShader)`.
   *
   * ```js example
   * let myShader;
   *
   * function setup() {
   *   createCanvas(200, 200, WEBGL);
   *   myShader = baseMaterialShader().modify({
   *     uniforms: {
   *       'float time': () => millis() // Uniform for time
   *     },
   *     'Vertex getWorldInputs': `(Vertex inputs) {
   *       inputs.position.y +=
   *         20. * sin(time * 0.001 + inputs.position.x * 0.05);
   *       return inputs;
   *     }`
   *   });
   * }
   *
   * function draw() {
   *   background(255);
   *   shader(myShader); // Apply the custom shader
   *   lights();         // Enable lighting
   *   noStroke();       // Disable stroke
   *   fill('red');      // Set fill color to red
   *   sphere(50);       // Draw a sphere with the shader applied
   * }
   * ```
   *
   * You can also add a `declarations` key, where the value is a GLSL string declaring
   * custom uniform variables, globals, and functions shared
   * between hooks. To add declarations just in a vertex or fragment shader, add
   * `vertexDeclarations` and `fragmentDeclarations` keys.
   *
   * ```js example
   * let myShader;
   *
   * function setup() {
   *   createCanvas(200, 200, WEBGL);
   *   myShader = baseMaterialShader().modify({
   *     // Manually specifying a uniform
   *     declarations: 'uniform float time;',
   *     'Vertex getWorldInputs': `(Vertex inputs) {
   *       inputs.position.y +=
   *         20. * sin(time * 0.001 + inputs.position.x * 0.05);
   *       return inputs;
   *     }`
   *   });
   * }
   *
   * function draw() {
   *   background(255);
   *   shader(myShader);
   *   myShader.setUniform('time', millis());
   *   lights();
   *   noStroke();
   *   fill('red');
   *   sphere(50);
   * }
   * ```
   *
   * @beta
   * @param {Function} callback A function with p5.strands code to modify the shader.
   * @param {Object} [variables] An optional object with local variables p5.strands
   * should have access to.
   * @returns {p5.Shader}
   */
  /**
   * @param {Object} [hooks] The hooks in the shader to replace.
   * @returns {p5.Shader}
   */
  modify(hooks2) {
    const newHooks = {
      vertex: {},
      fragment: {},
      helpers: {}
    };
    for (const key in hooks2) {
      if (key === "declarations") continue;
      if (key === "uniforms") continue;
      if (key === "vertexDeclarations") {
        newHooks.vertex.declarations = (newHooks.vertex.declarations || "") + "\n" + hooks2[key];
      } else if (key === "fragmentDeclarations") {
        newHooks.fragment.declarations = (newHooks.fragment.declarations || "") + "\n" + hooks2[key];
      } else if (this.hooks.vertex[key]) {
        newHooks.vertex[key] = hooks2[key];
      } else if (this.hooks.fragment[key]) {
        newHooks.fragment[key] = hooks2[key];
      } else {
        newHooks.helpers[key] = hooks2[key];
      }
    }
    const modifiedVertex = Object.assign({}, this.hooks.modified.vertex);
    const modifiedFragment = Object.assign({}, this.hooks.modified.fragment);
    for (const key in newHooks.vertex || {}) {
      if (key === "declarations") continue;
      modifiedVertex[key] = true;
    }
    for (const key in newHooks.fragment || {}) {
      if (key === "declarations") continue;
      modifiedFragment[key] = true;
    }
    return new _Shader(this._renderer, this._vertSrc, this._fragSrc, {
      declarations: (this.hooks.declarations || "") + "\n" + (hooks2.declarations || ""),
      uniforms: Object.assign({}, this.hooks.uniforms, hooks2.uniforms || {}),
      fragment: Object.assign({}, this.hooks.fragment, newHooks.fragment || {}),
      vertex: Object.assign({}, this.hooks.vertex, newHooks.vertex || {}),
      helpers: Object.assign({}, this.hooks.helpers, newHooks.helpers || {}),
      modified: {
        vertex: modifiedVertex,
        fragment: modifiedFragment
      }
    });
  }
  /**
   * Creates, compiles, and links the shader based on its
   * sources for the vertex and fragment shaders (provided
   * to the constructor). Populates known attributes and
   * uniforms from the shader.
   * @chainable
   * @private
   */
  init() {
    if (this._glProgram === 0) {
      const gl = this._renderer.GL;
      this._vertShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(this._vertShader, this.vertSrc());
      gl.compileShader(this._vertShader);
      if (!gl.getShaderParameter(this._vertShader, gl.COMPILE_STATUS)) {
        const glError = gl.getShaderInfoLog(this._vertShader);
        if (typeof IS_MINIFIED !== "undefined") {
          console.error(glError);
        } else {
          throw glError;
        }
        return null;
      }
      this._fragShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(this._fragShader, this.fragSrc());
      gl.compileShader(this._fragShader);
      if (!gl.getShaderParameter(this._fragShader, gl.COMPILE_STATUS)) {
        const glError = gl.getShaderInfoLog(this._fragShader);
        if (typeof IS_MINIFIED !== "undefined") {
          console.error(glError);
        } else {
          throw glError;
        }
        return null;
      }
      this._glProgram = gl.createProgram();
      gl.attachShader(this._glProgram, this._vertShader);
      gl.attachShader(this._glProgram, this._fragShader);
      gl.linkProgram(this._glProgram);
      if (!gl.getProgramParameter(this._glProgram, gl.LINK_STATUS)) {
        p5._friendlyError(
          `Snap! Error linking shader program: ${gl.getProgramInfoLog(
            this._glProgram
          )}`
        );
      }
      this._loadAttributes();
      this._loadUniforms();
    }
    return this;
  }
  /**
   * @private
   */
  setDefaultUniforms() {
    for (const key in this.hooks.uniforms) {
      const [, name] = key.split(" ");
      const initializer3 = this.hooks.uniforms[key];
      let value;
      if (initializer3 instanceof Function) {
        value = initializer3();
      } else {
        value = initializer3;
      }
      if (value !== void 0 && value !== null) {
        this.setUniform(name, value);
      }
    }
  }
  /**
   * Copies the shader from one drawing context to another.
   *
   * Each `p5.Shader` object must be compiled by calling
   * <a href="#/p5/shader">shader()</a> before it can run. Compilation happens
   * in a drawing context which is usually the main canvas or an instance of
   * <a href="#/p5.Graphics">p5.Graphics</a>. A shader can only be used in the
   * context where it was compiled. The `copyToContext()` method compiles the
   * shader again and copies it to another drawing context where it can be
   * reused.
   *
   * The parameter, `context`, is the drawing context where the shader will be
   * used. The shader can be copied to an instance of
   * <a href="#/p5.Graphics">p5.Graphics</a>, as in
   * `myShader.copyToContext(pg)`. The shader can also be copied from a
   * <a href="#/p5.Graphics">p5.Graphics</a> object to the main canvas using
   * the `p5.instance` variable, as in `myShader.copyToContext(p5.instance)`.
   *
   * Note: A <a href="#/p5.Shader">p5.Shader</a> object created with
   * <a href="#/p5/createShader">createShader()</a>,
   * <a href="#/p5/createFilterShader">createFilterShader()</a>, or
   * <a href="#/p5/loadShader">loadShader()</a>
   * can be used directly with a <a href="#/p5.Framebuffer">p5.Framebuffer</a>
   * object created with
   * <a href="#/p5/createFramebuffer">createFramebuffer()</a>. Both objects
   * have the same context as the main canvas.
   *
   * @param {p5|p5.Graphics} context WebGL context for the copied shader.
   * @returns {p5.Shader} new shader compiled for the target context.
   *
   * @example
   * <div>
   * <code>
   * // Note: A "uniform" is a global variable within a shader program.
   *
   * // Create a string with the vertex shader program.
   * // The vertex shader is called for each vertex.
   * let vertSrc = `
   * precision highp float;
   * uniform mat4 uModelViewMatrix;
   * uniform mat4 uProjectionMatrix;
   *
   * attribute vec3 aPosition;
   * attribute vec2 aTexCoord;
   * varying vec2 vTexCoord;
   *
   * void main() {
   *   vTexCoord = aTexCoord;
   *   vec4 positionVec4 = vec4(aPosition, 1.0);
   *   gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
   * }
   * `;
   *
   * // Create a string with the fragment shader program.
   * // The fragment shader is called for each pixel.
   * let fragSrc = `
   * precision mediump float;
   * varying vec2 vTexCoord;
   *
   * void main() {
   *   vec2 uv = vTexCoord;
   *   vec3 color = vec3(uv.x, uv.y, min(uv.x + uv.y, 1.0));
   *   gl_FragColor = vec4(color, 1.0);\
   * }
   * `;
   *
   * let pg;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Create a p5.Shader object.
   *   let original = createShader(vertSrc, fragSrc);
   *
   *   // Compile the p5.Shader object.
   *   shader(original);
   *
   *   // Create a p5.Graphics object.
   *   pg = createGraphics(50, 50, WEBGL);
   *
   *   // Copy the original shader to the p5.Graphics object.
   *   let copied = original.copyToContext(pg);
   *
   *   // Apply the copied shader to the p5.Graphics object.
   *   pg.shader(copied);
   *
   *   // Style the display surface.
   *   pg.noStroke();
   *
   *   // Add a display surface for the shader.
   *   pg.plane(50, 50);
   *
   *   describe('A square with purple-blue gradient on its surface drawn against a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Draw the p5.Graphics object to the main canvas.
   *   image(pg, -25, -25);
   * }
   * </code>
   * </div>
   *
   * <div class='notest'>
   * <code>
   * // Note: A "uniform" is a global variable within a shader program.
   *
   * // Create a string with the vertex shader program.
   * // The vertex shader is called for each vertex.
   * let vertSrc = `
   * precision highp float;
   * uniform mat4 uModelViewMatrix;
   * uniform mat4 uProjectionMatrix;
   *
   * attribute vec3 aPosition;
   * attribute vec2 aTexCoord;
   * varying vec2 vTexCoord;
   *
   * void main() {
   *   vTexCoord = aTexCoord;
   *   vec4 positionVec4 = vec4(aPosition, 1.0);
   *   gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
   * }
   * `;
   *
   * // Create a string with the fragment shader program.
   * // The fragment shader is called for each pixel.
   * let fragSrc = `
   * precision mediump float;
   *
   * varying vec2 vTexCoord;
   *
   * void main() {
   *   vec2 uv = vTexCoord;
   *   vec3 color = vec3(uv.x, uv.y, min(uv.x + uv.y, 1.0));
   *   gl_FragColor = vec4(color, 1.0);
   * }
   * `;
   *
   * let copied;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Graphics object.
   *   let pg = createGraphics(25, 25, WEBGL);
   *
   *   // Create a p5.Shader object.
   *   let original = pg.createShader(vertSrc, fragSrc);
   *
   *   // Compile the p5.Shader object.
   *   pg.shader(original);
   *
   *   // Copy the original shader to the main canvas.
   *   copied = original.copyToContext(p5.instance);
   *
   *   // Apply the copied shader to the main canvas.
   *   shader(copied);
   *
   *   describe('A rotating cube with a purple-blue gradient on its surface drawn against a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Rotate around the x-, y-, and z-axes.
   *   rotateX(frameCount * 0.01);
   *   rotateY(frameCount * 0.01);
   *   rotateZ(frameCount * 0.01);
   *
   *   // Draw the box.
   *   box(50);
   * }
   * </code>
   * </div>
   */
  copyToContext(context) {
    const shader2 = new _Shader(
      context._renderer,
      this._vertSrc,
      this._fragSrc
    );
    shader2.ensureCompiledOnContext(context._renderer);
    return shader2;
  }
  /**
   * @private
   */
  ensureCompiledOnContext(context) {
    var _a2, _b2;
    if (this._glProgram !== 0 && this._renderer !== context) {
      throw new Error(
        "The shader being run is attached to a different context. Do you need to copy it to this context first with .copyToContext()?"
      );
    } else if (this._glProgram === 0) {
      this._renderer = ((_b2 = (_a2 = context == null ? void 0 : context._renderer) == null ? void 0 : _a2.filterRenderer) == null ? void 0 : _b2._renderer) || context;
      this.init();
    }
  }
  /**
   * Queries the active attributes for this shader and loads
   * their names and locations into the attributes array.
   * @private
   */
  _loadAttributes() {
    if (this._loadedAttributes) {
      return;
    }
    this.attributes = {};
    const gl = this._renderer.GL;
    const numAttributes = gl.getProgramParameter(
      this._glProgram,
      gl.ACTIVE_ATTRIBUTES
    );
    for (let i = 0; i < numAttributes; ++i) {
      const attributeInfo = gl.getActiveAttrib(this._glProgram, i);
      const name = attributeInfo.name;
      const location2 = gl.getAttribLocation(this._glProgram, name);
      const attribute = {};
      attribute.name = name;
      attribute.location = location2;
      attribute.index = i;
      attribute.type = attributeInfo.type;
      attribute.size = attributeInfo.size;
      this.attributes[name] = attribute;
    }
    this._loadedAttributes = true;
  }
  /**
   * Queries the active uniforms for this shader and loads
   * their names and locations into the uniforms array.
   * @private
   */
  _loadUniforms() {
    if (this._loadedUniforms) {
      return;
    }
    const gl = this._renderer.GL;
    const numUniforms = gl.getProgramParameter(
      this._glProgram,
      gl.ACTIVE_UNIFORMS
    );
    let samplerIndex = 0;
    for (let i = 0; i < numUniforms; ++i) {
      const uniformInfo = gl.getActiveUniform(this._glProgram, i);
      const uniform = {};
      uniform.location = gl.getUniformLocation(
        this._glProgram,
        uniformInfo.name
      );
      uniform.size = uniformInfo.size;
      let uniformName = uniformInfo.name;
      if (uniformInfo.size > 1) {
        uniformName = uniformName.substring(0, uniformName.indexOf("[0]"));
      }
      uniform.name = uniformName;
      uniform.type = uniformInfo.type;
      uniform._cachedData = void 0;
      if (uniform.type === gl.SAMPLER_2D) {
        uniform.samplerIndex = samplerIndex;
        samplerIndex++;
        this.samplers.push(uniform);
      }
      uniform.isArray = uniformInfo.size > 1 || uniform.type === gl.FLOAT_MAT3 || uniform.type === gl.FLOAT_MAT4 || uniform.type === gl.FLOAT_VEC2 || uniform.type === gl.FLOAT_VEC3 || uniform.type === gl.FLOAT_VEC4 || uniform.type === gl.INT_VEC2 || uniform.type === gl.INT_VEC4 || uniform.type === gl.INT_VEC3;
      this.uniforms[uniformName] = uniform;
    }
    this._loadedUniforms = true;
  }
  compile() {
  }
  /**
   * initializes (if needed) and binds the shader program.
   * @private
   */
  bindShader() {
    this.init();
    if (!this._bound) {
      this.useProgram();
      this._bound = true;
    }
  }
  /**
   * @chainable
   * @private
   */
  unbindShader() {
    if (this._bound) {
      this.unbindTextures();
      this._bound = false;
    }
    return this;
  }
  bindTextures() {
    const gl = this._renderer.GL;
    const empty2 = this._renderer._getEmptyTexture();
    for (const uniform of this.samplers) {
      let tex = uniform.texture;
      if (tex === void 0 || false) {
        uniform.texture = tex = empty2;
      }
      gl.activeTexture(gl.TEXTURE0 + uniform.samplerIndex);
      tex.bindTexture();
      tex.update();
      gl.uniform1i(uniform.location, uniform.samplerIndex);
    }
  }
  updateTextures() {
    for (const uniform of this.samplers) {
      const tex = uniform.texture;
      if (tex) {
        tex.update();
      }
    }
  }
  unbindTextures() {
    var _a2;
    const gl = this._renderer.GL;
    const empty2 = this._renderer._getEmptyTexture();
    for (const uniform of this.samplers) {
      if ((_a2 = uniform.texture) == null ? void 0 : _a2.isFramebufferTexture) {
        gl.activeTexture(gl.TEXTURE0 + uniform.samplerIndex);
        empty2.bindTexture();
        gl.uniform1i(uniform.location, uniform.samplerIndex);
      }
    }
  }
  /**
   * @chainable
   * @private
   */
  useProgram() {
    const gl = this._renderer.GL;
    if (this._renderer._curShader !== this) {
      gl.useProgram(this._glProgram);
      this._renderer._curShader = this;
    }
    return this;
  }
  /**
   * Sets the shader’s uniform (global) variables.
   *
   * Shader programs run on the computer’s graphics processing unit (GPU).
   * They live in part of the computer’s memory that’s completely separate
   * from the sketch that runs them. Uniforms are global variables within a
   * shader program. They provide a way to pass values from a sketch running
   * on the CPU to a shader program running on the GPU.
   *
   * The first parameter, `uniformName`, is a string with the uniform’s name.
   * For the shader above, `uniformName` would be `'r'`.
   *
   * The second parameter, `data`, is the value that should be used to set the
   * uniform. For example, calling `myShader.setUniform('r', 0.5)` would set
   * the `r` uniform in the shader above to `0.5`. data should match the
   * uniform’s type. Numbers, strings, booleans, arrays, and many types of
   * images can all be passed to a shader with `setUniform()`.
   *
   * @chainable
   * @param {String} uniformName name of the uniform. Must match the name
   *                             used in the vertex and fragment shaders.
   * @param {Boolean|Number|Number[]|p5.Image|p5.Graphics|p5.MediaElement|p5.Texture}
   * data value to assign to the uniform. Must match the uniform’s data type.
   *
   * @example
   * <div>
   * <code>
   * // Note: A "uniform" is a global variable within a shader program.
   *
   * // Create a string with the vertex shader program.
   * // The vertex shader is called for each vertex.
   * let vertSrc = `
   * precision highp float;
   * uniform mat4 uModelViewMatrix;
   * uniform mat4 uProjectionMatrix;
   *
   * attribute vec3 aPosition;
   * attribute vec2 aTexCoord;
   * varying vec2 vTexCoord;
   *
   * void main() {
   *   vTexCoord = aTexCoord;
   *   vec4 positionVec4 = vec4(aPosition, 1.0);
   *   gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
   * }
   * `;
   *
   * // Create a string with the fragment shader program.
   * // The fragment shader is called for each pixel.
   * let fragSrc = `
   * precision mediump float;
   *
   * uniform float r;
   *
   * void main() {
   *   gl_FragColor = vec4(r, 1.0, 1.0, 1.0);
   * }
   * `;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Shader object.
   *   let myShader = createShader(vertSrc, fragSrc);
   *
   *   // Apply the p5.Shader object.
   *   shader(myShader);
   *
   *   // Set the r uniform to 0.5.
   *   myShader.setUniform('r', 0.5);
   *
   *   // Style the drawing surface.
   *   noStroke();
   *
   *   // Add a plane as a drawing surface for the shader.
   *   plane(100, 100);
   *
   *   describe('A cyan square.');
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Note: A "uniform" is a global variable within a shader program.
   *
   * // Create a string with the vertex shader program.
   * // The vertex shader is called for each vertex.
   * let vertSrc = `
   * precision highp float;
   * uniform mat4 uModelViewMatrix;
   * uniform mat4 uProjectionMatrix;
   *
   * attribute vec3 aPosition;
   * attribute vec2 aTexCoord;
   * varying vec2 vTexCoord;
   *
   * void main() {
   *   vTexCoord = aTexCoord;
   *   vec4 positionVec4 = vec4(aPosition, 1.0);
   *   gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
   * }
   * `;
   *
   * // Create a string with the fragment shader program.
   * // The fragment shader is called for each pixel.
   * let fragSrc = `
   * precision mediump float;
   *
   * uniform float r;
   *
   * void main() {
   *   gl_FragColor = vec4(r, 1.0, 1.0, 1.0);
   * }
   * `;
   *
   * let myShader;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Shader object.
   *   myShader = createShader(vertSrc, fragSrc);
   *
   *   // Compile and apply the p5.Shader object.
   *   shader(myShader);
   *
   *   describe('A square oscillates color between cyan and white.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Style the drawing surface.
   *   noStroke();
   *
   *   // Update the r uniform.
   *   let nextR = 0.5 * (sin(frameCount * 0.01) + 1);
   *   myShader.setUniform('r', nextR);
   *
   *   // Add a plane as a drawing surface.
   *   plane(100, 100);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Note: A "uniform" is a global variable within a shader program.
   *
   * // Create a string with the vertex shader program.
   * // The vertex shader is called for each vertex.
   * let vertSrc = `
   * precision highp float;
   * uniform mat4 uModelViewMatrix;
   * uniform mat4 uProjectionMatrix;
   *
   * attribute vec3 aPosition;
   * attribute vec2 aTexCoord;
   * varying vec2 vTexCoord;
   *
   * void main() {
   *   vTexCoord = aTexCoord;
   *   vec4 positionVec4 = vec4(aPosition, 1.0);
   *   gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
   * }
   * `;
   *
   * // Create a string with the fragment shader program.
   * // The fragment shader is called for each pixel.
   * let fragSrc = `
   * precision highp float;
   * uniform vec2 p;
   * uniform float r;
   * const int numIterations = 500;
   * varying vec2 vTexCoord;
   *
   * void main() {
   *   vec2 c = p + gl_FragCoord.xy * r;
   *   vec2 z = c;
   *   float n = 0.0;
   *
   *   for (int i = numIterations; i > 0; i--) {
   *     if (z.x * z.x + z.y * z.y > 4.0) {
   *       n = float(i) / float(numIterations);
   *       break;
   *     }
   *
   *     z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;
   *   }
   *
   *   gl_FragColor = vec4(
   *     0.5 - cos(n * 17.0) / 2.0,
   *     0.5 - cos(n * 13.0) / 2.0,
   *     0.5 - cos(n * 23.0) / 2.0,
   *     1.0
   *   );
   * }
   * `;
   *
   * let mandelbrot;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Shader object.
   *   mandelbrot = createShader(vertSrc, fragSrc);
   *
   *   // Compile and apply the p5.Shader object.
   *   shader(mandelbrot);
   *
   *   // Set the shader uniform p to an array.
   *   // p is the center point of the Mandelbrot image.
   *   mandelbrot.setUniform('p', [-0.74364388703, 0.13182590421]);
   *
   *   describe('A fractal image zooms in and out of focus.');
   * }
   *
   * function draw() {
   *   // Set the shader uniform r to a value that oscillates
   *   // between 0 and 0.005.
   *   // r is the size of the image in Mandelbrot-space.
   *   let radius = 0.005 * (sin(frameCount * 0.01) + 1);
   *   mandelbrot.setUniform('r', radius);
   *
   *   // Style the drawing surface.
   *   noStroke();
   *
   *   // Add a plane as a drawing surface.
   *   plane(100, 100);
   * }
   * </code>
   * </div>
   */
  setUniform(uniformName, data3) {
    this.init();
    const uniform = this.uniforms[uniformName];
    if (!uniform) {
      return;
    }
    const gl = this._renderer.GL;
    if (uniform.isArray) {
      if (uniform._cachedData && this._renderer._arraysEqual(uniform._cachedData, data3)) {
        return;
      } else {
        uniform._cachedData = data3.slice(0);
      }
    } else if (uniform._cachedData && uniform._cachedData === data3) {
      return;
    } else {
      if (Array.isArray(data3)) {
        uniform._cachedData = data3.slice(0);
      } else {
        uniform._cachedData = data3;
      }
    }
    const location2 = uniform.location;
    this.useProgram();
    switch (uniform.type) {
      case gl.BOOL:
        if (data3 === true) {
          gl.uniform1i(location2, 1);
        } else {
          gl.uniform1i(location2, 0);
        }
        break;
      case gl.INT:
        if (uniform.size > 1) {
          data3.length && gl.uniform1iv(location2, data3);
        } else {
          gl.uniform1i(location2, data3);
        }
        break;
      case gl.FLOAT:
        if (uniform.size > 1) {
          data3.length && gl.uniform1fv(location2, data3);
        } else {
          gl.uniform1f(location2, data3);
        }
        break;
      case gl.FLOAT_MAT3:
        gl.uniformMatrix3fv(location2, false, data3);
        break;
      case gl.FLOAT_MAT4:
        gl.uniformMatrix4fv(location2, false, data3);
        break;
      case gl.FLOAT_VEC2:
        if (uniform.size > 1) {
          data3.length && gl.uniform2fv(location2, data3);
        } else {
          gl.uniform2f(location2, data3[0], data3[1]);
        }
        break;
      case gl.FLOAT_VEC3:
        if (uniform.size > 1) {
          data3.length && gl.uniform3fv(location2, data3);
        } else {
          gl.uniform3f(location2, data3[0], data3[1], data3[2]);
        }
        break;
      case gl.FLOAT_VEC4:
        if (uniform.size > 1) {
          data3.length && gl.uniform4fv(location2, data3);
        } else {
          gl.uniform4f(location2, data3[0], data3[1], data3[2], data3[3]);
        }
        break;
      case gl.INT_VEC2:
        if (uniform.size > 1) {
          data3.length && gl.uniform2iv(location2, data3);
        } else {
          gl.uniform2i(location2, data3[0], data3[1]);
        }
        break;
      case gl.INT_VEC3:
        if (uniform.size > 1) {
          data3.length && gl.uniform3iv(location2, data3);
        } else {
          gl.uniform3i(location2, data3[0], data3[1], data3[2]);
        }
        break;
      case gl.INT_VEC4:
        if (uniform.size > 1) {
          data3.length && gl.uniform4iv(location2, data3);
        } else {
          gl.uniform4i(location2, data3[0], data3[1], data3[2], data3[3]);
        }
        break;
      case gl.SAMPLER_2D:
        if (typeof data3 == "number") {
          if (data3 < gl.TEXTURE0 || data3 > gl.TEXTURE31 || data3 !== Math.ceil(data3)) {
            console.log(
              "🌸 p5.js says: You're trying to use a number as the data for a texture.Please use a texture."
            );
            return this;
          }
          gl.activeTexture(data3);
          gl.uniform1i(location2, data3);
        } else {
          gl.activeTexture(gl.TEXTURE0 + uniform.samplerIndex);
          uniform.texture = data3 instanceof Texture ? data3 : this._renderer.getTexture(data3);
          gl.uniform1i(location2, uniform.samplerIndex);
          if (uniform.texture.src.gifProperties) {
            uniform.texture.src._animateGif(this._renderer._pInst);
          }
        }
        break;
      case gl.SAMPLER_CUBE:
      case gl.SAMPLER_3D:
      case gl.SAMPLER_2D_SHADOW:
      case gl.SAMPLER_2D_ARRAY:
      case gl.SAMPLER_2D_ARRAY_SHADOW:
      case gl.SAMPLER_CUBE_SHADOW:
      case gl.INT_SAMPLER_2D:
      case gl.INT_SAMPLER_3D:
      case gl.INT_SAMPLER_CUBE:
      case gl.INT_SAMPLER_2D_ARRAY:
      case gl.UNSIGNED_INT_SAMPLER_2D:
      case gl.UNSIGNED_INT_SAMPLER_3D:
      case gl.UNSIGNED_INT_SAMPLER_CUBE:
      case gl.UNSIGNED_INT_SAMPLER_2D_ARRAY:
        if (typeof data3 !== "number") {
          break;
        }
        if (data3 < gl.TEXTURE0 || data3 > gl.TEXTURE31 || data3 !== Math.ceil(data3)) {
          console.log(
            "🌸 p5.js says: You're trying to use a number as the data for a texture.Please use a texture."
          );
          break;
        }
        gl.activeTexture(data3);
        gl.uniform1i(location2, data3);
        break;
    }
    return this;
  }
  /**
   * @chainable
   * @private
   */
  enableAttrib(attr, size, type3, normalized, stride, offset2) {
    if (attr) {
      if (typeof IS_MINIFIED === "undefined" && this.attributes[attr.name] !== attr) {
        console.warn(
          `The attribute "${attr.name}"passed to enableAttrib does not belong to this shader.`
        );
      }
      const loc = attr.location;
      if (loc !== -1) {
        const gl = this._renderer.GL;
        if (!this._renderer.registerEnabled.has(loc)) {
          gl.enableVertexAttribArray(loc);
          this._renderer.registerEnabled.add(loc);
        }
        this._renderer.GL.vertexAttribPointer(
          loc,
          size,
          type3 || gl.FLOAT,
          normalized || false,
          stride || 0,
          offset2 || 0
        );
      }
    }
    return this;
  }
  /**
   * Once all buffers have been bound, this checks to see if there are any
   * remaining active attributes, likely left over from previous renders,
   * and disables them so that they don't affect rendering.
   * @private
   */
  disableRemainingAttributes() {
    for (const location2 of this._renderer.registerEnabled.values()) {
      if (!Object.keys(this.attributes).some(
        (key) => this.attributes[key].location === location2
      )) {
        this._renderer.GL.disableVertexAttribArray(location2);
        this._renderer.registerEnabled.delete(location2);
      }
    }
  }
};
function shader(p53, fn2) {
  p53.Shader = Shader;
}
if (typeof p5 !== "undefined") {
  shader(p5, p5.prototype);
}
var filterBaseVert = "precision highp int;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nIN vec3 aPosition;\nIN vec2 aTexCoord;\nOUT vec2 vTexCoord;\n\nvoid main() {\n  // transferring texcoords for the frag shader\n  vTexCoord = aTexCoord;\n\n  // copy position with a fourth coordinate for projection (1.0 is normal)\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n\n  // project to 3D space\n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n}\n";
var lightingShader = '#define PI 3.141592\n\nprecision highp float;\nprecision highp int;\n\nuniform mat4 uViewMatrix;\n\nuniform bool uUseLighting;\n\nuniform int uAmbientLightCount;\nuniform vec3 uAmbientColor[5];\nuniform mat3 uCameraRotation;\nuniform int uDirectionalLightCount;\nuniform vec3 uLightingDirection[5];\nuniform vec3 uDirectionalDiffuseColors[5];\nuniform vec3 uDirectionalSpecularColors[5];\n\nuniform int uPointLightCount;\nuniform vec3 uPointLightLocation[5];\nuniform vec3 uPointLightDiffuseColors[5];	\nuniform vec3 uPointLightSpecularColors[5];\n\nuniform int uSpotLightCount;\nuniform float uSpotLightAngle[5];\nuniform float uSpotLightConc[5];\nuniform vec3 uSpotLightDiffuseColors[5];\nuniform vec3 uSpotLightSpecularColors[5];\nuniform vec3 uSpotLightLocation[5];\nuniform vec3 uSpotLightDirection[5];\n\nuniform bool uSpecular;\nuniform float uShininess;\nuniform float uMetallic;\n\nuniform float uConstantAttenuation;\nuniform float uLinearAttenuation;\nuniform float uQuadraticAttenuation;\n\n// setting from  _setImageLightUniforms()\n// boolean to initiate the calculateImageDiffuse and calculateImageSpecular\nuniform bool uUseImageLight;\n// texture for use in calculateImageDiffuse\nuniform sampler2D environmentMapDiffused;\n// texture for use in calculateImageSpecular\nuniform sampler2D environmentMapSpecular;\n\nconst float specularFactor = 2.0;\nconst float diffuseFactor = 0.73;\n\nstruct LightResult {\n  float specular;\n  float diffuse;\n};\n\nfloat _phongSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n\n  vec3 R = reflect(lightDirection, surfaceNormal);\n  return pow(max(0.0, dot(R, viewDirection)), shininess);\n}\n\nfloat _lambertDiffuse(vec3 lightDirection, vec3 surfaceNormal) {\n  return max(0.0, dot(-lightDirection, surfaceNormal));\n}\n\nLightResult _light(vec3 viewDirection, vec3 normal, vec3 lightVector, float shininess, float metallic) {\n\n  vec3 lightDir = normalize(lightVector);\n\n  //compute our diffuse & specular terms\n  LightResult lr;\n  float specularIntensity = mix(1.0, 0.4, metallic);\n  float diffuseIntensity = mix(1.0, 0.1, metallic);\n  if (uSpecular)\n    lr.specular = (_phongSpecular(lightDir, viewDirection, normal, shininess)) * specularIntensity;\n    lr.diffuse = _lambertDiffuse(lightDir, normal) * diffuseIntensity;\n  return lr;\n}\n\n// converts the range of "value" from [min1 to max1] to [min2 to max2]\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvec2 mapTextureToNormal( vec3 v ){\n  // x = r sin(phi) cos(theta)   \n  // y = r cos(phi)  \n  // z = r sin(phi) sin(theta)\n  float phi = acos( v.y );\n  // if phi is 0, then there are no x, z components\n  float theta = 0.0;\n  // else \n  theta = acos(v.x / sin(phi));\n  float sinTheta = v.z / sin(phi);\n  if (sinTheta < 0.0) {\n    // Turn it into -theta, but in the 0-2PI range\n    theta = 2.0 * PI - theta;\n  }\n  theta = theta / (2.0 * 3.14159);\n  phi = phi / 3.14159 ;\n  \n  vec2 angles = vec2( fract(theta + 0.25), 1.0 - phi );\n  return angles;\n}\n\n\nvec3 calculateImageDiffuse(vec3 vNormal, vec3 vViewPosition, float metallic){\n  // make 2 seperate builds \n  vec3 worldCameraPosition =  vec3(0.0, 0.0, 0.0);  // hardcoded world camera position\n  vec3 worldNormal = normalize(vNormal * uCameraRotation);\n  vec2 newTexCoor = mapTextureToNormal( worldNormal );\n  vec4 texture = TEXTURE( environmentMapDiffused, newTexCoor );\n  // this is to make the darker sections more dark\n  // png and jpg usually flatten the brightness so it is to reverse that\n  return mix(smoothstep(vec3(0.0), vec3(1.0), texture.xyz), vec3(0.0), metallic);\n}\n\nvec3 calculateImageSpecular(vec3 vNormal, vec3 vViewPosition, float shininess, float metallic){\n  vec3 worldCameraPosition =  vec3(0.0, 0.0, 0.0);\n  vec3 worldNormal = normalize(vNormal);\n  vec3 lightDirection = normalize( vViewPosition - worldCameraPosition );\n  vec3 R = reflect(lightDirection, worldNormal) * uCameraRotation;\n  vec2 newTexCoor = mapTextureToNormal( R );\n#ifdef WEBGL2\n  // In p5js the range of shininess is >= 1,\n  // Therefore roughness range will be ([0,1]*8)*20 or [0, 160]\n  // The factor of 8 is because currently the getSpecularTexture\n  // only calculated 8 different levels of roughness\n  // The factor of 20 is just to spread up this range so that,\n  // [1, max] of shininess is converted to [0,160] of roughness\n  float roughness = 20. / shininess;\n  vec4 outColor = textureLod(environmentMapSpecular, newTexCoor, roughness * 8.);\n#else\n  vec4 outColor = TEXTURE(environmentMapSpecular, newTexCoor);\n#endif\n  // this is to make the darker sections more dark\n  // png and jpg usually flatten the brightness so it is to reverse that\n  return mix(\n    pow(outColor.xyz, vec3(10)),\n    pow(outColor.xyz, vec3(1.2)),\n    metallic \n  );\n}\n\nvoid totalLight(\n  vec3 modelPosition,\n  vec3 normal,\n  float shininess,\n  float metallic,\n  out vec3 totalDiffuse,\n  out vec3 totalSpecular\n) {\n\n  totalSpecular = vec3(0.0);\n\n  if (!uUseLighting) {\n    totalDiffuse = vec3(1.0);\n    return;\n  }\n\n  totalDiffuse = vec3(0.0);\n\n  vec3 viewDirection = normalize(-modelPosition);\n\n  for (int j = 0; j < 5; j++) {\n    if (j < uDirectionalLightCount) {\n      vec3 lightVector = (uViewMatrix * vec4(uLightingDirection[j], 0.0)).xyz;\n      vec3 lightColor = uDirectionalDiffuseColors[j];\n      vec3 specularColor = uDirectionalSpecularColors[j];\n      LightResult result = _light(viewDirection, normal, lightVector, shininess, metallic);\n      totalDiffuse += result.diffuse * lightColor;\n      totalSpecular += result.specular * lightColor * specularColor;\n    }\n\n    if (j < uPointLightCount) {\n      vec3 lightPosition = (uViewMatrix * vec4(uPointLightLocation[j], 1.0)).xyz;\n      vec3 lightVector = modelPosition - lightPosition;\n      //calculate attenuation\n      float lightDistance = length(lightVector);\n      float lightFalloff = 1.0 / (uConstantAttenuation + lightDistance * uLinearAttenuation + (lightDistance * lightDistance) * uQuadraticAttenuation);\n      vec3 lightColor = lightFalloff * uPointLightDiffuseColors[j];\n      vec3 specularColor = lightFalloff * uPointLightSpecularColors[j];\n\n      LightResult result = _light(viewDirection, normal, lightVector, shininess, metallic);\n      totalDiffuse += result.diffuse * lightColor;\n      totalSpecular += result.specular * lightColor * specularColor;\n    }\n\n    if(j < uSpotLightCount) {\n      vec3 lightPosition = (uViewMatrix * vec4(uSpotLightLocation[j], 1.0)).xyz;\n      vec3 lightVector = modelPosition - lightPosition;\n    \n      float lightDistance = length(lightVector);\n      float lightFalloff = 1.0 / (uConstantAttenuation + lightDistance * uLinearAttenuation + (lightDistance * lightDistance) * uQuadraticAttenuation);\n\n      vec3 lightDirection = (uViewMatrix * vec4(uSpotLightDirection[j], 0.0)).xyz;\n      float spotDot = dot(normalize(lightVector), normalize(lightDirection));\n      float spotFalloff;\n      if(spotDot < uSpotLightAngle[j]) {\n        spotFalloff = 0.0;\n      }\n      else {\n        spotFalloff = pow(spotDot, uSpotLightConc[j]);\n      }\n      lightFalloff *= spotFalloff;\n\n      vec3 lightColor = uSpotLightDiffuseColors[j];\n      vec3 specularColor = uSpotLightSpecularColors[j];\n     \n      LightResult result = _light(viewDirection, normal, lightVector, shininess, metallic);\n      \n      totalDiffuse += result.diffuse * lightColor * lightFalloff;\n      totalSpecular += result.specular * lightColor * specularColor * lightFalloff;\n    }\n  }\n\n  if( uUseImageLight ){\n    totalDiffuse += calculateImageDiffuse(normal, modelPosition, metallic);\n    totalSpecular += calculateImageSpecular(normal, modelPosition, shininess, metallic);\n  }\n\n  totalDiffuse *= diffuseFactor;\n  totalSpecular *= specularFactor;\n}\n';
var webgl2CompatibilityShader = "#ifdef WEBGL2\n\n#define IN in\n#define OUT out\n\n#ifdef FRAGMENT_SHADER\nout vec4 outColor;\n#define OUT_COLOR outColor\n#endif\n#define TEXTURE texture\n\n#else\n\n#ifdef FRAGMENT_SHADER\n#define IN varying\n#else\n#define IN attribute\n#endif\n#define OUT varying\n#define TEXTURE texture2D\n\n#ifdef FRAGMENT_SHADER\n#define OUT_COLOR gl_FragColor\n#endif\n\n#endif\n\n#ifdef FRAGMENT_SHADER\nvec4 getTexture(in sampler2D content, vec2 coord) {\n  vec4 color = TEXTURE(content, coord);\n  color.rgb /= color.a;\n  return color;\n}\n#endif\n";
var normalVert = "IN vec3 aPosition;\nIN vec3 aNormal;\nIN vec2 aTexCoord;\nIN vec4 aVertexColor;\n\n#define HOOK_DEFINES\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat3 uModelNormalMatrix;\nuniform mat3 uCameraNormalMatrix;\n#else\nuniform mat4 uModelViewMatrix;\nuniform mat3 uNormalMatrix;\n#endif\nuniform mat4 uProjectionMatrix;\n\nuniform vec4 uMaterialColor;\nuniform bool uUseVertexColor;\n\nOUT vec3 vVertexNormal;\nOUT highp vec2 vVertTexCoord;\nOUT vec4 vColor;\n\nstruct Vertex {\n  vec3 position;\n  vec3 normal;\n  vec2 texCoord;\n  vec4 color;\n};\n\nvoid main(void) {\n  HOOK_beforeVertex();\n\n  Vertex inputs;\n  inputs.position = aPosition;\n  inputs.normal = aNormal;\n  inputs.texCoord = aTexCoord;\n  inputs.color = (uUseVertexColor && aVertexColor.x >= 0.0) ? aVertexColor : uMaterialColor;\n#ifdef AUGMENTED_HOOK_getObjectInputs\n  inputs = HOOK_getObjectInputs(inputs);\n#endif\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\n  inputs.position = (uModelMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.normal = uModelNormalMatrix * inputs.normal;\n  inputs = HOOK_getWorldInputs(inputs);\n#endif\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\n  // Already multiplied by the model matrix, just apply view\n  inputs.position = (uViewMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.normal = uCameraNormalMatrix * inputs.normal;\n#else\n  // Apply both at once\n  inputs.position = (uModelViewMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.normal = uNormalMatrix * inputs.normal;\n#endif\n#ifdef AUGMENTED_HOOK_getCameraInputs\n  inputs = HOOK_getCameraInputs(inputs);\n#endif\n\n  // Pass varyings to fragment shader\n  vVertTexCoord = inputs.texCoord;\n  vVertexNormal = normalize(inputs.normal);\n  vColor = inputs.color;\n\n  gl_Position = uProjectionMatrix * vec4(inputs.position, 1.);\n\n  HOOK_afterVertex();\n}\n";
var normalFrag = "IN vec3 vVertexNormal;\nvoid main(void) {\n  HOOK_beforeFragment();\n  OUT_COLOR = HOOK_getFinalColor(vec4(vVertexNormal, 1.0));\n  HOOK_afterFragment();\n}\n";
var basicFrag = "IN vec4 vColor;\nvoid main(void) {\n  HOOK_beforeFragment();\n  OUT_COLOR = HOOK_getFinalColor(vec4(vColor.rgb, 1.) * vColor.a);\n  HOOK_afterFragment();\n}\n";
var sphereMappingFrag = "#define PI 3.141592\n\nprecision highp float;\n  \nuniform sampler2D uEnvMap;\nuniform mat3 uNewNormalMatrix;\nuniform float uFovY;\nuniform float uAspect;\n\nvarying vec2 vTexCoord;\n  \nvoid main() {\n    float uFovX = uFovY * uAspect; \n    float angleY = mix(uFovY/2.0,  -uFovY/2.0, vTexCoord.y);\n    float angleX = mix(uFovX/2.0, -uFovX/2.0, vTexCoord.x);\n    vec3 rotatedNormal = vec3( angleX, angleY, 1.0 );\n    rotatedNormal = uNewNormalMatrix * normalize(rotatedNormal);\n    float temp = rotatedNormal.z;\n    rotatedNormal.z = rotatedNormal.x;\n    rotatedNormal.x = -temp;\n    vec2 suv;\n    suv.y = 0.5 + 0.5 * (-rotatedNormal.y);\n    suv.x = atan(rotatedNormal.z, rotatedNormal.x) / (2.0 * PI) + 0.5;\n    vec4 newTexColor = texture2D(uEnvMap, suv.xy);\n    gl_FragColor = newTexColor;\n}\n";
var lightVert = "// include lighting.glgl\n\nIN vec3 aPosition;\nIN vec3 aNormal;\nIN vec2 aTexCoord;\nIN vec4 aVertexColor;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\n\nuniform bool uUseVertexColor;\nuniform vec4 uMaterialColor;\n\nOUT highp vec2 vVertTexCoord;\nOUT vec3 vDiffuseColor;\nOUT vec3 vSpecularColor;\nOUT vec4 vColor;\n\nvoid main(void) {\n\n  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);\n  gl_Position = uProjectionMatrix * viewModelPosition;\n\n  vec3 vertexNormal = normalize(uNormalMatrix * aNormal);\n  vVertTexCoord = aTexCoord;\n\n  totalLight(viewModelPosition.xyz, vertexNormal, vDiffuseColor, vSpecularColor);\n\n  for (int i = 0; i < 8; i++) {\n    if (i < uAmbientLightCount) {\n      vDiffuseColor += uAmbientColor[i];\n    }\n  }\n  \n  vColor = ((uUseVertexColor && aVertexColor.x >= 0.0) ? aVertexColor : uMaterialColor);\n}\n";
var lightTextureFrag = "uniform vec4 uTint;\nuniform sampler2D uSampler;\nuniform bool isTexture;\nuniform bool uEmissive;\n\nIN highp vec2 vVertTexCoord;\nIN vec3 vDiffuseColor;\nIN vec3 vSpecularColor;\nIN vec4 vColor;\n\nvoid main(void) {\n  if(uEmissive && !isTexture) {\n    OUT_COLOR = vColor;\n  }\n  else {\n    vec4 baseColor = isTexture\n      // Textures come in with premultiplied alpha. To apply tint and still have\n      // premultiplied alpha output, we need to multiply the RGB channels by the\n      // tint RGB, and all channels by the tint alpha.\n      ? TEXTURE(uSampler, vVertTexCoord) * vec4(uTint.rgb/255., 1.) * (uTint.a/255.)\n      // Colors come in with unmultiplied alpha, so we need to multiply the RGB\n      // channels by alpha to convert it to premultiplied alpha.\n      : vec4(vColor.rgb * vColor.a, vColor.a);\n    OUT_COLOR = vec4(baseColor.rgb * vDiffuseColor + vSpecularColor, baseColor.a);\n  }\n}\n";
var phongVert = "precision highp int;\n\n#define HOOK_DEFINES\n\nIN vec3 aPosition;\nIN vec3 aNormal;\nIN vec2 aTexCoord;\nIN vec4 aVertexColor;\n\nuniform vec3 uAmbientColor[5];\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat3 uModelNormalMatrix;\nuniform mat3 uCameraNormalMatrix;\n#else\nuniform mat4 uModelViewMatrix;\nuniform mat3 uNormalMatrix;\n#endif\nuniform mat4 uProjectionMatrix;\nuniform int uAmbientLightCount;\n\nuniform bool uUseVertexColor;\nuniform vec4 uMaterialColor;\n\nOUT vec3 vNormal;\nOUT vec2 vTexCoord;\nOUT vec3 vViewPosition;\nOUT vec3 vAmbientColor;\nOUT vec4 vColor;\n\nstruct Vertex {\n  vec3 position;\n  vec3 normal;\n  vec2 texCoord;\n  vec4 color;\n};\n\nvoid main(void) {\n  HOOK_beforeVertex();\n\n  Vertex inputs;\n  inputs.position = aPosition;\n  inputs.normal = aNormal;\n  inputs.texCoord = aTexCoord;\n  inputs.color = (uUseVertexColor && aVertexColor.x >= 0.0) ? aVertexColor : uMaterialColor;\n#ifdef AUGMENTED_HOOK_getObjectInputs\n  inputs = HOOK_getObjectInputs(inputs);\n#endif\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\n  inputs.position = (uModelMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.normal = uModelNormalMatrix * inputs.normal;\n  inputs = HOOK_getWorldInputs(inputs);\n#endif\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\n  // Already multiplied by the model matrix, just apply view\n  inputs.position = (uViewMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.normal = uCameraNormalMatrix * inputs.normal;\n#else\n  // Apply both at once\n  inputs.position = (uModelViewMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.normal = uNormalMatrix * inputs.normal;\n#endif\n#ifdef AUGMENTED_HOOK_getCameraInputs\n  inputs = HOOK_getCameraInputs(inputs);\n#endif\n\n  // Pass varyings to fragment shader\n  vViewPosition = inputs.position;\n  vTexCoord = inputs.texCoord;\n  vNormal = inputs.normal;\n  vColor = inputs.color;\n\n  // TODO: this should be a uniform\n  vAmbientColor = vec3(0.0);\n  for (int i = 0; i < 5; i++) {\n    if (i < uAmbientLightCount) {\n      vAmbientColor += uAmbientColor[i];\n    }\n  }\n\n  gl_Position = uProjectionMatrix * vec4(inputs.position, 1.);\n  HOOK_afterVertex();\n}\n";
var phongFrag = "// include lighting.glsl\nprecision highp int;\n\nuniform bool uHasSetAmbient;\nuniform vec4 uSpecularMatColor;\nuniform vec4 uAmbientMatColor;\nuniform vec4 uEmissiveMatColor;\n\nuniform vec4 uTint;\nuniform sampler2D uSampler;\nuniform bool isTexture;\n\nIN vec3 vNormal;\nIN vec2 vTexCoord;\nIN vec3 vViewPosition;\nIN vec3 vAmbientColor;\nIN vec4 vColor;\n\nstruct ColorComponents {\n  vec3 baseColor;\n  float opacity;\n  vec3 ambientColor;\n  vec3 specularColor;\n  vec3 diffuse;\n  vec3 ambient;\n  vec3 specular;\n  vec3 emissive;\n};\n\nstruct Inputs {\n  vec3 normal;\n  vec2 texCoord;\n  vec3 ambientLight;\n  vec3 ambientMaterial;\n  vec3 specularMaterial;\n  vec3 emissiveMaterial;\n  vec4 color;\n  float shininess;\n  float metalness;\n};\n\nvoid main(void) {\n  HOOK_beforeFragment();\n\n  Inputs inputs;\n  inputs.normal = normalize(vNormal);\n  inputs.texCoord = vTexCoord;\n  inputs.ambientLight = vAmbientColor;\n  inputs.color = isTexture\n      ? TEXTURE(uSampler, vTexCoord) * (vec4(uTint.rgb/255., 1.) * uTint.a/255.)\n      : vColor;\n  if (isTexture && inputs.color.a > 0.0) {\n    // Textures come in with premultiplied alpha. Temporarily unpremultiply it\n    // so hooks users don't have to think about premultiplied alpha.\n    inputs.color.rgb /= inputs.color.a;\n  }\n  inputs.shininess = uShininess;\n  inputs.metalness = uMetallic;\n  inputs.ambientMaterial = uHasSetAmbient ? uAmbientMatColor.rgb : inputs.color.rgb;\n  inputs.specularMaterial = uSpecularMatColor.rgb;\n  inputs.emissiveMaterial = uEmissiveMatColor.rgb;\n  inputs = HOOK_getPixelInputs(inputs);\n\n  vec3 diffuse;\n  vec3 specular;\n  totalLight(vViewPosition, inputs.normal, inputs.shininess, inputs.metalness, diffuse, specular);\n\n  // Calculating final color as result of all lights (plus emissive term).\n\n  vec2 texCoord = inputs.texCoord;\n  vec4 baseColor = inputs.color;\n  ColorComponents c;\n  c.opacity = baseColor.a;\n  c.baseColor = baseColor.rgb;\n  c.ambientColor = inputs.ambientMaterial;\n  c.specularColor = inputs.specularMaterial;\n  c.diffuse = diffuse;\n  c.ambient = inputs.ambientLight;\n  c.specular = specular;\n  c.emissive = inputs.emissiveMaterial;\n  OUT_COLOR = HOOK_getFinalColor(HOOK_combineColors(c));\n  OUT_COLOR.rgb *= OUT_COLOR.a; // Premultiply alpha before rendering\n  HOOK_afterFragment();\n}\n";
var fontVert = "IN vec3 aPosition;\nIN vec2 aTexCoord;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nuniform vec4 uGlyphRect;\nuniform float uGlyphOffset;\n\nOUT vec2 vTexCoord;\nOUT float w;\n\nvoid main() {\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n\n  // scale by the size of the glyph's rectangle\n  positionVec4.xy *= uGlyphRect.zw - uGlyphRect.xy;\n\n  // Expand glyph bounding boxes by 1px on each side to give a bit of room\n  // for antialiasing\n  vec3 newOrigin = (uModelViewMatrix * vec4(0., 0., 0., 1.)).xyz;\n  vec3 newDX = (uModelViewMatrix * vec4(1., 0., 0., 1.)).xyz;\n  vec3 newDY = (uModelViewMatrix * vec4(0., 1., 0., 1.)).xyz;\n  vec2 pixelScale = vec2(\n    1. / length(newOrigin - newDX),\n    1. / length(newOrigin - newDY)\n  );\n  vec2 offset = pixelScale * normalize(aTexCoord - vec2(0.5, 0.5));\n  vec2 textureOffset = offset * (1. / vec2(\n    uGlyphRect.z - uGlyphRect.x,\n    uGlyphRect.w - uGlyphRect.y\n  ));\n\n  // move to the corner of the glyph\n  positionVec4.xy += uGlyphRect.xy;\n\n  // move to the letter's line offset\n  positionVec4.x += uGlyphOffset;\n\n  positionVec4.xy += offset;\n  \n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n  vTexCoord = aTexCoord + textureOffset;\n  w = gl_Position.w;\n}\n";
var fontFrag = "#ifndef WEBGL2\n#extension GL_OES_standard_derivatives : enable\n#endif\n\n#if 0\n  // simulate integer math using floats\n	#define int float\n	#define ivec2 vec2\n	#define INT(x) float(x)\n\n	int ifloor(float v) { return floor(v); }\n	ivec2 ifloor(vec2 v) { return floor(v); }\n\n#else\n  // use native integer math\n	precision highp int;\n	#define INT(x) x\n\n	int ifloor(float v) { return int(v); }\n	int ifloor(int v) { return v; }\n	ivec2 ifloor(vec2 v) { return ivec2(v); }\n\n#endif\n\nuniform sampler2D uSamplerStrokes;\nuniform sampler2D uSamplerRowStrokes;\nuniform sampler2D uSamplerRows;\nuniform sampler2D uSamplerColStrokes;\nuniform sampler2D uSamplerCols;\n\nuniform ivec2 uStrokeImageSize;\nuniform ivec2 uCellsImageSize;\nuniform ivec2 uGridImageSize;\n\nuniform ivec2 uGridOffset;\nuniform ivec2 uGridSize;\nuniform vec4 uMaterialColor;\n\nIN vec2 vTexCoord;\n\n// some helper functions\nint ROUND(float v) { return ifloor(v + 0.5); }\nivec2 ROUND(vec2 v) { return ifloor(v + 0.5); }\nfloat saturate(float v) { return clamp(v, 0.0, 1.0); }\nvec2 saturate(vec2 v) { return clamp(v, 0.0, 1.0); }\n\nint mul(float v1, int v2) {\n  return ifloor(v1 * float(v2));\n}\n\nivec2 mul(vec2 v1, ivec2 v2) {\n  return ifloor(v1 * vec2(v2) + 0.5);\n}\n\n// unpack a 16-bit integer from a float vec2\nint getInt16(vec2 v) {\n  ivec2 iv = ROUND(v * 255.0);\n  return iv.x * INT(128) + iv.y;\n}\n\nvec2 pixelScale;\nvec2 coverage = vec2(0.0);\nvec2 weight = vec2(0.5);\nconst float minDistance = 1.0/8192.0;\nconst float hardness = 1.05; // amount of antialias\n\n// the maximum number of curves in a glyph\nconst int N = INT(250);\n\n// retrieves an indexed pixel from a sampler\nvec4 getTexel(sampler2D sampler, int pos, ivec2 size) {\n  int width = size.x;\n  int y = ifloor(pos / width);\n  int x = pos - y * width;  // pos % width\n\n  return TEXTURE(sampler, (vec2(x, y) + 0.5) / vec2(size));\n}\n\nvoid calulateCrossings(vec2 p0, vec2 p1, vec2 p2, out vec2 C1, out vec2 C2) {\n\n  // get the coefficients of the quadratic in t\n  vec2 a = p0 - p1 * 2.0 + p2;\n  vec2 b = p0 - p1;\n  vec2 c = p0 - vTexCoord;\n\n  // found out which values of 't' it crosses the axes\n  vec2 surd = sqrt(max(vec2(0.0), b * b - a * c));\n  vec2 t1 = ((b - surd) / a).yx;\n  vec2 t2 = ((b + surd) / a).yx;\n\n  // approximate straight lines to avoid rounding errors\n  if (abs(a.y) < 0.001)\n    t1.x = t2.x = c.y / (2.0 * b.y);\n\n  if (abs(a.x) < 0.001)\n    t1.y = t2.y = c.x / (2.0 * b.x);\n\n  // plug into quadratic formula to find the corrdinates of the crossings\n  C1 = ((a * t1 - b * 2.0) * t1 + c) * pixelScale;\n  C2 = ((a * t2 - b * 2.0) * t2 + c) * pixelScale;\n}\n\nvoid coverageX(vec2 p0, vec2 p1, vec2 p2) {\n\n  vec2 C1, C2;\n  calulateCrossings(p0, p1, p2, C1, C2);\n\n  // determine on which side of the x-axis the points lie\n  bool y0 = p0.y > vTexCoord.y;\n  bool y1 = p1.y > vTexCoord.y;\n  bool y2 = p2.y > vTexCoord.y;\n\n  // could web be under the curve (after t1)?\n  if (y1 ? !y2 : y0) {\n    // add the coverage for t1\n    coverage.x += saturate(C1.x + 0.5);\n    // calculate the anti-aliasing for t1\n    weight.x = min(weight.x, abs(C1.x));\n  }\n\n  // are we outside the curve (after t2)?\n  if (y1 ? !y0 : y2) {\n    // subtract the coverage for t2\n    coverage.x -= saturate(C2.x + 0.5);\n    // calculate the anti-aliasing for t2\n    weight.x = min(weight.x, abs(C2.x));\n  }\n}\n\n// this is essentially the same as coverageX, but with the axes swapped\nvoid coverageY(vec2 p0, vec2 p1, vec2 p2) {\n\n  vec2 C1, C2;\n  calulateCrossings(p0, p1, p2, C1, C2);\n\n  bool x0 = p0.x > vTexCoord.x;\n  bool x1 = p1.x > vTexCoord.x;\n  bool x2 = p2.x > vTexCoord.x;\n\n  if (x1 ? !x2 : x0) {\n    coverage.y -= saturate(C1.y + 0.5);\n    weight.y = min(weight.y, abs(C1.y));\n  }\n\n  if (x1 ? !x0 : x2) {\n    coverage.y += saturate(C2.y + 0.5);\n    weight.y = min(weight.y, abs(C2.y));\n  }\n}\n\nvoid main() {\n\n  // calculate the pixel scale based on screen-coordinates\n  pixelScale = hardness / fwidth(vTexCoord);\n\n  // which grid cell is this pixel in?\n  ivec2 gridCoord = ifloor(vTexCoord * vec2(uGridSize));\n\n  // intersect curves in this row\n  {\n    // the index into the row info bitmap\n    int rowIndex = gridCoord.y + uGridOffset.y;\n    // fetch the info texel\n    vec4 rowInfo = getTexel(uSamplerRows, rowIndex, uGridImageSize);\n    // unpack the rowInfo\n    int rowStrokeIndex = getInt16(rowInfo.xy);\n    int rowStrokeCount = getInt16(rowInfo.zw);\n\n    for (int iRowStroke = INT(0); iRowStroke < N; iRowStroke++) {\n      if (iRowStroke >= rowStrokeCount)\n        break;\n\n      // each stroke is made up of 3 points: the start and control point\n      // and the start of the next curve.\n      // fetch the indices of this pair of strokes:\n      vec4 strokeIndices = getTexel(uSamplerRowStrokes, rowStrokeIndex++, uCellsImageSize);\n\n      // unpack the stroke index\n      int strokePos = getInt16(strokeIndices.xy);\n\n      // fetch the two strokes\n      vec4 stroke0 = getTexel(uSamplerStrokes, strokePos + INT(0), uStrokeImageSize);\n      vec4 stroke1 = getTexel(uSamplerStrokes, strokePos + INT(1), uStrokeImageSize);\n\n      // calculate the coverage\n      coverageX(stroke0.xy, stroke0.zw, stroke1.xy);\n    }\n  }\n\n  // intersect curves in this column\n  {\n    int colIndex = gridCoord.x + uGridOffset.x;\n    vec4 colInfo = getTexel(uSamplerCols, colIndex, uGridImageSize);\n    int colStrokeIndex = getInt16(colInfo.xy);\n    int colStrokeCount = getInt16(colInfo.zw);\n    \n    for (int iColStroke = INT(0); iColStroke < N; iColStroke++) {\n      if (iColStroke >= colStrokeCount)\n        break;\n\n      vec4 strokeIndices = getTexel(uSamplerColStrokes, colStrokeIndex++, uCellsImageSize);\n\n      int strokePos = getInt16(strokeIndices.xy);\n      vec4 stroke0 = getTexel(uSamplerStrokes, strokePos + INT(0), uStrokeImageSize);\n      vec4 stroke1 = getTexel(uSamplerStrokes, strokePos + INT(1), uStrokeImageSize);\n      coverageY(stroke0.xy, stroke0.zw, stroke1.xy);\n    }\n  }\n\n  weight = saturate(1.0 - weight * 2.0);\n  float distance = max(weight.x + weight.y, minDistance); // manhattan approx.\n  float antialias = abs(dot(coverage, weight) / distance);\n  float cover = min(abs(coverage.x), abs(coverage.y));\n  OUT_COLOR = vec4(uMaterialColor.rgb, 1.) * uMaterialColor.a;\n  OUT_COLOR *= saturate(max(antialias, cover));\n}\n";
var lineVert = "/*\n  Part of the Processing project - http://processing.org\n  Copyright (c) 2012-15 The Processing Foundation\n  Copyright (c) 2004-12 Ben Fry and Casey Reas\n  Copyright (c) 2001-04 Massachusetts Institute of Technology\n  This library is free software; you can redistribute it and/or\n  modify it under the terms of the GNU Lesser General Public\n  License as published by the Free Software Foundation, version 2.1.\n  This library is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n  Lesser General Public License for more details.\n  You should have received a copy of the GNU Lesser General\n  Public License along with this library; if not, write to the\n  Free Software Foundation, Inc., 59 Temple Place, Suite 330,\n  Boston, MA  02111-1307  USA\n*/\n\n#define PROCESSING_LINE_SHADER\n\n#define HOOK_DEFINES\n\nprecision highp int;\nprecision highp float;\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\n#else\nuniform mat4 uModelViewMatrix;\n#endif\n\nuniform mat4 uProjectionMatrix;\nuniform float uStrokeWeight;\n\nuniform bool uUseLineColor;\nuniform bool uSimpleLines;\nuniform vec4 uMaterialColor;\n\nuniform vec4 uViewport;\nuniform int uPerspective;\nuniform int uStrokeJoin;\n\nIN vec3 aPosition;\nIN vec3 aTangentIn;\nIN vec3 aTangentOut;\nIN float aSide;\nIN vec4 aVertexColor;\n\nOUT vec4 vColor;\nOUT vec2 vTangent;\nOUT vec2 vCenter;\nOUT vec2 vPosition;\nOUT float vMaxDist;\nOUT float vCap;\nOUT float vJoin;\nOUT float vStrokeWeight;\n\nvec2 lineIntersection(vec2 aPoint, vec2 aDir, vec2 bPoint, vec2 bDir) {\n  // Rotate and translate so a starts at the origin and goes out to the right\n  bPoint -= aPoint;\n  vec2 rotatedBFrom = vec2(\n    bPoint.x*aDir.x + bPoint.y*aDir.y,\n    bPoint.y*aDir.x - bPoint.x*aDir.y\n  );\n  vec2 bTo = bPoint + bDir;\n  vec2 rotatedBTo = vec2(\n    bTo.x*aDir.x + bTo.y*aDir.y,\n    bTo.y*aDir.x - bTo.x*aDir.y\n  );\n  float intersectionDistance =\n    rotatedBTo.x + (rotatedBFrom.x - rotatedBTo.x) * rotatedBTo.y /\n    (rotatedBTo.y - rotatedBFrom.y);\n  return aPoint + aDir * intersectionDistance;\n}\n\nstruct StrokeVertex {\n  vec3 position;\n  vec3 tangentIn;\n  vec3 tangentOut;\n  vec4 color;\n  float weight;\n};\n\nvoid main() {\n  HOOK_beforeVertex();\n\n  if (!uSimpleLines) {\n      // Caps have one of either the in or out tangent set to 0\n      vCap = (aTangentIn == vec3(0.)) != (aTangentOut == vec3(0.)) ? 1. : 0.;\n\n      // Joins have two unique, defined tangents\n      vJoin = (\n          aTangentIn != vec3(0.) &&\n          aTangentOut != vec3(0.) &&\n          aTangentIn != aTangentOut\n      ) ? 1. : 0.;\n  }\n\n  StrokeVertex inputs;\n  inputs.position = aPosition.xyz;\n  inputs.color = uUseLineColor ? aVertexColor : uMaterialColor;\n  inputs.weight = uStrokeWeight;\n  inputs.tangentIn = aTangentIn;\n  inputs.tangentOut = aTangentOut;\n\n#ifdef AUGMENTED_HOOK_getObjectInputs\n  inputs = HOOK_getObjectInputs(inputs);\n#endif\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\n  inputs.position = (uModelMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.tangentIn = (uModelMatrix * vec4(aTangentIn, 0.)).xyz;\n  inputs.tangentOut = (uModelMatrix * vec4(aTangentOut, 0.)).xyz;\n  inputs = HOOK_getWorldInputs(inputs);\n#endif\n\n#ifdef AUGMENTED_HOOK_getWorldInputs\n  // Already multiplied by the model matrix, just apply view\n  inputs.position = (uViewMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.tangentIn = (uViewMatrix * vec4(aTangentIn, 0.)).xyz;\n  inputs.tangentOut = (uViewMatrix * vec4(aTangentOut, 0.)).xyz;\n#else\n  // Apply both at once\n  inputs.position = (uModelViewMatrix * vec4(inputs.position, 1.)).xyz;\n  inputs.tangentIn = (uModelViewMatrix * vec4(aTangentIn, 0.)).xyz;\n  inputs.tangentOut = (uModelViewMatrix * vec4(aTangentOut, 0.)).xyz;\n#endif\n#ifdef AUGMENTED_HOOK_getCameraInputs\n  inputs = hook_getCameraInputs(inputs);\n#endif\n\n  vec4 posp = vec4(inputs.position, 1.);\n  vec4 posqIn = vec4(inputs.position + inputs.tangentIn, 1.);\n  vec4 posqOut = vec4(inputs.position + inputs.tangentOut, 1.);\n  vStrokeWeight = inputs.weight;\n\n  float facingCamera = pow(\n    // The word space tangent's z value is 0 if it's facing the camera\n    abs(normalize(posqIn-posp).z),\n\n    // Using pow() here to ramp `facingCamera` up from 0 to 1 really quickly\n    // so most lines get scaled and don't get clipped\n    0.25\n  );\n\n  // Moving vertices slightly toward the camera\n  // to avoid depth-fighting with the fill triangles.\n  // A mix of scaling and offsetting is used based on distance\n  // Discussion here:\n  // https://github.com/processing/p5.js/issues/7200 \n\n  // using a scale <1 moves the lines towards nearby camera\n  // in order to prevent popping effects due to half of\n  // the line disappearing behind the geometry faces.\n  float zDistance = -posp.z; \n  float distanceFactor = smoothstep(0.0, 800.0, zDistance); \n  \n  // Discussed here:\n  // http://www.opengl.org/discussion_boards/ubbthreads.php?ubb=showflat&Number=252848  \n  float scale = mix(1., 0.995, facingCamera);\n  float dynamicScale = mix(scale, 1.0, distanceFactor); // Closer = more scale, farther = less\n\n  posp.xyz = posp.xyz * dynamicScale;\n  posqIn.xyz = posqIn.xyz * dynamicScale;\n  posqOut.xyz = posqOut.xyz * dynamicScale;\n\n  // Moving vertices slightly toward camera when far away \n  // https://github.com/processing/p5.js/issues/6956 \n  float zOffset = mix(0., -1., facingCamera);\n  float dynamicZAdjustment = mix(0.0, zOffset, distanceFactor); // Closer = less zAdjustment, farther = more\n\n  posp.z -= dynamicZAdjustment;\n  posqIn.z -= dynamicZAdjustment;\n  posqOut.z -= dynamicZAdjustment;\n  \n  vec4 p = uProjectionMatrix * posp;\n  vec4 qIn = uProjectionMatrix * posqIn;\n  vec4 qOut = uProjectionMatrix * posqOut;\n\n  // formula to convert from clip space (range -1..1) to screen space (range 0..[width or height])\n  // screen_p = (p.xy/p.w + <1,1>) * 0.5 * uViewport.zw\n\n  // prevent division by W by transforming the tangent formula (div by 0 causes\n  // the line to disappear, see https://github.com/processing/processing/issues/5183)\n  // t = screen_q - screen_p\n  //\n  // tangent is normalized and we don't care which aDirection it points to (+-)\n  // t = +- normalize( screen_q - screen_p )\n  // t = +- normalize( (q.xy/q.w+<1,1>)*0.5*uViewport.zw - (p.xy/p.w+<1,1>)*0.5*uViewport.zw )\n  //\n  // extract common factor, <1,1> - <1,1> cancels out\n  // t = +- normalize( (q.xy/q.w - p.xy/p.w) * 0.5 * uViewport.zw )\n  //\n  // convert to common divisor\n  // t = +- normalize( ((q.xy*p.w - p.xy*q.w) / (p.w*q.w)) * 0.5 * uViewport.zw )\n  //\n  // remove the common scalar divisor/factor, not needed due to normalize and +-\n  // (keep uViewport - can't remove because it has different components for x and y\n  //  and corrects for aspect ratio, see https://github.com/processing/processing/issues/5181)\n  // t = +- normalize( (q.xy*p.w - p.xy*q.w) * uViewport.zw )\n\n  vec2 tangentIn = normalize((qIn.xy*p.w - p.xy*qIn.w) * uViewport.zw);\n  vec2 tangentOut = normalize((qOut.xy*p.w - p.xy*qOut.w) * uViewport.zw);\n\n  vec2 curPerspScale;\n  if(uPerspective == 1) {\n    // Perspective ---\n    // convert from world to clip by multiplying with projection scaling factor\n    // to get the right thickness (see https://github.com/processing/processing/issues/5182)\n\n    // The y value of the projection matrix may be flipped if rendering to a Framebuffer.\n    // Multiplying again by its sign here negates the flip to get just the scale.\n    curPerspScale = (uProjectionMatrix * vec4(1, sign(uProjectionMatrix[1][1]), 0, 0)).xy;\n  } else {\n    // No Perspective ---\n    // multiply by W (to cancel out division by W later in the pipeline) and\n    // convert from screen to clip (derived from clip to screen above)\n    curPerspScale = p.w / (0.5 * uViewport.zw);\n  }\n\n  vec2 offset;\n  if (vJoin == 1. && !uSimpleLines) {\n    vTangent = normalize(tangentIn + tangentOut);\n    vec2 normalIn = vec2(-tangentIn.y, tangentIn.x);\n    vec2 normalOut = vec2(-tangentOut.y, tangentOut.x);\n    float side = sign(aSide);\n    float sideEnum = abs(aSide);\n\n    // We generate vertices for joins on either side of the centerline, but\n    // the \"elbow\" side is the only one needing a join. By not setting the\n    // offset for the other side, all its vertices will end up in the same\n    // spot and not render, effectively discarding it.\n    if (sign(dot(tangentOut, vec2(-tangentIn.y, tangentIn.x))) != side) {\n      // Side enums:\n      //   1: the side going into the join\n      //   2: the middle of the join\n      //   3: the side going out of the join\n      if (sideEnum == 2.) {\n        // Calculate the position + tangent on either side of the join, and\n        // find where the lines intersect to find the elbow of the join\n        vec2 c = (posp.xy/posp.w + vec2(1.,1.)) * 0.5 * uViewport.zw;\n        vec2 intersection = lineIntersection(\n          c + (side * normalIn * inputs.weight / 2.),\n          tangentIn,\n          c + (side * normalOut * inputs.weight / 2.),\n          tangentOut\n        );\n        offset = (intersection - c);\n\n        // When lines are thick and the angle of the join approaches 180, the\n        // elbow might be really far from the center. We'll apply a limit to\n        // the magnitude to avoid lines going across the whole screen when this\n        // happens.\n        float mag = length(offset);\n        float maxMag = 3. * inputs.weight;\n        if (mag > maxMag) {\n          offset *= maxMag / mag;\n        }\n      } else if (sideEnum == 1.) {\n        offset = side * normalIn * inputs.weight / 2.;\n      } else if (sideEnum == 3.) {\n        offset = side * normalOut * inputs.weight / 2.;\n      }\n    }\n    if (uStrokeJoin == STROKE_JOIN_BEVEL) {\n      vec2 avgNormal = vec2(-vTangent.y, vTangent.x);\n      vMaxDist = abs(dot(avgNormal, normalIn * inputs.weight / 2.));\n    } else {\n      vMaxDist = inputs.weight / 2.;\n    }\n  } else {\n    vec2 tangent = aTangentIn == vec3(0.) ? tangentOut : tangentIn;\n    vTangent = tangent;\n    vec2 normal = vec2(-tangent.y, tangent.x);\n\n    float normalOffset = sign(aSide);\n    // Caps will have side values of -2 or 2 on the edge of the cap that\n    // extends out from the line\n    float tangentOffset = abs(aSide) - 1.;\n    offset = (normal * normalOffset + tangent * tangentOffset) *\n      inputs.weight * 0.5;\n    vMaxDist = inputs.weight / 2.;\n  }\n\n  vCenter = p.xy;\n  vPosition = vCenter + offset;\n  vColor = inputs.color;\n\n  gl_Position.xy = p.xy + offset.xy * curPerspScale;\n  gl_Position.zw = p.zw;\n  \n  HOOK_afterVertex();\n}\n";
var lineFrag = "precision highp int;\nprecision highp float;\n\nuniform vec4 uMaterialColor;\nuniform int uStrokeCap;\nuniform int uStrokeJoin;\n\nIN vec4 vColor;\nIN vec2 vTangent;\nIN vec2 vCenter;\nIN vec2 vPosition;\nIN float vStrokeWeight;\nIN float vMaxDist;\nIN float vCap;\nIN float vJoin;\n\nfloat distSquared(vec2 a, vec2 b) {\n  vec2 aToB = b - a;\n  return dot(aToB, aToB);\n}\n\nstruct Inputs {\n  vec4 color;\n  vec2 tangent;\n  vec2 center;\n  vec2 position;\n  float strokeWeight;\n};\n\nvoid main() {\n  HOOK_beforeFragment();\n\n  Inputs inputs;\n  inputs.color = vColor;\n  inputs.tangent = vTangent;\n  inputs.center = vCenter;\n  inputs.position = vPosition;\n  inputs.strokeWeight = vStrokeWeight;\n  inputs = HOOK_getPixelInputs(inputs);\n\n  if (vCap > 0.) {\n    if (\n      uStrokeCap == STROKE_CAP_ROUND &&\n      HOOK_shouldDiscard(distSquared(inputs.position, inputs.center) > inputs.strokeWeight * inputs.strokeWeight * 0.25)\n    ) {\n      discard;\n    } else if (\n      uStrokeCap == STROKE_CAP_SQUARE &&\n      HOOK_shouldDiscard(dot(inputs.position - inputs.center, inputs.tangent) > 0.)\n    ) {\n      discard;\n    // Use full area for PROJECT\n    } else if (HOOK_shouldDiscard(false)) {\n      discard;\n    }\n  } else if (vJoin > 0.) {\n    if (\n      uStrokeJoin == STROKE_JOIN_ROUND &&\n      HOOK_shouldDiscard(distSquared(inputs.position, inputs.center) > inputs.strokeWeight * inputs.strokeWeight * 0.25)\n    ) {\n      discard;\n    } else if (uStrokeJoin == STROKE_JOIN_BEVEL) {\n      vec2 normal = vec2(-inputs.tangent.y, inputs.tangent.x);\n      if (HOOK_shouldDiscard(abs(dot(inputs.position - inputs.center, normal)) > vMaxDist)) {\n        discard;\n      }\n    // Use full area for MITER\n    } else if (HOOK_shouldDiscard(false)) {\n      discard;\n    }\n  }\n  OUT_COLOR = HOOK_getFinalColor(vec4(inputs.color.rgb, 1.) * inputs.color.a);\n  HOOK_afterFragment();\n}\n";
var pointVert = "IN vec3 aPosition;\nuniform float uPointSize;\nOUT float vStrokeWeight;\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvoid main() {\n  HOOK_beforeVertex();\n  vec4 viewModelPosition = vec4(HOOK_getWorldPosition(\n    (uModelViewMatrix * vec4(HOOK_getLocalPosition(aPosition), 1.0)).xyz\n  ), 1.);\n  gl_Position = uProjectionMatrix * viewModelPosition;  \n\n  float pointSize = HOOK_getPointSize(uPointSize);\n\n	gl_PointSize = pointSize;\n	vStrokeWeight = pointSize;\n  HOOK_afterVertex();\n}\n";
var pointFrag = "precision mediump int;\nuniform vec4 uMaterialColor;\nIN float vStrokeWeight;\n\nvoid main(){\n  HOOK_beforeFragment();\n  float mask = 0.0;\n\n  // make a circular mask using the gl_PointCoord (goes from 0 - 1 on a point)\n  // might be able to get a nicer edge on big strokeweights with smoothstep but slightly less performant\n\n  mask = step(0.98, length(gl_PointCoord * 2.0 - 1.0));\n\n  // if strokeWeight is 1 or less lets just draw a square\n  // this prevents weird artifacting from carving circles when our points are really small\n  // if strokeWeight is larger than 1, we just use it as is\n\n  mask = mix(0.0, mask, clamp(floor(vStrokeWeight - 0.5),0.0,1.0));\n\n  // throw away the borders of the mask\n  // otherwise we get weird alpha blending issues\n\n  if(HOOK_shouldDiscard(mask > 0.98)){\n    discard;\n  }\n\n  OUT_COLOR = HOOK_getFinalColor(vec4(uMaterialColor.rgb, 1.) * uMaterialColor.a);\n  HOOK_afterFragment();\n}\n";
var imageLightVert = "precision highp float;\nattribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aTexCoord;\n\nvarying vec3 localPos;\nvarying vec3 vWorldNormal;\nvarying vec3 vWorldPosition;\nvarying vec2 vTexCoord;\n\nuniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\nuniform mat3 uNormalMatrix;\n\nvoid main() {\n  // Multiply the position by the matrix.\n  vec4 viewModelPosition = uModelViewMatrix * vec4(aPosition, 1.0);\n  gl_Position = uProjectionMatrix * viewModelPosition;  \n  \n  // orient the normals and pass to the fragment shader\n  vWorldNormal = uNormalMatrix * aNormal;\n  \n  // send the view position to the fragment shader\n  vWorldPosition = (uModelViewMatrix * vec4(aPosition, 1.0)).xyz;\n  \n  localPos = vWorldPosition;\n  vTexCoord = aTexCoord;\n}\n\n\n/*\nin the vertex shader we'll compute the world position and world oriented normal of the vertices and pass those to the fragment shader as varyings.\n*/\n";
var imageLightDiffusedFrag = "precision highp float;\nvarying vec3 localPos;\n\n// the HDR cubemap converted (can be from an equirectangular environment map.)\nuniform sampler2D environmentMap;\nvarying vec2 vTexCoord;\n\nconst float PI = 3.14159265359;\n\nvec2 nTOE( vec3 v ){\n  // x = r sin(phi) cos(theta)   \n  // y = r cos(phi)  \n  // z = r sin(phi) sin(theta)\n  float phi = acos( v.y );\n  // if phi is 0, then there are no x, z components\n  float theta = 0.0;\n  // else \n  theta = acos(v.x / sin(phi));\n  float sinTheta = v.z / sin(phi);\n  if (sinTheta < 0.0) {\n    // Turn it into -theta, but in the 0-2PI range\n    theta = 2.0 * PI - theta;\n  }\n  theta = theta / (2.0 * 3.14159);\n  phi = phi / 3.14159 ;\n  \n  vec2 angles = vec2( phi, theta );\n  return angles;\n}\n\nfloat random(vec2 p) {\n  vec3 p3  = fract(vec3(p.xyx) * .1031);\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid main()\n{   	 \n	// the sample direction equals the hemisphere's orientation\n  float phi = vTexCoord.x * 2.0 * PI;\n  float theta = vTexCoord.y * PI;\n  float x = sin(theta) * cos(phi);\n  float y = sin(theta) * sin(phi);\n  float z = cos(theta);\n  vec3 normal = vec3( x, y, z);\n\n	// Discretely sampling the hemisphere given the integral's\n  // spherical coordinates translates to the following fragment code:\n	vec3 irradiance = vec3(0.0);  \n	vec3 up	= vec3(0.0, 1.0, 0.0);\n	vec3 right = normalize(cross(up, normal));\n	up = normalize(cross(normal, right));\n\n	//  We specify a fixed sampleDelta delta value to traverse\n  // the hemisphere; decreasing or increasing the sample delta\n  // will increase or decrease the accuracy respectively.\n	const float sampleDelta = 0.100;\n	float nrSamples = 0.0;\n  float randomOffset = random(gl_FragCoord.xy) * sampleDelta;\n	for(float rawPhi = 0.0; rawPhi < 2.0 * PI; rawPhi += sampleDelta)\n	{\n    float phi = rawPhi + randomOffset;\n    for(float rawTheta = 0.0; rawTheta < ( 0.5 ) * PI; rawTheta += sampleDelta)\n    {\n      float theta = rawTheta + randomOffset;\n      // spherical to cartesian (in tangent space) // tangent space to world // add each sample result to irradiance\n      float x = sin(theta) * cos(phi);\n      float y = sin(theta) * sin(phi);\n      float z = cos(theta);\n      vec3 tangentSample = vec3( x, y, z);\n      \n      vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * normal;\n        irradiance += (texture2D(environmentMap, nTOE(sampleVec)).xyz) * cos(theta) * sin(theta);\n      nrSamples++;\n    }\n	}\n	// divide by the total number of samples taken, giving us the average sampled irradiance.\n	irradiance = PI * irradiance * (1.0 / float(nrSamples )) ;\n  \n \n	gl_FragColor = vec4(irradiance, 1.0);\n}";
var imageLightSpecularFrag = "precision highp float;\r\nvarying vec3 localPos;\r\nvarying vec2 vTexCoord;\r\n\r\n// our texture\r\nuniform sampler2D environmentMap;\r\nuniform float roughness;\r\n\r\nconst float PI = 3.14159265359;\r\n\r\nfloat VanDerCorput(int bits);\r\nvec2 HammersleyNoBitOps(int i, int N);\r\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness);\r\n\r\n\r\nvec2 nTOE( vec3 v ){\r\n  // x = r sin(phi) cos(theta)   \r\n  // y = r cos(phi)  \r\n  // z = r sin(phi) sin(theta)\r\n  float phi = acos( v.y );\r\n  // if phi is 0, then there are no x, z components\r\n  float theta = 0.0;\r\n  // else \r\n  theta = acos(v.x / sin(phi));\r\n  float sinTheta = v.z / sin(phi);\r\n  if (sinTheta < 0.0) {\r\n    // Turn it into -theta, but in the 0-2PI range\r\n    theta = 2.0 * PI - theta;\r\n  }\r\n  theta = theta / (2.0 * 3.14159);\r\n  phi = phi / 3.14159 ;\r\n  \r\n  vec2 angles = vec2( phi, theta );\r\n  return angles;\r\n}\r\n\r\n\r\nvoid main(){\r\n  const int SAMPLE_COUNT = 400; // 4096\r\n  int lowRoughnessLimit = int(pow(2.0,(roughness+0.1)*20.0));\r\n  float totalWeight = 0.0;\r\n  vec3 prefilteredColor = vec3(0.0);\r\n  float phi = vTexCoord.x * 2.0 * PI;\r\n  float theta = vTexCoord.y * PI;\r\n  float x = sin(theta) * cos(phi);\r\n  float y = sin(theta) * sin(phi);\r\n  float z = cos(theta);\r\n  vec3 N = vec3(x,y,z);\r\n  vec3 V = N;\r\n  for (int i = 0; i < SAMPLE_COUNT; ++i)\r\n  {\r\n    // break at smaller sample numbers for low roughness levels\r\n    if(i == lowRoughnessLimit)\r\n    {\r\n      break;\r\n    }\r\n    vec2 Xi = HammersleyNoBitOps(i, SAMPLE_COUNT);\r\n    vec3 H = ImportanceSampleGGX(Xi, N, roughness);\r\n    vec3 L = normalize(2.0 * dot(V, H) * H - V);\r\n\r\n    float NdotL = max(dot(N, L), 0.0);\r\n    if (NdotL > 0.0)\r\n    {\r\n      prefilteredColor += texture2D(environmentMap, nTOE(L)).xyz * NdotL;\r\n      totalWeight += NdotL;\r\n    }\r\n  }\r\n  prefilteredColor = prefilteredColor / totalWeight;\r\n\r\n  gl_FragColor = vec4(prefilteredColor, 1.0);\r\n}\r\n\r\nvec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness){\r\n  float a = roughness * roughness;\r\n\r\n  float phi = 2.0 * PI * Xi.x;\r\n  float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));\r\n  float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\r\n  // from spherical coordinates to cartesian coordinates\r\n  vec3 H;\r\n  H.x = cos(phi) * sinTheta;\r\n  H.y = sin(phi) * sinTheta;\r\n  H.z = cosTheta;\r\n\r\n  // from tangent-space vector to world-space sample vector\r\n  vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\r\n  vec3 tangent = normalize(cross(up, N));\r\n  vec3 bitangent = cross(N, tangent);\r\n\r\n  vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\r\n  return normalize(sampleVec);\r\n}\r\n\r\n\r\nfloat VanDerCorput(int n, int base)\r\n{\r\n#ifdef WEBGL2\r\n\r\n    uint bits = uint(n);\r\n    bits = (bits << 16u) | (bits >> 16u);\r\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\r\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\r\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\r\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\r\n    return float(bits) * 2.3283064365386963e-10; // / 0x100000000\r\n\r\n#else\r\n\r\n  float invBase = 1.0 / float(base);\r\n  float denom = 1.0;\r\n  float result = 0.0;\r\n\r\n\r\n  for (int i = 0; i < 32; ++i)\r\n  {\r\n        if (n > 0)\r\n        {\r\n        denom = mod(float(n), 2.0);\r\n        result += denom * invBase;\r\n        invBase = invBase / 2.0;\r\n        n = int(float(n) / 2.0);\r\n        }\r\n  }\r\n\r\n\r\n  return result;\r\n\r\n#endif\r\n}\r\n\r\nvec2 HammersleyNoBitOps(int i, int N)\r\n{\r\n  return vec2(float(i) / float(N), VanDerCorput(i, 2));\r\n}\r\n";
var filterBaseFrag = "precision highp float;\n\nuniform sampler2D tex0;\nuniform vec2 canvasSize;\nuniform vec2 texelSize;\n\nIN vec2 vTexCoord;\n\nstruct FilterInputs {\n  vec2 texCoord;\n  vec2 canvasSize;\n  vec2 texelSize;\n};\n\nvoid main(void) {\n  FilterInputs inputs;\n  inputs.texCoord = vTexCoord;\n  inputs.canvasSize = canvasSize;\n  inputs.texelSize = texelSize;\n  OUT_COLOR = HOOK_getColor(inputs, tex0);\n  OUT_COLOR.rgb *= outColor.a;\n}\n";
var filterGrayFrag = "precision highp float;\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D tex0;\n\nfloat luma(vec3 color) {\n  // weighted grayscale with luminance values\n  return dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\n\nvoid main() {\n  vec4 tex = texture2D(tex0, vTexCoord);\n  float gray = luma(tex.rgb);\n  gl_FragColor = vec4(gray, gray, gray, tex.a);\n}\n";
var filterErodeFrag = "// Reduces the bright areas in an image\n\nprecision highp float;\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D tex0;\nuniform vec2 texelSize;\n\nfloat luma(vec3 color) {\n  // weighted grayscale with luminance values\n  // weights 77, 151, 28 taken from src/image/filters.js\n  return dot(color, vec3(0.300781, 0.589844, 0.109375));\n}\n\nvoid main() {\n  vec4 color = texture2D(tex0, vTexCoord);\n  float lum = luma(color.rgb);\n\n  // set current color as the darkest neighbor color\n\n  vec4 neighbors[4];\n  neighbors[0] = texture2D(tex0, vTexCoord + vec2( texelSize.x, 0.0));\n  neighbors[1] = texture2D(tex0, vTexCoord + vec2(-texelSize.x, 0.0));\n  neighbors[2] = texture2D(tex0, vTexCoord + vec2(0.0,  texelSize.y));\n  neighbors[3] = texture2D(tex0, vTexCoord + vec2(0.0, -texelSize.y));\n\n  for (int i = 0; i < 4; i++) {\n    vec4 neighborColor = neighbors[i];\n    float neighborLum = luma(neighborColor.rgb);\n\n    if (neighborLum < lum) {\n      color = neighborColor;\n      lum = neighborLum;\n    }\n  }\n\n  gl_FragColor = color;\n}\n";
var filterDilateFrag = "// Increase the bright areas in an image\n\nprecision highp float;\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D tex0;\nuniform vec2 texelSize;\n\nfloat luma(vec3 color) {\n  // weighted grayscale with luminance values\n  // weights 77, 151, 28 taken from src/image/filters.js\n  return dot(color, vec3(0.300781, 0.589844, 0.109375));\n}\n\nvoid main() {\n  vec4 color = texture2D(tex0, vTexCoord);\n  float lum = luma(color.rgb);\n\n  // set current color as the brightest neighbor color\n\n  vec4 neighbors[4];\n  neighbors[0] = texture2D(tex0, vTexCoord + vec2( texelSize.x, 0.0));\n  neighbors[1] = texture2D(tex0, vTexCoord + vec2(-texelSize.x, 0.0));\n  neighbors[2] = texture2D(tex0, vTexCoord + vec2(0.0,  texelSize.y));\n  neighbors[3] = texture2D(tex0, vTexCoord + vec2(0.0, -texelSize.y));\n\n  for (int i = 0; i < 4; i++) {\n    vec4 neighborColor = neighbors[i];\n    float neighborLum = luma(neighborColor.rgb);\n\n    if (neighborLum > lum) {\n      color = neighborColor;\n      lum = neighborLum;\n    }\n  }\n\n  gl_FragColor = color;\n}\n";
var filterBlurFrag = "precision highp float;\n\n// Two-pass blur filter, unweighted kernel.\n// See also a similar blur at Adam Ferriss' repo of shader examples:\n// https://github.com/aferriss/p5jsShaderExamples/blob/gh-pages/4_image-effects/4-9_single-pass-blur/effect.frag\n\n\nuniform sampler2D tex0;\nvarying vec2 vTexCoord;\nuniform vec2 direction;\nuniform vec2 canvasSize;\nuniform float radius;\n\nfloat random(vec2 p) {\n  vec3 p3  = fract(vec3(p.xyx) * .1031);\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\n// This isn't a real Gaussian weight, it's a quadratic weight. It's what the\n// CPU mode's blur uses though, so we also use it here to match.\nfloat quadWeight(float x, float e) {\n  return pow(e-abs(x), 2.);\n}\n\nvoid main(){\n  vec2 uv = vTexCoord;\n\n  // A reasonable maximum number of samples\n  const float maxSamples = 64.0;\n\n  float numSamples = floor(7. * radius);\n  if (fract(numSamples / 2.) == 0.) {\n    numSamples++;\n  }\n  vec4 avg = vec4(0.0);\n  float total = 0.0;\n\n  // Calculate the spacing to avoid skewing if numSamples > maxSamples\n  float spacing = 1.0;\n  if (numSamples > maxSamples) {\n    spacing = numSamples / maxSamples;\n    numSamples = maxSamples;\n  }\n\n  float randomOffset = (spacing - 1.0) * mix(-0.5, 0.5, random(gl_FragCoord.xy));\n  for (float i = 0.0; i < maxSamples; i++) {\n    if (i >= numSamples) break;\n\n    float sample = i * spacing - (numSamples - 1.0) * 0.5 * spacing + randomOffset;\n    vec2 sampleCoord = uv + vec2(sample, sample) / canvasSize * direction;\n    float weight = quadWeight(sample, (numSamples - 1.0) * 0.5 * spacing);\n\n    avg += weight * texture2D(tex0, sampleCoord);\n    total += weight;\n  }\n\n  avg /= total;\n  gl_FragColor = avg;\n}\n";
var filterPosterizeFrag = "// Limit color space for a stylized cartoon / poster effect\n\nprecision highp float;\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D tex0;\nuniform float filterParameter;\n\nvec3 quantize(vec3 color, float n) {\n  // restrict values to N options/bins\n  // and floor each channel to nearest value\n  //\n  // eg. when N = 5, values = 0.0, 0.25, 0.50, 0.75, 1.0\n  // then quantize (0.1, 0.7, 0.9) -> (0.0, 0.5, 1.0)\n\n  color = color * n;\n  color = floor(color);\n  color = color / (n - 1.0);\n  return color;\n}\n\nvoid main() {\n  vec4 color = texture2D(tex0, vTexCoord);\n\n  vec3 restrictedColor = quantize(color.rgb / color.a, filterParameter);\n\n  gl_FragColor = vec4(restrictedColor.rgb * color.a, color.a);\n}\n";
var filterOpaqueFrag = "// Set alpha channel to entirely opaque\n\nprecision highp float;\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D tex0;\n\nvoid main() {\n  vec4 color = texture2D(tex0, vTexCoord);\n  gl_FragColor = vec4(color.rgb / color.a, 1.0);\n}\n";
var filterInvertFrag = "// Set each pixel to inverse value\n// Note that original INVERT does not change the opacity, so this follows suit\n\nprecision highp float;\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D tex0;\n\nvoid main() {\nvec4 color = texture2D(tex0, vTexCoord);\nvec3 origColor = color.rgb / color.a;\nvec3 invertedColor = vec3(1.0) - origColor;\ngl_FragColor = vec4(invertedColor * color.a, color.a);\n}\n";
var filterThresholdFrag = "// Convert pixels to either white or black, \n// depending on if their luma is above or below filterParameter\n\nprecision highp float;\n\nvarying vec2 vTexCoord;\n\nuniform sampler2D tex0;\nuniform float filterParameter;\n\nfloat luma(vec3 color) {\n  // weighted grayscale with luminance values\n  return dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\n\nvoid main() {\n  vec4 color = texture2D(tex0, vTexCoord);\n  float gray = luma(color.rgb / color.a);\n  // floor() used to match src/image/filters.js\n  float threshold = floor(filterParameter * 255.0) / 255.0;\n  float blackOrWhite = step(threshold, gray);\n  gl_FragColor = vec4(vec3(blackOrWhite) * color.a, color.a);\n}\n";
var filterShaderVert = "uniform mat4 uModelViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nattribute vec3 aPosition;\n// texcoords only come from p5 to vertex shader\n// so pass texcoords on to the fragment shader in a varying variable\nattribute vec2 aTexCoord;\nvarying vec2 vTexCoord;\n\nvoid main() {\n  // transferring texcoords for the frag shader\n  vTexCoord = aTexCoord;\n\n  // copy position with a fourth coordinate for projection (1.0 is normal)\n  vec4 positionVec4 = vec4(aPosition, 1.0);\n\n  gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;\n}\n";
var STROKE_CAP_ENUM = {};
var STROKE_JOIN_ENUM = {};
var lineDefs = "";
var defineStrokeCapEnum = function(key, val2) {
  lineDefs += `#define STROKE_CAP_${key} ${val2}
`;
  STROKE_CAP_ENUM[constants[key]] = val2;
};
var defineStrokeJoinEnum = function(key, val2) {
  lineDefs += `#define STROKE_JOIN_${key} ${val2}
`;
  STROKE_JOIN_ENUM[constants[key]] = val2;
};
defineStrokeCapEnum("ROUND", 0);
defineStrokeCapEnum("PROJECT", 1);
defineStrokeCapEnum("SQUARE", 2);
defineStrokeJoinEnum("ROUND", 0);
defineStrokeJoinEnum("MITER", 1);
defineStrokeJoinEnum("BEVEL", 2);
var defaultShaders = {
  normalVert,
  normalFrag,
  basicFrag,
  sphereMappingFrag,
  lightVert: lightingShader + lightVert,
  lightTextureFrag,
  phongVert,
  phongFrag: lightingShader + phongFrag,
  fontVert,
  fontFrag,
  lineVert: lineDefs + lineVert,
  lineFrag: lineDefs + lineFrag,
  pointVert,
  pointFrag,
  imageLightVert,
  imageLightDiffusedFrag,
  imageLightSpecularFrag,
  filterBaseVert,
  filterBaseFrag
};
var sphereMapping = defaultShaders.sphereMappingFrag;
for (const key in defaultShaders) {
  defaultShaders[key] = webgl2CompatibilityShader + defaultShaders[key];
}
var filterShaderFrags = {
  [GRAY]: filterGrayFrag,
  [ERODE]: filterErodeFrag,
  [DILATE]: filterDilateFrag,
  [BLUR]: filterBlurFrag,
  [POSTERIZE]: filterPosterizeFrag,
  [OPAQUE]: filterOpaqueFrag,
  [INVERT]: filterInvertFrag,
  [THRESHOLD]: filterThresholdFrag
};
var RendererGL = class _RendererGL extends Renderer {
  constructor(pInst, w, h, isMainCanvas, elt, attr) {
    super(pInst, w, h, isMainCanvas);
    this.canvas = this.elt = elt || document.createElement("canvas");
    this._setAttributeDefaults(pInst);
    this._initContext();
    this.GL = this.drawingContext;
    if (this._isMainCanvas) {
      this._pInst._curElement = this;
      this._pInst.canvas = this.canvas;
    } else {
      this.canvas.style.display = "none";
    }
    this.elt.id = "defaultCanvas0";
    this.elt.classList.add("p5Canvas");
    this.wrappedElt = new Element(this.elt, this._pInst);
    for (const p2 of Object.getOwnPropertyNames(Element.prototype)) {
      if (p2 !== "constructor" && p2[0] !== "_") {
        Object.defineProperty(this, p2, {
          get() {
            return this.wrappedElt[p2];
          }
        });
      }
    }
    const dimensions = this._adjustDimensions(w, h);
    w = dimensions.adjustedWidth;
    h = dimensions.adjustedHeight;
    this.width = w;
    this.height = h;
    this.elt.width = w * this._pixelDensity;
    this.elt.height = h * this._pixelDensity;
    this.elt.style.width = `${w}px`;
    this.elt.style.height = `${h}px`;
    this._origViewport = {
      width: this.GL.drawingBufferWidth,
      height: this.GL.drawingBufferHeight
    };
    this.viewport(this._origViewport.width, this._origViewport.height);
    if (this._pInst._userNode) {
      this._pInst._userNode.appendChild(this.elt);
    } else {
      if (document.getElementsByTagName("main").length === 0) {
        let m3 = document.createElement("main");
        document.body.appendChild(m3);
      }
      document.getElementsByTagName("main")[0].appendChild(this.elt);
    }
    this.isP3D = true;
    this.geometryBuilder = void 0;
    this.states.uModelMatrix = new Matrix(4);
    this.states.uViewMatrix = new Matrix(4);
    this.states.uPMatrix = new Matrix(4);
    this.states.curCamera = new Camera(this);
    this.states.uPMatrix.set(this.states.curCamera.projMatrix);
    this.states.uViewMatrix.set(this.states.curCamera.cameraMatrix);
    this.states.enableLighting = false;
    this.states.ambientLightColors = [];
    this.states.specularColors = [1, 1, 1];
    this.states.directionalLightDirections = [];
    this.states.directionalLightDiffuseColors = [];
    this.states.directionalLightSpecularColors = [];
    this.states.pointLightPositions = [];
    this.states.pointLightDiffuseColors = [];
    this.states.pointLightSpecularColors = [];
    this.states.spotLightPositions = [];
    this.states.spotLightDirections = [];
    this.states.spotLightDiffuseColors = [];
    this.states.spotLightSpecularColors = [];
    this.states.spotLightAngle = [];
    this.states.spotLightConc = [];
    this.states.activeImageLight = null;
    this.states.curFillColor = [1, 1, 1, 1];
    this.states.curAmbientColor = [1, 1, 1, 1];
    this.states.curSpecularColor = [0, 0, 0, 0];
    this.states.curEmissiveColor = [0, 0, 0, 0];
    this.states.curStrokeColor = [0, 0, 0, 1];
    this.states.curBlendMode = BLEND;
    this.states._hasSetAmbient = false;
    this.states._useSpecularMaterial = false;
    this.states._useEmissiveMaterial = false;
    this.states._useNormalMaterial = false;
    this.states._useShininess = 1;
    this.states._useMetalness = 0;
    this.states.tint = [255, 255, 255, 255];
    this.states.constantAttenuation = 1;
    this.states.linearAttenuation = 0;
    this.states.quadraticAttenuation = 0;
    this.states._currentNormal = new Vector(0, 0, 1);
    this.states.drawMode = FILL;
    this.states._tex = null;
    this.states.textureMode = IMAGE;
    this.states.textureWrapX = CLAMP;
    this.states.textureWrapY = CLAMP;
    this._isErasing = false;
    this._simpleLines = false;
    this._clipDepths = [];
    this._isClipApplied = false;
    this._stencilTestOn = false;
    this.mixedAmbientLight = [];
    this.mixedSpecularColor = [];
    this.diffusedTextures = /* @__PURE__ */ new Map();
    this.specularTextures = /* @__PURE__ */ new Map();
    this.preEraseBlend = void 0;
    this._cachedBlendMode = void 0;
    this._cachedFillStyle = [1, 1, 1, 1];
    this._cachedStrokeStyle = [0, 0, 0, 1];
    if (this.webglVersion === WEBGL2) {
      this.blendExt = this.GL;
    } else {
      this.blendExt = this.GL.getExtension("EXT_blend_minmax");
    }
    this._isBlending = false;
    this._useLineColor = false;
    this._useVertexColor = false;
    this.registerEnabled = /* @__PURE__ */ new Set();
    this.states.curCamera._computeCameraDefaultSettings();
    this.states.curCamera._setDefaultCamera();
    this.filterCamera = new Camera(this);
    this.filterCamera._computeCameraDefaultSettings();
    this.filterCamera._setDefaultCamera();
    this.prevTouches = [];
    this.zoomVelocity = 0;
    this.rotateVelocity = new Vector(0, 0);
    this.moveVelocity = new Vector(0, 0);
    this.executeZoom = false;
    this.executeRotateAndMove = false;
    this._drawingFilter = false;
    this._drawingImage = false;
    this.specularShader = void 0;
    this.sphereMapping = void 0;
    this.diffusedShader = void 0;
    this._baseFilterShader = void 0;
    this._defaultLightShader = void 0;
    this._defaultImmediateModeShader = void 0;
    this._defaultNormalShader = void 0;
    this._defaultColorShader = void 0;
    this._defaultPointShader = void 0;
    this.states.userFillShader = void 0;
    this.states.userStrokeShader = void 0;
    this.states.userPointShader = void 0;
    this.states.userImageShader = void 0;
    this.states.curveDetail = 1 / 4;
    this.shapeBuilder = new ShapeBuilder(this);
    this.buffers = {
      fill: [
        new RenderBuffer(
          3,
          "vertices",
          "vertexBuffer",
          "aPosition",
          this,
          this._vToNArray
        ),
        new RenderBuffer(
          3,
          "vertexNormals",
          "normalBuffer",
          "aNormal",
          this,
          this._vToNArray
        ),
        new RenderBuffer(
          4,
          "vertexColors",
          "colorBuffer",
          "aVertexColor",
          this
        ),
        new RenderBuffer(
          3,
          "vertexAmbients",
          "ambientBuffer",
          "aAmbientColor",
          this
        ),
        new RenderBuffer(
          2,
          "uvs",
          "uvBuffer",
          "aTexCoord",
          this,
          (arr2) => arr2.flat()
        )
      ],
      stroke: [
        new RenderBuffer(
          4,
          "lineVertexColors",
          "lineColorBuffer",
          "aVertexColor",
          this
        ),
        new RenderBuffer(
          3,
          "lineVertices",
          "lineVerticesBuffer",
          "aPosition",
          this
        ),
        new RenderBuffer(
          3,
          "lineTangentsIn",
          "lineTangentsInBuffer",
          "aTangentIn",
          this
        ),
        new RenderBuffer(
          3,
          "lineTangentsOut",
          "lineTangentsOutBuffer",
          "aTangentOut",
          this
        ),
        new RenderBuffer(1, "lineSides", "lineSidesBuffer", "aSide", this)
      ],
      text: [
        new RenderBuffer(
          3,
          "vertices",
          "vertexBuffer",
          "aPosition",
          this,
          this._vToNArray
        ),
        new RenderBuffer(
          2,
          "uvs",
          "uvBuffer",
          "aTexCoord",
          this,
          (arr2) => arr2.flat()
        )
      ],
      point: this.GL.createBuffer(),
      user: []
    };
    this.geometryBufferCache = new GeometryBufferCache(this);
    this.curStrokeCap = ROUND;
    this.curStrokeJoin = ROUND;
    this.textures = /* @__PURE__ */ new Map();
    this.framebuffers = /* @__PURE__ */ new Set();
    this.activeFramebuffers = [];
    this.states.filterShader = void 0;
    this.filterLayer = void 0;
    this.filterLayerTemp = void 0;
    this.defaultFilterShaders = {};
    this.fontInfos = {};
    this._curShader = void 0;
    this.drawShapeCount = 1;
    this.scratchMat3 = new Matrix(3);
    this._userEnabledStencil = false;
    this._internalEnable = this.drawingContext.enable;
    this._internalDisable = this.drawingContext.disable;
    this.drawingContext.enable = (key) => {
      if (key === this.drawingContext.STENCIL_TEST) {
        if (!this._clipping) {
          this._userEnabledStencil = true;
        }
      }
      return this._internalEnable.call(this.drawingContext, key);
    };
    this.drawingContext.disable = (key) => {
      if (key === this.drawingContext.STENCIL_TEST) {
        this._userEnabledStencil = false;
      }
      return this._internalDisable.call(this.drawingContext, key);
    };
    this._validateFaces = false;
  }
  remove() {
    this.wrappedElt.remove();
    this.wrappedElt = null;
    this.canvas = null;
    this.elt = null;
  }
  //////////////////////////////////////////////
  // Geometry Building
  //////////////////////////////////////////////
  /**
   * Starts creating a new p5.Geometry. Subsequent shapes drawn will be added
   * to the geometry and then returned when
   * <a href="#/p5/endGeometry">endGeometry()</a> is called. One can also use
   * <a href="#/p5/buildGeometry">buildGeometry()</a> to pass a function that
   * draws shapes.
   *
   * If you need to draw complex shapes every frame which don't change over time,
   * combining them upfront with `beginGeometry()` and `endGeometry()` and then
   * drawing that will run faster than repeatedly drawing the individual pieces.
   * @private
   */
  beginGeometry() {
    if (this.geometryBuilder) {
      throw new Error(
        "It looks like `beginGeometry()` is being called while another p5.Geometry is already being build."
      );
    }
    this.geometryBuilder = new GeometryBuilder(this);
    this.geometryBuilder.prevFillColor = this.states.fillColor;
    this.fill(new Color([-1, -1, -1, -1]));
  }
  /**
   * Finishes creating a new <a href="#/p5.Geometry">p5.Geometry</a> that was
   * started using <a href="#/p5/beginGeometry">beginGeometry()</a>. One can also
   * use <a href="#/p5/buildGeometry">buildGeometry()</a> to pass a function that
   * draws shapes.
   * @private
   *
   * @returns {p5.Geometry} The model that was built.
   */
  endGeometry() {
    if (!this.geometryBuilder) {
      throw new Error(
        "Make sure you call beginGeometry() before endGeometry()!"
      );
    }
    const geometry2 = this.geometryBuilder.finish();
    this.fill(this.geometryBuilder.prevFillColor);
    this.geometryBuilder = void 0;
    return geometry2;
  }
  /**
   * Creates a new <a href="#/p5.Geometry">p5.Geometry</a> that contains all
   * the shapes drawn in a provided callback function. The returned combined shape
   * can then be drawn all at once using <a href="#/p5/model">model()</a>.
   *
   * If you need to draw complex shapes every frame which don't change over time,
   * combining them with `buildGeometry()` once and then drawing that will run
   * faster than repeatedly drawing the individual pieces.
   *
   * One can also draw shapes directly between
   * <a href="#/p5/beginGeometry">beginGeometry()</a> and
   * <a href="#/p5/endGeometry">endGeometry()</a> instead of using a callback
   * function.
   * @param {Function} callback A function that draws shapes.
   * @returns {p5.Geometry} The model that was built from the callback function.
   */
  buildGeometry(callback) {
    this.beginGeometry();
    callback();
    return this.endGeometry();
  }
  //////////////////////////////////////////////
  // Shape drawing
  //////////////////////////////////////////////
  beginShape(...args) {
    super.beginShape(...args);
  }
  curveDetail(d2) {
    if (d2 === void 0) {
      return this.states.curveDetail;
    } else {
      this.states.setValue("curveDetail", d2);
    }
  }
  drawShape(shape2) {
    const visitor = new PrimitiveToVerticesConverter({
      curveDetail: this.states.curveDetail
    });
    shape2.accept(visitor);
    this.shapeBuilder.constructFromContours(shape2, visitor.contours);
    if (this.geometryBuilder) {
      this.geometryBuilder.addImmediate(
        this.shapeBuilder.geometry,
        this.shapeBuilder.shapeMode,
        { validateFaces: this._validateFaces }
      );
    } else if (this.states.fillColor || this.states.strokeColor) {
      if (this.shapeBuilder.shapeMode === POINTS) {
        this._drawPoints(
          this.shapeBuilder.geometry.vertices,
          this.buffers.point
        );
      } else {
        this._drawGeometry(this.shapeBuilder.geometry, {
          mode: this.shapeBuilder.shapeMode,
          count: this.drawShapeCount
        });
      }
    }
    this.drawShapeCount = 1;
  }
  endShape(mode, count) {
    this.drawShapeCount = count;
    super.endShape(mode, count);
  }
  vertexProperty(...args) {
    this.currentShape.vertexProperty(...args);
  }
  normal(xorv, y, z) {
    if (xorv instanceof Vector) {
      this.states.setValue("_currentNormal", xorv);
    } else {
      this.states.setValue("_currentNormal", new Vector(xorv, y, z));
    }
    this.updateShapeVertexProperties();
  }
  model(model, count = 1) {
    if (model.vertices.length > 0) {
      if (this.geometryBuilder) {
        this.geometryBuilder.addRetained(model);
      } else {
        if (!this.geometryInHash(model.gid)) {
          model._edgesToVertices();
          this._getOrMakeCachedBuffers(model);
        }
        this._drawGeometry(model, { count });
      }
    }
  }
  //////////////////////////////////////////////
  // Rendering
  //////////////////////////////////////////////
  _drawGeometry(geometry2, { mode = TRIANGLES, count = 1 } = {}) {
    for (const propName in geometry2.userVertexProperties) {
      const prop = geometry2.userVertexProperties[propName];
      this.buffers.user.push(
        new RenderBuffer(
          prop.getDataSize(),
          prop.getSrcName(),
          prop.getDstName(),
          prop.getName(),
          this
        )
      );
    }
    if (this.states.fillColor && geometry2.vertices.length >= 3 && ![LINES, POINTS].includes(mode)) {
      this._drawFills(geometry2, { mode, count });
    }
    if (this.states.strokeColor && geometry2.lineVertices.length >= 1) {
      this._drawStrokes(geometry2, { count });
    }
    this.buffers.user = [];
  }
  _drawGeometryScaled(model, scaleX, scaleY, scaleZ) {
    let originalModelMatrix = this.states.uModelMatrix;
    this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
    try {
      this.states.uModelMatrix.scale(scaleX, scaleY, scaleZ);
      if (this.geometryBuilder) {
        this.geometryBuilder.addRetained(model);
      } else {
        this._drawGeometry(model);
      }
    } finally {
      this.states.setValue("uModelMatrix", originalModelMatrix);
    }
  }
  _drawFills(geometry2, { count, mode } = {}) {
    this._useVertexColor = geometry2.vertexColors.length > 0;
    const shader2 = !this._drawingFilter && this.states.userFillShader ? this.states.userFillShader : this._getFillShader();
    shader2.bindShader();
    this._setGlobalUniforms(shader2);
    this._setFillUniforms(shader2);
    shader2.bindTextures();
    for (const buff of this.buffers.fill) {
      buff._prepareBuffer(geometry2, shader2);
    }
    this._prepareUserAttributes(geometry2, shader2);
    shader2.disableRemainingAttributes();
    this._applyColorBlend(
      this.states.curFillColor,
      geometry2.hasFillTransparency()
    );
    this._drawBuffers(geometry2, { mode, count });
    shader2.unbindShader();
  }
  _drawStrokes(geometry2, { count } = {}) {
    const gl = this.GL;
    this._useLineColor = geometry2.vertexStrokeColors.length > 0;
    const shader2 = this._getStrokeShader();
    shader2.bindShader();
    this._setGlobalUniforms(shader2);
    this._setStrokeUniforms(shader2);
    shader2.bindTextures();
    for (const buff of this.buffers.stroke) {
      buff._prepareBuffer(geometry2, shader2);
    }
    this._prepareUserAttributes(geometry2, shader2);
    shader2.disableRemainingAttributes();
    this._applyColorBlend(
      this.states.curStrokeColor,
      geometry2.hasStrokeTransparency()
    );
    if (count === 1) {
      gl.drawArrays(gl.TRIANGLES, 0, geometry2.lineVertices.length / 3);
    } else {
      try {
        gl.drawArraysInstanced(
          gl.TRIANGLES,
          0,
          geometry2.lineVertices.length / 3,
          count
        );
      } catch (e2) {
        console.log(
          "🌸 p5.js says: Instancing is only supported in WebGL2 mode"
        );
      }
    }
    shader2.unbindShader();
  }
  _drawPoints(vertices, vertexBuffer) {
    const gl = this.GL;
    const pointShader = this._getPointShader();
    pointShader.bindShader();
    this._setGlobalUniforms(pointShader);
    this._setPointUniforms(pointShader);
    pointShader.bindTextures();
    this._bindBuffer(
      vertexBuffer,
      gl.ARRAY_BUFFER,
      this._vToNArray(vertices),
      Float32Array,
      gl.STATIC_DRAW
    );
    pointShader.enableAttrib(pointShader.attributes.aPosition, 3);
    this._applyColorBlend(this.states.curStrokeColor);
    gl.drawArrays(gl.Points, 0, vertices.length);
    pointShader.unbindShader();
  }
  _prepareUserAttributes(geometry2, shader2) {
    for (const buff of this.buffers.user) {
      if (!this._pInst.constructor.disableFriendlyErrors) {
        const prop = geometry2.userVertexProperties[buff.attr];
        if (prop) {
          const adjustedLength = prop.getSrcArray().length / prop.getDataSize();
          if (adjustedLength > geometry2.vertices.length) {
            this._pInst.constructor._friendlyError(
              `One of the geometries has a custom vertex property '${prop.getName()}' with more values than vertices. This is probably caused by directly using the Geometry.vertexProperty() method.`,
              "vertexProperty()"
            );
          } else if (adjustedLength < geometry2.vertices.length) {
            this._pInst.constructor._friendlyError(
              `One of the geometries has a custom vertex property '${prop.getName()}' with fewer values than vertices. This is probably caused by directly using the Geometry.vertexProperty() method.`,
              "vertexProperty()"
            );
          }
        }
      }
      buff._prepareBuffer(geometry2, shader2);
    }
  }
  _drawBuffers(geometry2, { mode = this.GL.TRIANGLES, count }) {
    const gl = this.GL;
    const glBuffers = this.geometryBufferCache.getCached(geometry2);
    if (!glBuffers) return;
    if (glBuffers.indexBuffer) {
      this._bindBuffer(glBuffers.indexBuffer, gl.ELEMENT_ARRAY_BUFFER);
      if (this._pInst.webglVersion !== WEBGL2 && glBuffers.indexBufferType === gl.UNSIGNED_INT) {
        if (!gl.getExtension("OES_element_index_uint")) {
          throw new Error(
            "Unable to render a 3d model with > 65535 triangles. Your web browser does not support the WebGL Extension OES_element_index_uint."
          );
        }
      }
      if (count === 1) {
        gl.drawElements(
          gl.TRIANGLES,
          geometry2.faces.length * 3,
          glBuffers.indexBufferType,
          0
        );
      } else {
        try {
          gl.drawElementsInstanced(
            gl.TRIANGLES,
            geometry2.faces.length * 3,
            glBuffers.indexBufferType,
            0,
            count
          );
        } catch (e2) {
          console.log(
            "🌸 p5.js says: Instancing is only supported in WebGL2 mode"
          );
        }
      }
    } else {
      if (count === 1) {
        gl.drawArrays(mode, 0, geometry2.vertices.length);
      } else {
        try {
          gl.drawArraysInstanced(mode, 0, geometry2.vertices.length, count);
        } catch (e2) {
          console.log(
            "🌸 p5.js says: Instancing is only supported in WebGL2 mode"
          );
        }
      }
    }
  }
  _getOrMakeCachedBuffers(geometry2) {
    return this.geometryBufferCache.ensureCached(geometry2);
  }
  //////////////////////////////////////////////
  // Setting
  //////////////////////////////////////////////
  _setAttributeDefaults(pInst) {
    const applyAA = navigator.userAgent.toLowerCase().includes("safari");
    const defaults2 = {
      alpha: true,
      depth: true,
      stencil: true,
      antialias: applyAA,
      premultipliedAlpha: true,
      preserveDrawingBuffer: true,
      perPixelLighting: true,
      version: 2
    };
    if (pInst._glAttributes === null) {
      pInst._glAttributes = defaults2;
    } else {
      pInst._glAttributes = Object.assign(defaults2, pInst._glAttributes);
    }
    return;
  }
  _initContext() {
    var _a2;
    if (((_a2 = this._pInst._glAttributes) == null ? void 0 : _a2.version) !== 1) {
      this.drawingContext = this.canvas.getContext(
        "webgl2",
        this._pInst._glAttributes
      );
    }
    this.webglVersion = this.drawingContext ? WEBGL2 : WEBGL;
    this._pInst.webglVersion = this.webglVersion;
    if (!this.drawingContext) {
      this.drawingContext = this.canvas.getContext("webgl", this._pInst._glAttributes) || this.canvas.getContext("experimental-webgl", this._pInst._glAttributes);
    }
    if (this.drawingContext === null) {
      throw new Error("Error creating webgl context");
    } else {
      const gl = this.drawingContext;
      gl.enable(gl.DEPTH_TEST);
      gl.depthFunc(gl.LEQUAL);
      gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
      this._viewport = this.drawingContext.getParameter(
        this.drawingContext.VIEWPORT
      );
    }
  }
  _getMaxTextureSize() {
    const gl = this.drawingContext;
    return gl.getParameter(gl.MAX_TEXTURE_SIZE);
  }
  _adjustDimensions(width, height) {
    if (!this._maxTextureSize) {
      this._maxTextureSize = this._getMaxTextureSize();
    }
    let maxTextureSize = this._maxTextureSize;
    let maxAllowedPixelDimensions = Math.floor(
      maxTextureSize / this._pixelDensity
    );
    let adjustedWidth = Math.min(width, maxAllowedPixelDimensions);
    let adjustedHeight = Math.min(height, maxAllowedPixelDimensions);
    if (adjustedWidth !== width || adjustedHeight !== height) {
      console.warn(
        `Warning: The requested width/height exceeds hardware limits. Adjusting dimensions to width: ${adjustedWidth}, height: ${adjustedHeight}.`
      );
    }
    return { adjustedWidth, adjustedHeight };
  }
  //This is helper function to reset the context anytime the attributes
  //are changed with setAttributes()
  _resetContext(options2, callback) {
    const w = this.width;
    const h = this.height;
    const defaultId = this.canvas.id;
    const isPGraphics = this._pInst instanceof Graphics;
    const prevStyle = {
      position: this.canvas.style.position,
      top: this.canvas.style.top,
      left: this.canvas.style.left
    };
    if (isPGraphics) {
      const pg = this._pInst;
      pg.canvas.parentNode.removeChild(pg.canvas);
      pg.canvas = document.createElement("canvas");
      const node = pg._pInst._userNode || document.body;
      node.appendChild(pg.canvas);
      Element.call(pg, pg.canvas, pg._pInst);
      pg.width = w;
      pg.height = h;
    } else {
      let c4 = this.canvas;
      if (c4) {
        c4.parentNode.removeChild(c4);
      }
      c4 = document.createElement("canvas");
      c4.id = defaultId;
      if (this._pInst._userNode) {
        this._pInst._userNode.appendChild(c4);
      } else {
        document.body.appendChild(c4);
      }
      this._pInst.canvas = c4;
      this.canvas = c4;
      this.canvas.style.position = prevStyle.position;
      this.canvas.style.top = prevStyle.top;
      this.canvas.style.left = prevStyle.left;
    }
    const renderer2 = new _RendererGL(
      this._pInst,
      w,
      h,
      !isPGraphics,
      this._pInst.canvas
    );
    this._pInst._renderer = renderer2;
    renderer2._applyDefaults();
    if (typeof callback === "function") {
      setTimeout(() => {
        callback.apply(window._renderer, options2);
      }, 0);
    }
  }
  _update() {
    this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
    this.states.uModelMatrix.reset();
    this.states.setValue("uViewMatrix", this.states.uViewMatrix.clone());
    this.states.uViewMatrix.set(this.states.curCamera.cameraMatrix);
    this.states.setValue("ambientLightColors", []);
    this.states.setValue("specularColors", [1, 1, 1]);
    this.states.setValue("directionalLightDirections", []);
    this.states.setValue("directionalLightDiffuseColors", []);
    this.states.setValue("directionalLightSpecularColors", []);
    this.states.setValue("pointLightPositions", []);
    this.states.setValue("pointLightDiffuseColors", []);
    this.states.setValue("pointLightSpecularColors", []);
    this.states.setValue("spotLightPositions", []);
    this.states.setValue("spotLightDirections", []);
    this.states.setValue("spotLightDiffuseColors", []);
    this.states.setValue("spotLightSpecularColors", []);
    this.states.setValue("spotLightAngle", []);
    this.states.setValue("spotLightConc", []);
    this.states.setValue("enableLighting", false);
    this.states.setValue("tint", [255, 255, 255, 255]);
    this.GL.clearStencil(0);
    this.GL.clear(this.GL.DEPTH_BUFFER_BIT | this.GL.STENCIL_BUFFER_BIT);
    if (!this._userEnabledStencil) {
      this._internalDisable.call(this.GL, this.GL.STENCIL_TEST);
    }
  }
  /**
   * [background description]
   */
  background(...args) {
    const _col = this._pInst.color(...args);
    this.clear(..._col._getRGBA());
  }
  //////////////////////////////////////////////
  // Positioning
  //////////////////////////////////////////////
  get uModelMatrix() {
    return this.states.uModelMatrix;
  }
  get uViewMatrix() {
    return this.states.uViewMatrix;
  }
  get uPMatrix() {
    return this.states.uPMatrix;
  }
  get uMVMatrix() {
    const m3 = this.uModelMatrix.copy();
    m3.mult(this.uViewMatrix);
    return m3;
  }
  /**
   * Get a matrix from world-space to screen-space
   */
  getWorldToScreenMatrix() {
    const modelMatrix = this.states.uModelMatrix;
    const viewMatrix = this.states.uViewMatrix;
    const projectionMatrix = this.states.uPMatrix;
    const projectedToScreenMatrix = new Matrix(4);
    projectedToScreenMatrix.scale(this.width, this.height, 1);
    projectedToScreenMatrix.translate([0.5, 0.5, 0.5]);
    projectedToScreenMatrix.scale(0.5, -0.5, 0.5);
    const modelViewMatrix = modelMatrix.copy().mult(viewMatrix);
    const modelViewProjectionMatrix = modelViewMatrix.mult(projectionMatrix);
    const worldToScreenMatrix = modelViewProjectionMatrix.mult(projectedToScreenMatrix);
    return worldToScreenMatrix;
  }
  //////////////////////////////////////////////
  // COLOR
  //////////////////////////////////////////////
  /**
   * Basic fill material for geometry with a given color
   * @param  {Number|Number[]|String|p5.Color} v1  gray value,
   * red or hue value (depending on the current color mode),
   * or color Array, or CSS color string
   * @param  {Number}            [v2] green or saturation value
   * @param  {Number}            [v3] blue or brightness value
   * @param  {Number}            [a]  opacity
   * @chainable
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(200, 200, WEBGL);
   * }
   *
   * function draw() {
   *   background(0);
   *   noStroke();
   *   fill(100, 100, 240);
   *   rotateX(frameCount * 0.01);
   *   rotateY(frameCount * 0.01);
   *   box(75, 75, 75);
   * }
   * </code>
   * </div>
   *
   * @alt
   * black canvas with purple cube spinning
   */
  fill(...args) {
    super.fill(...args);
    const color3 = this.states.fillColor;
    this.states.setValue("curFillColor", color3._array);
    this.states.setValue("drawMode", FILL);
    this.states.setValue("_useNormalMaterial", false);
    this.states.setValue("_tex", null);
  }
  /**
   * Basic stroke material for geometry with a given color
   * @param  {Number|Number[]|String|p5.Color} v1  gray value,
   * red or hue value (depending on the current color mode),
   * or color Array, or CSS color string
   * @param  {Number}            [v2] green or saturation value
   * @param  {Number}            [v3] blue or brightness value
   * @param  {Number}            [a]  opacity
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(200, 200, WEBGL);
   * }
   *
   * function draw() {
   *   background(0);
   *   stroke(240, 150, 150);
   *   fill(100, 100, 240);
   *   rotateX(frameCount * 0.01);
   *   rotateY(frameCount * 0.01);
   *   box(75, 75, 75);
   * }
   * </code>
   * </div>
   *
   * @alt
   * black canvas with purple cube with pink outline spinning
   */
  stroke(...args) {
    super.stroke(...args);
    this.states.setValue("curStrokeColor", this.states.strokeColor._array);
  }
  getCommonVertexProperties() {
    return {
      ...super.getCommonVertexProperties(),
      stroke: this.states.strokeColor,
      fill: this.states.fillColor,
      normal: this.states._currentNormal
    };
  }
  getSupportedIndividualVertexProperties() {
    return {
      textureCoordinates: true
    };
  }
  strokeCap(cap) {
    this.curStrokeCap = cap;
  }
  strokeJoin(join) {
    this.curStrokeJoin = join;
  }
  getFilterLayer() {
    if (!this.filterLayer) {
      this.filterLayer = new Framebuffer(this);
    }
    return this.filterLayer;
  }
  getFilterLayerTemp() {
    if (!this.filterLayerTemp) {
      this.filterLayerTemp = new Framebuffer(this);
    }
    return this.filterLayerTemp;
  }
  matchSize(fboToMatch, target) {
    if (fboToMatch.width !== target.width || fboToMatch.height !== target.height) {
      fboToMatch.resize(target.width, target.height);
    }
    if (fboToMatch.pixelDensity() !== target.pixelDensity()) {
      fboToMatch.pixelDensity(target.pixelDensity());
    }
  }
  filter(...args) {
    let fbo = this.getFilterLayer();
    let filterParameter = void 0;
    let operation = void 0;
    if (typeof args[0] === "string") {
      operation = args[0];
      let useDefaultParam = operation in filterParamDefaults && args[1] === void 0;
      filterParameter = useDefaultParam ? filterParamDefaults[operation] : args[1];
      if (!(operation in this.defaultFilterShaders)) {
        this.defaultFilterShaders[operation] = new Shader(
          fbo.renderer,
          filterShaderVert,
          filterShaderFrags[operation]
        );
      }
      this.states.setValue(
        "filterShader",
        this.defaultFilterShaders[operation]
      );
    } else {
      this.states.setValue("filterShader", args[0]);
    }
    const target = this.activeFramebuffer() || this;
    this.matchSize(fbo, target);
    fbo.draw(() => this.clear());
    let texelSize = [
      1 / (target.width * target.pixelDensity()),
      1 / (target.height * target.pixelDensity())
    ];
    if (operation === BLUR) {
      const tmp = this.getFilterLayerTemp();
      this.matchSize(tmp, target);
      this.push();
      this.states.setValue("strokeColor", null);
      this.blendMode(BLEND);
      this.shader(this.states.filterShader);
      this.states.filterShader.setUniform("texelSize", texelSize);
      this.states.filterShader.setUniform("canvasSize", [
        target.width,
        target.height
      ]);
      this.states.filterShader.setUniform(
        "radius",
        Math.max(1, filterParameter)
      );
      tmp.draw(() => {
        this.states.filterShader.setUniform("direction", [1, 0]);
        this.states.filterShader.setUniform("tex0", target);
        this.clear();
        this.shader(this.states.filterShader);
        this.noLights();
        this.plane(target.width, target.height);
      });
      fbo.draw(() => {
        this.states.filterShader.setUniform("direction", [0, 1]);
        this.states.filterShader.setUniform("tex0", tmp);
        this.clear();
        this.shader(this.states.filterShader);
        this.noLights();
        this.plane(target.width, target.height);
      });
      this.pop();
    } else {
      fbo.draw(() => {
        this.states.setValue("strokeColor", null);
        this.blendMode(BLEND);
        this.shader(this.states.filterShader);
        this.states.filterShader.setUniform("tex0", target);
        this.states.filterShader.setUniform("texelSize", texelSize);
        this.states.filterShader.setUniform("canvasSize", [
          target.width,
          target.height
        ]);
        this.states.filterShader.setUniform("filterParameter", filterParameter);
        this.noLights();
        this.plane(target.width, target.height);
      });
    }
    this.push();
    this.states.setValue("strokeColor", null);
    this.clear();
    this.push();
    this.states.setValue("imageMode", CORNER);
    this.blendMode(BLEND);
    target.filterCamera._resize();
    this.setCamera(target.filterCamera);
    this.resetMatrix();
    this._drawingFilter = true;
    this.image(
      fbo,
      0,
      0,
      this.width,
      this.height,
      -target.width / 2,
      -target.height / 2,
      target.width,
      target.height
    );
    this._drawingFilter = false;
    this.clearDepth();
    this.pop();
    this.pop();
  }
  // Pass this off to the host instance so that we can treat a renderer and a
  // framebuffer the same in filter()
  pixelDensity(newDensity) {
    if (newDensity) {
      return this._pInst.pixelDensity(newDensity);
    }
    return this._pInst.pixelDensity();
  }
  blendMode(mode) {
    if (mode === DARKEST || mode === LIGHTEST || mode === ADD || mode === BLEND || mode === SUBTRACT || mode === SCREEN || mode === EXCLUSION || mode === REPLACE || mode === MULTIPLY || mode === REMOVE)
      this.states.setValue("curBlendMode", mode);
    else if (mode === BURN || mode === OVERLAY || mode === HARD_LIGHT || mode === SOFT_LIGHT || mode === DODGE) {
      console.warn(
        "BURN, OVERLAY, HARD_LIGHT, SOFT_LIGHT, and DODGE only work for blendMode in 2D mode."
      );
    }
  }
  erase(opacityFill, opacityStroke) {
    if (!this._isErasing) {
      this.preEraseBlend = this.states.curBlendMode;
      this._isErasing = true;
      this.blendMode(REMOVE);
      this._cachedFillStyle = this.states.curFillColor.slice();
      this.states.setValue("curFillColor", [1, 1, 1, opacityFill / 255]);
      this._cachedStrokeStyle = this.states.curStrokeColor.slice();
      this.states.setValue("curStrokeColor", [1, 1, 1, opacityStroke / 255]);
    }
  }
  noErase() {
    if (this._isErasing) {
      this.states.setValue("curFillColor", this._cachedFillStyle.slice());
      this.states.setValue("curStrokeColor", this._cachedStrokeStyle.slice());
      this.states.setValue("curBlendMode", this.preEraseBlend);
      this.blendMode(this.preEraseBlend);
      this._isErasing = false;
      this._applyBlendMode();
    }
  }
  drawTarget() {
    return this.activeFramebuffers[this.activeFramebuffers.length - 1] || this;
  }
  beginClip(options2 = {}) {
    super.beginClip(options2);
    this.drawTarget()._isClipApplied = true;
    const gl = this.GL;
    gl.clearStencil(0);
    gl.clear(gl.STENCIL_BUFFER_BIT);
    this._internalEnable.call(gl, gl.STENCIL_TEST);
    this._stencilTestOn = true;
    gl.stencilFunc(
      gl.ALWAYS,
      // the test
      1,
      // reference value
      255
      // mask
    );
    gl.stencilOp(
      gl.KEEP,
      // what to do if the stencil test fails
      gl.KEEP,
      // what to do if the depth test fails
      gl.REPLACE
      // what to do if both tests pass
    );
    gl.disable(gl.DEPTH_TEST);
    this.push();
    this.resetShader();
    if (this.states.fillColor) this.fill(0, 0);
    if (this.states.strokeColor) this.stroke(0, 0);
  }
  endClip() {
    this.pop();
    const gl = this.GL;
    gl.stencilOp(
      gl.KEEP,
      // what to do if the stencil test fails
      gl.KEEP,
      // what to do if the depth test fails
      gl.KEEP
      // what to do if both tests pass
    );
    gl.stencilFunc(
      this._clipInvert ? gl.EQUAL : gl.NOTEQUAL,
      // the test
      0,
      // reference value
      255
      // mask
    );
    gl.enable(gl.DEPTH_TEST);
    this._clipDepths.push(this._pushPopDepth);
    super.endClip();
  }
  _clearClip() {
    this.GL.clearStencil(1);
    this.GL.clear(this.GL.STENCIL_BUFFER_BIT);
    if (this._clipDepths.length > 0) {
      this._clipDepths.pop();
    }
    this.drawTarget()._isClipApplied = false;
  }
  // x,y are canvas-relative (pre-scaled by _pixelDensity)
  _getPixel(x, y) {
    const gl = this.GL;
    return readPixelWebGL(
      gl,
      null,
      x,
      y,
      gl.RGBA,
      gl.UNSIGNED_BYTE,
      this._pInst.height * this._pInst.pixelDensity()
    );
  }
  /**
   * Loads the pixels data for this canvas into the pixels[] attribute.
   * Note that updatePixels() and set() do not work.
   * Any pixel manipulation must be done directly to the pixels[] array.
   *
   * @private
   */
  loadPixels() {
    if (this._pInst._glAttributes.preserveDrawingBuffer !== true) {
      console.log(
        "loadPixels only works in WebGL when preserveDrawingBuffer is true."
      );
      return;
    }
    const pd = this._pixelDensity;
    const gl = this.GL;
    this.pixels = readPixelsWebGL(
      this.pixels,
      gl,
      null,
      0,
      0,
      this.width * pd,
      this.height * pd,
      gl.RGBA,
      gl.UNSIGNED_BYTE,
      this.height * pd
    );
  }
  updatePixels() {
    const fbo = this._getTempFramebuffer();
    fbo.pixels = this.pixels;
    fbo.updatePixels();
    this.push();
    this.resetMatrix();
    this.clear();
    this.states.setValue("imageMode", CORNER);
    this.image(
      fbo,
      0,
      0,
      fbo.width,
      fbo.height,
      -fbo.width / 2,
      -fbo.height / 2,
      fbo.width,
      fbo.height
    );
    this.pop();
    this.GL.clearDepth(1);
    this.GL.clear(this.GL.DEPTH_BUFFER_BIT);
  }
  /**
   * @private
   * @returns {p5.Framebuffer} A p5.Framebuffer set to match the size and settings
   * of the renderer's canvas. It will be created if it does not yet exist, and
   * reused if it does.
   */
  _getTempFramebuffer() {
    if (!this._tempFramebuffer) {
      this._tempFramebuffer = new Framebuffer(this, {
        format: UNSIGNED_BYTE,
        useDepth: this._pInst._glAttributes.depth,
        depthFormat: UNSIGNED_INT,
        antialias: this._pInst._glAttributes.antialias
      });
    }
    return this._tempFramebuffer;
  }
  //////////////////////////////////////////////
  // HASH | for geometry
  //////////////////////////////////////////////
  geometryInHash(gid) {
    return this.geometryBufferCache.isCached(gid);
  }
  viewport(w, h) {
    this._viewport = [0, 0, w, h];
    this.GL.viewport(0, 0, w, h);
  }
  /**
   * [resize description]
   * @private
   * @param  {Number} w [description]
   * @param  {Number} h [description]
   */
  resize(w, h) {
    super.resize(w, h);
    const props = {};
    for (const key in this.drawingContext) {
      const val2 = this.drawingContext[key];
      if (typeof val2 !== "object" && typeof val2 !== "function") {
        props[key] = val2;
      }
    }
    const dimensions = this._adjustDimensions(w, h);
    w = dimensions.adjustedWidth;
    h = dimensions.adjustedHeight;
    this.width = w;
    this.height = h;
    this.canvas.width = w * this._pixelDensity;
    this.canvas.height = h * this._pixelDensity;
    this.canvas.style.width = `${w}px`;
    this.canvas.style.height = `${h}px`;
    this._origViewport = {
      width: this.GL.drawingBufferWidth,
      height: this.GL.drawingBufferHeight
    };
    this.viewport(this._origViewport.width, this._origViewport.height);
    this.states.curCamera._resize();
    if (typeof this.pixels !== "undefined") {
      this.pixels = new Uint8Array(
        this.GL.drawingBufferWidth * this.GL.drawingBufferHeight * 4
      );
    }
    for (const framebuffer2 of this.framebuffers) {
      framebuffer2._canvasSizeChanged();
    }
    for (const savedKey in props) {
      try {
        this.drawingContext[savedKey] = props[savedKey];
      } catch (err2) {
      }
    }
  }
  /**
   * clears color and depth buffers
   * with r,g,b,a
   * @private
   * @param {Number} r normalized red val.
   * @param {Number} g normalized green val.
   * @param {Number} b normalized blue val.
   * @param {Number} a normalized alpha val.
   */
  clear(...args) {
    const _r = args[0] || 0;
    const _g = args[1] || 0;
    const _b2 = args[2] || 0;
    let _a2 = args[3] || 0;
    const activeFramebuffer = this.activeFramebuffer();
    if (activeFramebuffer && activeFramebuffer.format === UNSIGNED_BYTE && !activeFramebuffer.antialias && _a2 === 0) {
      _a2 = 1e-10;
    }
    this.GL.clearColor(_r * _a2, _g * _a2, _b2 * _a2, _a2);
    this.GL.clearDepth(1);
    this.GL.clear(this.GL.COLOR_BUFFER_BIT | this.GL.DEPTH_BUFFER_BIT);
  }
  /**
   * Resets all depth information so that nothing previously drawn will
   * occlude anything subsequently drawn.
   */
  clearDepth(depth = 1) {
    this.GL.clearDepth(depth);
    this.GL.clear(this.GL.DEPTH_BUFFER_BIT);
  }
  applyMatrix(a2, b3, c4, d2, e2, f) {
    this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
    if (arguments.length === 16) {
      Matrix.prototype.apply.apply(this.states.uModelMatrix, arguments);
    } else {
      this.states.uModelMatrix.apply([
        a2,
        b3,
        0,
        0,
        c4,
        d2,
        0,
        0,
        0,
        0,
        1,
        0,
        e2,
        f,
        0,
        1
      ]);
    }
  }
  /**
   * [translate description]
   * @private
   * @param  {Number} x [description]
   * @param  {Number} y [description]
   * @param  {Number} z [description]
   * @chainable
   * @todo implement handle for components or vector as args
   */
  translate(x, y, z) {
    if (x instanceof Vector) {
      z = x.z;
      y = x.y;
      x = x.x;
    }
    this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
    this.states.uModelMatrix.translate([x, y, z]);
    return this;
  }
  /**
   * Scales the Model View Matrix by a vector
   * @private
   * @param  {Number | p5.Vector | Array} x [description]
   * @param  {Number} [y] y-axis scalar
   * @param  {Number} [z] z-axis scalar
   * @chainable
   */
  scale(x, y, z) {
    this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
    this.states.uModelMatrix.scale(x, y, z);
    return this;
  }
  rotate(rad, axis) {
    if (typeof axis === "undefined") {
      return this.rotateZ(rad);
    }
    this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
    Matrix.prototype.rotate4x4.apply(this.states.uModelMatrix, arguments);
    return this;
  }
  rotateX(rad) {
    this.rotate(rad, 1, 0, 0);
    return this;
  }
  rotateY(rad) {
    this.rotate(rad, 0, 1, 0);
    return this;
  }
  rotateZ(rad) {
    this.rotate(rad, 0, 0, 1);
    return this;
  }
  pop(...args) {
    if (this._clipDepths.length > 0 && this._pushPopDepth === this._clipDepths[this._clipDepths.length - 1]) {
      this._clearClip();
      if (!this._userEnabledStencil) {
        this._internalDisable.call(this.GL, this.GL.STENCIL_TEST);
      }
    }
    super.pop(...args);
    this._applyStencilTestIfClipping();
  }
  _applyStencilTestIfClipping() {
    const drawTarget = this.drawTarget();
    if (drawTarget._isClipApplied !== this._stencilTestOn) {
      if (drawTarget._isClipApplied) {
        this._internalEnable.call(this.GL, this.GL.STENCIL_TEST);
        this._stencilTestOn = true;
      } else {
        if (!this._userEnabledStencil) {
          this._internalDisable.call(this.GL, this.GL.STENCIL_TEST);
        }
        this._stencilTestOn = false;
      }
    }
  }
  resetMatrix() {
    this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
    this.states.uModelMatrix.reset();
    this.states.setValue("uViewMatrix", this.states.uViewMatrix.clone());
    this.states.uViewMatrix.set(this.states.curCamera.cameraMatrix);
    return this;
  }
  //////////////////////////////////////////////
  // SHADER
  //////////////////////////////////////////////
  /*
   * shaders are created and cached on a per-renderer basis,
   * on the grounds that each renderer will have its own gl context
   * and the shader must be valid in that context.
   */
  _getStrokeShader() {
    const stroke = this.states.userStrokeShader;
    if (stroke) {
      return stroke;
    }
    return this._getLineShader();
  }
  _getSphereMapping(img) {
    if (!this.sphereMapping) {
      this.sphereMapping = this._pInst.createFilterShader(sphereMapping);
    }
    this.scratchMat3.inverseTranspose4x4(this.states.uViewMatrix);
    this.scratchMat3.invert(this.scratchMat3);
    this.sphereMapping.setUniform("uFovY", this.states.curCamera.cameraFOV);
    this.sphereMapping.setUniform("uAspect", this.states.curCamera.aspectRatio);
    this.sphereMapping.setUniform("uNewNormalMatrix", this.scratchMat3.mat3);
    this.sphereMapping.setUniform("uEnvMap", img);
    return this.sphereMapping;
  }
  /*
   * This method will handle both image shaders and
   * fill shaders, returning the appropriate shader
   * depending on the current context (image or shape).
   */
  _getFillShader() {
    if (this._drawingImage) {
      if (this.states.userImageShader && !this._drawingFilter) {
        return this.states.userImageShader;
      } else {
        return this._getLightShader();
      }
    } else if (this.states.userFillShader) {
      return this.states.userFillShader;
    } else if (this.states._useNormalMaterial) {
      return this._getNormalShader();
    } else if (this.states.enableLighting || this.states._tex) {
      return this._getLightShader();
    }
    return this._getColorShader();
  }
  _getPointShader() {
    const point = this.states.userPointShader;
    if (!point || !point.isPointShader()) {
      return this._getPointShader();
    }
    return point;
  }
  baseMaterialShader() {
    if (!this._pInst._glAttributes.perPixelLighting) {
      throw new Error(
        "The material shader does not support hooks without perPixelLighting. Try turning it back on."
      );
    }
    return this._getLightShader();
  }
  _getLightShader() {
    if (!this._defaultLightShader) {
      if (this._pInst._glAttributes.perPixelLighting) {
        this._defaultLightShader = new Shader(
          this,
          this._webGL2CompatibilityPrefix("vert", "highp") + defaultShaders.phongVert,
          this._webGL2CompatibilityPrefix("frag", "highp") + defaultShaders.phongFrag,
          {
            vertex: {
              "void beforeVertex": "() {}",
              "Vertex getObjectInputs": "(Vertex inputs) { return inputs; }",
              "Vertex getWorldInputs": "(Vertex inputs) { return inputs; }",
              "Vertex getCameraInputs": "(Vertex inputs) { return inputs; }",
              "void afterVertex": "() {}"
            },
            fragment: {
              "void beforeFragment": "() {}",
              "Inputs getPixelInputs": "(Inputs inputs) { return inputs; }",
              "vec4 combineColors": `(ColorComponents components) {
                vec4 color = vec4(0.);
                color.rgb += components.diffuse * components.baseColor;
                color.rgb += components.ambient * components.ambientColor;
                color.rgb += components.specular * components.specularColor;
                color.rgb += components.emissive;
                color.a = components.opacity;
                return color;
              }`,
              "vec4 getFinalColor": "(vec4 color) { return color; }",
              "void afterFragment": "() {}"
            }
          }
        );
      } else {
        this._defaultLightShader = new Shader(
          this,
          this._webGL2CompatibilityPrefix("vert", "highp") + defaultShaders.lightVert,
          this._webGL2CompatibilityPrefix("frag", "highp") + defaultShaders.lightTextureFrag
        );
      }
    }
    return this._defaultLightShader;
  }
  baseNormalShader() {
    return this._getNormalShader();
  }
  _getNormalShader() {
    if (!this._defaultNormalShader) {
      this._defaultNormalShader = new Shader(
        this,
        this._webGL2CompatibilityPrefix("vert", "mediump") + defaultShaders.normalVert,
        this._webGL2CompatibilityPrefix("frag", "mediump") + defaultShaders.normalFrag,
        {
          vertex: {
            "void beforeVertex": "() {}",
            "Vertex getObjectInputs": "(Vertex inputs) { return inputs; }",
            "Vertex getWorldInputs": "(Vertex inputs) { return inputs; }",
            "Vertex getCameraInputs": "(Vertex inputs) { return inputs; }",
            "void afterVertex": "() {}"
          },
          fragment: {
            "void beforeFragment": "() {}",
            "vec4 getFinalColor": "(vec4 color) { return color; }",
            "void afterFragment": "() {}"
          }
        }
      );
    }
    return this._defaultNormalShader;
  }
  baseColorShader() {
    return this._getColorShader();
  }
  _getColorShader() {
    if (!this._defaultColorShader) {
      this._defaultColorShader = new Shader(
        this,
        this._webGL2CompatibilityPrefix("vert", "mediump") + defaultShaders.normalVert,
        this._webGL2CompatibilityPrefix("frag", "mediump") + defaultShaders.basicFrag,
        {
          vertex: {
            "void beforeVertex": "() {}",
            "Vertex getObjectInputs": "(Vertex inputs) { return inputs; }",
            "Vertex getWorldInputs": "(Vertex inputs) { return inputs; }",
            "Vertex getCameraInputs": "(Vertex inputs) { return inputs; }",
            "void afterVertex": "() {}"
          },
          fragment: {
            "void beforeFragment": "() {}",
            "vec4 getFinalColor": "(vec4 color) { return color; }",
            "void afterFragment": "() {}"
          }
        }
      );
    }
    return this._defaultColorShader;
  }
  /**
   * TODO(dave): un-private this when there is a way to actually override the
   * shader used for points
   *
   * Get the shader used when drawing points with <a href="#/p5/point">`point()`</a>.
   *
   * You can call <a href="#/p5.Shader/modify">`pointShader().modify()`</a>
   * and change any of the following hooks:
   * - `void beforeVertex`: Called at the start of the vertex shader.
   * - `vec3 getLocalPosition`: Update the position of vertices before transforms are applied. It takes in `vec3 position` and must return a modified version.
   * - `vec3 getWorldPosition`: Update the position of vertices after transforms are applied. It takes in `vec3 position` and pust return a modified version.
   * - `float getPointSize`: Update the size of the point. It takes in `float size` and must return a modified version.
   * - `void afterVertex`: Called at the end of the vertex shader.
   * - `void beforeFragment`: Called at the start of the fragment shader.
   * - `bool shouldDiscard`: Points are drawn inside a square, with the corners discarded in the fragment shader to create a circle. Use this to change this logic. It takes in a `bool willDiscard` and must return a modified version.
   * - `vec4 getFinalColor`: Update the final color after mixing. It takes in a `vec4 color` and must return a modified version.
   * - `void afterFragment`: Called at the end of the fragment shader.
   *
   * Call `pointShader().inspectHooks()` to see all the possible hooks and
   * their default implementations.
   *
   * @returns {p5.Shader} The `point()` shader
   * @private()
   */
  pointShader() {
    return this._getPointShader();
  }
  _getPointShader() {
    if (!this._defaultPointShader) {
      this._defaultPointShader = new Shader(
        this,
        this._webGL2CompatibilityPrefix("vert", "mediump") + defaultShaders.pointVert,
        this._webGL2CompatibilityPrefix("frag", "mediump") + defaultShaders.pointFrag,
        {
          vertex: {
            "void beforeVertex": "() {}",
            "vec3 getLocalPosition": "(vec3 position) { return position; }",
            "vec3 getWorldPosition": "(vec3 position) { return position; }",
            "float getPointSize": "(float size) { return size; }",
            "void afterVertex": "() {}"
          },
          fragment: {
            "void beforeFragment": "() {}",
            "vec4 getFinalColor": "(vec4 color) { return color; }",
            "bool shouldDiscard": "(bool outside) { return outside; }",
            "void afterFragment": "() {}"
          }
        }
      );
    }
    return this._defaultPointShader;
  }
  baseStrokeShader() {
    return this._getLineShader();
  }
  _getLineShader() {
    if (!this._defaultLineShader) {
      this._defaultLineShader = new Shader(
        this,
        this._webGL2CompatibilityPrefix("vert", "mediump") + defaultShaders.lineVert,
        this._webGL2CompatibilityPrefix("frag", "mediump") + defaultShaders.lineFrag,
        {
          vertex: {
            "void beforeVertex": "() {}",
            "StrokeVertex getObjectInputs": "(StrokeVertex inputs) { return inputs; }",
            "StrokeVertex getWorldInputs": "(StrokeVertex inputs) { return inputs; }",
            "StrokeVertex getCameraInputs": "(StrokeVertex inputs) { return inputs; }",
            "void afterVertex": "() {}"
          },
          fragment: {
            "void beforeFragment": "() {}",
            "Inputs getPixelInputs": "(Inputs inputs) { return inputs; }",
            "vec4 getFinalColor": "(vec4 color) { return color; }",
            "bool shouldDiscard": "(bool outside) { return outside; }",
            "void afterFragment": "() {}"
          }
        }
      );
    }
    return this._defaultLineShader;
  }
  _getFontShader() {
    if (!this._defaultFontShader) {
      if (this.webglVersion === WEBGL) {
        this.GL.getExtension("OES_standard_derivatives");
      }
      this._defaultFontShader = new Shader(
        this,
        this._webGL2CompatibilityPrefix("vert", "highp") + defaultShaders.fontVert,
        this._webGL2CompatibilityPrefix("frag", "highp") + defaultShaders.fontFrag
      );
    }
    return this._defaultFontShader;
  }
  baseFilterShader() {
    if (!this._baseFilterShader) {
      this._baseFilterShader = new Shader(
        this,
        this._webGL2CompatibilityPrefix("vert", "highp") + defaultShaders.filterBaseVert,
        this._webGL2CompatibilityPrefix("frag", "highp") + defaultShaders.filterBaseFrag,
        {
          vertex: {},
          fragment: {
            "vec4 getColor": `(FilterInputs inputs, in sampler2D canvasContent) {
                return getTexture(canvasContent, inputs.texCoord);
              }`
          }
        }
      );
    }
    return this._baseFilterShader;
  }
  _webGL2CompatibilityPrefix(shaderType, floatPrecision) {
    let code = "";
    if (this.webglVersion === WEBGL2) {
      code += "#version 300 es\n#define WEBGL2\n";
    }
    if (shaderType === "vert") {
      code += "#define VERTEX_SHADER\n";
    } else if (shaderType === "frag") {
      code += "#define FRAGMENT_SHADER\n";
    }
    if (floatPrecision) {
      code += `precision ${floatPrecision} float;
`;
    }
    return code;
  }
  /**
   * @private
   * Note: DO NOT CALL THIS while in the middle of binding another texture,
   * since it will change the texture binding in order to allocate the empty
   * texture! Grab its value beforehand!
   */
  _getEmptyTexture() {
    if (!this._emptyTexture) {
      const im = new Image(1, 1);
      im.set(0, 0, 255);
      this._emptyTexture = new Texture(this, im);
    }
    return this._emptyTexture;
  }
  getTexture(input) {
    let src = input;
    if (src instanceof Framebuffer) {
      src = src.color;
    }
    const texture2 = this.textures.get(src);
    if (texture2) {
      return texture2;
    }
    const tex = new Texture(this, src);
    this.textures.set(src, tex);
    return tex;
  }
  /*
   *  used in imageLight,
   *  To create a blurry image from the input non blurry img, if it doesn't already exist
   *  Add it to the diffusedTexture map,
   *  Returns the blurry image
   *  maps a Image used by imageLight() to a p5.Framebuffer
   */
  getDiffusedTexture(input) {
    if (this.diffusedTextures.get(input) != null) {
      return this.diffusedTextures.get(input);
    }
    let newFramebuffer;
    let smallWidth = 200;
    let width = smallWidth;
    let height = Math.floor(smallWidth * (input.height / input.width));
    newFramebuffer = new Framebuffer(this, {
      width,
      height,
      density: 1
    });
    if (!this.diffusedShader) {
      this.diffusedShader = this._pInst.createShader(
        defaultShaders.imageLightVert,
        defaultShaders.imageLightDiffusedFrag
      );
    }
    newFramebuffer.draw(() => {
      this.shader(this.diffusedShader);
      this.diffusedShader.setUniform("environmentMap", input);
      this.states.setValue("strokeColor", null);
      this.noLights();
      this.plane(width, height);
    });
    this.diffusedTextures.set(input, newFramebuffer);
    return newFramebuffer;
  }
  /*
   *  used in imageLight,
   *  To create a texture from the input non blurry image, if it doesn't already exist
   *  Creating 8 different levels of textures according to different
   *  sizes and atoring them in `levels` array
   *  Creating a new Mipmap texture with that `levels` array
   *  Storing the texture for input image in map called `specularTextures`
   *  maps the input Image to a p5.MipmapTexture
   */
  getSpecularTexture(input) {
    if (this.specularTextures.get(input) != null) {
      return this.specularTextures.get(input);
    }
    const size = 512;
    let tex;
    const levels = [];
    const framebuffer2 = new Framebuffer(this, {
      width: size,
      height: size,
      density: 1
    });
    let count = Math.log(size) / Math.log(2);
    if (!this.specularShader) {
      this.specularShader = this._pInst.createShader(
        defaultShaders.imageLightVert,
        defaultShaders.imageLightSpecularFrag
      );
    }
    for (let w = size; w >= 1; w /= 2) {
      framebuffer2.resize(w, w);
      let currCount = Math.log(w) / Math.log(2);
      let roughness = 1 - currCount / count;
      framebuffer2.draw(() => {
        this.shader(this.specularShader);
        this.clear();
        this.specularShader.setUniform("environmentMap", input);
        this.specularShader.setUniform("roughness", roughness);
        this.states.setValue("strokeColor", null);
        this.noLights();
        this.plane(w, w);
      });
      levels.push(framebuffer2.get().drawingContext.getImageData(0, 0, w, w));
    }
    framebuffer2.remove();
    tex = new MipmapTexture(this, levels, {});
    this.specularTextures.set(input, tex);
    return tex;
  }
  /**
   * @private
   * @returns {p5.Framebuffer|null} The currently active framebuffer, or null if
   * the main canvas is the current draw target.
   */
  activeFramebuffer() {
    return this.activeFramebuffers[this.activeFramebuffers.length - 1] || null;
  }
  createFramebuffer(options2) {
    return new Framebuffer(this, options2);
  }
  _setGlobalUniforms(shader2) {
    const modelMatrix = this.states.uModelMatrix;
    const viewMatrix = this.states.uViewMatrix;
    const projectionMatrix = this.states.uPMatrix;
    const modelViewMatrix = modelMatrix.copy().mult(viewMatrix);
    shader2.setUniform(
      "uPerspective",
      this.states.curCamera.useLinePerspective ? 1 : 0
    );
    shader2.setUniform("uViewMatrix", viewMatrix.mat4);
    shader2.setUniform("uProjectionMatrix", projectionMatrix.mat4);
    shader2.setUniform("uModelMatrix", modelMatrix.mat4);
    shader2.setUniform("uModelViewMatrix", modelViewMatrix.mat4);
    if (shader2.uniforms.uModelViewProjectionMatrix) {
      const modelViewProjectionMatrix = modelViewMatrix.copy();
      modelViewProjectionMatrix.mult(projectionMatrix);
      shader2.setUniform(
        "uModelViewProjectionMatrix",
        modelViewProjectionMatrix.mat4
      );
    }
    if (shader2.uniforms.uNormalMatrix) {
      this.scratchMat3.inverseTranspose4x4(modelViewMatrix);
      shader2.setUniform("uNormalMatrix", this.scratchMat3.mat3);
    }
    if (shader2.uniforms.uModelNormalMatrix) {
      this.scratchMat3.inverseTranspose4x4(this.states.uModelMatrix);
      shader2.setUniform("uModelNormalMatrix", this.scratchMat3.mat3);
    }
    if (shader2.uniforms.uCameraNormalMatrix) {
      this.scratchMat3.inverseTranspose4x4(this.states.uViewMatrix);
      shader2.setUniform("uCameraNormalMatrix", this.scratchMat3.mat3);
    }
    if (shader2.uniforms.uCameraRotation) {
      this.scratchMat3.inverseTranspose4x4(this.states.uViewMatrix);
      shader2.setUniform("uCameraRotation", this.scratchMat3.mat3);
    }
    shader2.setUniform("uViewport", this._viewport);
  }
  _setStrokeUniforms(strokeShader) {
    strokeShader.setUniform("uSimpleLines", this._simpleLines);
    strokeShader.setUniform("uUseLineColor", this._useLineColor);
    strokeShader.setUniform("uMaterialColor", this.states.curStrokeColor);
    strokeShader.setUniform("uStrokeWeight", this.states.strokeWeight);
    strokeShader.setUniform("uStrokeCap", STROKE_CAP_ENUM[this.curStrokeCap]);
    strokeShader.setUniform(
      "uStrokeJoin",
      STROKE_JOIN_ENUM[this.curStrokeJoin]
    );
  }
  _setFillUniforms(fillShader) {
    this.mixedSpecularColor = [...this.states.curSpecularColor];
    const empty2 = this._getEmptyTexture();
    if (this.states._useMetalness > 0) {
      this.mixedSpecularColor = this.mixedSpecularColor.map(
        (mixedSpecularColor, index) => this.states.curFillColor[index] * this.states._useMetalness + mixedSpecularColor * (1 - this.states._useMetalness)
      );
    }
    fillShader.setUniform("uUseVertexColor", this._useVertexColor);
    fillShader.setUniform("uMaterialColor", this.states.curFillColor);
    fillShader.setUniform("isTexture", !!this.states._tex);
    fillShader.setUniform("uSampler", this.states._tex || empty2);
    fillShader.setUniform("uTint", this.states.tint);
    fillShader.setUniform("uHasSetAmbient", this.states._hasSetAmbient);
    fillShader.setUniform("uAmbientMatColor", this.states.curAmbientColor);
    fillShader.setUniform("uSpecularMatColor", this.mixedSpecularColor);
    fillShader.setUniform("uEmissiveMatColor", this.states.curEmissiveColor);
    fillShader.setUniform("uSpecular", this.states._useSpecularMaterial);
    fillShader.setUniform("uEmissive", this.states._useEmissiveMaterial);
    fillShader.setUniform("uShininess", this.states._useShininess);
    fillShader.setUniform("uMetallic", this.states._useMetalness);
    this._setImageLightUniforms(fillShader);
    fillShader.setUniform("uUseLighting", this.states.enableLighting);
    const pointLightCount = this.states.pointLightDiffuseColors.length / 3;
    fillShader.setUniform("uPointLightCount", pointLightCount);
    fillShader.setUniform(
      "uPointLightLocation",
      this.states.pointLightPositions
    );
    fillShader.setUniform(
      "uPointLightDiffuseColors",
      this.states.pointLightDiffuseColors
    );
    fillShader.setUniform(
      "uPointLightSpecularColors",
      this.states.pointLightSpecularColors
    );
    const directionalLightCount = this.states.directionalLightDiffuseColors.length / 3;
    fillShader.setUniform("uDirectionalLightCount", directionalLightCount);
    fillShader.setUniform(
      "uLightingDirection",
      this.states.directionalLightDirections
    );
    fillShader.setUniform(
      "uDirectionalDiffuseColors",
      this.states.directionalLightDiffuseColors
    );
    fillShader.setUniform(
      "uDirectionalSpecularColors",
      this.states.directionalLightSpecularColors
    );
    const ambientLightCount = this.states.ambientLightColors.length / 3;
    this.mixedAmbientLight = [...this.states.ambientLightColors];
    if (this.states._useMetalness > 0) {
      this.mixedAmbientLight = this.mixedAmbientLight.map((ambientColors) => {
        let mixing = ambientColors - this.states._useMetalness;
        return Math.max(0, mixing);
      });
    }
    fillShader.setUniform("uAmbientLightCount", ambientLightCount);
    fillShader.setUniform("uAmbientColor", this.mixedAmbientLight);
    const spotLightCount = this.states.spotLightDiffuseColors.length / 3;
    fillShader.setUniform("uSpotLightCount", spotLightCount);
    fillShader.setUniform("uSpotLightAngle", this.states.spotLightAngle);
    fillShader.setUniform("uSpotLightConc", this.states.spotLightConc);
    fillShader.setUniform(
      "uSpotLightDiffuseColors",
      this.states.spotLightDiffuseColors
    );
    fillShader.setUniform(
      "uSpotLightSpecularColors",
      this.states.spotLightSpecularColors
    );
    fillShader.setUniform("uSpotLightLocation", this.states.spotLightPositions);
    fillShader.setUniform(
      "uSpotLightDirection",
      this.states.spotLightDirections
    );
    fillShader.setUniform(
      "uConstantAttenuation",
      this.states.constantAttenuation
    );
    fillShader.setUniform("uLinearAttenuation", this.states.linearAttenuation);
    fillShader.setUniform(
      "uQuadraticAttenuation",
      this.states.quadraticAttenuation
    );
  }
  // getting called from _setFillUniforms
  _setImageLightUniforms(shader2) {
    shader2.setUniform("uUseImageLight", this.states.activeImageLight != null);
    if (this.states.activeImageLight) {
      let diffusedLight = this.getDiffusedTexture(this.states.activeImageLight);
      shader2.setUniform("environmentMapDiffused", diffusedLight);
      let specularLight = this.getSpecularTexture(this.states.activeImageLight);
      shader2.setUniform("environmentMapSpecular", specularLight);
    }
  }
  _setPointUniforms(pointShader) {
    pointShader.setUniform("uMaterialColor", this.states.curStrokeColor);
    pointShader.setUniform(
      "uPointSize",
      this.states.strokeWeight * this._pixelDensity
    );
  }
  /* Binds a buffer to the drawing context
   * when passed more than two arguments it also updates or initializes
   * the data associated with the buffer
   */
  _bindBuffer(buffer, target, values, type3, usage) {
    if (!target) target = this.GL.ARRAY_BUFFER;
    this.GL.bindBuffer(target, buffer);
    if (values !== void 0) {
      let data3 = values;
      if (values instanceof DataArray) {
        data3 = values.dataArray();
      } else if (!(data3 instanceof (type3 || Float32Array))) {
        data3 = new (type3 || Float32Array)(data3);
      }
      this.GL.bufferData(target, data3, usage || this.GL.STATIC_DRAW);
    }
  }
  ///////////////////////////////
  //// UTILITY FUNCTIONS
  //////////////////////////////
  _arraysEqual(a2, b3) {
    const aLength = a2.length;
    if (aLength !== b3.length) return false;
    return a2.every((ai, i) => ai === b3[i]);
  }
  _isTypedArray(arr2) {
    return [
      Float32Array,
      Float64Array,
      Int16Array,
      Uint16Array,
      Uint32Array
    ].some((x) => arr2 instanceof x);
  }
  /**
   * turn a p5.Vector Array into a one dimensional number array
   * @private
   * @param  {p5.Vector[]} arr  an array of p5.Vector
   * @return {Number[]}     a one dimensional array of numbers
   * [p5.Vector(1, 2, 3), p5.Vector(4, 5, 6)] ->
   * [1, 2, 3, 4, 5, 6]
   */
  _vToNArray(arr2) {
    return arr2.flatMap((item) => [item.x, item.y, item.z]);
  }
};
function rendererGL(p53, fn2) {
  p53.RendererGL = RendererGL;
  fn2.setAttributes = function(key, value) {
    if (typeof this._glAttributes === "undefined") {
      console.log(
        "You are trying to use setAttributes on a p5.Graphics object that does not use a WEBGL renderer."
      );
      return;
    }
    let unchanged = true;
    if (typeof value !== "undefined") {
      if (this._glAttributes === null) {
        this._glAttributes = {};
      }
      if (this._glAttributes[key] !== value) {
        this._glAttributes[key] = value;
        unchanged = false;
      }
    } else if (key instanceof Object) {
      if (this._glAttributes !== key) {
        this._glAttributes = key;
        unchanged = false;
      }
    }
    if (!this._renderer.isP3D || unchanged) {
      return;
    }
    if (!this._setupDone) {
      if (this._renderer.geometryBufferCache.numCached() > 0) {
        p53._friendlyError(
          "Sorry, Could not set the attributes, you need to call setAttributes() before calling the other drawing methods in setup()"
        );
        return;
      }
    }
    this._renderer._resetContext();
    if (this._renderer.states.curCamera) {
      this._renderer.states.curCamera._renderer = this._renderer;
    }
  };
  fn2._assert3d = function(name) {
    if (!this._renderer.isP3D)
      throw new Error(
        `${name}() is only supported in WEBGL mode. If you'd like to use 3D graphics and WebGL, see  https://p5js.org/examples/form-3d-primitives.html for more information.`
      );
  };
  p53.renderers[WEBGL] = p53.RendererGL;
  p53.renderers[WEBGL2] = p53.RendererGL;
}
function readPixelsWebGL(pixels2, gl, framebuffer2, x, y, width, height, format, type3, flipY) {
  const prevFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer2);
  const channels = format === gl.RGBA ? 4 : 3;
  const len = width * height * channels;
  const TypedArrayClass = type3 === gl.UNSIGNED_BYTE ? Uint8Array : Float32Array;
  if (!(pixels2 instanceof TypedArrayClass) || pixels2.length !== len) {
    pixels2 = new TypedArrayClass(len);
  }
  gl.readPixels(
    x,
    flipY ? flipY - y - height : y,
    width,
    height,
    format,
    type3,
    pixels2
  );
  gl.bindFramebuffer(gl.FRAMEBUFFER, prevFramebuffer);
  if (flipY) {
    const halfHeight = Math.floor(height / 2);
    const tmpRow = new TypedArrayClass(width * channels);
    for (let y2 = 0; y2 < halfHeight; y2++) {
      const topOffset = y2 * width * 4;
      const bottomOffset = (height - y2 - 1) * width * 4;
      tmpRow.set(pixels2.subarray(topOffset, topOffset + width * 4));
      pixels2.copyWithin(topOffset, bottomOffset, bottomOffset + width * 4);
      pixels2.set(tmpRow, bottomOffset);
    }
  }
  return pixels2;
}
function readPixelWebGL(gl, framebuffer2, x, y, format, type3, flipY) {
  const prevFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
  gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer2);
  const channels = format === gl.RGBA ? 4 : 3;
  const TypedArrayClass = type3 === gl.UNSIGNED_BYTE ? Uint8Array : Float32Array;
  const pixels2 = new TypedArrayClass(channels);
  gl.readPixels(x, flipY ? flipY - y - 1 : y, 1, 1, format, type3, pixels2);
  gl.bindFramebuffer(gl.FRAMEBUFFER, prevFramebuffer);
  return Array.from(pixels2);
}
if (typeof p5 !== "undefined") {
  rendererGL(p5, p5.prototype);
}
function primitives3D(p53, fn2) {
  fn2.strokeMode = function(mode) {
    if (mode === void 0) {
      return this._renderer._simpleLines ? SIMPLE : FULL;
    } else if (mode === SIMPLE) {
      this._renderer._simpleLines = true;
    } else if (mode === FULL) {
      this._renderer._simpleLines = false;
    } else {
      throw Error("no such parameter");
    }
  };
  fn2.buildGeometry = function(callback) {
    return this._renderer.buildGeometry(callback);
  };
  fn2.freeGeometry = function(geometry2) {
    this._renderer.geometryBufferCache.freeBuffers(geometry2.gid);
  };
  fn2.plane = function(width = 50, height = width, detailX = 1, detailY = 1) {
    this._assert3d("plane");
    this._renderer.plane(width, height, detailX, detailY);
    return this;
  };
  fn2.box = function(width, height, depth, detailX, detailY) {
    this._assert3d("box");
    this._renderer.box(width, height, depth, detailX, detailY);
    return this;
  };
  fn2.sphere = function(radius = 50, detailX = 24, detailY = 16) {
    this._assert3d("sphere");
    this._renderer.sphere(radius, detailX, detailY);
    return this;
  };
  fn2.cylinder = function(radius = 50, height = radius, detailX = 24, detailY = 1, bottomCap = true, topCap = true) {
    this._assert3d("cylinder");
    this._renderer.cylinder(radius, height, detailX, detailY, bottomCap, topCap);
    return this;
  };
  fn2.cone = function(radius = 50, height = radius, detailX = 24, detailY = 1, cap = true) {
    this._assert3d("cone");
    this._renderer.cone(radius, height, detailX, detailY, cap);
    return this;
  };
  fn2.ellipsoid = function(radiusX = 50, radiusY = radiusX, radiusZ = radiusX, detailX = 24, detailY = 16) {
    this._assert3d("ellipsoid");
    this._renderer.ellipsoid(radiusX, radiusY, radiusZ, detailX, detailY);
    return this;
  };
  fn2.torus = function(radius, tubeRadius, detailX, detailY) {
    this._assert3d("torus");
    this._renderer.torus(radius, tubeRadius, detailX, detailY);
    return this;
  };
  RendererGL.prototype.point = function(x, y, z = 0) {
    const _vertex = [];
    _vertex.push(new Vector(x, y, z));
    this._drawPoints(_vertex, this.buffers.point);
    return this;
  };
  RendererGL.prototype.triangle = function(args) {
    const x1 = args[0], y1 = args[1];
    const x2 = args[2], y2 = args[3];
    const x3 = args[4], y3 = args[5];
    const gid = "tri";
    if (!this.geometryInHash(gid)) {
      const _triangle = function() {
        const vertices = [];
        vertices.push(new Vector(0, 0, 0));
        vertices.push(new Vector(1, 0, 0));
        vertices.push(new Vector(0, 1, 0));
        this.edges = [[0, 1], [1, 2], [2, 0]];
        this.vertices = vertices;
        this.faces = [[0, 1, 2]];
        this.uvs = [0, 0, 1, 0, 1, 1];
      };
      const triGeom = new Geometry(1, 1, _triangle, this);
      triGeom._edgesToVertices();
      triGeom.computeNormals();
      triGeom.gid = gid;
      this.geometryBufferCache.ensureCached(triGeom);
    }
    const uModelMatrix = this.states.uModelMatrix.copy();
    try {
      const orientation = Math.sign(x1 * y2 - x2 * y1 + x2 * y3 - x3 * y2 + x3 * y1 - x1 * y3);
      const mult = new Matrix([
        x2 - x1,
        y2 - y1,
        0,
        0,
        // the resulting unit X-axis
        x3 - x1,
        y3 - y1,
        0,
        0,
        // the resulting unit Y-axis
        0,
        0,
        orientation,
        0,
        // the resulting unit Z-axis (Reflect the specified order of vertices)
        x1,
        y1,
        0,
        1
        // the resulting origin
      ]).mult(this.states.uModelMatrix);
      this.states.setValue("uModelMatrix", mult);
      this._drawGeometry(this.geometryBufferCache.getGeometryByID(gid));
    } finally {
      this.states.setValue("uModelMatrix", uModelMatrix);
    }
    return this;
  };
  RendererGL.prototype.ellipse = function(args) {
    this.arc(
      args[0],
      args[1],
      args[2],
      args[3],
      0,
      TWO_PI,
      OPEN,
      args[4]
    );
  };
  RendererGL.prototype.arc = function(...args) {
    const x = args[0];
    const y = args[1];
    const width = args[2];
    const height = args[3];
    const start = args[4];
    const stop = args[5];
    const mode = args[6];
    const detail = args[7] || 25;
    let shape2;
    let gid;
    if (Math.abs(stop - start) >= TWO_PI) {
      shape2 = "ellipse";
      gid = `${shape2}|${detail}|`;
    } else {
      shape2 = "arc";
      gid = `${shape2}|${start}|${stop}|${mode}|${detail}|`;
    }
    if (!this.geometryInHash(gid)) {
      const _arc = function() {
        if (start.toFixed(10) !== stop.toFixed(10)) {
          if (mode === PIE || typeof mode === "undefined") {
            this.vertices.push(new Vector(0.5, 0.5, 0));
            this.uvs.push([0.5, 0.5]);
          }
          for (let i = 0; i <= detail; i++) {
            const u = i / detail;
            const theta = (stop - start) * u + start;
            const _x = 0.5 + Math.cos(theta) / 2;
            const _y = 0.5 + Math.sin(theta) / 2;
            this.vertices.push(new Vector(_x, _y, 0));
            this.uvs.push([_x, _y]);
            if (i < detail - 1) {
              this.faces.push([0, i + 1, i + 2]);
              this.edges.push([i + 1, i + 2]);
            }
          }
          switch (mode) {
            case PIE:
              this.faces.push([
                0,
                this.vertices.length - 2,
                this.vertices.length - 1
              ]);
              this.edges.push([0, 1]);
              this.edges.push([
                this.vertices.length - 2,
                this.vertices.length - 1
              ]);
              this.edges.push([0, this.vertices.length - 1]);
              break;
            case CHORD:
              this.edges.push([0, 1]);
              this.edges.push([0, this.vertices.length - 1]);
              break;
            case OPEN:
              this.edges.push([0, 1]);
              break;
            default:
              this.faces.push([
                0,
                this.vertices.length - 2,
                this.vertices.length - 1
              ]);
              this.edges.push([
                this.vertices.length - 2,
                this.vertices.length - 1
              ]);
          }
        }
      };
      const arcGeom = new Geometry(detail, 1, _arc, this);
      arcGeom.computeNormals();
      if (detail <= 50) {
        arcGeom._edgesToVertices(arcGeom);
      } else if (this.states.strokeColor) {
        console.log(
          `Cannot apply a stroke to an ${shape2} with more than 50 detail`
        );
      }
      arcGeom.gid = gid;
      this.geometryBufferCache.ensureCached(arcGeom);
    }
    const uModelMatrix = this.states.uModelMatrix;
    this.states.setValue("uModelMatrix", this.states.uModelMatrix.clone());
    try {
      this.states.uModelMatrix.translate([x, y, 0]);
      this.states.uModelMatrix.scale(width, height, 1);
      this._drawGeometry(this.geometryBufferCache.getGeometryByID(gid));
    } finally {
      this.states.setValue("uModelMatrix", uModelMatrix);
    }
    return this;
  };
  RendererGL.prototype.rect = function(args) {
    const x = args[0];
    const y = args[1];
    const width = args[2];
    const height = args[3];
    if (typeof args[4] === "undefined") {
      const perPixelLighting = this._pInst._glAttributes.perPixelLighting;
      const detailX = args[4] || (perPixelLighting ? 1 : 24);
      const detailY = args[5] || (perPixelLighting ? 1 : 16);
      const gid = `rect|${detailX}|${detailY}`;
      if (!this.geometryInHash(gid)) {
        const _rect = function() {
          for (let i = 0; i <= this.detailY; i++) {
            const v = i / this.detailY;
            for (let j2 = 0; j2 <= this.detailX; j2++) {
              const u = j2 / this.detailX;
              const p2 = new Vector(u, v, 0);
              this.vertices.push(p2);
              this.uvs.push(u, v);
            }
          }
          if (detailX > 0 && detailY > 0) {
            this.edges = [
              [0, detailX],
              [detailX, (detailX + 1) * (detailY + 1) - 1],
              [(detailX + 1) * (detailY + 1) - 1, (detailX + 1) * detailY],
              [(detailX + 1) * detailY, 0]
            ];
          }
        };
        const rectGeom = new Geometry(detailX, detailY, _rect, this);
        rectGeom.computeFaces().computeNormals()._edgesToVertices();
        rectGeom.gid = gid;
        this.geometryBufferCache.ensureCached(rectGeom);
      }
      const uModelMatrix = this.states.uModelMatrix;
      this.states.setValue("uModelMatrix", this.states.uModelMatrix.copy());
      try {
        this.states.uModelMatrix.translate([x, y, 0]);
        this.states.uModelMatrix.scale(width, height, 1);
        this._drawGeometry(this.geometryBufferCache.getGeometryByID(gid));
      } finally {
        this.states.setValue("uModelMatrix", uModelMatrix);
      }
    } else {
      let tl = args[4];
      let tr = typeof args[5] === "undefined" ? tl : args[5];
      let br = typeof args[6] === "undefined" ? tr : args[6];
      let bl = typeof args[7] === "undefined" ? br : args[7];
      let a2 = x;
      let b3 = y;
      let c4 = width;
      let d2 = height;
      c4 += a2;
      d2 += b3;
      if (a2 > c4) {
        const temp = a2;
        a2 = c4;
        c4 = temp;
      }
      if (b3 > d2) {
        const temp = b3;
        b3 = d2;
        d2 = temp;
      }
      const maxRounding = Math.min((c4 - a2) / 2, (d2 - b3) / 2);
      if (tl > maxRounding) tl = maxRounding;
      if (tr > maxRounding) tr = maxRounding;
      if (br > maxRounding) br = maxRounding;
      if (bl > maxRounding) bl = maxRounding;
      let x1 = a2;
      let y1 = b3;
      let x2 = c4;
      let y2 = d2;
      const prevMode = this.states.textureMode;
      this.states.setValue("textureMode", NORMAL);
      const prevOrder = this.bezierOrder();
      this.bezierOrder(2);
      this.beginShape();
      const addUVs = (x3, y3) => [x3, y3, (x3 - x1) / width, (y3 - y1) / height];
      if (tr !== 0) {
        this.vertex(...addUVs(x2 - tr, y1));
        this.bezierVertex(...addUVs(x2, y1));
        this.bezierVertex(...addUVs(x2, y1 + tr));
      } else {
        this.vertex(...addUVs(x2, y1));
      }
      if (br !== 0) {
        this.vertex(...addUVs(x2, y2 - br));
        this.bezierVertex(...addUVs(x2, y2));
        this.bezierVertex(...addUVs(x2 - br, y2));
      } else {
        this.vertex(...addUVs(x2, y2));
      }
      if (bl !== 0) {
        this.vertex(...addUVs(x1 + bl, y2));
        this.bezierVertex(...addUVs(x1, y2));
        this.bezierVertex(...addUVs(x1, y2 - bl));
      } else {
        this.vertex(...addUVs(x1, y2));
      }
      if (tl !== 0) {
        this.vertex(...addUVs(x1, y1 + tl));
        this.bezierVertex(...addUVs(x1, y1));
        this.bezierVertex(...addUVs(x1 + tl, y1));
      } else {
        this.vertex(...addUVs(x1, y1));
      }
      this.endShape(CLOSE);
      this.states.setValue("textureMode", prevMode);
      this.bezierOrder(prevOrder);
    }
    return this;
  };
  RendererGL.prototype.quad = function(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4, detailX = 2, detailY = 2) {
    const gid = `quad|${x1}|${y1}|${z1}|${x2}|${y2}|${z2}|${x3}|${y3}|${z3}|${x4}|${y4}|${z4}|${detailX}|${detailY}`;
    if (!this.geometryInHash(gid)) {
      const quadGeom = new Geometry(detailX, detailY, function() {
        let xRes = 1 / (this.detailX - 1);
        let yRes = 1 / (this.detailY - 1);
        for (let y = 0; y < this.detailY; y++) {
          for (let x = 0; x < this.detailX; x++) {
            let pctx = x * xRes;
            let pcty = y * yRes;
            let linePt0x = (1 - pcty) * x1 + pcty * x4;
            let linePt0y = (1 - pcty) * y1 + pcty * y4;
            let linePt0z = (1 - pcty) * z1 + pcty * z4;
            let linePt1x = (1 - pcty) * x2 + pcty * x3;
            let linePt1y = (1 - pcty) * y2 + pcty * y3;
            let linePt1z = (1 - pcty) * z2 + pcty * z3;
            let ptx = (1 - pctx) * linePt0x + pctx * linePt1x;
            let pty = (1 - pctx) * linePt0y + pctx * linePt1y;
            let ptz = (1 - pctx) * linePt0z + pctx * linePt1z;
            this.vertices.push(new Vector(ptx, pty, ptz));
            this.uvs.push([pctx, pcty]);
          }
        }
      }, this);
      quadGeom.faces = [];
      for (let y = 0; y < detailY - 1; y++) {
        for (let x = 0; x < detailX - 1; x++) {
          let pt0 = x + y * detailX;
          let pt1 = x + 1 + y * detailX;
          let pt2 = x + 1 + (y + 1) * detailX;
          let pt3 = x + (y + 1) * detailX;
          quadGeom.faces.push([pt0, pt1, pt2]);
          quadGeom.faces.push([pt0, pt2, pt3]);
        }
      }
      quadGeom.computeNormals();
      quadGeom.edges.length = 0;
      const vertexOrder = [0, 2, 3, 1];
      for (let i = 0; i < vertexOrder.length; i++) {
        const startVertex = vertexOrder[i];
        const endVertex = vertexOrder[(i + 1) % vertexOrder.length];
        quadGeom.edges.push([startVertex, endVertex]);
      }
      quadGeom._edgesToVertices();
      quadGeom.gid = gid;
      this.geometryBufferCache.ensureCached(quadGeom);
    }
    this._drawGeometry(this.geometryBufferCache.getGeometryByID(gid));
    return this;
  };
  RendererGL.prototype.bezier = function(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
    if (arguments.length === 8) {
      y4 = y3;
      x4 = x3;
      y3 = z2;
      x3 = y2;
      y2 = x2;
      x2 = z1;
      z1 = z2 = z3 = z4 = 0;
    }
    this.bezierOrder();
    this.bezierOrder(3);
    this.beginShape();
    this.vertex(x1, y1, z1);
    this.bezierVertex(x2, y2, z2);
    this.bezierVertex(x3, y3, z3);
    this.bezierVertex(x4, y4, z4);
    this.endShape();
  };
  RendererGL.prototype.curve = function(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
    if (arguments.length === 8) {
      x4 = x3;
      y4 = y3;
      x3 = y2;
      y3 = x2;
      x2 = z1;
      y2 = x2;
      z1 = z2 = z3 = z4 = 0;
    }
    this.beginShape();
    this.splineVertex(x1, y1, z1);
    this.splineVertex(x2, y2, z2);
    this.splineVertex(x3, y3, z3);
    this.splineVertex(x4, y4, z4);
    this.endShape();
  };
  RendererGL.prototype.line = function(...args) {
    if (args.length === 6) {
      this.beginShape(LINES);
      this.vertex(args[0], args[1], args[2]);
      this.vertex(args[3], args[4], args[5]);
      this.endShape();
    } else if (args.length === 4) {
      this.beginShape(LINES);
      this.vertex(args[0], args[1], 0);
      this.vertex(args[2], args[3], 0);
      this.endShape();
    }
    return this;
  };
  RendererGL.prototype.image = function(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
    if (this._isErasing) {
      this.blendMode(this._cachedBlendMode);
    }
    this.push();
    this.noLights();
    this.states.setValue("strokeColor", null);
    this.texture(img);
    this.states.setValue("textureMode", NORMAL);
    let u0 = 0;
    if (sx <= img.width) {
      u0 = sx / img.width;
    }
    let u1 = 1;
    if (sx + sWidth <= img.width) {
      u1 = (sx + sWidth) / img.width;
    }
    let v0 = 0;
    if (sy <= img.height) {
      v0 = sy / img.height;
    }
    let v1 = 1;
    if (sy + sHeight <= img.height) {
      v1 = (sy + sHeight) / img.height;
    }
    this._drawingImage = true;
    this.beginShape();
    this.vertex(dx, dy, 0, u0, v0);
    this.vertex(dx + dWidth, dy, 0, u1, v0);
    this.vertex(dx + dWidth, dy + dHeight, 0, u1, v1);
    this.vertex(dx, dy + dHeight, 0, u0, v1);
    this.endShape(CLOSE);
    this._drawingImage = false;
    this.pop();
    if (this._isErasing) {
      this.blendMode(REMOVE);
    }
  };
  const _truncatedCone = function(bottomRadius, topRadius, height, detailX, detailY, bottomCap, topCap) {
    bottomRadius = bottomRadius <= 0 ? 1 : bottomRadius;
    topRadius = topRadius < 0 ? 0 : topRadius;
    height = height <= 0 ? bottomRadius : height;
    detailX = detailX < 3 ? 3 : detailX;
    detailY = detailY < 1 ? 1 : detailY;
    bottomCap = bottomCap === void 0 ? true : bottomCap;
    topCap = topCap === void 0 ? topRadius !== 0 : topCap;
    const start = bottomCap ? -2 : 0;
    const end = detailY + (topCap ? 2 : 0);
    const slant = Math.atan2(bottomRadius - topRadius, height);
    const sinSlant = Math.sin(slant);
    const cosSlant = Math.cos(slant);
    let yy, ii, jj;
    for (yy = start; yy <= end; ++yy) {
      let v = yy / detailY;
      let y = height * v;
      let ringRadius;
      if (yy < 0) {
        y = 0;
        v = 0;
        ringRadius = bottomRadius;
      } else if (yy > detailY) {
        y = height;
        v = 1;
        ringRadius = topRadius;
      } else {
        ringRadius = bottomRadius + (topRadius - bottomRadius) * v;
      }
      if (yy === -2 || yy === detailY + 2) {
        ringRadius = 0;
      }
      y -= height / 2;
      for (ii = 0; ii < detailX; ++ii) {
        const u = ii / (detailX - 1);
        const ur = 2 * Math.PI * u;
        const sur = Math.sin(ur);
        const cur = Math.cos(ur);
        this.vertices.push(new Vector(sur * ringRadius, y, cur * ringRadius));
        let vertexNormal;
        if (yy < 0) {
          vertexNormal = new Vector(0, -1, 0);
        } else if (yy > detailY && topRadius) {
          vertexNormal = new Vector(0, 1, 0);
        } else {
          vertexNormal = new Vector(sur * cosSlant, sinSlant, cur * cosSlant);
        }
        this.vertexNormals.push(vertexNormal);
        this.uvs.push(u, v);
      }
    }
    let startIndex = 0;
    if (bottomCap) {
      for (jj = 0; jj < detailX; ++jj) {
        const nextjj = (jj + 1) % detailX;
        this.faces.push([
          startIndex + jj,
          startIndex + detailX + nextjj,
          startIndex + detailX + jj
        ]);
      }
      startIndex += detailX * 2;
    }
    for (yy = 0; yy < detailY; ++yy) {
      for (ii = 0; ii < detailX; ++ii) {
        const nextii = (ii + 1) % detailX;
        this.faces.push([
          startIndex + ii,
          startIndex + nextii,
          startIndex + detailX + nextii
        ]);
        this.faces.push([
          startIndex + ii,
          startIndex + detailX + nextii,
          startIndex + detailX + ii
        ]);
      }
      startIndex += detailX;
    }
    if (topCap) {
      startIndex += detailX;
      for (ii = 0; ii < detailX; ++ii) {
        this.faces.push([
          startIndex + ii,
          startIndex + (ii + 1) % detailX,
          startIndex + detailX
        ]);
      }
    }
  };
  RendererGL.prototype.plane = function(width = 50, height = width, detailX = 1, detailY = 1) {
    const gid = `plane|${detailX}|${detailY}`;
    if (!this.geometryInHash(gid)) {
      const _plane = function() {
        let u, v, p2;
        for (let i = 0; i <= this.detailY; i++) {
          v = i / this.detailY;
          for (let j2 = 0; j2 <= this.detailX; j2++) {
            u = j2 / this.detailX;
            p2 = new Vector(u - 0.5, v - 0.5, 0);
            this.vertices.push(p2);
            this.uvs.push(u, v);
          }
        }
      };
      const planeGeom = new Geometry(detailX, detailY, _plane, this);
      planeGeom.computeFaces().computeNormals();
      if (detailX <= 1 && detailY <= 1) {
        planeGeom._makeTriangleEdges()._edgesToVertices();
      } else if (this.states.strokeColor) {
        console.log(
          "Cannot draw stroke on plane objects with more than 1 detailX or 1 detailY"
        );
      }
      planeGeom.gid = gid;
      this.geometryBufferCache.ensureCached(planeGeom);
    }
    this._drawGeometryScaled(this.geometryBufferCache.getGeometryByID(gid), width, height, 1);
  };
  RendererGL.prototype.box = function(width = 50, height = width, depth = height, detailX, detailY) {
    const perPixelLighting = this.attributes && this.attributes.perPixelLighting;
    if (typeof detailX === "undefined") {
      detailX = perPixelLighting ? 1 : 4;
    }
    if (typeof detailY === "undefined") {
      detailY = perPixelLighting ? 1 : 4;
    }
    const gid = `box|${detailX}|${detailY}`;
    if (!this.geometryInHash(gid)) {
      const _box = function() {
        const cubeIndices = [
          [0, 4, 2, 6],
          // -1, 0, 0],// -x
          [1, 3, 5, 7],
          // +1, 0, 0],// +x
          [0, 1, 4, 5],
          // 0, -1, 0],// -y
          [2, 6, 3, 7],
          // 0, +1, 0],// +y
          [0, 2, 1, 3],
          // 0, 0, -1],// -z
          [4, 5, 6, 7]
          // 0, 0, +1] // +z
        ];
        this.edges = [
          [0, 1],
          [1, 3],
          [3, 2],
          [6, 7],
          [8, 9],
          [9, 11],
          [14, 15],
          [16, 17],
          [17, 19],
          [18, 19],
          [20, 21],
          [22, 23]
        ];
        cubeIndices.forEach((cubeIndex, i) => {
          const v = i * 4;
          for (let j2 = 0; j2 < 4; j2++) {
            const d2 = cubeIndex[j2];
            const octant = new Vector(
              ((d2 & 1) * 2 - 1) / 2,
              ((d2 & 2) - 1) / 2,
              ((d2 & 4) / 2 - 1) / 2
            );
            this.vertices.push(octant);
            this.uvs.push(j2 & 1, (j2 & 2) / 2);
          }
          this.faces.push([v, v + 1, v + 2]);
          this.faces.push([v + 2, v + 1, v + 3]);
        });
      };
      const boxGeom = new Geometry(detailX, detailY, _box, this);
      boxGeom.computeNormals();
      if (detailX <= 4 && detailY <= 4) {
        boxGeom._edgesToVertices();
      } else if (this.states.strokeColor) {
        console.log(
          "Cannot draw stroke on box objects with more than 4 detailX or 4 detailY"
        );
      }
      boxGeom.gid = gid;
      this.geometryBufferCache.ensureCached(boxGeom);
    }
    this._drawGeometryScaled(this.geometryBufferCache.getGeometryByID(gid), width, height, depth);
  };
  RendererGL.prototype.sphere = function(radius = 50, detailX = 24, detailY = 16) {
    this.ellipsoid(radius, radius, radius, detailX, detailY);
  };
  RendererGL.prototype.ellipsoid = function(radiusX = 50, radiusY = radiusX, radiusZ = radiusX, detailX = 24, detailY = 16) {
    const gid = `ellipsoid|${detailX}|${detailY}`;
    if (!this.geometryInHash(gid)) {
      const _ellipsoid = function() {
        for (let i = 0; i <= this.detailY; i++) {
          const v = i / this.detailY;
          const phi2 = Math.PI * v - Math.PI / 2;
          const cosPhi = Math.cos(phi2);
          const sinPhi = Math.sin(phi2);
          for (let j2 = 0; j2 <= this.detailX; j2++) {
            const u = j2 / this.detailX;
            const theta = 2 * Math.PI * u;
            const cosTheta = Math.cos(theta);
            const sinTheta = Math.sin(theta);
            const p2 = new p53.Vector(cosPhi * sinTheta, sinPhi, cosPhi * cosTheta);
            this.vertices.push(p2);
            this.vertexNormals.push(p2);
            this.uvs.push(u, v);
          }
        }
      };
      const ellipsoidGeom = new Geometry(detailX, detailY, _ellipsoid, this);
      ellipsoidGeom.computeFaces();
      if (detailX <= 24 && detailY <= 24) {
        ellipsoidGeom._makeTriangleEdges()._edgesToVertices();
      } else if (this.states.strokeColor) {
        console.log(
          "Cannot draw stroke on ellipsoids with more than 24 detailX or 24 detailY"
        );
      }
      ellipsoidGeom.gid = gid;
      this.geometryBufferCache.ensureCached(ellipsoidGeom);
    }
    this._drawGeometryScaled(this.geometryBufferCache.getGeometryByID(gid), radiusX, radiusY, radiusZ);
  };
  RendererGL.prototype.cylinder = function(radius = 50, height = radius, detailX = 24, detailY = 1, bottomCap = true, topCap = true) {
    const gid = `cylinder|${detailX}|${detailY}|${bottomCap}|${topCap}`;
    if (!this.geometryInHash(gid)) {
      const cylinderGeom = new p53.Geometry(detailX, detailY, function() {
        _truncatedCone.call(
          this,
          1,
          1,
          1,
          detailX,
          detailY,
          bottomCap,
          topCap
        );
      }, this);
      if (detailX <= 24 && detailY <= 16) {
        cylinderGeom._makeTriangleEdges()._edgesToVertices();
      } else if (this.states.strokeColor) {
        console.log(
          "Cannot draw stroke on cylinder objects with more than 24 detailX or 16 detailY"
        );
      }
      cylinderGeom.gid = gid;
      this.geometryBufferCache.ensureCached(cylinderGeom);
    }
    this._drawGeometryScaled(this.geometryBufferCache.getGeometryByID(gid), radius, height, radius);
  };
  RendererGL.prototype.cone = function(radius = 50, height = radius, detailX = 24, detailY = 1, cap = true) {
    const gid = `cone|${detailX}|${detailY}|${cap}`;
    if (!this.geometryInHash(gid)) {
      const coneGeom = new Geometry(detailX, detailY, function() {
        _truncatedCone.call(
          this,
          1,
          0,
          1,
          detailX,
          detailY,
          cap,
          false
        );
      }, this);
      if (detailX <= 24 && detailY <= 16) {
        coneGeom._makeTriangleEdges()._edgesToVertices();
      } else if (this.states.strokeColor) {
        console.log(
          "Cannot draw stroke on cone objects with more than 24 detailX or 16 detailY"
        );
      }
      coneGeom.gid = gid;
      this.geometryBufferCache.ensureCached(coneGeom);
    }
    this._drawGeometryScaled(this.geometryBufferCache.getGeometryByID(gid), radius, height, radius);
  };
  RendererGL.prototype.torus = function(radius = 50, tubeRadius = 10, detailX = 24, detailY = 16) {
    if (radius === 0) {
      return;
    }
    if (tubeRadius === 0) {
      return;
    }
    const tubeRatio = (tubeRadius / radius).toPrecision(4);
    const gid = `torus|${tubeRatio}|${detailX}|${detailY}`;
    if (!this.geometryInHash(gid)) {
      const _torus = function() {
        for (let i = 0; i <= this.detailY; i++) {
          const v = i / this.detailY;
          const phi2 = 2 * Math.PI * v;
          const cosPhi = Math.cos(phi2);
          const sinPhi = Math.sin(phi2);
          const r = 1 + tubeRatio * cosPhi;
          for (let j2 = 0; j2 <= this.detailX; j2++) {
            const u = j2 / this.detailX;
            const theta = 2 * Math.PI * u;
            const cosTheta = Math.cos(theta);
            const sinTheta = Math.sin(theta);
            const p2 = new Vector(
              r * cosTheta,
              r * sinTheta,
              tubeRatio * sinPhi
            );
            const n3 = new Vector(cosPhi * cosTheta, cosPhi * sinTheta, sinPhi);
            this.vertices.push(p2);
            this.vertexNormals.push(n3);
            this.uvs.push(u, v);
          }
        }
      };
      const torusGeom = new Geometry(detailX, detailY, _torus, this);
      torusGeom.computeFaces();
      if (detailX <= 24 && detailY <= 16) {
        torusGeom._makeTriangleEdges()._edgesToVertices();
      } else if (this.states.strokeColor) {
        console.log(
          "Cannot draw strokes on torus object with more than 24 detailX or 16 detailY"
        );
      }
      torusGeom.gid = gid;
      this.geometryBufferCache.ensureCached(torusGeom);
    }
    this._drawGeometryScaled(this.geometryBufferCache.getGeometryByID(gid), radius, radius, radius);
  };
  fn2.curveDetail = function(d2) {
    if (!(this._renderer instanceof RendererGL)) {
      throw new Error(
        "curveDetail() only works in WebGL mode. Did you mean to call createCanvas(width, height, WEBGL)?"
      );
    }
    return this._renderer.curveDetail(d2);
  };
}
if (typeof p5 !== "undefined") {
  primitives3D(p5, p5.prototype);
}
function light(p53, fn2) {
  fn2.ambientLight = function(v1, v2, v3, a2) {
    this._assert3d("ambientLight");
    this._renderer.ambientLight(...arguments);
    return this;
  };
  fn2.specularColor = function(v1, v2, v3) {
    this._assert3d("specularColor");
    this._renderer.specularColor(...arguments);
    return this;
  };
  fn2.directionalLight = function(v1, v2, v3, x, y, z) {
    this._assert3d("directionalLight");
    this._renderer.directionalLight(...arguments);
    return this;
  };
  fn2.pointLight = function(v1, v2, v3, x, y, z) {
    this._assert3d("pointLight");
    this._renderer.pointLight(...arguments);
    return this;
  };
  fn2.imageLight = function(img) {
    this._renderer.imageLight(img);
  };
  fn2.panorama = function(img) {
    this.filter(this._renderer._getSphereMapping(img));
  };
  fn2.lights = function() {
    this._assert3d("lights");
    this._renderer.lights();
    return this;
  };
  fn2.lightFalloff = function(constantAttenuation, linearAttenuation, quadraticAttenuation) {
    this._assert3d("lightFalloff");
    this._renderer.lightFalloff(
      constantAttenuation,
      linearAttenuation,
      quadraticAttenuation
    );
    return this;
  };
  fn2.spotLight = function(v1, v2, v3, x, y, z, nx, ny, nz, angle, concentration) {
    this._assert3d("spotLight");
    this._renderer.spotLight(...arguments);
    return this;
  };
  fn2.noLights = function(...args) {
    this._assert3d("noLights");
    this._renderer.noLights();
    return this;
  };
  RendererGL.prototype.ambientLight = function(v1, v2, v3, a2) {
    const color3 = this._pInst.color(...arguments);
    this.states.setValue("ambientLightColors", [...this.states.ambientLightColors]);
    this.states.ambientLightColors.push(
      color3._array[0],
      color3._array[1],
      color3._array[2]
    );
    this.states.setValue("enableLighting", true);
  };
  RendererGL.prototype.specularColor = function(v1, v2, v3) {
    const color3 = this._pInst.color(...arguments);
    this.states.setValue("specularColors", [
      color3._array[0],
      color3._array[1],
      color3._array[2]
    ]);
  };
  RendererGL.prototype.directionalLight = function(v1, v2, v3, x, y, z) {
    let color3;
    if (v1 instanceof Color) {
      color3 = v1;
    } else {
      color3 = this._pInst.color(v1, v2, v3);
    }
    let _x, _y, _z;
    const v = arguments[arguments.length - 1];
    if (typeof v === "number") {
      _x = arguments[arguments.length - 3];
      _y = arguments[arguments.length - 2];
      _z = arguments[arguments.length - 1];
    } else {
      _x = v.x;
      _y = v.y;
      _z = v.z;
    }
    const l = Math.sqrt(_x * _x + _y * _y + _z * _z);
    this.states.setValue("directionalLightDirections", [...this.states.directionalLightDirections]);
    this.states.directionalLightDirections.push(_x / l, _y / l, _z / l);
    this.states.setValue("directionalLightDiffuseColors", [...this.states.directionalLightDiffuseColors]);
    this.states.directionalLightDiffuseColors.push(
      color3._array[0],
      color3._array[1],
      color3._array[2]
    );
    this.states.setValue("directionalLightSpecularColors", [...this.states.directionalLightSpecularColors]);
    Array.prototype.push.apply(
      this.states.directionalLightSpecularColors,
      this.states.specularColors
    );
    this.states.setValue("enableLighting", true);
  };
  RendererGL.prototype.pointLight = function(v1, v2, v3, x, y, z) {
    let color3;
    if (v1 instanceof Color) {
      color3 = v1;
    } else {
      color3 = this._pInst.color(v1, v2, v3);
    }
    let _x, _y, _z;
    const v = arguments[arguments.length - 1];
    if (typeof v === "number") {
      _x = arguments[arguments.length - 3];
      _y = arguments[arguments.length - 2];
      _z = arguments[arguments.length - 1];
    } else {
      _x = v.x;
      _y = v.y;
      _z = v.z;
    }
    this.states.setValue("pointLightPositions", [...this.states.pointLightPositions]);
    this.states.pointLightPositions.push(_x, _y, _z);
    this.states.setValue("pointLightDiffuseColors", [...this.states.pointLightDiffuseColors]);
    this.states.pointLightDiffuseColors.push(
      color3._array[0],
      color3._array[1],
      color3._array[2]
    );
    this.states.setValue("pointLightSpecularColors", [...this.states.pointLightSpecularColors]);
    Array.prototype.push.apply(
      this.states.pointLightSpecularColors,
      this.states.specularColors
    );
    this.states.setValue("enableLighting", true);
  };
  RendererGL.prototype.imageLight = function(img) {
    this.states.setValue("activeImageLight", img);
    this.states.setValue("enableLighting", true);
  };
  RendererGL.prototype.lights = function() {
    const grayColor = this._pInst.color("rgb(128,128,128)");
    this.ambientLight(grayColor);
    this.directionalLight(grayColor, 0, 0, -1);
  };
  RendererGL.prototype.lightFalloff = function(constantAttenuation, linearAttenuation, quadraticAttenuation) {
    if (constantAttenuation < 0) {
      constantAttenuation = 0;
      console.warn(
        "Value of constant argument in lightFalloff() should be never be negative. Set to 0."
      );
    }
    if (linearAttenuation < 0) {
      linearAttenuation = 0;
      console.warn(
        "Value of linear argument in lightFalloff() should be never be negative. Set to 0."
      );
    }
    if (quadraticAttenuation < 0) {
      quadraticAttenuation = 0;
      console.warn(
        "Value of quadratic argument in lightFalloff() should be never be negative. Set to 0."
      );
    }
    if (constantAttenuation === 0 && (linearAttenuation === 0 && quadraticAttenuation === 0)) {
      constantAttenuation = 1;
      console.warn(
        "Either one of the three arguments in lightFalloff() should be greater than zero. Set constant argument to 1."
      );
    }
    this.states.setValue("constantAttenuation", constantAttenuation);
    this.states.setValue("linearAttenuation", linearAttenuation);
    this.states.setValue("quadraticAttenuation", quadraticAttenuation);
  };
  RendererGL.prototype.spotLight = function(v1, v2, v3, x, y, z, nx, ny, nz, angle, concentration) {
    let color3, position, direction;
    const length = arguments.length;
    switch (length) {
      case 11:
      case 10:
        color3 = this._pInst.color(v1, v2, v3);
        position = new Vector(x, y, z);
        direction = new Vector(nx, ny, nz);
        break;
      case 9:
        if (v1 instanceof Color) {
          color3 = v1;
          position = new Vector(v2, v3, x);
          direction = new Vector(y, z, nx);
          angle = ny;
          concentration = nz;
        } else if (x instanceof Vector) {
          color3 = this._pInst.color(v1, v2, v3);
          position = x;
          direction = new Vector(y, z, nx);
          angle = ny;
          concentration = nz;
        } else if (nx instanceof Vector) {
          color3 = this._pInst.color(v1, v2, v3);
          position = new Vector(x, y, z);
          direction = nx;
          angle = ny;
          concentration = nz;
        } else {
          color3 = this._pInst.color(v1, v2, v3);
          position = new Vector(x, y, z);
          direction = new Vector(nx, ny, nz);
        }
        break;
      case 8:
        if (v1 instanceof Color) {
          color3 = v1;
          position = new Vector(v2, v3, x);
          direction = new Vector(y, z, nx);
          angle = ny;
        } else if (x instanceof Vector) {
          color3 = this._pInst.color(v1, v2, v3);
          position = x;
          direction = new Vector(y, z, nx);
          angle = ny;
        } else {
          color3 = this._pInst.color(v1, v2, v3);
          position = new Vector(x, y, z);
          direction = nx;
          angle = ny;
        }
        break;
      case 7:
        if (v1 instanceof Color && v2 instanceof Vector) {
          color3 = v1;
          position = v2;
          direction = new Vector(v3, x, y);
          angle = z;
          concentration = nx;
        } else if (v1 instanceof Color && y instanceof Vector) {
          color3 = v1;
          position = new Vector(v2, v3, x);
          direction = y;
          angle = z;
          concentration = nx;
        } else if (x instanceof Vector && y instanceof Vector) {
          color3 = this._pInst.color(v1, v2, v3);
          position = x;
          direction = y;
          angle = z;
          concentration = nx;
        } else if (v1 instanceof Color) {
          color3 = v1;
          position = new Vector(v2, v3, x);
          direction = new Vector(y, z, nx);
        } else if (x instanceof Vector) {
          color3 = this._pInst.color(v1, v2, v3);
          position = x;
          direction = new Vector(y, z, nx);
        } else {
          color3 = this._pInst.color(v1, v2, v3);
          position = new Vector(x, y, z);
          direction = nx;
        }
        break;
      case 6:
        if (x instanceof Vector && y instanceof Vector) {
          color3 = this._pInst.color(v1, v2, v3);
          position = x;
          direction = y;
          angle = z;
        } else if (v1 instanceof Color && y instanceof Vector) {
          color3 = v1;
          position = new Vector(v2, v3, x);
          direction = y;
          angle = z;
        } else if (v1 instanceof Color && v2 instanceof Vector) {
          color3 = v1;
          position = v2;
          direction = new Vector(v3, x, y);
          angle = z;
        }
        break;
      case 5:
        if (v1 instanceof Color && v2 instanceof Vector && v3 instanceof Vector) {
          color3 = v1;
          position = v2;
          direction = v3;
          angle = x;
          concentration = y;
        } else if (x instanceof Vector && y instanceof Vector) {
          color3 = this._pInst.color(v1, v2, v3);
          position = x;
          direction = y;
        } else if (v1 instanceof Color && y instanceof Vector) {
          color3 = v1;
          position = new Vector(v2, v3, x);
          direction = y;
        } else if (v1 instanceof Color && v2 instanceof Vector) {
          color3 = v1;
          position = v2;
          direction = new Vector(v3, x, y);
        }
        break;
      case 4:
        color3 = v1;
        position = v2;
        direction = v3;
        angle = x;
        break;
      case 3:
        color3 = v1;
        position = v2;
        direction = v3;
        break;
      default:
        console.warn(
          `Sorry, input for spotlight() is not in prescribed format. Too ${length < 3 ? "few" : "many"} arguments were provided`
        );
        return;
    }
    this.states.setValue("spotLightDiffuseColors", [
      color3._array[0],
      color3._array[1],
      color3._array[2]
    ]);
    this.states.setValue("spotLightSpecularColors", [
      ...this.states.specularColors
    ]);
    this.states.setValue("spotLightPositions", [position.x, position.y, position.z]);
    direction.normalize();
    this.states.setValue("spotLightDirections", [
      direction.x,
      direction.y,
      direction.z
    ]);
    if (angle === void 0) {
      angle = Math.PI / 3;
    }
    if (concentration !== void 0 && concentration < 1) {
      concentration = 1;
      console.warn(
        "Value of concentration needs to be greater than 1. Setting it to 1"
      );
    } else if (concentration === void 0) {
      concentration = 100;
    }
    angle = this._pInst._toRadians(angle);
    this.states.setValue("spotLightAngle", [Math.cos(angle)]);
    this.states.setValue("spotLightConc", [concentration]);
    this.states.setValue("enableLighting", true);
  };
  RendererGL.prototype.noLights = function() {
    this.states.setValue("activeImageLight", null);
    this.states.setValue("enableLighting", false);
    this.states.setValue("ambientLightColors", []);
    this.states.setValue("specularColors", [1, 1, 1]);
    this.states.setValue("directionalLightDirections", []);
    this.states.setValue("directionalLightDiffuseColors", []);
    this.states.setValue("directionalLightSpecularColors", []);
    this.states.setValue("pointLightPositions", []);
    this.states.setValue("pointLightDiffuseColors", []);
    this.states.setValue("pointLightSpecularColors", []);
    this.states.setValue("spotLightPositions", []);
    this.states.setValue("spotLightDirections", []);
    this.states.setValue("spotLightDiffuseColors", []);
    this.states.setValue("spotLightSpecularColors", []);
    this.states.setValue("spotLightAngle", []);
    this.states.setValue("spotLightConc", []);
    this.states.setValue("constantAttenuation", 1);
    this.states.setValue("linearAttenuation", 0);
    this.states.setValue("quadraticAttenuation", 0);
    this.states.setValue("_useShininess", 1);
    this.states.setValue("_useMetalness", 0);
  };
}
if (typeof p5 !== "undefined") {
  light(p5, p5.prototype);
}
function material(p53, fn2) {
  fn2.loadShader = async function(vertFilename, fragFilename, successCallback, failureCallback) {
    const loadedShader = new Shader();
    try {
      loadedShader._vertSrc = (await request(vertFilename, "text")).data;
      loadedShader._fragSrc = (await request(fragFilename, "text")).data;
      if (successCallback) {
        return successCallback(loadedShader);
      } else {
        return loadedShader;
      }
    } catch (err2) {
      if (failureCallback) {
        return failureCallback(err2);
      } else {
        throw err2;
      }
    }
  };
  fn2.createShader = function(vertSrc, fragSrc, options2) {
    return new Shader(this._renderer, vertSrc, fragSrc, options2);
  };
  fn2.loadFilterShader = async function(fragFilename, successCallback, failureCallback) {
    try {
      const fragSrc = await this.loadStrings(fragFilename);
      const fragString = await fragSrc.join("\n");
      const loadedShader = this.createFilterShader(fragString, true);
      if (successCallback) {
        successCallback(loadedShader);
      }
      return loadedShader;
    } catch (err2) {
      if (failureCallback) {
        failureCallback(err2);
      } else {
        console.error(err2);
      }
    }
  };
  fn2.createFilterShader = function(fragSrc, skipContextCheck = false) {
    let defaultVertV1 = `
      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;

      attribute vec3 aPosition;
      // texcoords only come from p5 to vertex shader
      // so pass texcoords on to the fragment shader in a varying variable
      attribute vec2 aTexCoord;
      varying vec2 vTexCoord;

      void main() {
        // transferring texcoords for the frag shader
        vTexCoord = aTexCoord;

        // copy position with a fourth coordinate for projection (1.0 is normal)
        vec4 positionVec4 = vec4(aPosition, 1.0);

        // project to 3D space
        gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
      }
    `;
    let defaultVertV2 = `#version 300 es
      uniform mat4 uModelViewMatrix;
      uniform mat4 uProjectionMatrix;

      in vec3 aPosition;
      in vec2 aTexCoord;
      out vec2 vTexCoord;

      void main() {
        // transferring texcoords for the frag shader
        vTexCoord = aTexCoord;

        // copy position with a fourth coordinate for projection (1.0 is normal)
        vec4 positionVec4 = vec4(aPosition, 1.0);

        // project to 3D space
        gl_Position = uProjectionMatrix * uModelViewMatrix * positionVec4;
      }
    `;
    let vertSrc = fragSrc.includes("#version 300 es") ? defaultVertV2 : defaultVertV1;
    const shader2 = new Shader(this._renderer, vertSrc, fragSrc);
    if (!skipContextCheck) {
      if (this._renderer.GL) {
        shader2.ensureCompiledOnContext(this._renderer);
      } else {
        shader2.ensureCompiledOnContext(this);
      }
    }
    return shader2;
  };
  fn2.shader = function(s) {
    this._assert3d("shader");
    this._renderer.shader(s);
    return this;
  };
  fn2.strokeShader = function(s) {
    this._assert3d("strokeShader");
    this._renderer.strokeShader(s);
    return this;
  };
  fn2.imageShader = function(s) {
    this._assert3d("imageShader");
    this._renderer.imageShader(s);
    return this;
  };
  fn2.baseMaterialShader = function() {
    this._assert3d("baseMaterialShader");
    return this._renderer.baseMaterialShader();
  };
  fn2.baseFilterShader = function() {
    return (this._renderer.filterRenderer || this._renderer).baseFilterShader();
  };
  fn2.baseNormalShader = function() {
    this._assert3d("baseNormalShader");
    return this._renderer.baseNormalShader();
  };
  fn2.baseColorShader = function() {
    this._assert3d("baseColorShader");
    return this._renderer.baseColorShader();
  };
  fn2.baseStrokeShader = function() {
    this._assert3d("baseStrokeShader");
    return this._renderer.baseStrokeShader();
  };
  fn2.resetShader = function() {
    this._renderer.resetShader();
    return this;
  };
  fn2.texture = function(tex) {
    this._assert3d("texture");
    if (tex.gifProperties) {
      tex._animateGif(this);
    }
    this._renderer.texture(tex);
    return this;
  };
  fn2.textureMode = function(mode) {
    if (mode !== IMAGE && mode !== NORMAL) {
      console.warn(
        `You tried to set ${mode} textureMode only supports IMAGE & NORMAL `
      );
    } else {
      this._renderer.states.setValue("textureMode", mode);
    }
  };
  fn2.textureWrap = function(wrapX, wrapY = wrapX) {
    this._renderer.states.setValue("textureWrapX", wrapX);
    this._renderer.states.setValue("textureWrapY", wrapY);
    for (const texture2 of this._renderer.textures.values()) {
      texture2.setWrapMode(wrapX, wrapY);
    }
  };
  fn2.normalMaterial = function(...args) {
    this._assert3d("normalMaterial");
    this._renderer.normalMaterial(...args);
    return this;
  };
  fn2.ambientMaterial = function(v1, v2, v3) {
    this._assert3d("ambientMaterial");
    const color3 = fn2.color.apply(this, arguments);
    this._renderer.states.setValue("_hasSetAmbient", true);
    this._renderer.states.setValue("curAmbientColor", color3._array);
    this._renderer.states.setValue("_useNormalMaterial", false);
    this._renderer.states.setValue("enableLighting", true);
    if (!this._renderer.states.fillColor) {
      this._renderer.states.setValue("fillColor", new Color([1, 1, 1]));
    }
    return this;
  };
  fn2.emissiveMaterial = function(v1, v2, v3, a2) {
    this._assert3d("emissiveMaterial");
    const color3 = fn2.color.apply(this, arguments);
    this._renderer.states.setValue("curEmissiveColor", color3._array);
    this._renderer.states.setValue("_useEmissiveMaterial", true);
    this._renderer.states.setValue("_useNormalMaterial", false);
    this._renderer.states.setValue("enableLighting", true);
    return this;
  };
  fn2.specularMaterial = function(v1, v2, v3, alpha) {
    this._assert3d("specularMaterial");
    const color3 = fn2.color.apply(this, arguments);
    this._renderer.states.setValue("curSpecularColor", color3._array);
    this._renderer.states.setValue("_useSpecularMaterial", true);
    this._renderer.states.setValue("_useNormalMaterial", false);
    this._renderer.states.setValue("enableLighting", true);
    return this;
  };
  fn2.shininess = function(shine) {
    this._assert3d("shininess");
    this._renderer.shininess(shine);
    return this;
  };
  fn2.metalness = function(metallic) {
    this._assert3d("metalness");
    this._renderer.metalness(metallic);
    return this;
  };
  RendererGL.prototype._applyColorBlend = function(colors, hasTransparency) {
    const gl = this.GL;
    const isTexture = this.states.drawMode === TEXTURE;
    const doBlend = hasTransparency || this.states.userFillShader || this.states.userStrokeShader || this.states.userPointShader || isTexture || this.states.curBlendMode !== BLEND || colors[colors.length - 1] < 1 || this._isErasing;
    if (doBlend !== this._isBlending) {
      if (doBlend || this.states.curBlendMode !== BLEND && this.states.curBlendMode !== ADD) {
        gl.enable(gl.BLEND);
      } else {
        gl.disable(gl.BLEND);
      }
      gl.depthMask(true);
      this._isBlending = doBlend;
    }
    this._applyBlendMode();
    return colors;
  };
  RendererGL.prototype._applyBlendMode = function() {
    if (this._cachedBlendMode === this.states.curBlendMode) {
      return;
    }
    const gl = this.GL;
    switch (this.states.curBlendMode) {
      case BLEND:
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        break;
      case ADD:
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ONE, gl.ONE);
        break;
      case REMOVE:
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ZERO, gl.ONE_MINUS_SRC_ALPHA);
        break;
      case MULTIPLY:
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA);
        break;
      case SCREEN:
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_COLOR);
        break;
      case EXCLUSION:
        gl.blendEquationSeparate(gl.FUNC_ADD, gl.FUNC_ADD);
        gl.blendFuncSeparate(
          gl.ONE_MINUS_DST_COLOR,
          gl.ONE_MINUS_SRC_COLOR,
          gl.ONE,
          gl.ONE
        );
        break;
      case REPLACE:
        gl.blendEquation(gl.FUNC_ADD);
        gl.blendFunc(gl.ONE, gl.ZERO);
        break;
      case SUBTRACT:
        gl.blendEquationSeparate(gl.FUNC_REVERSE_SUBTRACT, gl.FUNC_ADD);
        gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        break;
      case DARKEST:
        if (this.blendExt) {
          gl.blendEquationSeparate(
            this.blendExt.MIN || this.blendExt.MIN_EXT,
            gl.FUNC_ADD
          );
          gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
        } else {
          console.warn(
            "blendMode(DARKEST) does not work in your browser in WEBGL mode."
          );
        }
        break;
      case LIGHTEST:
        if (this.blendExt) {
          gl.blendEquationSeparate(
            this.blendExt.MAX || this.blendExt.MAX_EXT,
            gl.FUNC_ADD
          );
          gl.blendFuncSeparate(gl.ONE, gl.ONE, gl.ONE, gl.ONE);
        } else {
          console.warn(
            "blendMode(LIGHTEST) does not work in your browser in WEBGL mode."
          );
        }
        break;
      default:
        console.error(
          "Oops! Somehow RendererGL set curBlendMode to an unsupported mode."
        );
        break;
    }
    this._cachedBlendMode = this.states.curBlendMode;
  };
  RendererGL.prototype.shader = function(s) {
    this.states.setValue("userFillShader", s);
    this.states.setValue("_useNormalMaterial", false);
    s.ensureCompiledOnContext(this);
    s.setDefaultUniforms();
  };
  RendererGL.prototype.strokeShader = function(s) {
    this.states.setValue("userStrokeShader", s);
    s.ensureCompiledOnContext(this);
    s.setDefaultUniforms();
  };
  RendererGL.prototype.imageShader = function(s) {
    this.states.setValue("userImageShader", s);
    s.ensureCompiledOnContext(this);
    s.setDefaultUniforms();
  };
  RendererGL.prototype.resetShader = function() {
    this.states.setValue("userFillShader", null);
    this.states.setValue("userStrokeShader", null);
    this.states.setValue("userImageShader", null);
  };
  RendererGL.prototype.texture = function(tex) {
    this.states.setValue("drawMode", TEXTURE);
    this.states.setValue("_useNormalMaterial", false);
    this.states.setValue("_tex", tex);
    this.states.setValue("fillColor", new Color([1, 1, 1]));
  };
  RendererGL.prototype.normalMaterial = function(...args) {
    this.states.setValue("drawMode", FILL);
    this.states.setValue("_useSpecularMaterial", false);
    this.states.setValue("_useEmissiveMaterial", false);
    this.states.setValue("_useNormalMaterial", true);
    this.states.setValue("curFillColor", [1, 1, 1, 1]);
    this.states.setValue("fillColor", new Color([1, 1, 1]));
    this.states.setValue("strokeColor", null);
  };
  RendererGL.prototype.shininess = function(shine) {
    if (shine < 1) {
      shine = 1;
    }
    this.states.setValue("_useShininess", shine);
  };
  RendererGL.prototype.metalness = function(metallic) {
    const metalMix = 1 - Math.exp(-metallic / 100);
    this.states.setValue("_useMetalness", metalMix);
  };
}
if (typeof p5 !== "undefined") {
  loading(p5, p5.prototype);
}
var Graphics = class {
  constructor(w, h, renderer2, pInst, canvas2) {
    const r = renderer2 || P2D;
    this._pInst = pInst;
    this._renderer = new renderers[r](this, w, h, false, canvas2);
    this._initializeInstanceVariables(this);
    this._renderer._applyDefaults();
    return this;
  }
  get deltaTime() {
    return this._pInst.deltaTime;
  }
  get canvas() {
    var _a2;
    return (_a2 = this._renderer) == null ? void 0 : _a2.canvas;
  }
  get drawingContext() {
    return this._renderer.drawingContext;
  }
  get width() {
    var _a2;
    return (_a2 = this._renderer) == null ? void 0 : _a2.width;
  }
  get height() {
    var _a2;
    return (_a2 = this._renderer) == null ? void 0 : _a2.height;
  }
  get pixels() {
    var _a2;
    return (_a2 = this._renderer) == null ? void 0 : _a2.pixels;
  }
  pixelDensity(val2) {
    let returnValue;
    if (typeof val2 === "number") {
      if (val2 !== this._renderer._pixelDensity) {
        this._renderer._pixelDensity = val2;
      }
      returnValue = this;
      this.resizeCanvas(this.width, this.height, true);
    } else {
      returnValue = this._renderer._pixelDensity;
    }
    return returnValue;
  }
  resizeCanvas(w, h) {
    this._renderer.resize(w, h);
  }
  /**
   * Resets the graphics buffer's transformations and lighting.
   *
   * By default, the main canvas resets certain transformation and lighting
   * values each time <a href="#/p5/draw">draw()</a> executes. `p5.Graphics`
   * objects must reset these values manually by calling `myGraphics.reset()`.
   *
   *
   * @example
   * <div>
   * <code>
   * let pg;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.Graphics object.
   *   pg = createGraphics(60, 60);
   *
   *   describe('A white circle moves downward slowly within a dark square. The circle resets at the top of the dark square when the user presses the mouse.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Translate the p5.Graphics object's coordinate system.
   *   // The translation accumulates; the white circle moves.
   *   pg.translate(0, 0.1);
   *
   *   // Draw to the p5.Graphics object.
   *   pg.background(100);
   *   pg.circle(30, 0, 10);
   *
   *   // Display the p5.Graphics object.
   *   image(pg, 20, 20);
   *
   *   // Translate the main canvas' coordinate system.
   *   // The translation doesn't accumulate; the dark
   *   // square is always in the same place.
   *   translate(0, 0.1);
   *
   *   // Reset the p5.Graphics object when the
   *   // user presses the mouse.
   *   if (mouseIsPressed === true) {
   *     pg.reset();
   *   }
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let pg;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.Graphics object.
   *   pg = createGraphics(60, 60);
   *
   *   describe('A white circle at the center of a dark gray square. The image is drawn on a light gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Translate the p5.Graphics object's coordinate system.
   *   pg.translate(30, 30);
   *
   *   // Draw to the p5.Graphics object.
   *   pg.background(100);
   *   pg.circle(0, 0, 10);
   *
   *   // Display the p5.Graphics object.
   *   image(pg, 20, 20);
   *
   *   // Reset the p5.Graphics object automatically.
   *   pg.reset();
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let pg;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.Graphics object using WebGL mode.
   *   pg = createGraphics(100, 100, WEBGL);
   *
   *   describe("A sphere lit from above with a red light. The sphere's surface becomes glossy while the user clicks and holds the mouse.");
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Add a red point light from the top-right.
   *   pg.pointLight(255, 0, 0, 50, -100, 50);
   *
   *   // Style the sphere.
   *   // It should appear glossy when the
   *   // lighting values are reset.
   *   pg.noStroke();
   *   pg.specularMaterial(255);
   *   pg.shininess(100);
   *
   *   // Draw the sphere.
   *   pg.sphere(30);
   *
   *   // Display the p5.Graphics object.
   *   image(pg, -50, -50);
   *
   *   // Reset the p5.Graphics object when
   *   // the user presses the mouse.
   *   if (mouseIsPressed === true) {
   *     pg.reset();
   *   }
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let pg;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.Graphics object using WebGL mode.
   *   pg = createGraphics(100, 100, WEBGL);
   *
   *   describe('A sphere with a glossy surface is lit from the top-right by a red light.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Add a red point light from the top-right.
   *   pg.pointLight(255, 0, 0, 50, -100, 50);
   *
   *   // Style the sphere.
   *   pg.noStroke();
   *   pg.specularMaterial(255);
   *   pg.shininess(100);
   *
   *   // Draw the sphere.
   *   pg.sphere(30);
   *
   *   // Display the p5.Graphics object.
   *   image(pg, 0, 0);
   *
   *   // Reset the p5.Graphics object automatically.
   *   pg.reset();
   * }
   * </code>
   * </div>
   */
  reset() {
    this._renderer.resetMatrix();
    if (this._renderer.isP3D) {
      this._renderer._update();
    }
  }
  /**
   * Removes the graphics buffer from the web page.
   *
   * Calling `myGraphics.remove()` removes the graphics buffer's
   * `&lt;canvas&gt;` element from the web page. The graphics buffer also uses
   * a bit of memory on the CPU that can be freed like so:
   *
   * ```js
   * // Remove the graphics buffer from the web page.
   * myGraphics.remove();
   *
   * // Delete the graphics buffer from CPU memory.
   * myGraphics = undefined;
   * ```
   *
   * Note: All variables that reference the graphics buffer must be assigned
   * the value `undefined` to delete the graphics buffer from CPU memory. If any
   * variable still refers to the graphics buffer, then it won't be garbage
   * collected.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to remove the p5.Graphics object.
   *
   * let pg;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.Graphics object.
   *   pg = createGraphics(60, 60);
   *
   *   // Draw to the p5.Graphics object.
   *   pg.background(100);
   *   pg.circle(30, 30, 20);
   *
   *   describe('A white circle at the center of a dark gray square disappears when the user double-clicks.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Display the p5.Graphics object if
   *   // it's available.
   *   if (pg) {
   *     image(pg, 20, 20);
   *   }
   * }
   *
   * // Remove the p5.Graphics object when the
   * // the user double-clicks.
   * function doubleClicked() {
   *   // Remove the p5.Graphics object from the web page.
   *   pg.remove();
   *   pg = undefined;
   * }
   * </code>
   * </div>
   */
  remove() {
    this._renderer.remove();
    this._renderer = void 0;
  }
  /**
   * Creates a new <a href="#/p5.Framebuffer">p5.Framebuffer</a> object with
   * the same WebGL context as the graphics buffer.
   *
   * <a href="#/p5.Framebuffer">p5.Framebuffer</a> objects are separate drawing
   * surfaces that can be used as textures in WebGL mode. They're similar to
   * <a href="#/p5.Graphics">p5.Graphics</a> objects and generally run much
   * faster when used as textures. Creating a
   * <a href="#/p5.Framebuffer">p5.Framebuffer</a> object in the same context
   * as the graphics buffer makes this speedup possible.
   *
   * The parameter, `options`, is optional. An object can be passed to configure
   * the <a href="#/p5.Framebuffer">p5.Framebuffer</a> object. The available
   * properties are:
   *
   * - `format`: data format of the texture, either `UNSIGNED_BYTE`, `FLOAT`, or `HALF_FLOAT`. Default is `UNSIGNED_BYTE`.
   * - `channels`: whether to store `RGB` or `RGBA` color channels. Default is to match the graphics buffer which is `RGBA`.
   * - `depth`: whether to include a depth buffer. Default is `true`.
   * - `depthFormat`: data format of depth information, either `UNSIGNED_INT` or `FLOAT`. Default is `FLOAT`.
   * - `stencil`: whether to include a stencil buffer for masking. `depth` must be `true` for this feature to work. Defaults to the value of `depth` which is `true`.
   * - `antialias`: whether to perform anti-aliasing. If set to `true`, as in `{ antialias: true }`, 2 samples will be used by default. The number of samples can also be set, as in `{ antialias: 4 }`. Default is to match <a href="#/p5/setAttributes">setAttributes()</a> which is `false` (`true` in Safari).
   * - `width`: width of the <a href="#/p5.Framebuffer">p5.Framebuffer</a> object. Default is to always match the graphics buffer width.
   * - `height`: height of the <a href="#/p5.Framebuffer">p5.Framebuffer</a> object. Default is to always match the graphics buffer height.
   * - `density`: pixel density of the <a href="#/p5.Framebuffer">p5.Framebuffer</a> object. Default is to always match the graphics buffer pixel density.
   * - `textureFiltering`: how to read values from the <a href="#/p5.Framebuffer">p5.Framebuffer</a> object. Either `LINEAR` (nearby pixels will be interpolated) or `NEAREST` (no interpolation). Generally, use `LINEAR` when using the texture as an image and `NEAREST` if reading the texture as data. Default is `LINEAR`.
   *
   * If the `width`, `height`, or `density` attributes are set, they won't
   * automatically match the graphics buffer and must be changed manually.
   *
   * @param {Object} [options] configuration options.
   * @return {p5.Framebuffer} new framebuffer.
   *
   * @example
   * <div>
   * <code>
   * // Click and hold a mouse button to change shapes.
   *
   * let pg;
   * let torusLayer;
   * let boxLayer;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create a p5.Graphics object using WebGL mode.
   *   pg = createGraphics(100, 100, WEBGL);
   *
   *   // Create the p5.Framebuffer objects.
   *   torusLayer = pg.createFramebuffer();
   *   boxLayer = pg.createFramebuffer();
   *
   *   describe('A grid of white toruses rotating against a dark gray background. The shapes become boxes while the user holds a mouse button.');
   * }
   *
   * function draw() {
   *   // Update and draw the layers offscreen.
   *   drawTorus();
   *   drawBox();
   *
   *   // Choose the layer to display.
   *   let layer;
   *   if (mouseIsPressed === true) {
   *     layer = boxLayer;
   *   } else {
   *     layer = torusLayer;
   *   }
   *
   *   // Draw to the p5.Graphics object.
   *   pg.background(50);
   *
   *   // Iterate from left to right.
   *   for (let x = -50; x < 50; x += 25) {
   *     // Iterate from top to bottom.
   *     for (let y = -50; y < 50; y += 25) {
   *       // Draw the layer to the p5.Graphics object
   *       pg.image(layer, x, y, 25, 25);
   *     }
   *   }
   *
   *   // Display the p5.Graphics object.
   *   image(pg, 0, 0);
   * }
   *
   * // Update and draw the torus layer offscreen.
   * function drawTorus() {
   *   // Start drawing to the torus p5.Framebuffer.
   *   torusLayer.begin();
   *
   *   // Clear the drawing surface.
   *   pg.clear();
   *
   *   // Turn on the lights.
   *   pg.lights();
   *
   *   // Rotate the coordinate system.
   *   pg.rotateX(frameCount * 0.01);
   *   pg.rotateY(frameCount * 0.01);
   *
   *   // Style the torus.
   *   pg.noStroke();
   *
   *   // Draw the torus.
   *   pg.torus(20);
   *
   *   // Start drawing to the torus p5.Framebuffer.
   *   torusLayer.end();
   * }
   *
   * // Update and draw the box layer offscreen.
   * function drawBox() {
   *   // Start drawing to the box p5.Framebuffer.
   *   boxLayer.begin();
   *
   *   // Clear the drawing surface.
   *   pg.clear();
   *
   *   // Turn on the lights.
   *   pg.lights();
   *
   *   // Rotate the coordinate system.
   *   pg.rotateX(frameCount * 0.01);
   *   pg.rotateY(frameCount * 0.01);
   *
   *   // Style the box.
   *   pg.noStroke();
   *
   *   // Draw the box.
   *   pg.box(30);
   *
   *   // Start drawing to the box p5.Framebuffer.
   *   boxLayer.end();
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * // Click and hold a mouse button to change shapes.
   *
   * let pg;
   * let torusLayer;
   * let boxLayer;
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   // Create an options object.
   *   let options = { width: 25, height: 25 };
   *
   *   // Create a p5.Graphics object using WebGL mode.
   *   pg = createGraphics(100, 100, WEBGL);
   *
   *   // Create the p5.Framebuffer objects.
   *   // Use options for configuration.
   *   torusLayer = pg.createFramebuffer(options);
   *   boxLayer = pg.createFramebuffer(options);
   *
   *   describe('A grid of white toruses rotating against a dark gray background. The shapes become boxes while the user holds a mouse button.');
   * }
   *
   * function draw() {
   *   // Update and draw the layers offscreen.
   *   drawTorus();
   *   drawBox();
   *
   *   // Choose the layer to display.
   *   let layer;
   *   if (mouseIsPressed === true) {
   *     layer = boxLayer;
   *   } else {
   *     layer = torusLayer;
   *   }
   *
   *   // Draw to the p5.Graphics object.
   *   pg.background(50);
   *
   *   // Iterate from left to right.
   *   for (let x = -50; x < 50; x += 25) {
   *     // Iterate from top to bottom.
   *     for (let y = -50; y < 50; y += 25) {
   *       // Draw the layer to the p5.Graphics object
   *       pg.image(layer, x, y);
   *     }
   *   }
   *
   *   // Display the p5.Graphics object.
   *   image(pg, 0, 0);
   * }
   *
   * // Update and draw the torus layer offscreen.
   * function drawTorus() {
   *   // Start drawing to the torus p5.Framebuffer.
   *   torusLayer.begin();
   *
   *   // Clear the drawing surface.
   *   pg.clear();
   *
   *   // Turn on the lights.
   *   pg.lights();
   *
   *   // Rotate the coordinate system.
   *   pg.rotateX(frameCount * 0.01);
   *   pg.rotateY(frameCount * 0.01);
   *
   *   // Style the torus.
   *   pg.noStroke();
   *
   *   // Draw the torus.
   *   pg.torus(5, 2.5);
   *
   *   // Start drawing to the torus p5.Framebuffer.
   *   torusLayer.end();
   * }
   *
   * // Update and draw the box layer offscreen.
   * function drawBox() {
   *   // Start drawing to the box p5.Framebuffer.
   *   boxLayer.begin();
   *
   *   // Clear the drawing surface.
   *   pg.clear();
   *
   *   // Turn on the lights.
   *   pg.lights();
   *
   *   // Rotate the coordinate system.
   *   pg.rotateX(frameCount * 0.01);
   *   pg.rotateY(frameCount * 0.01);
   *
   *   // Style the box.
   *   pg.noStroke();
   *
   *   // Draw the box.
   *   pg.box(7.5);
   *
   *   // Start drawing to the box p5.Framebuffer.
   *   boxLayer.end();
   * }
   * </code>
   * </div>
   */
  createFramebuffer(options2) {
    return new Framebuffer(this._renderer, options2);
  }
  _assert3d(name) {
    if (!this._renderer.isP3D)
      throw new Error(
        `${name}() is only supported in WEBGL mode. If you'd like to use 3D graphics and WebGL, see  https://p5js.org/examples/form-3d-primitives.html for more information.`
      );
  }
  _initializeInstanceVariables() {
    this._accessibleOutputs = {
      text: false,
      grid: false,
      textLabel: false,
      gridLabel: false
    };
    this._styles = [];
    this._downKeys = {};
  }
};
function graphics(p53, fn2) {
  p53.Graphics = Graphics;
  primitives(p53, p53.Graphics.prototype);
  attributes(p53, p53.Graphics.prototype);
  curves(p53, p53.Graphics.prototype);
  vertex(p53, p53.Graphics.prototype);
  customShapes(p53, p53.Graphics.prototype);
  setting(p53, p53.Graphics.prototype);
  loadingDisplaying(p53, p53.Graphics.prototype);
  image2(p53, p53.Graphics.prototype);
  pixels(p53, p53.Graphics.prototype);
  transform(p53, p53.Graphics.prototype);
  primitives3D(p53, p53.Graphics.prototype);
  light(p53, p53.Graphics.prototype);
  material(p53, p53.Graphics.prototype);
  creatingReading(p53, p53.Graphics.prototype);
  trigonometry(p53, p53.Graphics.prototype);
}
var Texture = class {
  constructor(renderer2, obj, settings) {
    this._renderer = renderer2;
    const gl = this._renderer.GL;
    settings = settings || {};
    this.src = obj;
    this.glTex = void 0;
    this.glTarget = gl.TEXTURE_2D;
    this.glFormat = settings.format || gl.RGBA;
    this.mipmaps = false;
    this.glMinFilter = settings.minFilter || gl.LINEAR;
    this.glMagFilter = settings.magFilter || gl.LINEAR;
    this.glWrapS = settings.wrapS || gl.CLAMP_TO_EDGE;
    this.glWrapT = settings.wrapT || gl.CLAMP_TO_EDGE;
    this.glDataType = settings.dataType || gl.UNSIGNED_BYTE;
    const support = checkWebGLCapabilities(renderer2);
    if (this.glFormat === gl.HALF_FLOAT && !support.halfFloat) {
      console.log("This device does not support dataType HALF_FLOAT. Falling back to FLOAT.");
      this.glDataType = gl.FLOAT;
    }
    if (this.glFormat === gl.HALF_FLOAT && (this.glMinFilter === gl.LINEAR || this.glMagFilter === gl.LINEAR) && !support.halfFloatLinear) {
      console.log("This device does not support linear filtering for dataType FLOAT. Falling back to NEAREST.");
      if (this.glMinFilter === gl.LINEAR) this.glMinFilter = gl.NEAREST;
      if (this.glMagFilter === gl.LINEAR) this.glMagFilter = gl.NEAREST;
    }
    if (this.glFormat === gl.FLOAT && !support.float) {
      console.log("This device does not support dataType FLOAT. Falling back to UNSIGNED_BYTE.");
      this.glDataType = gl.UNSIGNED_BYTE;
    }
    if (this.glFormat === gl.FLOAT && (this.glMinFilter === gl.LINEAR || this.glMagFilter === gl.LINEAR) && !support.floatLinear) {
      console.log("This device does not support linear filtering for dataType FLOAT. Falling back to NEAREST.");
      if (this.glMinFilter === gl.LINEAR) this.glMinFilter = gl.NEAREST;
      if (this.glMagFilter === gl.LINEAR) this.glMagFilter = gl.NEAREST;
    }
    this.isSrcMediaElement = false;
    this._videoPrevUpdateTime = 0;
    this.isSrcHTMLElement = typeof Element !== "undefined" && obj instanceof Element && !(obj instanceof Graphics) && !(obj instanceof Renderer);
    this.isSrcP5Image = obj instanceof Image;
    this.isSrcP5Graphics = obj instanceof Graphics;
    this.isSrcP5Renderer = obj instanceof Renderer;
    this.isImageData = typeof ImageData !== "undefined" && obj instanceof ImageData;
    this.isFramebufferTexture = obj instanceof FramebufferTexture;
    const textureData = this._getTextureDataFromSource();
    this.width = textureData.width;
    this.height = textureData.height;
    this.init(textureData);
    return this;
  }
  remove() {
    if (this.glTex) {
      const gl = this._renderer.GL;
      gl.deleteTexture(this.glTex);
      this.glTex = void 0;
    }
  }
  _getTextureDataFromSource() {
    let textureData;
    if (this.isFramebufferTexture) {
      textureData = this.src.rawTexture();
    } else if (this.isSrcP5Image) {
      textureData = this.src.canvas;
    } else if (this.isSrcMediaElement || this.isSrcHTMLElement) {
      if (this.src._ensureCanvas) {
        this.src._ensureCanvas();
      }
      textureData = this.src.elt;
    } else if (this.isSrcP5Graphics || this.isSrcP5Renderer) {
      textureData = this.src.canvas;
    } else if (this.isImageData) {
      textureData = this.src;
    }
    return textureData;
  }
  /**
   * Initializes common texture parameters, creates a gl texture,
   * tries to upload the texture for the first time if data is
   * already available.
   */
  init(data3) {
    const gl = this._renderer.GL;
    if (!this.isFramebufferTexture) {
      this.glTex = gl.createTexture();
    }
    this.glWrapS = this._renderer.states.textureWrapX;
    this.glWrapT = this._renderer.states.textureWrapY;
    this.setWrapMode(this.glWrapS, this.glWrapT);
    this.bindTexture();
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this.glMagFilter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.glMinFilter);
    if (this.isFramebufferTexture) ;
    else if (this.width === 0 || this.height === 0 || this.isSrcMediaElement && !this.src.loadedmetadata) {
      const tmpdata = new Uint8Array([1, 1, 1, 1]);
      gl.texImage2D(
        this.glTarget,
        0,
        gl.RGBA,
        1,
        1,
        0,
        this.glFormat,
        this.glDataType,
        tmpdata
      );
    } else {
      gl.texImage2D(
        this.glTarget,
        0,
        this.glFormat,
        this.glFormat,
        this.glDataType,
        data3
      );
    }
  }
  /**
   * Checks if the source data for this texture has changed (if it's
   * easy to do so) and reuploads the texture if necessary. If it's not
   * possible or to expensive to do a calculation to determine wheter or
   * not the data has occurred, this method simply re-uploads the texture.
   */
  update() {
    const data3 = this.src;
    if (data3.width === 0 || data3.height === 0) {
      return false;
    }
    if (this.isFramebufferTexture) {
      this.src.update();
      return false;
    }
    const textureData = this._getTextureDataFromSource();
    let updated = false;
    const gl = this._renderer.GL;
    if (textureData.width !== this.width || textureData.height !== this.height) {
      updated = true;
      this.width = textureData.width || data3.width;
      this.height = textureData.height || data3.height;
      if (this.isSrcP5Image) {
        data3.setModified(false);
      } else if (this.isSrcMediaElement || this.isSrcHTMLElement) {
        data3.setModified && data3.setModified(true);
      }
    } else if (this.isSrcP5Image) {
      if (data3.isModified()) {
        updated = true;
        data3.setModified(false);
      }
    } else if (this.isSrcMediaElement) {
      if (data3.isModified()) {
        updated = true;
        data3.setModified(false);
      } else if (data3.loadedmetadata) {
        if (this._videoPrevUpdateTime !== data3.time()) {
          this._videoPrevUpdateTime = data3.time();
          updated = true;
        }
      }
    } else if (this.isImageData) {
      if (data3._dirty) {
        data3._dirty = false;
        updated = true;
      }
    } else {
      updated = true;
    }
    if (updated) {
      this.bindTexture();
      gl.texImage2D(
        this.glTarget,
        0,
        this.glFormat,
        this.glFormat,
        this.glDataType,
        textureData
      );
    }
    return updated;
  }
  /**
   * Binds the texture to the appropriate GL target.
   */
  bindTexture() {
    const gl = this._renderer.GL;
    gl.bindTexture(this.glTarget, this.getTexture());
    return this;
  }
  /**
   * Unbinds the texture from the appropriate GL target.
   */
  unbindTexture() {
    const gl = this._renderer.GL;
    gl.bindTexture(this.glTarget, null);
  }
  getTexture() {
    if (this.isFramebufferTexture) {
      return this.src.rawTexture();
    } else {
      return this.glTex;
    }
  }
  /**
   * Sets how a texture is be interpolated when upscaled or downscaled.
   * Nearest filtering uses nearest neighbor scaling when interpolating
   * Linear filtering uses WebGL's linear scaling when interpolating
   * @param {String} downScale Specifies the texture filtering when
   *                           textures are shrunk. Options are LINEAR or NEAREST
   * @param {String} upScale Specifies the texture filtering when
   *                         textures are magnified. Options are LINEAR or NEAREST
   * @todo implement mipmapping filters
   */
  setInterpolation(downScale, upScale) {
    const gl = this._renderer.GL;
    this.glMinFilter = this.glFilter(downScale);
    this.glMagFilter = this.glFilter(upScale);
    this.bindTexture();
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.glMinFilter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this.glMagFilter);
    this.unbindTexture();
  }
  glFilter(filter) {
    const gl = this._renderer.GL;
    if (filter === NEAREST) {
      return gl.NEAREST;
    } else {
      return gl.LINEAR;
    }
  }
  /**
   * Sets the texture wrapping mode. This controls how textures behave
   * when their uv's go outside of the 0 - 1 range. There are three options:
   * CLAMP, REPEAT, and MIRROR. REPEAT & MIRROR are only available if the texture
   * is a power of two size (128, 256, 512, 1024, etc.).
   * @param {String} wrapX Controls the horizontal texture wrapping behavior
   * @param {String} wrapY Controls the vertical texture wrapping behavior
   */
  setWrapMode(wrapX, wrapY) {
    const gl = this._renderer.GL;
    const isPowerOfTwo = (x) => (x & x - 1) === 0;
    const textureData = this._getTextureDataFromSource();
    let wrapWidth;
    let wrapHeight;
    if (textureData.naturalWidth && textureData.naturalHeight) {
      wrapWidth = textureData.naturalWidth;
      wrapHeight = textureData.naturalHeight;
    } else {
      wrapWidth = this.width;
      wrapHeight = this.height;
    }
    const widthPowerOfTwo = isPowerOfTwo(wrapWidth);
    const heightPowerOfTwo = isPowerOfTwo(wrapHeight);
    if (wrapX === REPEAT) {
      if (this._renderer.webglVersion === WEBGL2 || widthPowerOfTwo && heightPowerOfTwo) {
        this.glWrapS = gl.REPEAT;
      } else {
        console.warn(
          "You tried to set the wrap mode to REPEAT but the texture size is not a power of two. Setting to CLAMP instead"
        );
        this.glWrapS = gl.CLAMP_TO_EDGE;
      }
    } else if (wrapX === MIRROR) {
      if (this._renderer.webglVersion === WEBGL2 || widthPowerOfTwo && heightPowerOfTwo) {
        this.glWrapS = gl.MIRRORED_REPEAT;
      } else {
        console.warn(
          "You tried to set the wrap mode to MIRROR but the texture size is not a power of two. Setting to CLAMP instead"
        );
        this.glWrapS = gl.CLAMP_TO_EDGE;
      }
    } else {
      this.glWrapS = gl.CLAMP_TO_EDGE;
    }
    if (wrapY === REPEAT) {
      if (this._renderer.webglVersion === WEBGL2 || widthPowerOfTwo && heightPowerOfTwo) {
        this.glWrapT = gl.REPEAT;
      } else {
        console.warn(
          "You tried to set the wrap mode to REPEAT but the texture size is not a power of two. Setting to CLAMP instead"
        );
        this.glWrapT = gl.CLAMP_TO_EDGE;
      }
    } else if (wrapY === MIRROR) {
      if (this._renderer.webglVersion === WEBGL2 || widthPowerOfTwo && heightPowerOfTwo) {
        this.glWrapT = gl.MIRRORED_REPEAT;
      } else {
        console.warn(
          "You tried to set the wrap mode to MIRROR but the texture size is not a power of two. Setting to CLAMP instead"
        );
        this.glWrapT = gl.CLAMP_TO_EDGE;
      }
    } else {
      this.glWrapT = gl.CLAMP_TO_EDGE;
    }
    this.bindTexture();
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this.glWrapS);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this.glWrapT);
    this.unbindTexture();
  }
};
var MipmapTexture = class extends Texture {
  constructor(renderer2, levels, settings) {
    super(renderer2, levels, settings);
    const gl = this._renderer.GL;
    if (this.glMinFilter === gl.LINEAR) {
      this.glMinFilter = gl.LINEAR_MIPMAP_LINEAR;
    }
  }
  glFilter(_filter) {
    const gl = this._renderer.GL;
    return gl.LINEAR_MIPMAP_LINEAR;
  }
  _getTextureDataFromSource() {
    return this.src;
  }
  init(levels) {
    const gl = this._renderer.GL;
    this.glTex = gl.createTexture();
    this.bindTexture();
    for (let level = 0; level < levels.length; level++) {
      gl.texImage2D(
        this.glTarget,
        level,
        this.glFormat,
        this.glFormat,
        this.glDataType,
        levels[level]
      );
    }
    this.glMinFilter = gl.LINEAR_MIPMAP_LINEAR;
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this.glMagFilter);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.glMinFilter);
    this.unbindTexture();
  }
  update() {
  }
};
function texture(p53, fn2) {
  p53.Texture = Texture;
  p53.MipmapTexture = MipmapTexture;
}
function checkWebGLCapabilities({ GL, webglVersion }) {
  const gl = GL;
  const supportsFloat = webglVersion === WEBGL2 ? gl.getExtension("EXT_color_buffer_float") && gl.getExtension("EXT_float_blend") : gl.getExtension("OES_texture_float");
  const supportsFloatLinear = supportsFloat && gl.getExtension("OES_texture_float_linear");
  const supportsHalfFloat = webglVersion === WEBGL2 ? gl.getExtension("EXT_color_buffer_float") : gl.getExtension("OES_texture_half_float");
  const supportsHalfFloatLinear = supportsHalfFloat && gl.getExtension("OES_texture_half_float_linear");
  return {
    float: supportsFloat,
    floatLinear: supportsFloatLinear,
    halfFloat: supportsHalfFloat,
    halfFloatLinear: supportsHalfFloatLinear
  };
}
if (typeof p5 !== "undefined") {
  texture(p5, p5.prototype);
}
var constrain2 = (n3, low, high) => Math.max(Math.min(n3, high), low);
var FramebufferCamera = class extends Camera {
  constructor(framebuffer2) {
    super(framebuffer2.renderer);
    this.fbo = framebuffer2;
    this.yScale = -1;
  }
  _computeCameraDefaultSettings() {
    super._computeCameraDefaultSettings();
    this.defaultAspectRatio = this.fbo.width / this.fbo.height;
    this.defaultCameraFOV = 2 * Math.atan(this.fbo.height / 2 / this.defaultEyeZ);
  }
};
var FramebufferTexture = class {
  constructor(framebuffer2, property) {
    this.framebuffer = framebuffer2;
    this.property = property;
  }
  get width() {
    return this.framebuffer.width * this.framebuffer.density;
  }
  get height() {
    return this.framebuffer.height * this.framebuffer.density;
  }
  update() {
    this.framebuffer._update(this.property);
  }
  rawTexture() {
    return this.framebuffer[this.property];
  }
};
var Framebuffer = class {
  constructor(renderer2, settings = {}) {
    this.renderer = renderer2;
    this.renderer.framebuffers.add(this);
    this._isClipApplied = false;
    this.dirty = { colorTexture: false, depthTexture: false };
    this.pixels = [];
    this.format = settings.format || UNSIGNED_BYTE;
    this.channels = settings.channels || (this.renderer._pInst._glAttributes.alpha ? RGBA : RGB);
    this.useDepth = settings.depth === void 0 ? true : settings.depth;
    this.depthFormat = settings.depthFormat || FLOAT;
    this.textureFiltering = settings.textureFiltering || LINEAR;
    if (settings.antialias === void 0) {
      this.antialiasSamples = this.renderer._pInst._glAttributes.antialias ? 2 : 0;
    } else if (typeof settings.antialias === "number") {
      this.antialiasSamples = settings.antialias;
    } else {
      this.antialiasSamples = settings.antialias ? 2 : 0;
    }
    this.antialias = this.antialiasSamples > 0;
    if (this.antialias && this.renderer.webglVersion !== WEBGL2) {
      console.warn("Antialiasing is unsupported in a WebGL 1 context");
      this.antialias = false;
    }
    this.density = settings.density || this.renderer._pixelDensity;
    const gl = this.renderer.GL;
    this.gl = gl;
    if (settings.width && settings.height) {
      const dimensions = this.renderer._adjustDimensions(settings.width, settings.height);
      this.width = dimensions.adjustedWidth;
      this.height = dimensions.adjustedHeight;
      this._autoSized = false;
    } else {
      if (settings.width === void 0 !== (settings.height === void 0)) {
        console.warn(
          "Please supply both width and height for a framebuffer to give it a size. Only one was given, so the framebuffer will match the size of its canvas."
        );
      }
      this.width = this.renderer.width;
      this.height = this.renderer.height;
      this._autoSized = true;
    }
    this._checkIfFormatsAvailable();
    if (settings.stencil && !this.useDepth) {
      console.warn("A stencil buffer can only be used if also using depth. Since the framebuffer has no depth buffer, the stencil buffer will be ignored.");
    }
    this.useStencil = this.useDepth && (settings.stencil === void 0 ? true : settings.stencil);
    this.framebuffer = gl.createFramebuffer();
    if (!this.framebuffer) {
      throw new Error("Unable to create a framebuffer");
    }
    if (this.antialias) {
      this.aaFramebuffer = gl.createFramebuffer();
      if (!this.aaFramebuffer) {
        throw new Error("Unable to create a framebuffer for antialiasing");
      }
    }
    this._recreateTextures();
    const prevCam = this.renderer.states.curCamera;
    this.defaultCamera = this.createCamera();
    this.filterCamera = this.createCamera();
    this.renderer.states.setValue("curCamera", prevCam);
    this.draw(() => this.renderer.clear());
  }
  /**
   * Resizes the framebuffer to a given width and height.
   *
   * The parameters, `width` and `height`, set the dimensions of the
   * framebuffer. For example, calling `myBuffer.resize(300, 500)` resizes
   * the framebuffer to 300×500 pixels, then sets `myBuffer.width` to 300
   * and `myBuffer.height` 500.
   *
   * @param {Number} width width of the framebuffer.
   * @param {Number} height height of the framebuffer.
   *
   * @example
   * <div>
   * <code>
   * let myBuffer;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Framebuffer object.
   *   myBuffer = createFramebuffer();
   *
   *   describe('A multicolor sphere on a white surface. The image grows larger or smaller when the user moves the mouse, revealing a gray background.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Draw to the p5.Framebuffer object.
   *   myBuffer.begin();
   *   background(255);
   *   normalMaterial();
   *   sphere(20);
   *   myBuffer.end();
   *
   *   // Display the p5.Framebuffer object.
   *   image(myBuffer, -50, -50);
   * }
   *
   * // Resize the p5.Framebuffer object when the
   * // user moves the mouse.
   * function mouseMoved() {
   *   myBuffer.resize(mouseX, mouseY);
   * }
   * </code>
   * </div>
   */
  resize(width, height) {
    this._autoSized = false;
    const dimensions = this.renderer._adjustDimensions(width, height);
    width = dimensions.adjustedWidth;
    height = dimensions.adjustedHeight;
    this.width = width;
    this.height = height;
    this._handleResize();
  }
  /**
   * Sets the framebuffer's pixel density or returns its current density.
   *
   * Computer displays are grids of little lights called pixels. A display's
   * pixel density describes how many pixels it packs into an area. Displays
   * with smaller pixels have a higher pixel density and create sharper
   * images.
   *
   * The parameter, `density`, is optional. If a number is passed, as in
   * `myBuffer.pixelDensity(1)`, it sets the framebuffer's pixel density. By
   * default, the framebuffer's pixel density will match that of the canvas
   * where it was created. All canvases default to match the display's pixel
   * density.
   *
   * Calling `myBuffer.pixelDensity()` without an argument returns its current
   * pixel density.
   *
   * @param {Number} [density] pixel density to set.
   * @returns {Number} current pixel density.
   *
   * @example
   * <div>
   * <code>
   * let myBuffer;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Framebuffer object.
   *   myBuffer = createFramebuffer();
   *
   *   describe("A white circle on a gray canvas. The circle's edge become fuzzy while the user presses and holds the mouse.");
   * }
   *
   * function draw() {
   *   // Draw to the p5.Framebuffer object.
   *   myBuffer.begin();
   *   background(200);
   *   circle(0, 0, 40);
   *   myBuffer.end();
   *
   *   // Display the p5.Framebuffer object.
   *   image(myBuffer, -50, -50);
   * }
   *
   * // Decrease the pixel density when the user
   * // presses the mouse.
   * function mousePressed() {
   *   myBuffer.pixelDensity(1);
   * }
   *
   * // Increase the pixel density when the user
   * // releases the mouse.
   * function mouseReleased() {
   *   myBuffer.pixelDensity(2);
   * }
   * </code>
   * </div>
   *
   * <div>
   * <code>
   * let myBuffer;
   * let myFont;
   *
   * async function setup() {
   *   // Load a font and create a p5.Font object.
   *   myFont = await loadFont('assets/inconsolata.otf');
   *
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Create a p5.Framebuffer object.
   *   myBuffer = createFramebuffer();
   *
   *   // Get the p5.Framebuffer object's pixel density.
   *   let d = myBuffer.pixelDensity();
   *
   *   // Style the text.
   *   textAlign(CENTER, CENTER);
   *   textFont(myFont);
   *   textSize(16);
   *   fill(0);
   *
   *   // Display the pixel density.
   *   text(`Density: ${d}`, 0, 0);
   *
   *   describe(`The text "Density: ${d}" written in black on a gray background.`);
   * }
   * </code>
   * </div>
   */
  pixelDensity(density) {
    if (density) {
      this._autoSized = false;
      this.density = density;
      this._handleResize();
    } else {
      return this.density;
    }
  }
  /**
   * Toggles the framebuffer's autosizing mode or returns the current mode.
   *
   * By default, the framebuffer automatically resizes to match the canvas
   * that created it. Calling `myBuffer.autoSized(false)` disables this
   * behavior and calling `myBuffer.autoSized(true)` re-enables it.
   *
   * Calling `myBuffer.autoSized()` without an argument returns `true` if
   * the framebuffer automatically resizes and `false` if not.
   *
   * @param {Boolean} [autoSized] whether to automatically resize the framebuffer to match the canvas.
   * @returns {Boolean} current autosize setting.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to toggle the autosizing mode.
   *
   * let myBuffer;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Framebuffer object.
   *   myBuffer = createFramebuffer();
   *
   *   describe('A multicolor sphere on a gray background. The image resizes when the user moves the mouse.');
   * }
   *
   * function draw() {
   *   background(50);
   *
   *   // Draw to the p5.Framebuffer object.
   *   myBuffer.begin();
   *   background(200);
   *   normalMaterial();
   *   sphere(width / 4);
   *   myBuffer.end();
   *
   *   // Display the p5.Framebuffer object.
   *   image(myBuffer, -width / 2, -height / 2);
   * }
   *
   * // Resize the canvas when the user moves the mouse.
   * function mouseMoved() {
   *   let w = constrain(mouseX, 0, 100);
   *   let h = constrain(mouseY, 0, 100);
   *   resizeCanvas(w, h);
   * }
   *
   * // Toggle autoSizing when the user double-clicks.
   * // Note: opened an issue to fix(?) this.
   * function doubleClicked() {
   *   let isAuto = myBuffer.autoSized();
   *   myBuffer.autoSized(!isAuto);
   * }
   * </code>
   * </div>
   */
  autoSized(autoSized) {
    if (autoSized === void 0) {
      return this._autoSized;
    } else {
      this._autoSized = autoSized;
      this._handleResize();
    }
  }
  /**
   * Checks the capabilities of the current WebGL environment to see if the
   * settings supplied by the user are capable of being fulfilled. If they
   * are not, warnings will be logged and the settings will be changed to
   * something close that can be fulfilled.
   *
   * @private
   */
  _checkIfFormatsAvailable() {
    const gl = this.gl;
    if (this.useDepth && this.renderer.webglVersion === WEBGL && !gl.getExtension("WEBGL_depth_texture")) {
      console.warn(
        "Unable to create depth textures in this environment. Falling back to a framebuffer without depth."
      );
      this.useDepth = false;
    }
    if (this.useDepth && this.renderer.webglVersion === WEBGL && this.depthFormat === FLOAT) {
      console.warn(
        "FLOAT depth format is unavailable in WebGL 1. Defaulting to UNSIGNED_INT."
      );
      this.depthFormat = UNSIGNED_INT;
    }
    if (![
      UNSIGNED_BYTE,
      FLOAT,
      HALF_FLOAT
    ].includes(this.format)) {
      console.warn(
        "Unknown Framebuffer format. Please use UNSIGNED_BYTE, FLOAT, or HALF_FLOAT. Defaulting to UNSIGNED_BYTE."
      );
      this.format = UNSIGNED_BYTE;
    }
    if (this.useDepth && ![
      UNSIGNED_INT,
      FLOAT
    ].includes(this.depthFormat)) {
      console.warn(
        "Unknown Framebuffer depth format. Please use UNSIGNED_INT or FLOAT. Defaulting to FLOAT."
      );
      this.depthFormat = FLOAT;
    }
    const support = checkWebGLCapabilities(this.renderer);
    if (!support.float && this.format === FLOAT) {
      console.warn(
        "This environment does not support FLOAT textures. Falling back to UNSIGNED_BYTE."
      );
      this.format = UNSIGNED_BYTE;
    }
    if (this.useDepth && !support.float && this.depthFormat === FLOAT) {
      console.warn(
        "This environment does not support FLOAT depth textures. Falling back to UNSIGNED_INT."
      );
      this.depthFormat = UNSIGNED_INT;
    }
    if (!support.halfFloat && this.format === HALF_FLOAT) {
      console.warn(
        "This environment does not support HALF_FLOAT textures. Falling back to UNSIGNED_BYTE."
      );
      this.format = UNSIGNED_BYTE;
    }
    if (this.channels === RGB && [FLOAT, HALF_FLOAT].includes(this.format)) {
      console.warn(
        "FLOAT and HALF_FLOAT formats do not work cross-platform with only RGB channels. Falling back to RGBA."
      );
      this.channels = RGBA;
    }
  }
  /**
   * Creates new textures and renderbuffers given the current size of the
   * framebuffer.
   *
   * @private
   */
  _recreateTextures() {
    const gl = this.gl;
    this._updateSize();
    const prevBoundTexture = gl.getParameter(gl.TEXTURE_BINDING_2D);
    const prevBoundFramebuffer = gl.getParameter(gl.FRAMEBUFFER_BINDING);
    const colorTexture = gl.createTexture();
    if (!colorTexture) {
      throw new Error("Unable to create color texture");
    }
    gl.bindTexture(gl.TEXTURE_2D, colorTexture);
    const colorFormat = this._glColorFormat();
    gl.texImage2D(
      gl.TEXTURE_2D,
      0,
      colorFormat.internalFormat,
      this.width * this.density,
      this.height * this.density,
      0,
      colorFormat.format,
      colorFormat.type,
      null
    );
    this.colorTexture = colorTexture;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    gl.framebufferTexture2D(
      gl.FRAMEBUFFER,
      gl.COLOR_ATTACHMENT0,
      gl.TEXTURE_2D,
      colorTexture,
      0
    );
    if (this.useDepth) {
      const depthTexture = gl.createTexture();
      if (!depthTexture) {
        throw new Error("Unable to create depth texture");
      }
      const depthFormat = this._glDepthFormat();
      gl.bindTexture(gl.TEXTURE_2D, depthTexture);
      gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        depthFormat.internalFormat,
        this.width * this.density,
        this.height * this.density,
        0,
        depthFormat.format,
        depthFormat.type,
        null
      );
      gl.framebufferTexture2D(
        gl.FRAMEBUFFER,
        this.useStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT,
        gl.TEXTURE_2D,
        depthTexture,
        0
      );
      this.depthTexture = depthTexture;
    }
    if (this.antialias) {
      this.colorRenderbuffer = gl.createRenderbuffer();
      gl.bindRenderbuffer(gl.RENDERBUFFER, this.colorRenderbuffer);
      gl.renderbufferStorageMultisample(
        gl.RENDERBUFFER,
        Math.max(
          0,
          Math.min(this.antialiasSamples, gl.getParameter(gl.MAX_SAMPLES))
        ),
        colorFormat.internalFormat,
        this.width * this.density,
        this.height * this.density
      );
      if (this.useDepth) {
        const depthFormat = this._glDepthFormat();
        this.depthRenderbuffer = gl.createRenderbuffer();
        gl.bindRenderbuffer(gl.RENDERBUFFER, this.depthRenderbuffer);
        gl.renderbufferStorageMultisample(
          gl.RENDERBUFFER,
          Math.max(
            0,
            Math.min(this.antialiasSamples, gl.getParameter(gl.MAX_SAMPLES))
          ),
          depthFormat.internalFormat,
          this.width * this.density,
          this.height * this.density
        );
      }
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.aaFramebuffer);
      gl.framebufferRenderbuffer(
        gl.FRAMEBUFFER,
        gl.COLOR_ATTACHMENT0,
        gl.RENDERBUFFER,
        this.colorRenderbuffer
      );
      if (this.useDepth) {
        gl.framebufferRenderbuffer(
          gl.FRAMEBUFFER,
          this.useStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT,
          gl.RENDERBUFFER,
          this.depthRenderbuffer
        );
      }
    }
    if (this.useDepth) {
      this.depth = new FramebufferTexture(this, "depthTexture");
      const depthFilter = gl.NEAREST;
      this.depthP5Texture = new Texture(
        this.renderer,
        this.depth,
        {
          minFilter: depthFilter,
          magFilter: depthFilter
        }
      );
      this.renderer.textures.set(this.depth, this.depthP5Texture);
    }
    this.color = new FramebufferTexture(this, "colorTexture");
    const filter = this.textureFiltering === LINEAR ? gl.LINEAR : gl.NEAREST;
    this.colorP5Texture = new Texture(
      this.renderer,
      this.color,
      {
        minFilter: filter,
        magFilter: filter
      }
    );
    this.renderer.textures.set(this.color, this.colorP5Texture);
    gl.bindTexture(gl.TEXTURE_2D, prevBoundTexture);
    gl.bindFramebuffer(gl.FRAMEBUFFER, prevBoundFramebuffer);
  }
  /**
   * To create a WebGL texture, one needs to supply three pieces of information:
   * the type (the data type each channel will be stored as, e.g. int or float),
   * the format (the color channels that will each be stored in the previously
   * specified type, e.g. rgb or rgba), and the internal format (the specifics
   * of how data for each channel, in the aforementioned type, will be packed
   * together, such as how many bits to use, e.g. RGBA32F or RGB565.)
   *
   * The format and channels asked for by the user hint at what these values
   * need to be, and the WebGL version affects what options are avaiable.
   * This method returns the values for these three properties, given the
   * framebuffer's settings.
   *
   * @private
   */
  _glColorFormat() {
    let type3, format, internalFormat;
    const gl = this.gl;
    if (this.format === FLOAT) {
      type3 = gl.FLOAT;
    } else if (this.format === HALF_FLOAT) {
      type3 = this.renderer.webglVersion === WEBGL2 ? gl.HALF_FLOAT : gl.getExtension("OES_texture_half_float").HALF_FLOAT_OES;
    } else {
      type3 = gl.UNSIGNED_BYTE;
    }
    if (this.channels === RGBA) {
      format = gl.RGBA;
    } else {
      format = gl.RGB;
    }
    if (this.renderer.webglVersion === WEBGL2) {
      const table2 = {
        [gl.FLOAT]: {
          [gl.RGBA]: gl.RGBA32F
          // gl.RGB32F is not available in Firefox without an alpha channel
        },
        [gl.HALF_FLOAT]: {
          [gl.RGBA]: gl.RGBA16F
          // gl.RGB16F is not available in Firefox without an alpha channel
        },
        [gl.UNSIGNED_BYTE]: {
          [gl.RGBA]: gl.RGBA8,
          // gl.RGBA4
          [gl.RGB]: gl.RGB8
          // gl.RGB565
        }
      };
      internalFormat = table2[type3][format];
    } else if (this.format === HALF_FLOAT) {
      internalFormat = gl.RGBA;
    } else {
      internalFormat = format;
    }
    return { internalFormat, format, type: type3 };
  }
  /**
   * To create a WebGL texture, one needs to supply three pieces of information:
   * the type (the data type each channel will be stored as, e.g. int or float),
   * the format (the color channels that will each be stored in the previously
   * specified type, e.g. rgb or rgba), and the internal format (the specifics
   * of how data for each channel, in the aforementioned type, will be packed
   * together, such as how many bits to use, e.g. RGBA32F or RGB565.)
   *
   * This method takes into account the settings asked for by the user and
   * returns values for these three properties that can be used for the
   * texture storing depth information.
   *
   * @private
   */
  _glDepthFormat() {
    let type3, format, internalFormat;
    const gl = this.gl;
    if (this.useStencil) {
      if (this.depthFormat === FLOAT) {
        type3 = gl.FLOAT_32_UNSIGNED_INT_24_8_REV;
      } else if (this.renderer.webglVersion === WEBGL2) {
        type3 = gl.UNSIGNED_INT_24_8;
      } else {
        type3 = gl.getExtension("WEBGL_depth_texture").UNSIGNED_INT_24_8_WEBGL;
      }
    } else {
      if (this.depthFormat === FLOAT) {
        type3 = gl.FLOAT;
      } else {
        type3 = gl.UNSIGNED_INT;
      }
    }
    if (this.useStencil) {
      format = gl.DEPTH_STENCIL;
    } else {
      format = gl.DEPTH_COMPONENT;
    }
    if (this.useStencil) {
      if (this.depthFormat === FLOAT) {
        internalFormat = gl.DEPTH32F_STENCIL8;
      } else if (this.renderer.webglVersion === WEBGL2) {
        internalFormat = gl.DEPTH24_STENCIL8;
      } else {
        internalFormat = gl.DEPTH_STENCIL;
      }
    } else if (this.renderer.webglVersion === WEBGL2) {
      if (this.depthFormat === FLOAT) {
        internalFormat = gl.DEPTH_COMPONENT32F;
      } else {
        internalFormat = gl.DEPTH_COMPONENT24;
      }
    } else {
      internalFormat = gl.DEPTH_COMPONENT;
    }
    return { internalFormat, format, type: type3 };
  }
  /**
   * A method that will be called when recreating textures. If the framebuffer
   * is auto-sized, it will update its width, height, and density properties.
   *
   * @private
   */
  _updateSize() {
    if (this._autoSized) {
      this.width = this.renderer.width;
      this.height = this.renderer.height;
      this.density = this.renderer._pixelDensity;
    }
  }
  /**
   * Called when the canvas that the framebuffer is attached to resizes. If the
   * framebuffer is auto-sized, it will update its textures to match the new
   * size.
   *
   * @private
   */
  _canvasSizeChanged() {
    if (this._autoSized) {
      this._handleResize();
    }
  }
  /**
   * Called when the size of the framebuffer has changed (either by being
   * manually updated or from auto-size updates when its canvas changes size.)
   * Old textures and renderbuffers will be deleted, and then recreated with the
   * new size.
   *
   * @private
   */
  _handleResize() {
    const oldColor = this.color;
    const oldDepth = this.depth;
    const oldColorRenderbuffer = this.colorRenderbuffer;
    const oldDepthRenderbuffer = this.depthRenderbuffer;
    this._deleteTexture(oldColor);
    if (oldDepth) this._deleteTexture(oldDepth);
    const gl = this.gl;
    if (oldColorRenderbuffer) gl.deleteRenderbuffer(oldColorRenderbuffer);
    if (oldDepthRenderbuffer) gl.deleteRenderbuffer(oldDepthRenderbuffer);
    this._recreateTextures();
    this.defaultCamera._resize();
  }
  /**
   * Creates a new
   * <a href="#/p5.Camera">p5.Camera</a> object to use with the framebuffer.
   *
   * The new camera is initialized with a default position `(0, 0, 800)` and a
   * default perspective projection. Its properties can be controlled with
   * <a href="#/p5.Camera">p5.Camera</a> methods such as `myCamera.lookAt(0, 0, 0)`.
   *
   * Framebuffer cameras should be created between calls to
   * <a href="#/p5.Framebuffer/begin">myBuffer.begin()</a> and
   * <a href="#/p5.Framebuffer/end">myBuffer.end()</a> like so:
   *
   * ```js
   * let myCamera;
   *
   * myBuffer.begin();
   *
   * // Create the camera for the framebuffer.
   * myCamera = myBuffer.createCamera();
   *
   * myBuffer.end();
   * ```
   *
   * Calling <a href="#/p5/setCamera">setCamera()</a> updates the
   * framebuffer's projection using the camera.
   * <a href="#/p5/resetMatrix">resetMatrix()</a> must also be called for the
   * view to change properly:
   *
   * ```js
   * myBuffer.begin();
   *
   * // Set the camera for the framebuffer.
   * setCamera(myCamera);
   *
   * // Reset all transformations.
   * resetMatrix();
   *
   * // Draw stuff...
   *
   * myBuffer.end();
   * ```
   *
   * @returns {p5.Camera} new camera.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to toggle between cameras.
   *
   * let myBuffer;
   * let cam1;
   * let cam2;
   * let usingCam1 = true;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Framebuffer object.
   *   myBuffer = createFramebuffer();
   *
   *   // Create the cameras between begin() and end().
   *   myBuffer.begin();
   *
   *   // Create the first camera.
   *   // Keep its default settings.
   *   cam1 = myBuffer.createCamera();
   *
   *   // Create the second camera.
   *   // Place it at the top-left.
   *   // Point it at the origin.
   *   cam2 = myBuffer.createCamera();
   *   cam2.setPosition(400, -400, 800);
   *   cam2.lookAt(0, 0, 0);
   *
   *   myBuffer.end();
   *
   *   describe(
   *     'A white cube on a gray background. The camera toggles between frontal and aerial views when the user double-clicks.'
   *   );
   * }
   *
   * function draw() {
   *   // Draw to the p5.Framebuffer object.
   *   myBuffer.begin();
   *   background(200);
   *
   *   // Set the camera.
   *   if (usingCam1 === true) {
   *     setCamera(cam1);
   *   } else {
   *     setCamera(cam2);
   *   }
   *
   *   // Reset all transformations.
   *   resetMatrix();
   *
   *   // Draw the box.
   *   box();
   *
   *   myBuffer.end();
   *
   *   // Display the p5.Framebuffer object.
   *   image(myBuffer, -50, -50);
   * }
   *
   * // Toggle the current camera when the user double-clicks.
   * function doubleClicked() {
   *   if (usingCam1 === true) {
   *     usingCam1 = false;
   *   } else {
   *     usingCam1 = true;
   *   }
   * }
   * </code>
   * </div>
   */
  createCamera() {
    const cam = new FramebufferCamera(this);
    cam._computeCameraDefaultSettings();
    cam._setDefaultCamera();
    return cam;
  }
  /**
   * Given a raw texture wrapper, delete its stored texture from WebGL memory,
   * and remove it from p5's list of active textures.
   *
   * @param {p5.FramebufferTexture} texture
   * @private
   */
  _deleteTexture(texture2) {
    const gl = this.gl;
    gl.deleteTexture(texture2.rawTexture());
    this.renderer.textures.delete(texture2);
  }
  /**
   * Deletes the framebuffer from GPU memory.
   *
   * Calling `myBuffer.remove()` frees the GPU memory used by the framebuffer.
   * The framebuffer also uses a bit of memory on the CPU which can be freed
   * like so:
   *
   * ```js
   * // Delete the framebuffer from GPU memory.
   * myBuffer.remove();
   *
   * // Delete the framebuffer from CPU memory.
   * myBuffer = undefined;
   * ```
   *
   * Note: All variables that reference the framebuffer must be assigned
   * the value `undefined` to delete the framebuffer from CPU memory. If any
   * variable still refers to the framebuffer, then it won't be garbage
   * collected.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to remove the p5.Framebuffer object.
   *
   * let myBuffer;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create an options object.
   *   let options = { width: 60, height: 60 };
   *
   *   // Create a p5.Framebuffer object and
   *   // configure it using options.
   *   myBuffer = createFramebuffer(options);
   *
   *   describe('A white circle at the center of a dark gray square disappears when the user double-clicks.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Display the p5.Framebuffer object if
   *   // it's available.
   *   if (myBuffer) {
   *     // Draw to the p5.Framebuffer object.
   *     myBuffer.begin();
   *     background(100);
   *     circle(0, 0, 20);
   *     myBuffer.end();
   *
   *     image(myBuffer, -30, -30);
   *   }
   * }
   *
   * // Remove the p5.Framebuffer object when the
   * // the user double-clicks.
   * function doubleClicked() {
   *   // Delete the framebuffer from GPU memory.
   *   myBuffer.remove();
   *
   *   // Delete the framebuffer from CPU memory.
   *   myBuffer = undefined;
   * }
   * </code>
   * </div>
   */
  remove() {
    const gl = this.gl;
    this._deleteTexture(this.color);
    if (this.depth) this._deleteTexture(this.depth);
    gl.deleteFramebuffer(this.framebuffer);
    if (this.aaFramebuffer) {
      gl.deleteFramebuffer(this.aaFramebuffer);
    }
    if (this.depthRenderbuffer) {
      gl.deleteRenderbuffer(this.depthRenderbuffer);
    }
    if (this.colorRenderbuffer) {
      gl.deleteRenderbuffer(this.colorRenderbuffer);
    }
    this.renderer.framebuffers.delete(this);
  }
  /**
   * Begins drawing shapes to the framebuffer.
   *
   * `myBuffer.begin()` and <a href="#/p5.Framebuffer/end">myBuffer.end()</a>
   * allow shapes to be drawn to the framebuffer. `myBuffer.begin()` begins
   * drawing to the framebuffer and
   * <a href="#/p5.Framebuffer/end">myBuffer.end()</a> stops drawing to the
   * framebuffer. Changes won't be visible until the framebuffer is displayed
   * as an image or texture.
   *
   * @example
   * <div>
   * <code>
   * let myBuffer;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Framebuffer object.
   *   myBuffer = createFramebuffer();
   *
   *   describe('An empty gray canvas. The canvas gets darker and a rotating, multicolor torus appears while the user presses and holds the mouse.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Start drawing to the p5.Framebuffer object.
   *   myBuffer.begin();
   *
   *   background(50);
   *   rotateY(frameCount * 0.01);
   *   normalMaterial();
   *   torus(30);
   *
   *   // Stop drawing to the p5.Framebuffer object.
   *   myBuffer.end();
   *
   *   // Display the p5.Framebuffer object while
   *   // the user presses the mouse.
   *   if (mouseIsPressed === true) {
   *     image(myBuffer, -50, -50);
   *   }
   * }
   * </code>
   * </div>
   */
  begin() {
    this.prevFramebuffer = this.renderer.activeFramebuffer();
    if (this.prevFramebuffer) {
      this.prevFramebuffer._beforeEnd();
    }
    this.renderer.activeFramebuffers.push(this);
    this._beforeBegin();
    this.renderer.push();
    this.renderer.states.setValue("curCamera", this.defaultCamera);
    this.renderer.states.setValue("uPMatrix", this.renderer.states.uPMatrix.clone());
    this.renderer.states.uPMatrix.set(this.defaultCamera.projMatrix);
    this.renderer.states.setValue("uViewMatrix", this.renderer.states.uViewMatrix.clone());
    this.renderer.states.uViewMatrix.set(this.defaultCamera.cameraMatrix);
    this.renderer.resetMatrix();
    this.renderer.states.uViewMatrix.set(this.renderer.states.curCamera.cameraMatrix);
    this.renderer.states.uModelMatrix.reset();
    this.renderer._applyStencilTestIfClipping();
  }
  /**
   * When making a p5.Framebuffer active so that it may be drawn to, this method
   * returns the underlying WebGL framebuffer that needs to be active to
   * support this. Antialiased framebuffers first write to a multisampled
   * renderbuffer, while other framebuffers can write directly to their main
   * framebuffers.
   *
   * @private
   */
  _framebufferToBind() {
    if (this.antialias) {
      return this.aaFramebuffer;
    } else {
      return this.framebuffer;
    }
  }
  /**
   * Ensure all readable textures are up-to-date.
   * @private
   * @property {'colorTexutre'|'depthTexture'} property The property to update
   */
  _update(property) {
    if (this.dirty[property] && this.antialias) {
      const gl = this.gl;
      gl.bindFramebuffer(gl.READ_FRAMEBUFFER, this.aaFramebuffer);
      gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, this.framebuffer);
      const partsToCopy = {
        colorTexture: [gl.COLOR_BUFFER_BIT, this.colorP5Texture.glMagFilter]
      };
      if (this.useDepth) {
        partsToCopy.depthTexture = [
          gl.DEPTH_BUFFER_BIT,
          this.depthP5Texture.glMagFilter
        ];
      }
      const [flag, filter] = partsToCopy[property];
      gl.blitFramebuffer(
        0,
        0,
        this.width * this.density,
        this.height * this.density,
        0,
        0,
        this.width * this.density,
        this.height * this.density,
        flag,
        filter
      );
      this.dirty[property] = false;
      const activeFbo = this.renderer.activeFramebuffer();
      if (activeFbo) {
        gl.bindFramebuffer(gl.FRAMEBUFFER, activeFbo._framebufferToBind());
      } else {
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
    }
  }
  /**
   * Ensures that the framebuffer is ready to be drawn to
   *
   * @private
   */
  _beforeBegin() {
    const gl = this.gl;
    gl.bindFramebuffer(gl.FRAMEBUFFER, this._framebufferToBind());
    this.renderer.viewport(
      this.width * this.density,
      this.height * this.density
    );
  }
  /**
   * Ensures that the framebuffer is ready to be read by other framebuffers.
   *
   * @private
   */
  _beforeEnd() {
    if (this.antialias) {
      this.dirty = { colorTexture: true, depthTexture: true };
    }
  }
  /**
   * Stops drawing shapes to the framebuffer.
   *
   * <a href="#/p5.Framebuffer/begin">myBuffer.begin()</a> and `myBuffer.end()`
   * allow shapes to be drawn to the framebuffer.
   * <a href="#/p5.Framebuffer/begin">myBuffer.begin()</a> begins drawing to
   * the framebuffer and `myBuffer.end()` stops drawing to the framebuffer.
   * Changes won't be visible until the framebuffer is displayed as an image
   * or texture.
   *
   * @example
   * <div>
   * <code>
   * let myBuffer;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Framebuffer object.
   *   myBuffer = createFramebuffer();
   *
   *   describe('An empty gray canvas. The canvas gets darker and a rotating, multicolor torus appears while the user presses and holds the mouse.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Start drawing to the p5.Framebuffer object.
   *   myBuffer.begin();
   *
   *   background(50);
   *   rotateY(frameCount * 0.01);
   *   normalMaterial();
   *   torus(30);
   *
   *   // Stop drawing to the p5.Framebuffer object.
   *   myBuffer.end();
   *
   *   // Display the p5.Framebuffer object while
   *   // the user presses the mouse.
   *   if (mouseIsPressed === true) {
   *     image(myBuffer, -50, -50);
   *   }
   * }
   * </code>
   * </div>
   */
  end() {
    const gl = this.gl;
    this.renderer.pop();
    const fbo = this.renderer.activeFramebuffers.pop();
    if (fbo !== this) {
      throw new Error("It looks like you've called end() while another Framebuffer is active.");
    }
    this._beforeEnd();
    if (this.prevFramebuffer) {
      this.prevFramebuffer._beforeBegin();
    } else {
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      this.renderer.viewport(
        this.renderer._origViewport.width,
        this.renderer._origViewport.height
      );
    }
    this.renderer._applyStencilTestIfClipping();
  }
  /**
   * Draws to the framebuffer by calling a function that contains drawing
   * instructions.
   *
   * The parameter, `callback`, is a function with the drawing instructions
   * for the framebuffer. For example, calling `myBuffer.draw(myFunction)`
   * will call a function named `myFunction()` to draw to the framebuffer.
   * Doing so has the same effect as the following:
   *
   * ```js
   * myBuffer.begin();
   * myFunction();
   * myBuffer.end();
   * ```
   *
   * @param {Function} callback function that draws to the framebuffer.
   *
   * @example
   * <div>
   * <code>
   * // Click the canvas to display the framebuffer.
   *
   * let myBuffer;
   *
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   // Create a p5.Framebuffer object.
   *   myBuffer = createFramebuffer();
   *
   *   describe('An empty gray canvas. The canvas gets darker and a rotating, multicolor torus appears while the user presses and holds the mouse.');
   * }
   *
   * function draw() {
   *   background(200);
   *
   *   // Draw to the p5.Framebuffer object.
   *   myBuffer.draw(bagel);
   *
   *   // Display the p5.Framebuffer object while
   *   // the user presses the mouse.
   *   if (mouseIsPressed === true) {
   *     image(myBuffer, -50, -50);
   *   }
   * }
   *
   * // Draw a rotating, multicolor torus.
   * function bagel() {
   *   background(50);
   *   rotateY(frameCount * 0.01);
   *   normalMaterial();
   *   torus(30);
   * }
   * </code>
   * </div>
   */
  draw(callback) {
    this.begin();
    callback();
    this.end();
  }
  /**
   * Loads the current value of each pixel in the framebuffer into its
   * <a href="#/p5.Framebuffer/pixels">pixels</a> array.
   *
   * `myBuffer.loadPixels()` must be called before reading from or writing to
   * <a href="#/p5.Framebuffer/pixels">myBuffer.pixels</a>.
   *
   * @method loadPixels
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Create a p5.Framebuffer object.
   *   let myBuffer = createFramebuffer();
   *
   *   // Load the pixels array.
   *   myBuffer.loadPixels();
   *
   *   // Get the number of pixels in the
   *   // top half of the framebuffer.
   *   let numPixels = myBuffer.pixels.length / 2;
   *
   *   // Set the framebuffer's top half to pink.
   *   for (let i = 0; i < numPixels; i += 4) {
   *     myBuffer.pixels[i] = 255;
   *     myBuffer.pixels[i + 1] = 102;
   *     myBuffer.pixels[i + 2] = 204;
   *     myBuffer.pixels[i + 3] = 255;
   *   }
   *
   *   // Update the pixels array.
   *   myBuffer.updatePixels();
   *
   *   // Draw the p5.Framebuffer object to the canvas.
   *   image(myBuffer, -50, -50);
   *
   *   describe('A pink rectangle above a gray rectangle.');
   * }
   * </code>
   * </div>
   */
  loadPixels() {
    this._update("colorTexture");
    const gl = this.gl;
    const prevFramebuffer = this.renderer.activeFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
    const colorFormat = this._glColorFormat();
    this.pixels = readPixelsWebGL(
      this.pixels,
      gl,
      this.framebuffer,
      0,
      0,
      this.width * this.density,
      this.height * this.density,
      colorFormat.format,
      colorFormat.type
    );
    if (prevFramebuffer) {
      gl.bindFramebuffer(gl.FRAMEBUFFER, prevFramebuffer._framebufferToBind());
    } else {
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    }
  }
  /**
   * Gets a pixel or a region of pixels from the framebuffer.
   *
   * `myBuffer.get()` is easy to use but it's not as fast as
   * <a href="#/p5.Framebuffer/pixels">myBuffer.pixels</a>. Use
   * <a href="#/p5.Framebuffer/pixels">myBuffer.pixels</a> to read many pixel
   * values.
   *
   * The version of `myBuffer.get()` with no parameters returns the entire
   * framebuffer as a a <a href="#/p5.Image">p5.Image</a> object.
   *
   * The version of `myBuffer.get()` with two parameters interprets them as
   * coordinates. It returns an array with the `[R, G, B, A]` values of the
   * pixel at the given point.
   *
   * The version of `myBuffer.get()` with four parameters interprets them as
   * coordinates and dimensions. It returns a subsection of the framebuffer as
   * a <a href="#/p5.Image">p5.Image</a> object. The first two parameters are
   * the coordinates for the upper-left corner of the subsection. The last two
   * parameters are the width and height of the subsection.
   *
   * @param  {Number} x x-coordinate of the pixel. Defaults to 0.
   * @param  {Number} y y-coordinate of the pixel. Defaults to 0.
   * @param  {Number} w width of the subsection to be returned.
   * @param  {Number} h height of the subsection to be returned.
   * @return {p5.Image} subsection as a <a href="#/p5.Image">p5.Image</a> object.
   */
  /**
   * @return {p5.Image} entire framebuffer as a <a href="#/p5.Image">p5.Image</a> object.
   */
  /**
   * @param  {Number} x
   * @param  {Number} y
   * @return {Number[]}  color of the pixel at `(x, y)` as an array of color values `[R, G, B, A]`.
   */
  get(x, y, w, h) {
    this._update("colorTexture");
    const colorFormat = this._glColorFormat();
    if (x === void 0 && y === void 0) {
      x = 0;
      y = 0;
      w = this.width;
      h = this.height;
    } else if (w === void 0 && h === void 0) {
      if (x < 0 || y < 0 || x >= this.width || y >= this.height) {
        console.warn(
          "The x and y values passed to p5.Framebuffer.get are outside of its range and will be clamped."
        );
        x = constrain2(x, 0, this.width - 1);
        y = constrain2(y, 0, this.height - 1);
      }
      return readPixelWebGL(
        this.gl,
        this.framebuffer,
        x * this.density,
        y * this.density,
        colorFormat.format,
        colorFormat.type
      );
    }
    x = constrain2(x, 0, this.width - 1);
    y = constrain2(y, 0, this.height - 1);
    w = constrain2(w, 1, this.width - x);
    h = constrain2(h, 1, this.height - y);
    const rawData = readPixelsWebGL(
      void 0,
      this.gl,
      this.framebuffer,
      x * this.density,
      y * this.density,
      w * this.density,
      h * this.density,
      colorFormat.format,
      colorFormat.type
    );
    const fullData = new Uint8ClampedArray(
      w * h * this.density * this.density * 4
    );
    fullData.fill(255);
    const channels = colorFormat.type === this.gl.RGB ? 3 : 4;
    for (let y2 = 0; y2 < h * this.density; y2++) {
      for (let x2 = 0; x2 < w * this.density; x2++) {
        for (let channel = 0; channel < 4; channel++) {
          const idx = (y2 * w * this.density + x2) * 4 + channel;
          if (channel < channels) {
            const rawDataIdx = channels === 4 ? idx : (y2 * w * this.density + x2) * channels + channel;
            fullData[idx] = rawData[rawDataIdx];
          }
        }
      }
    }
    const region = new Image(w * this.density, h * this.density);
    region.imageData = region.canvas.getContext("2d").createImageData(
      region.width,
      region.height
    );
    region.imageData.data.set(fullData);
    region.pixels = region.imageData.data;
    region.updatePixels();
    if (this.density !== 1) {
      region.resize(w, h);
    }
    return region;
  }
  /**
   * Updates the framebuffer with the RGBA values in the
   * <a href="#/p5.Framebuffer/pixels">pixels</a> array.
   *
   * `myBuffer.updatePixels()` only needs to be called after changing values
   * in the <a href="#/p5.Framebuffer/pixels">myBuffer.pixels</a> array. Such
   * changes can be made directly after calling
   * <a href="#/p5.Framebuffer/loadPixels">myBuffer.loadPixels()</a>.
   *
   * @method updatePixels
   *
   * @example
   * <div>
   * <code>
   * function setup() {
   *   createCanvas(100, 100, WEBGL);
   *
   *   background(200);
   *
   *   // Create a p5.Framebuffer object.
   *   let myBuffer = createFramebuffer();
   *
   *   // Load the pixels array.
   *   myBuffer.loadPixels();
   *
   *   // Get the number of pixels in the
   *   // top half of the framebuffer.
   *   let numPixels = myBuffer.pixels.length / 2;
   *
   *   // Set the framebuffer's top half to pink.
   *   for (let i = 0; i < numPixels; i += 4) {
   *     myBuffer.pixels[i] = 255;
   *     myBuffer.pixels[i + 1] = 102;
   *     myBuffer.pixels[i + 2] = 204;
   *     myBuffer.pixels[i + 3] = 255;
   *   }
   *
   *   // Update the pixels array.
   *   myBuffer.updatePixels();
   *
   *   // Draw the p5.Framebuffer object to the canvas.
   *   image(myBuffer, -50, -50);
   *
   *   describe('A pink rectangle above a gray rectangle.');
   * }
   * </code>
   * </div>
   */
  updatePixels() {
    const gl = this.gl;
    this.colorP5Texture.bindTexture();
    const colorFormat = this._glColorFormat();
    const channels = colorFormat.format === gl.RGBA ? 4 : 3;
    const len = this.width * this.height * this.density * this.density * channels;
    const TypedArrayClass = colorFormat.type === gl.UNSIGNED_BYTE ? Uint8Array : Float32Array;
    if (!(this.pixels instanceof TypedArrayClass) || this.pixels.length !== len) {
      throw new Error(
        "The pixels array has not been set correctly. Please call loadPixels() before updatePixels()."
      );
    }
    gl.texImage2D(
      gl.TEXTURE_2D,
      0,
      colorFormat.internalFormat,
      this.width * this.density,
      this.height * this.density,
      0,
      colorFormat.format,
      colorFormat.type,
      this.pixels
    );
    this.colorP5Texture.unbindTexture();
    this.dirty.colorTexture = false;
    const prevFramebuffer = this.renderer.activeFramebuffer();
    if (this.antialias) {
      this.begin();
      this.renderer.push();
      this.renderer.states.setValue("imageMode", CORNER);
      this.renderer.setCamera(this.filterCamera);
      this.renderer.resetMatrix();
      this.renderer.states.setValue("strokeColor", null);
      this.renderer.clear();
      this.renderer._drawingFilter = true;
      this.renderer.image(
        this,
        0,
        0,
        this.width,
        this.height,
        -this.renderer.width / 2,
        -this.renderer.height / 2,
        this.renderer.width,
        this.renderer.height
      );
      this.renderer._drawingFilter = false;
      this.renderer.pop();
      if (this.useDepth) {
        gl.clearDepth(1);
        gl.clear(gl.DEPTH_BUFFER_BIT);
      }
      this.end();
    } else {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffer);
      if (this.useDepth) {
        gl.clearDepth(1);
        gl.clear(gl.DEPTH_BUFFER_BIT);
      }
      if (prevFramebuffer) {
        gl.bindFramebuffer(
          gl.FRAMEBUFFER,
          prevFramebuffer._framebufferToBind()
        );
      } else {
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      }
    }
  }
};
function framebuffer(p53, fn2) {
  p53.FramebufferCamera = FramebufferCamera;
  p53.FramebufferTexture = FramebufferTexture;
  p53.Framebuffer = Framebuffer;
}
if (typeof p5 !== "undefined") {
  framebuffer(p5, p5.prototype);
}
var renderers;
function rendering(p53, fn2) {
  renderers = p53.renderers = {};
  fn2.createCanvas = function(w, h, renderer2, ...args) {
    let selectedRenderer = P2D;
    if (Reflect.ownKeys(renderers).includes(renderer2)) {
      selectedRenderer = renderer2;
    } else {
      args.unshift(renderer2);
    }
    if (this._renderer) this._renderer.remove();
    this._renderer = new renderers[selectedRenderer](this, w, h, true, ...args);
    this._defaultGraphicsCreated = true;
    this._elements.push(this._renderer);
    this._renderer._applyDefaults();
    if (!Object.hasOwn(this, "pixels")) {
      Object.defineProperty(this, "pixels", {
        get() {
          var _a2;
          return (_a2 = this._renderer) == null ? void 0 : _a2.pixels;
        }
      });
    }
    return this._renderer;
  };
  fn2.resizeCanvas = function(w, h, noRedraw) {
    if (this._renderer) {
      this._renderer.resize(w, h);
      if (!noRedraw) {
        this.redraw();
      }
    }
    if (this._addAccsOutput()) {
      this._updateAccsOutput();
    }
  };
  fn2.noCanvas = function() {
    if (this.canvas) {
      this.canvas.parentNode.removeChild(this.canvas);
    }
  };
  fn2.createGraphics = function(w, h, ...args) {
    if (args[0] instanceof HTMLCanvasElement) {
      args[1] = args[0];
      args[0] = P2D;
    }
    return new p53.Graphics(w, h, args[0], this, args[1]);
  };
  fn2.createFramebuffer = function(options2) {
    return new Framebuffer(this._renderer, options2);
  };
  fn2.clearDepth = function(depth) {
    this._assert3d("clearDepth");
    this._renderer.clearDepth(depth);
  };
}
if (typeof p5 !== "undefined") {
  rendering(p5, p5.prototype);
}

// node_modules/p5/dist/image/filterRenderer2D.js
var import_omggif = __toESM(require_omggif());
var import_file_saver4 = __toESM(require_FileSaver());
var import_libtess2 = __toESM(require_libtess_min());
var FilterRenderer2D = class {
  /**
   * Creates a new FilterRenderer2D instance.
   * @param {p5} pInst - The p5.js instance.
   */
  constructor(pInst) {
    this.pInst = pInst;
    this.canvas = document.createElement("canvas");
    this.canvas.width = pInst.width;
    this.canvas.height = pInst.height;
    let webglVersion = WEBGL2;
    this.gl = this.canvas.getContext("webgl2");
    if (!this.gl) {
      webglVersion = WEBGL;
      this.gl = this.canvas.getContext("webgl");
    }
    if (!this.gl) {
      console.error("WebGL not supported, cannot apply filter.");
      return;
    }
    this._renderer = {
      GL: this.gl,
      registerEnabled: /* @__PURE__ */ new Set(),
      _curShader: null,
      _emptyTexture: null,
      webglVersion,
      states: {
        textureWrapX: this.gl.CLAMP_TO_EDGE,
        textureWrapY: this.gl.CLAMP_TO_EDGE
      },
      _arraysEqual: (a2, b3) => JSON.stringify(a2) === JSON.stringify(b3),
      _getEmptyTexture: () => {
        if (!this._emptyTexture) {
          const im = new Image(1, 1);
          im.set(0, 0, 255);
          this._emptyTexture = new Texture(this._renderer, im);
        }
        return this._emptyTexture;
      }
    };
    this._baseFilterShader = void 0;
    this.filterShaderSources = {
      [BLUR]: filterBlurFrag,
      [INVERT]: filterInvertFrag,
      [THRESHOLD]: filterThresholdFrag,
      [ERODE]: filterErodeFrag,
      [GRAY]: filterGrayFrag,
      [DILATE]: filterDilateFrag,
      [POSTERIZE]: filterPosterizeFrag,
      [OPAQUE]: filterOpaqueFrag
    };
    this.filterShaders = {};
    this.operation = null;
    this.filterParameter = 1;
    this.customShader = null;
    this._shader = null;
    this.vertexBuffer = this.gl.createBuffer();
    this.texcoordBuffer = this.gl.createBuffer();
    this.vertices = new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]);
    this.texcoords = new Float32Array([0, 1, 1, 1, 0, 0, 1, 0]);
    this._bindBufferData(this.vertexBuffer, this.gl.ARRAY_BUFFER, this.vertices);
    this._bindBufferData(this.texcoordBuffer, this.gl.ARRAY_BUFFER, this.texcoords);
  }
  _webGL2CompatibilityPrefix(shaderType, floatPrecision) {
    let code = "";
    if (this._renderer.webglVersion === WEBGL2) {
      code += "#version 300 es\n#define WEBGL2\n";
    }
    if (shaderType === "vert") {
      code += "#define VERTEX_SHADER\n";
    } else if (shaderType === "frag") {
      code += "#define FRAGMENT_SHADER\n";
    }
    if (floatPrecision) {
      code += `precision ${floatPrecision} float;
`;
    }
    return code;
  }
  baseFilterShader() {
    if (!this._baseFilterShader) {
      this._baseFilterShader = new Shader(
        this._renderer,
        this._webGL2CompatibilityPrefix("vert", "highp") + webgl2CompatibilityShader + filterBaseVert,
        this._webGL2CompatibilityPrefix("frag", "highp") + webgl2CompatibilityShader + filterBaseFrag,
        {
          vertex: {},
          fragment: {
            "vec4 getColor": `(FilterInputs inputs, in sampler2D canvasContent) {
                return getTexture(canvasContent, inputs.texCoord);
              }`
          }
        }
      );
    }
    return this._baseFilterShader;
  }
  /**
   * Set the current filter operation and parameter. If a customShader is provided,
   * that overrides the operation-based shader.
   * @param {String} operation - The filter operation type (e.g., constants.BLUR).
   * @param {Number} filterParameter - The strength of the filter.
   * @param {p5.Shader} customShader - Optional custom shader.
   */
  setOperation(operation, filterParameter, customShader = null) {
    this.operation = operation;
    this.filterParameter = filterParameter;
    let useDefaultParam = operation in filterParamDefaults && filterParameter === void 0;
    if (useDefaultParam) {
      this.filterParameter = filterParamDefaults[operation];
    }
    this.customShader = customShader;
    this._initializeShader();
  }
  /**
   * Initializes or retrieves the shader program for the current operation.
   * If a customShader is provided, that is used.
   * Otherwise, returns a cached shader if available, or creates a new one, caches it, and sets it as current.
   */
  _initializeShader() {
    if (this.customShader) {
      this._shader = this.customShader;
      return;
    }
    if (!this.operation) {
      console.error("No operation set for FilterRenderer2D, cannot initialize shader.");
      return;
    }
    if (this.filterShaders[this.operation]) {
      this._shader = this.filterShaders[this.operation];
      return;
    }
    const fragShaderSrc = this.filterShaderSources[this.operation];
    if (!fragShaderSrc) {
      console.error("No shader available for this operation:", this.operation);
      return;
    }
    const newShader = new Shader(this._renderer, filterShaderVert, fragShaderSrc);
    this.filterShaders[this.operation] = newShader;
    this._shader = newShader;
  }
  /**
   * Binds a buffer to the drawing context
   * when passed more than two arguments it also updates or initializes
   * the data associated with the buffer
   */
  _bindBufferData(buffer, target, values) {
    const gl = this.gl;
    gl.bindBuffer(target, buffer);
    gl.bufferData(target, values, gl.STATIC_DRAW);
  }
  get canvasTexture() {
    if (!this._canvasTexture) {
      this._canvasTexture = new Texture(this._renderer, this.pInst.wrappedElt);
    }
    return this._canvasTexture;
  }
  /**
   * Prepares and runs the full-screen quad draw call.
   */
  _renderPass() {
    const gl = this.gl;
    this._shader.bindShader();
    const pixelDensity = this.pInst.pixelDensity ? this.pInst.pixelDensity() : 1;
    const texelSize = [
      1 / (this.pInst.width * pixelDensity),
      1 / (this.pInst.height * pixelDensity)
    ];
    const canvasTexture = this.canvasTexture;
    this._shader.setUniform("tex0", canvasTexture);
    this._shader.setUniform("texelSize", texelSize);
    this._shader.setUniform("canvasSize", [this.pInst.width, this.pInst.height]);
    this._shader.setUniform("radius", Math.max(1, this.filterParameter));
    this._shader.setUniform("filterParameter", this.filterParameter);
    this._shader.setDefaultUniforms();
    this.pInst.states.setValue("rectMode", CORNER);
    this.pInst.states.setValue("imageMode", CORNER);
    this.pInst.blendMode(BLEND);
    this.pInst.resetMatrix();
    const identityMatrix = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    this._shader.setUniform("uModelViewMatrix", identityMatrix);
    this._shader.setUniform("uProjectionMatrix", identityMatrix);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
    this._shader.enableAttrib(this._shader.attributes.aPosition, 2);
    gl.bindBuffer(gl.ARRAY_BUFFER, this.texcoordBuffer);
    this._shader.enableAttrib(this._shader.attributes.aTexCoord, 2);
    this._shader.bindTextures();
    this._shader.disableRemainingAttributes();
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    this._shader.unbindShader();
  }
  /**
   * Applies the current filter operation. If the filter requires multiple passes (e.g. blur),
   * it handles those internally. Make sure setOperation() has been called before applyFilter().
   */
  applyFilter() {
    if (!this._shader) {
      console.error("Cannot apply filter: shader not initialized.");
      return;
    }
    this.pInst.push();
    this.pInst.resetMatrix();
    if (this.operation === BLUR && !this.customShader) {
      this._shader.setUniform("direction", [1, 0]);
      this._renderPass();
      this.pInst.clear();
      this.pInst.drawingContext.drawImage(this.canvas, 0, 0, this.pInst.width, this.pInst.height);
      this._shader.setUniform("direction", [0, 1]);
      this._renderPass();
      this.pInst.clear();
      this.pInst.drawingContext.drawImage(this.canvas, 0, 0, this.pInst.width, this.pInst.height);
    } else {
      this._renderPass();
      this.pInst.clear();
      this.pInst.blendMode(BLEND);
      this.pInst.drawingContext.drawImage(this.canvas, 0, 0, this.pInst.width, this.pInst.height);
    }
    this.pInst.pop();
  }
};

// node_modules/p5/dist/main-B3Z63C6j.js
var styleEmpty = "rgba(0,0,0,0)";
var Renderer2D = class extends Renderer {
  constructor(pInst, w, h, isMainCanvas, elt, attributes2 = {}) {
    super(pInst, w, h, isMainCanvas);
    this.canvas = this.elt = elt || document.createElement("canvas");
    if (isMainCanvas) {
      this._pInst._curElement = this;
      this._pInst.canvas = this.canvas;
    } else {
      this.canvas.style.display = "none";
    }
    this.elt.id = "defaultCanvas0";
    this.elt.classList.add("p5Canvas");
    for (const p2 of Object.getOwnPropertyNames(Element.prototype)) {
      if (p2 !== "constructor" && p2[0] !== "_") {
        Object.defineProperty(this, p2, {
          get() {
            return this.wrappedElt[p2];
          }
        });
      }
    }
    this.elt.width = w * this._pixelDensity;
    this.elt.height = h * this._pixelDensity;
    this.elt.style.width = `${w}px`;
    this.elt.style.height = `${h}px`;
    if (this._pInst._userNode) {
      this._pInst._userNode.appendChild(this.elt);
    } else {
      if (document.getElementsByTagName("main").length === 0) {
        let m3 = document.createElement("main");
        document.body.appendChild(m3);
      }
      document.getElementsByTagName("main")[0].appendChild(this.elt);
    }
    this.drawingContext = this.canvas.getContext("2d", attributes2);
    if (attributes2.colorSpace === "display-p3") {
      this.states.colorMode = RGBHDR;
    }
    this.scale(this._pixelDensity, this._pixelDensity);
    if (!this.filterRenderer) {
      this.filterRenderer = new FilterRenderer2D(this);
    }
    this.wrappedElt = new Element(this.elt, this._pInst);
    this.clipPath = null;
  }
  remove() {
    this.wrappedElt.remove();
    this.wrappedElt = null;
    this.canvas = null;
    this.elt = null;
  }
  getFilterGraphicsLayer() {
    if (!this.filterGraphicsLayer) {
      const pInst = this._pInst;
      this.filterGraphicsLayer = new Graphics(
        this.width,
        this.height,
        WEBGL,
        pInst
      );
    }
    if (this.filterGraphicsLayer.width !== this.width || this.filterGraphicsLayer.height !== this.height) {
      this.filterGraphicsLayer.resizeCanvas(this.width, this.height);
    }
    if (this.filterGraphicsLayer.pixelDensity() !== this._pInst.pixelDensity()) {
      this.filterGraphicsLayer.pixelDensity(this._pInst.pixelDensity());
    }
    return this.filterGraphicsLayer;
  }
  _applyDefaults() {
    this.states.setValue("_cachedFillStyle", void 0);
    this.states.setValue("_cachedStrokeStyle", void 0);
    this._cachedBlendMode = BLEND;
    this._setFill(_DEFAULT_FILL);
    this._setStroke(_DEFAULT_STROKE);
    this.drawingContext.lineCap = ROUND;
    this.drawingContext.font = "normal 12px sans-serif";
  }
  resize(w, h) {
    super.resize(w, h);
    const props = {};
    for (const key in this.drawingContext) {
      const val2 = this.drawingContext[key];
      if (typeof val2 !== "object" && typeof val2 !== "function") {
        props[key] = val2;
      }
    }
    this.canvas.width = w * this._pixelDensity;
    this.canvas.height = h * this._pixelDensity;
    this.canvas.style.width = `${w}px`;
    this.canvas.style.height = `${h}px`;
    this.drawingContext.scale(
      this._pixelDensity,
      this._pixelDensity
    );
    for (const savedKey in props) {
      try {
        this.drawingContext[savedKey] = props[savedKey];
      } catch (err2) {
      }
    }
  }
  //////////////////////////////////////////////
  // COLOR | Setting
  //////////////////////////////////////////////
  background(...args) {
    var _a2, _b2, _c2, _d;
    this.push();
    this.resetMatrix();
    if (args[0] instanceof Image) {
      if (args[1] >= 0) {
        const img = args[0];
        this.drawingContext.globalAlpha = args[1] / 255;
        this._pInst.image(img, 0, 0, this.width, this.height);
      } else {
        this._pInst.image(args[0], 0, 0, this.width, this.height);
      }
    } else {
      const color3 = this._pInst.color(...args);
      if ((_b2 = (_a2 = this._pInst)._addAccsOutput) == null ? void 0 : _b2.call(_a2)) {
        (_d = (_c2 = this._pInst)._accsBackground) == null ? void 0 : _d.call(_c2, color3._getRGBA([255, 255, 255, 255]));
      }
      const newFill = color3.toString();
      this._setFill(newFill);
      if (this._isErasing) {
        this.blendMode(this._cachedBlendMode);
      }
      this.drawingContext.fillRect(0, 0, this.width, this.height);
      if (this._isErasing) {
        this._pInst.erase();
      }
    }
    this.pop();
  }
  clear() {
    this.drawingContext.save();
    this.resetMatrix();
    this.drawingContext.clearRect(0, 0, this.width, this.height);
    this.drawingContext.restore();
  }
  fill(...args) {
    var _a2, _b2, _c2, _d;
    super.fill(...args);
    const color3 = this.states.fillColor;
    this._setFill(color3.toString());
    if ((_b2 = (_a2 = this._pInst)._addAccsOutput) == null ? void 0 : _b2.call(_a2)) {
      (_d = (_c2 = this._pInst)._accsCanvasColors) == null ? void 0 : _d.call(_c2, "fill", color3._getRGBA([255, 255, 255, 255]));
    }
  }
  stroke(...args) {
    var _a2, _b2, _c2, _d;
    super.stroke(...args);
    const color3 = this.states.strokeColor;
    this._setStroke(color3.toString());
    if ((_b2 = (_a2 = this._pInst)._addAccsOutput) == null ? void 0 : _b2.call(_a2)) {
      (_d = (_c2 = this._pInst)._accsCanvasColors) == null ? void 0 : _d.call(_c2, "stroke", color3._getRGBA([255, 255, 255, 255]));
    }
  }
  erase(opacityFill, opacityStroke) {
    if (!this._isErasing) {
      this.states.setValue("_cachedFillStyle", this.drawingContext.fillStyle);
      const newFill = this._pInst.color(255, opacityFill).toString();
      this.drawingContext.fillStyle = newFill;
      this.states.setValue("_cachedStrokeStyle", this.drawingContext.strokeStyle);
      const newStroke = this._pInst.color(255, opacityStroke).toString();
      this.drawingContext.strokeStyle = newStroke;
      const tempBlendMode = this._cachedBlendMode;
      this.blendMode(REMOVE);
      this._cachedBlendMode = tempBlendMode;
      this._isErasing = true;
    }
  }
  noErase() {
    if (this._isErasing) {
      this.drawingContext.fillStyle = this.states._cachedFillStyle;
      this.drawingContext.strokeStyle = this.states._cachedStrokeStyle;
      this.blendMode(this._cachedBlendMode);
      this._isErasing = false;
    }
  }
  drawShape(shape2) {
    const visitor = new PrimitiveToPath2DConverter({ strokeWeight: this.states.strokeWeight });
    shape2.accept(visitor);
    if (this._clipping) {
      this.clipPath.addPath(visitor.path);
      this.clipPath.closePath();
    } else {
      if (this.states.fillColor) {
        this.drawingContext.fill(visitor.path);
      }
      if (this.states.strokeColor) {
        this.drawingContext.stroke(visitor.path);
      }
    }
  }
  beginClip(options2 = {}) {
    super.beginClip(options2);
    this.states.setValue("_cachedFillStyle", this.drawingContext.fillStyle);
    const newFill = this._pInst.color(255, 0).toString();
    this.drawingContext.fillStyle = newFill;
    this.states.setValue("_cachedStrokeStyle", this.drawingContext.strokeStyle);
    const newStroke = this._pInst.color(255, 0).toString();
    this.drawingContext.strokeStyle = newStroke;
    const tempBlendMode = this._cachedBlendMode;
    this.blendMode(BLEND);
    this._cachedBlendMode = tempBlendMode;
    this.clipPath = new Path2D();
    if (this._clipInvert) {
      this.clipPath.moveTo(
        -2 * this.width,
        -2 * this.height
      );
      this.clipPath.lineTo(
        -2 * this.width,
        2 * this.height
      );
      this.clipPath.lineTo(
        2 * this.width,
        2 * this.height
      );
      this.clipPath.lineTo(
        2 * this.width,
        -2 * this.height
      );
      this.clipPath.closePath();
    }
  }
  endClip() {
    this.drawingContext.clip(this.clipPath);
    this.clipPath = null;
    super.endClip();
    this.drawingContext.fillStyle = this.states._cachedFillStyle;
    this.drawingContext.strokeStyle = this.states._cachedStrokeStyle;
    this.blendMode(this._cachedBlendMode);
  }
  //////////////////////////////////////////////
  // IMAGE | Loading & Displaying
  //////////////////////////////////////////////
  image(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
    let cnv;
    if (img.gifProperties) {
      img._animateGif(this._pInst);
    }
    try {
      if (img instanceof MediaElement) {
        img._ensureCanvas();
      }
      if (this.states.tint && img.canvas) {
        cnv = this._getTintedImageCanvas(img);
      }
      if (!cnv) {
        cnv = img.canvas || img.elt;
      }
      let s = 1;
      if (img.width && img.width > 0) {
        s = cnv.width / img.width;
      }
      if (this._isErasing) {
        this.blendMode(this._cachedBlendMode);
      }
      this.drawingContext.drawImage(
        cnv,
        s * sx,
        s * sy,
        s * sWidth,
        s * sHeight,
        dx,
        dy,
        dWidth,
        dHeight
      );
      if (this._isErasing) {
        this._pInst.erase();
      }
    } catch (e2) {
      if (e2.name !== "NS_ERROR_NOT_AVAILABLE") {
        throw e2;
      }
    }
  }
  _getTintedImageCanvas(img) {
    if (!img.canvas) {
      return img;
    }
    if (!img.tintCanvas) {
      img.tintCanvas = document.createElement("canvas");
    }
    if (img.tintCanvas.width !== img.canvas.width) {
      img.tintCanvas.width = img.canvas.width;
    }
    if (img.tintCanvas.height !== img.canvas.height) {
      img.tintCanvas.height = img.canvas.height;
    }
    const ctx = img.tintCanvas.getContext("2d");
    ctx.save();
    ctx.clearRect(0, 0, img.canvas.width, img.canvas.height);
    if (this.states.tint[0] < 255 || this.states.tint[1] < 255 || this.states.tint[2] < 255) {
      ctx.drawImage(img.canvas, 0, 0);
      ctx.globalCompositeOperation = "luminosity";
      ctx.drawImage(img.canvas, 0, 0);
      ctx.globalCompositeOperation = "color";
      ctx.drawImage(img.canvas, 0, 0);
      ctx.globalCompositeOperation = "multiply";
      ctx.fillStyle = `rgb(${this.states.tint.slice(0, 3).join(", ")})`;
      ctx.fillRect(0, 0, img.canvas.width, img.canvas.height);
      ctx.globalCompositeOperation = "destination-in";
      ctx.globalAlpha = this.states.tint[3] / 255;
      ctx.drawImage(img.canvas, 0, 0);
    } else {
      ctx.globalAlpha = this.states.tint[3] / 255;
      ctx.drawImage(img.canvas, 0, 0);
    }
    ctx.restore();
    return img.tintCanvas;
  }
  //////////////////////////////////////////////
  // IMAGE | Pixels
  //////////////////////////////////////////////
  blendMode(mode) {
    if (mode === SUBTRACT) {
      console.warn("blendMode(SUBTRACT) only works in WEBGL mode.");
    } else if (mode === BLEND || mode === REMOVE || mode === DARKEST || mode === LIGHTEST || mode === DIFFERENCE || mode === MULTIPLY || mode === EXCLUSION || mode === SCREEN || mode === REPLACE || mode === OVERLAY || mode === HARD_LIGHT || mode === SOFT_LIGHT || mode === DODGE || mode === BURN || mode === ADD) {
      this._cachedBlendMode = mode;
      this.drawingContext.globalCompositeOperation = mode;
    } else {
      throw new Error(`Mode ${mode} not recognized.`);
    }
  }
  blend(...args) {
    const currBlend = this.drawingContext.globalCompositeOperation;
    const blendMode = args[args.length - 1];
    const copyArgs = Array.prototype.slice.call(args, 0, args.length - 1);
    this.drawingContext.globalCompositeOperation = blendMode;
    p52.prototype.copy.apply(this, copyArgs);
    this.drawingContext.globalCompositeOperation = currBlend;
  }
  // p5.Renderer2D.prototype.get = p5.Renderer.prototype.get;
  // .get() is not overridden
  // x,y are canvas-relative (pre-scaled by _pixelDensity)
  _getPixel(x, y) {
    let imageData, index;
    imageData = this.drawingContext.getImageData(x, y, 1, 1).data;
    index = 0;
    return [
      imageData[index + 0],
      imageData[index + 1],
      imageData[index + 2],
      imageData[index + 3]
    ];
  }
  loadPixels() {
    const pd = this._pixelDensity;
    const w = this.width * pd;
    const h = this.height * pd;
    const imageData = this.drawingContext.getImageData(0, 0, w, h);
    this.imageData = imageData;
    this.pixels = imageData.data;
  }
  set(x, y, imgOrCol) {
    x = Math.floor(x);
    y = Math.floor(y);
    if (imgOrCol instanceof Image) {
      this.drawingContext.save();
      this.drawingContext.setTransform(1, 0, 0, 1, 0, 0);
      this.drawingContext.scale(
        this._pixelDensity,
        this._pixelDensity
      );
      this.drawingContext.clearRect(x, y, imgOrCol.width, imgOrCol.height);
      this.drawingContext.drawImage(imgOrCol.canvas, x, y);
      this.drawingContext.restore();
    } else {
      let r = 0, g2 = 0, b3 = 0, a2 = 0;
      let idx = 4 * (y * this._pixelDensity * (this.width * this._pixelDensity) + x * this._pixelDensity);
      if (!this.imageData) {
        this.loadPixels();
      }
      if (typeof imgOrCol === "number") {
        if (idx < this.pixels.length) {
          r = imgOrCol;
          g2 = imgOrCol;
          b3 = imgOrCol;
          a2 = 255;
        }
      } else if (Array.isArray(imgOrCol)) {
        if (imgOrCol.length < 4) {
          throw new Error("pixel array must be of the form [R, G, B, A]");
        }
        if (idx < this.pixels.length) {
          r = imgOrCol[0];
          g2 = imgOrCol[1];
          b3 = imgOrCol[2];
          a2 = imgOrCol[3];
        }
      } else if (imgOrCol instanceof p52.Color) {
        if (idx < this.pixels.length) {
          [r, g2, b3, a2] = imgOrCol._getRGBA([255, 255, 255, 255]);
        }
      }
      for (let i = 0; i < this._pixelDensity; i++) {
        for (let j2 = 0; j2 < this._pixelDensity; j2++) {
          idx = 4 * ((y * this._pixelDensity + j2) * this.width * this._pixelDensity + (x * this._pixelDensity + i));
          this.pixels[idx] = r;
          this.pixels[idx + 1] = g2;
          this.pixels[idx + 2] = b3;
          this.pixels[idx + 3] = a2;
        }
      }
    }
  }
  updatePixels(x, y, w, h) {
    const pd = this._pixelDensity;
    if (x === void 0 && y === void 0 && w === void 0 && h === void 0) {
      x = 0;
      y = 0;
      w = this.width;
      h = this.height;
    }
    x *= pd;
    y *= pd;
    w *= pd;
    h *= pd;
    if (this.gifProperties) {
      this.gifProperties.frames[this.gifProperties.displayIndex].image = this.imageData;
    }
    this.drawingContext.putImageData(this.imageData, 0, 0, x, y, w, h);
  }
  //////////////////////////////////////////////
  // SHAPE | 2D Primitives
  //////////////////////////////////////////////
  /*
   * This function requires that:
   *
   *   0 <= start < TWO_PI
   *
   *   start <= stop < start + TWO_PI
   */
  arc(x, y, w, h, start, stop, mode) {
    const ctx = this.clipPa || this.drawingContext;
    const centerX = x + w / 2, centerY = y + h / 2, radiusX = w / 2, radiusY = h / 2;
    const createPieSlice = !(mode === CHORD || mode === OPEN || (stop - start) % TWO_PI === 0);
    if (this.states.fillColor) {
      if (!this._clipping) ctx.beginPath();
      ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, start, stop);
      if (createPieSlice) ctx.lineTo(centerX, centerY);
      ctx.closePath();
      if (!this._clipping) ctx.fill();
    }
    if (this.states.strokeColor) {
      if (!this._clipping) ctx.beginPath();
      ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, start, stop);
      if (mode === PIE && createPieSlice) {
        ctx.lineTo(centerX, centerY);
      }
      if (mode === PIE || mode === CHORD) {
        ctx.closePath();
      }
      if (!this._clipping) ctx.stroke();
    }
    return this;
  }
  ellipse(args) {
    const ctx = this.clipPath || this.drawingContext;
    const doFill = !!this.states.fillColor, doStroke = this.states.strokeColor;
    const x = parseFloat(args[0]), y = parseFloat(args[1]), w = parseFloat(args[2]), h = parseFloat(args[3]);
    if (doFill && !doStroke) {
      if (this._getFill() === styleEmpty) {
        return this;
      }
    } else if (!doFill && doStroke) {
      if (this._getStroke() === styleEmpty) {
        return this;
      }
    }
    const centerX = x + w / 2, centerY = y + h / 2, radiusX = w / 2, radiusY = h / 2;
    if (!this._clipping) ctx.beginPath();
    ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
    ctx.closePath();
    if (!this._clipping && doFill) {
      ctx.fill();
    }
    if (!this._clipping && doStroke) {
      ctx.stroke();
    }
  }
  line(x1, y1, x2, y2) {
    const ctx = this.clipPath || this.drawingContext;
    if (!this.states.strokeColor) {
      return this;
    } else if (this._getStroke() === styleEmpty) {
      return this;
    }
    if (!this._clipping) ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();
    return this;
  }
  point(x, y) {
    const ctx = this.clipPath || this.drawingContext;
    if (!this.states.strokeColor) {
      return this;
    } else if (this._getStroke() === styleEmpty) {
      return this;
    }
    const s = this._getStroke();
    const f = this._getFill();
    if (!this._clipping) {
      this._setFill(s);
    }
    if (!this._clipping) ctx.beginPath();
    ctx.arc(x, y, ctx.lineWidth / 2, 0, TWO_PI, false);
    if (!this._clipping) {
      ctx.fill();
      this._setFill(f);
    }
  }
  quad(x1, y1, x2, y2, x3, y3, x4, y4) {
    const ctx = this.clipPath || this.drawingContext;
    const doFill = !!this.states.fillColor, doStroke = this.states.strokeColor;
    if (doFill && !doStroke) {
      if (this._getFill() === styleEmpty) {
        return this;
      }
    } else if (!doFill && doStroke) {
      if (this._getStroke() === styleEmpty) {
        return this;
      }
    }
    if (!this._clipping) ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.lineTo(x3, y3);
    ctx.lineTo(x4, y4);
    ctx.closePath();
    if (!this._clipping && doFill) {
      ctx.fill();
    }
    if (!this._clipping && doStroke) {
      ctx.stroke();
    }
    return this;
  }
  rect(args) {
    const x = args[0];
    const y = args[1];
    const w = args[2];
    const h = args[3];
    let tl = args[4];
    let tr = args[5];
    let br = args[6];
    let bl = args[7];
    const ctx = this.clipPath || this.drawingContext;
    const doFill = !!this.states.fillColor, doStroke = this.states.strokeColor;
    if (doFill && !doStroke) {
      if (this._getFill() === styleEmpty) {
        return this;
      }
    } else if (!doFill && doStroke) {
      if (this._getStroke() === styleEmpty) {
        return this;
      }
    }
    if (!this._clipping) ctx.beginPath();
    if (typeof tl === "undefined") {
      ctx.rect(x, y, w, h);
    } else {
      if (typeof tr === "undefined") {
        tr = tl;
      }
      if (typeof br === "undefined") {
        br = tr;
      }
      if (typeof bl === "undefined") {
        bl = br;
      }
      const absW = Math.abs(w);
      const absH = Math.abs(h);
      const hw = absW / 2;
      const hh = absH / 2;
      if (absW < 2 * tl) {
        tl = hw;
      }
      if (absH < 2 * tl) {
        tl = hh;
      }
      if (absW < 2 * tr) {
        tr = hw;
      }
      if (absH < 2 * tr) {
        tr = hh;
      }
      if (absW < 2 * br) {
        br = hw;
      }
      if (absH < 2 * br) {
        br = hh;
      }
      if (absW < 2 * bl) {
        bl = hw;
      }
      if (absH < 2 * bl) {
        bl = hh;
      }
      ctx.roundRect(x, y, w, h, [tl, tr, br, bl]);
    }
    if (!this._clipping && this.states.fillColor) {
      ctx.fill();
    }
    if (!this._clipping && this.states.strokeColor) {
      ctx.stroke();
    }
    return this;
  }
  triangle(args) {
    const ctx = this.clipPath || this.drawingContext;
    const doFill = !!this.states.fillColor, doStroke = this.states.strokeColor;
    const x1 = args[0], y1 = args[1];
    const x2 = args[2], y2 = args[3];
    const x3 = args[4], y3 = args[5];
    if (doFill && !doStroke) {
      if (this._getFill() === styleEmpty) {
        return this;
      }
    } else if (!doFill && doStroke) {
      if (this._getStroke() === styleEmpty) {
        return this;
      }
    }
    if (!this._clipping) ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.lineTo(x3, y3);
    ctx.closePath();
    if (!this._clipping && doFill) {
      ctx.fill();
    }
    if (!this._clipping && doStroke) {
      ctx.stroke();
    }
  }
  //////////////////////////////////////////////
  // SHAPE | Attributes
  //////////////////////////////////////////////
  strokeCap(cap) {
    if (cap === ROUND || cap === SQUARE || cap === PROJECT) {
      this.drawingContext.lineCap = cap;
    }
    return this;
  }
  strokeJoin(join) {
    if (join === ROUND || join === BEVEL || join === MITER) {
      this.drawingContext.lineJoin = join;
    }
    return this;
  }
  strokeWeight(w) {
    super.strokeWeight(w);
    if (typeof w === "undefined" || w === 0) {
      this.drawingContext.lineWidth = 1e-4;
    } else {
      this.drawingContext.lineWidth = w;
    }
    return this;
  }
  _getFill() {
    if (!this.states._cachedFillStyle) {
      this.states.setValue("_cachedFillStyle", this.drawingContext.fillStyle);
    }
    return this.states._cachedFillStyle;
  }
  _setFill(fillStyle) {
    if (fillStyle !== this.states._cachedFillStyle) {
      this.drawingContext.fillStyle = fillStyle;
      this.states.setValue("_cachedFillStyle", fillStyle);
    }
  }
  _getStroke() {
    if (!this.states._cachedStrokeStyle) {
      this.states.setValue("_cachedStrokeStyle", this.drawingContext.strokeStyle);
    }
    return this.states._cachedStrokeStyle;
  }
  _setStroke(strokeStyle) {
    if (strokeStyle !== this.states._cachedStrokeStyle) {
      this.drawingContext.strokeStyle = strokeStyle;
      this.states.setValue("_cachedStrokeStyle", strokeStyle);
    }
  }
  //////////////////////////////////////////////
  // TRANSFORM
  //////////////////////////////////////////////
  applyMatrix(a2, b3, c4, d2, e2, f) {
    this.drawingContext.transform(a2, b3, c4, d2, e2, f);
  }
  getWorldToScreenMatrix() {
    let domMatrix = new DOMMatrix().scale(1 / this._pixelDensity).multiply(this.drawingContext.getTransform());
    return new Matrix(domMatrix.toFloat32Array());
  }
  resetMatrix() {
    this.drawingContext.setTransform(1, 0, 0, 1, 0, 0);
    this.drawingContext.scale(
      this._pixelDensity,
      this._pixelDensity
    );
    return this;
  }
  rotate(rad) {
    this.drawingContext.rotate(rad);
  }
  scale(x, y) {
    this.drawingContext.scale(x, y);
    return this;
  }
  translate(x, y) {
    if (x instanceof p52.Vector) {
      y = x.y;
      x = x.x;
    }
    this.drawingContext.translate(x, y);
    return this;
  }
  //////////////////////////////////////////////
  // TYPOGRAPHY (see src/type/textCore.js)
  //////////////////////////////////////////////
  //////////////////////////////////////////////
  // STRUCTURE
  //////////////////////////////////////////////
  // a push() operation is in progress.
  // the renderer should return a 'style' object that it wishes to
  // store on the push stack.
  // derived renderers should call the base class' push() method
  // to fetch the base style object.
  push() {
    this.drawingContext.save();
    return super.push();
  }
  // a pop() operation is in progress
  // the renderer is passed the 'style' object that it returned
  // from its push() method.
  // derived renderers should pass this object to their base
  // class' pop method
  pop(style) {
    this.drawingContext.restore();
    super.pop(style);
  }
};
function renderer2D(p53, fn2) {
  p53.Renderer2D = Renderer2D;
  p53.renderers[P2D] = Renderer2D;
  p53.renderers["p2d-hdr"] = new Proxy(Renderer2D, {
    construct(target, [pInst, w, h, isMainCanvas, elt]) {
      return new target(pInst, w, h, isMainCanvas, elt, { colorSpace: "display-p3" });
    }
  });
}
var _p5_instances, _start_fn, _setup_fn;
var _p5 = class _p5 {
  constructor(sketch, node) {
    __privateAdd(this, _p5_instances);
    this.hitCriticalError = false;
    this._setupDone = false;
    this._userNode = node;
    this._curElement = null;
    this._elements = [];
    this._glAttributes = null;
    this._requestAnimId = 0;
    this._isGlobal = false;
    this._loop = true;
    this._startListener = null;
    this._initializeInstanceVariables();
    this._events = {
      // keep track of user-events for unregistering later
      pointerdown: null,
      pointerup: null,
      pointermove: null,
      dragend: null,
      dragover: null,
      click: null,
      dblclick: null,
      mouseover: null,
      mouseout: null,
      keydown: null,
      keyup: null,
      keypress: null,
      wheel: null,
      resize: null,
      blur: null
    };
    this._millisStart = -1;
    this._recording = false;
    this._lcg_random_state = null;
    this._gaussian_previous = false;
    if (window.DeviceOrientationEvent) {
      this._events.deviceorientation = null;
    }
    if (window.DeviceMotionEvent && !window._isNodeWebkit) {
      this._events.devicemotion = null;
    }
    this._updateWindowSize();
    const bindGlobal = (property) => {
      Object.defineProperty(window, property, {
        configurable: true,
        enumerable: true,
        get: () => {
          if (typeof this[property] === "function") {
            return this[property].bind(this);
          } else {
            return this[property];
          }
        },
        set: (newValue) => {
          Object.defineProperty(window, property, {
            configurable: true,
            enumerable: true,
            value: newValue,
            writable: true
          });
          if (!_p5.disableFriendlyErrors) {
            console.log(`You just changed the value of "${property}", which was a p5 global value. This could cause problems later if you're not careful.`);
          }
        }
      });
    };
    if (!sketch) {
      this._isGlobal = true;
      if (window.hitCriticalError) {
        return;
      }
      _p5.instance = this;
      for (const p2 of Object.getOwnPropertyNames(_p5.prototype)) {
        if (p2[0] === "_") continue;
        bindGlobal(p2);
      }
      const protectedProperties = ["constructor", "length"];
      for (const p2 in this) {
        if (this.hasOwnProperty(p2)) {
          if (p2[0] === "_" || protectedProperties.includes(p2)) continue;
          bindGlobal(p2);
        }
      }
    } else {
      sketch(this);
      _p5._checkForUserDefinedFunctions(this);
    }
    for (const e2 in this._events) {
      const f = this[`_on${e2}`];
      if (f) {
        const m3 = f.bind(this);
        window.addEventListener(e2, m3, { passive: false });
        this._events[e2] = m3;
      }
    }
    const focusHandler = () => {
      this.focused = true;
    };
    const blurHandler = () => {
      this.focused = false;
    };
    window.addEventListener("focus", focusHandler);
    window.addEventListener("blur", blurHandler);
    _p5.lifecycleHooks.remove.push(function() {
      window.removeEventListener("focus", focusHandler);
      window.removeEventListener("blur", blurHandler);
    });
    if (document.readyState === "complete") {
      __privateMethod(this, _p5_instances, _start_fn).call(this);
    } else {
      this._startListener = __privateMethod(this, _p5_instances, _start_fn).bind(this);
      window.addEventListener("load", this._startListener, false);
    }
  }
  get pixels() {
    return this._renderer.pixels;
  }
  get drawingContext() {
    return this._renderer.drawingContext;
  }
  static registerAddon(addon) {
    const lifecycles = {};
    addon(_p5, _p5.prototype, lifecycles);
    const validLifecycles = Object.keys(_p5.lifecycleHooks);
    for (const name of validLifecycles) {
      if (typeof lifecycles[name] === "function") {
        _p5.lifecycleHooks[name].push(lifecycles[name]);
      }
    }
  }
  // While '#_draw' here is async, it is not awaited as 'requestAnimationFrame'
  // does not await its callback. Thus it is not recommended for 'draw()` to be
  // async and use await within as the next frame may start rendering before the
  // current frame finish awaiting. The same goes for lifecycle hooks 'predraw'
  // and 'postdraw'.
  async _draw(requestAnimationFrameTimestamp) {
    if (this.hitCriticalError) return;
    const now = requestAnimationFrameTimestamp || window.performance.now();
    const timeSinceLastFrame = now - this._lastTargetFrameTime;
    const targetTimeBetweenFrames = 1e3 / this._targetFrameRate;
    const epsilon = 5;
    if (!this._loop || timeSinceLastFrame >= targetTimeBetweenFrames - epsilon) {
      this.deltaTime = now - this._lastRealFrameTime;
      this._frameRate = 1e3 / this.deltaTime;
      await this.redraw();
      this._lastTargetFrameTime = Math.max(this._lastTargetFrameTime + targetTimeBetweenFrames, now);
      this._lastRealFrameTime = now;
      if (typeof this._updateMouseCoords !== "undefined") {
        this._updateMouseCoords();
        this.movedX = 0;
        this.movedY = 0;
      }
    }
    if (this._loop) {
      this._requestAnimId = window.requestAnimationFrame(
        this._draw.bind(this)
      );
    }
  }
  /**
   * Removes the sketch from the web page.
   *
   * Calling `remove()` stops the draw loop and removes any HTML elements
   * created by the sketch, including the canvas. A new sketch can be
   * created by using the <a href="#/p5/p5">p5()</a> constructor, as in
   * `new p5()`.
   *
   * @example
   * <div>
   * <code>
   * // Double-click to remove the canvas.
   *
   * function setup() {
   *   createCanvas(100, 100);
   *
   *   describe(
   *     'A white circle on a gray background. The circle follows the mouse as the user moves. The sketch disappears when the user double-clicks.'
   *   );
   * }
   *
   * function draw() {
   *   // Paint the background repeatedly.
   *   background(200);
   *
   *   // Draw circles repeatedly.
   *   circle(mouseX, mouseY, 40);
   * }
   *
   * // Remove the sketch when the user double-clicks.
   * function doubleClicked() {
   *   remove();
   * }
   * </code>
   * </div>
   */
  async remove() {
    if (this._startListener) {
      window.removeEventListener("load", this._startListener, false);
    }
    if (this._curElement) {
      this._loop = false;
      if (this._requestAnimId) {
        window.cancelAnimationFrame(this._requestAnimId);
      }
      for (const ev in this._events) {
        window.removeEventListener(ev, this._events[ev]);
      }
      for (const e2 of this._elements) {
        if (e2.elt && e2.elt.parentNode) {
          e2.elt.parentNode.removeChild(e2.elt);
        }
        for (const elt_ev in e2._events) {
          e2.elt.removeEventListener(elt_ev, e2._events[elt_ev]);
        }
      }
      await this._runLifecycleHook("remove");
    }
    if (this._isGlobal) {
      for (const p2 in _p5.prototype) {
        try {
          delete window[p2];
        } catch (x) {
          window[p2] = void 0;
        }
      }
      for (const p2 in this) {
        if (this.hasOwnProperty(p2)) {
          try {
            delete window[p2];
          } catch (x) {
            window[p2] = void 0;
          }
        }
      }
      _p5.instance = null;
    }
  }
  async _runLifecycleHook(hookName) {
    for (const hook of _p5.lifecycleHooks[hookName]) {
      await hook.call(this);
    }
  }
  _initializeInstanceVariables() {
    this._accessibleOutputs = {
      text: false,
      grid: false,
      textLabel: false,
      gridLabel: false
    };
    this._styles = [];
    this._downKeys = {};
    this._downKeyCodes = {};
  }
};
_p5_instances = new WeakSet();
_start_fn = async function() {
  if (this.hitCriticalError) return;
  if (this._userNode) {
    if (typeof this._userNode === "string") {
      this._userNode = document.getElementById(this._userNode);
    }
  }
  await __privateMethod(this, _p5_instances, _setup_fn).call(this);
  if (this.hitCriticalError) return;
  if (!this._recording) {
    this._draw();
  }
};
_setup_fn = async function() {
  await this._runLifecycleHook("presetup");
  if (this.hitCriticalError) return;
  this.createCanvas(
    100,
    100,
    P2D
  );
  this._millisStart = window.performance.now();
  const context = this._isGlobal ? window : this;
  if (typeof context.setup === "function") {
    await context.setup();
  }
  if (this.hitCriticalError) return;
  const canvases = document.getElementsByTagName("canvas");
  if (Object.keys(this._events).some((event) => event.startsWith("pointer"))) {
    for (const k of canvases) {
      k.style.touchAction = "none";
    }
  }
  for (const k of canvases) {
    if (k.dataset.hidden === "true") {
      k.style.visibility = "";
      delete k.dataset.hidden;
    }
  }
  this._lastTargetFrameTime = window.performance.now();
  this._lastRealFrameTime = window.performance.now();
  this._setupDone = true;
  if (this._accessibleOutputs.grid || this._accessibleOutputs.text) {
    this._updateAccsOutput();
  }
  await this._runLifecycleHook("postsetup");
  this._millisStart = window.performance.now();
};
__publicField(_p5, "VERSION", VERSION);
// This is a pointer to our global mode p5 instance, if we're in
// global mode.
__publicField(_p5, "instance", null);
__publicField(_p5, "lifecycleHooks", {
  presetup: [],
  postsetup: [],
  predraw: [],
  postdraw: [],
  remove: []
});
// FES stub
__publicField(_p5, "_checkForUserDefinedFunctions", () => {
});
__publicField(_p5, "_friendlyFileLoadError", () => {
});
var p52 = _p5;
for (const k in constants) {
  p52.prototype[k] = constants[k];
}
p52.disableFriendlyErrors = false;
p52.registerAddon(transform);
p52.registerAddon(structure);
p52.registerAddon(environment);
p52.registerAddon(rendering);
p52.registerAddon(renderer);
p52.registerAddon(renderer2D);
p52.registerAddon(graphics);

// node_modules/p5/dist/shape/index.js
function shape(p53) {
  p53.registerAddon(primitives);
  p53.registerAddon(attributes);
  p53.registerAddon(curves);
  p53.registerAddon(vertex);
  p53.registerAddon(customShapes);
}

// node_modules/p5/dist/accessibility/describe.js
function describe(p53, fn2) {
  const descContainer = "_Description";
  const fallbackDescId = "_fallbackDesc";
  const fallbackTableId = "_fallbackTable";
  const fallbackTableElId = "_fte_";
  const labelContainer = "_Label";
  const labelDescId = "_labelDesc";
  const labelTableId = "_labelTable";
  const labelTableElId = "_lte_";
  fn2.describe = function(text2, display2) {
    if (typeof text2 !== "string") {
      return;
    }
    const cnvId = this.canvas.id;
    text2 = _descriptionText(text2);
    if (!this.dummyDOM) {
      this.dummyDOM = document.getElementById(cnvId).parentNode;
    }
    if (!this.descriptions) {
      this.descriptions = {};
    }
    if (this.descriptions.fallback) {
      if (this.descriptions.fallback.innerHTML !== text2) {
        this.descriptions.fallback.innerHTML = text2;
      }
    } else {
      this._describeHTML("fallback", text2);
    }
    if (display2 === this.LABEL) {
      if (this.descriptions.label) {
        if (this.descriptions.label.innerHTML !== text2) {
          this.descriptions.label.innerHTML = text2;
        }
      } else {
        this._describeHTML("label", text2);
      }
    }
  };
  fn2.describeElement = function(name, text2, display2) {
    if (typeof text2 !== "string" || typeof name !== "string") {
      return;
    }
    const cnvId = this.canvas.id;
    text2 = _descriptionText(text2);
    let elementName = _elementName(name);
    name = name.replace(/[^a-zA-Z0-9]/g, "");
    let inner = `<th scope="row">${elementName}</th><td>${text2}</td>`;
    if (!this.dummyDOM) {
      this.dummyDOM = document.getElementById(cnvId).parentNode;
    }
    if (!this.descriptions) {
      this.descriptions = { fallbackElements: {} };
    } else if (!this.descriptions.fallbackElements) {
      this.descriptions.fallbackElements = {};
    }
    if (this.descriptions.fallbackElements[name]) {
      if (this.descriptions.fallbackElements[name].innerHTML !== inner) {
        this.descriptions.fallbackElements[name].innerHTML = inner;
      }
    } else {
      this._describeElementHTML("fallback", name, inner);
    }
    if (display2 === this.LABEL) {
      if (!this.descriptions.labelElements) {
        this.descriptions.labelElements = {};
      }
      if (this.descriptions.labelElements[name]) {
        if (this.descriptions.labelElements[name].innerHTML !== inner) {
          this.descriptions.labelElements[name].innerHTML = inner;
        }
      } else {
        this._describeElementHTML("label", name, inner);
      }
    }
  };
  function _descriptionText(text2) {
    if (text2 === "label" || text2 === "fallback") {
      throw new Error("description should not be LABEL or FALLBACK");
    }
    if (!text2.endsWith(".") && !text2.endsWith(";") && !text2.endsWith(",") && !text2.endsWith("?") && !text2.endsWith("!")) {
      text2 = text2 + ".";
    }
    return text2;
  }
  fn2._describeHTML = function(type3, text2) {
    const cnvId = this.canvas.id;
    if (type3 === "fallback") {
      if (!this.dummyDOM.querySelector(`#${cnvId + descContainer}`)) {
        let html = `<div id="${cnvId}${descContainer}" role="region" aria-label="Canvas Description"><p id="${cnvId}${fallbackDescId}"></p></div>`;
        if (!this.dummyDOM.querySelector(`#${cnvId}accessibleOutput`)) {
          this.dummyDOM.querySelector(`#${cnvId}`).innerHTML = html;
        } else {
          this.dummyDOM.querySelector(`#${cnvId}accessibleOutput`).insertAdjacentHTML("beforebegin", html);
        }
      } else {
        this.dummyDOM.querySelector("#" + cnvId + fallbackTableId).insertAdjacentHTML(
          "beforebegin",
          `<p id="${cnvId + fallbackDescId}"></p>`
        );
      }
      this.descriptions.fallback = this.dummyDOM.querySelector(
        `#${cnvId}${fallbackDescId}`
      );
      this.descriptions.fallback.innerHTML = text2;
      return;
    } else if (type3 === "label") {
      if (!this.dummyDOM.querySelector(`#${cnvId + labelContainer}`)) {
        let html = `<div id="${cnvId}${labelContainer}" class="p5Label"><p id="${cnvId}${labelDescId}"></p></div>`;
        if (!this.dummyDOM.querySelector(`#${cnvId}accessibleOutputLabel`)) {
          this.dummyDOM.querySelector("#" + cnvId).insertAdjacentHTML("afterend", html);
        } else {
          this.dummyDOM.querySelector(`#${cnvId}accessibleOutputLabel`).insertAdjacentHTML("beforebegin", html);
        }
      } else if (this.dummyDOM.querySelector(`#${cnvId + labelTableId}`)) {
        this.dummyDOM.querySelector(`#${cnvId + labelTableId}`).insertAdjacentHTML(
          "beforebegin",
          `<p id="${cnvId}${labelDescId}"></p>`
        );
      }
      this.descriptions.label = this.dummyDOM.querySelector(
        "#" + cnvId + labelDescId
      );
      this.descriptions.label.innerHTML = text2;
      return;
    }
  };
  function _elementName(name) {
    if (name === "label" || name === "fallback") {
      throw new Error("element name should not be LABEL or FALLBACK");
    }
    if (name.endsWith(".") || name.endsWith(";") || name.endsWith(",")) {
      name = name.replace(/.$/, ":");
    } else if (!name.endsWith(":")) {
      name = name + ":";
    }
    return name;
  }
  fn2._describeElementHTML = function(type3, name, text2) {
    const cnvId = this.canvas.id;
    if (type3 === "fallback") {
      if (!this.dummyDOM.querySelector(`#${cnvId + descContainer}`)) {
        let html = `<div id="${cnvId}${descContainer}" role="region" aria-label="Canvas Description"><table id="${cnvId}${fallbackTableId}"><caption>Canvas elements and their descriptions</caption></table></div>`;
        if (!this.dummyDOM.querySelector(`#${cnvId}accessibleOutput`)) {
          this.dummyDOM.querySelector("#" + cnvId).innerHTML = html;
        } else {
          this.dummyDOM.querySelector(`#${cnvId}accessibleOutput`).insertAdjacentHTML("beforebegin", html);
        }
      } else if (!this.dummyDOM.querySelector("#" + cnvId + fallbackTableId)) {
        this.dummyDOM.querySelector("#" + cnvId + fallbackDescId).insertAdjacentHTML(
          "afterend",
          `<table id="${cnvId}${fallbackTableId}"><caption>Canvas elements and their descriptions</caption></table>`
        );
      }
      let tableRow2 = document.createElement("tr");
      tableRow2.id = cnvId + fallbackTableElId + name;
      this.dummyDOM.querySelector("#" + cnvId + fallbackTableId).appendChild(tableRow2);
      this.descriptions.fallbackElements[name] = this.dummyDOM.querySelector(
        `#${cnvId}${fallbackTableElId}${name}`
      );
      this.descriptions.fallbackElements[name].innerHTML = text2;
      return;
    } else if (type3 === "label") {
      if (!this.dummyDOM.querySelector(`#${cnvId + labelContainer}`)) {
        let html = `<div id="${cnvId}${labelContainer}" class="p5Label"><table id="${cnvId}${labelTableId}"></table></div>`;
        if (!this.dummyDOM.querySelector(`#${cnvId}accessibleOutputLabel`)) {
          this.dummyDOM.querySelector("#" + cnvId).insertAdjacentHTML("afterend", html);
        } else {
          this.dummyDOM.querySelector(`#${cnvId}accessibleOutputLabel`).insertAdjacentHTML("beforebegin", html);
        }
      } else if (!this.dummyDOM.querySelector(`#${cnvId + labelTableId}`)) {
        this.dummyDOM.querySelector("#" + cnvId + labelDescId).insertAdjacentHTML(
          "afterend",
          `<table id="${cnvId + labelTableId}"></table>`
        );
      }
      let tableRow2 = document.createElement("tr");
      tableRow2.id = cnvId + labelTableElId + name;
      this.dummyDOM.querySelector("#" + cnvId + labelTableId).appendChild(tableRow2);
      this.descriptions.labelElements[name] = this.dummyDOM.querySelector(
        `#${cnvId}${labelTableElId}${name}`
      );
      this.descriptions.labelElements[name].innerHTML = text2;
    }
  };
}
if (typeof p5 !== "undefined") {
  describe(p5, p5.prototype);
}

// node_modules/p5/dist/accessibility/gridOutput.js
function gridOutput(p53, fn2) {
  fn2._updateGridOutput = function(idT) {
    if (!this.dummyDOM.querySelector(`#${idT}_summary`)) {
      return;
    }
    let current2 = this._accessibleOutputs[idT];
    let innerShapeDetails = _gridShapeDetails(idT, this.ingredients.shapes);
    let innerSummary = _gridSummary(
      innerShapeDetails.numShapes,
      this.ingredients.colors.background,
      this.width,
      this.height
    );
    let innerMap = _gridMap(idT, this.ingredients.shapes);
    if (innerSummary !== current2.summary.innerHTML) {
      current2.summary.innerHTML = innerSummary;
    }
    if (innerMap !== current2.map.innerHTML) {
      current2.map.innerHTML = innerMap;
    }
    if (innerShapeDetails.details !== current2.shapeDetails.innerHTML) {
      current2.shapeDetails.innerHTML = innerShapeDetails.details;
    }
    this._accessibleOutputs[idT] = current2;
  };
  function _gridMap(idT, ingredients) {
    let shapeNumber = 0;
    let table2 = "";
    let cells = Array.from(Array(10), () => Array(10));
    for (let x in ingredients) {
      for (let y in ingredients[x]) {
        let fill;
        if (x !== "line") {
          fill = `<a href="#${idT}shape${shapeNumber}">${ingredients[x][y].color} ${x}</a>`;
        } else {
          fill = `<a href="#${idT}shape${shapeNumber}">${ingredients[x][y].color} ${x} midpoint</a>`;
        }
        if (ingredients[x][y].loc.locY < cells.length && ingredients[x][y].loc.locX < cells[ingredients[x][y].loc.locY].length) {
          if (!cells[ingredients[x][y].loc.locY][ingredients[x][y].loc.locX]) {
            cells[ingredients[x][y].loc.locY][ingredients[x][y].loc.locX] = fill;
          } else {
            cells[ingredients[x][y].loc.locY][ingredients[x][y].loc.locX] = cells[ingredients[x][y].loc.locY][ingredients[x][y].loc.locX] + "  " + fill;
          }
          shapeNumber++;
        }
      }
    }
    for (let _r in cells) {
      let row = "<tr>";
      for (let c4 in cells[_r]) {
        row = row + "<td>";
        if (cells[_r][c4] !== void 0) {
          row = row + cells[_r][c4];
        }
        row = row + "</td>";
      }
      table2 = table2 + row + "</tr>";
    }
    return table2;
  }
  function _gridSummary(numShapes, background, width, height) {
    let text2 = `${background} canvas, ${width} by ${height} pixels, contains ${numShapes[0]}`;
    if (numShapes[0] === 1) {
      text2 = `${text2} shape: ${numShapes[1]}`;
    } else {
      text2 = `${text2} shapes: ${numShapes[1]}`;
    }
    return text2;
  }
  function _gridShapeDetails(idT, ingredients) {
    let shapeDetails = "";
    let shapes = "";
    let totalShapes = 0;
    for (let x in ingredients) {
      let shapeNum = 0;
      for (let y in ingredients[x]) {
        let line = `<li id="${idT}shape${totalShapes}">${ingredients[x][y].color} ${x},`;
        if (x === "line") {
          line = line + ` location = ${ingredients[x][y].pos}, length = ${ingredients[x][y].length} pixels`;
        } else {
          line = line + ` location = ${ingredients[x][y].pos}`;
          if (x !== "point") {
            line = line + `, area = ${ingredients[x][y].area} %`;
          }
          line = line + "</li>";
        }
        shapeDetails = shapeDetails + line;
        shapeNum++;
        totalShapes++;
      }
      if (shapeNum > 1) {
        shapes = `${shapes} ${shapeNum} ${x}s`;
      } else {
        shapes = `${shapes} ${shapeNum} ${x}`;
      }
    }
    return { numShapes: [totalShapes, shapes], details: shapeDetails };
  }
}
if (typeof p5 !== "undefined") {
  gridOutput(p5, p5.prototype);
}

// node_modules/p5/dist/accessibility/textOutput.js
function textOutput(p53, fn2) {
  fn2._updateTextOutput = function(idT) {
    if (!this.dummyDOM.querySelector(`#${idT}_summary`)) {
      return;
    }
    let current2 = this._accessibleOutputs[idT];
    let innerList = _shapeList(idT, this.ingredients.shapes);
    let innerSummary = _textSummary(
      innerList.numShapes,
      this.ingredients.colors.background,
      this.width,
      this.height
    );
    let innerShapeDetails = _shapeDetails(idT, this.ingredients.shapes);
    if (innerSummary !== current2.summary.innerHTML) {
      current2.summary.innerHTML = innerSummary;
    }
    if (innerList.listShapes !== current2.list.innerHTML) {
      current2.list.innerHTML = innerList.listShapes;
    }
    if (innerShapeDetails !== current2.shapeDetails.innerHTML) {
      current2.shapeDetails.innerHTML = innerShapeDetails;
    }
    this._accessibleOutputs[idT] = current2;
  };
  function _textSummary(numShapes, background, width, height) {
    let text2 = `Your output is a, ${width} by ${height} pixels, ${background} canvas containing the following`;
    if (numShapes === 1) {
      text2 = `${text2} shape:`;
    } else {
      text2 = `${text2} ${numShapes} shapes:`;
    }
    return text2;
  }
  function _shapeDetails(idT, ingredients) {
    let shapeDetails = "";
    let shapeNumber = 0;
    for (let x in ingredients) {
      for (let y in ingredients[x]) {
        let row = `<tr id="${idT}shape${shapeNumber}"><th>${ingredients[x][y].color} ${x}</th>`;
        if (x === "line") {
          row = row + `<td>location = ${ingredients[x][y].pos}</td><td>length = ${ingredients[x][y].length} pixels</td></tr>`;
        } else {
          row = row + `<td>location = ${ingredients[x][y].pos}</td>`;
          if (x !== "point") {
            row = row + `<td> area = ${ingredients[x][y].area}%</td>`;
          }
          row = row + "</tr>";
        }
        shapeDetails = shapeDetails + row;
        shapeNumber++;
      }
    }
    return shapeDetails;
  }
  function _shapeList(idT, ingredients) {
    let shapeList = "";
    let shapeNumber = 0;
    for (let x in ingredients) {
      for (let y in ingredients[x]) {
        let _line = `<li><a href="#${idT}shape${shapeNumber}">${ingredients[x][y].color} ${x}</a>`;
        if (x === "line") {
          _line = _line + `, ${ingredients[x][y].pos}, ${ingredients[x][y].length} pixels long.</li>`;
        } else {
          _line = _line + `, at ${ingredients[x][y].pos}`;
          if (x !== "point") {
            _line = _line + `, covering ${ingredients[x][y].area}% of the canvas`;
          }
          _line = _line + ".</li>";
        }
        shapeList = shapeList + _line;
        shapeNumber++;
      }
    }
    return { numShapes: shapeNumber, listShapes: shapeList };
  }
}
if (typeof p5 !== "undefined") {
  textOutput(p5, p5.prototype);
}

// node_modules/p5/dist/accessibility/outputs.js
function outputs(p53, fn2) {
  fn2.textOutput = function(display2) {
    if (this._accessibleOutputs.text) {
      return;
    } else {
      this._accessibleOutputs.text = true;
      this._createOutput("textOutput", "Fallback");
      if (display2 === this.LABEL) {
        this._accessibleOutputs.textLabel = true;
        this._createOutput("textOutput", "Label");
      }
    }
  };
  fn2.gridOutput = function(display2) {
    if (this._accessibleOutputs.grid) {
      return;
    } else {
      this._accessibleOutputs.grid = true;
      this._createOutput("gridOutput", "Fallback");
      if (display2 === this.LABEL) {
        this._accessibleOutputs.gridLabel = true;
        this._createOutput("gridOutput", "Label");
      }
    }
  };
  fn2._addAccsOutput = function() {
    if (!this._accessibleOutputs) {
      this._accessibleOutputs = {
        text: false,
        grid: false,
        textLabel: false,
        gridLabel: false
      };
    }
    return this._accessibleOutputs.grid || this._accessibleOutputs.text;
  };
  fn2._createOutput = function(type3, display2) {
    let cnvId = this.canvas.id;
    if (!this.ingredients) {
      this.ingredients = {
        shapes: {},
        colors: { background: "white", fill: "white", stroke: "black" },
        pShapes: "",
        pBackground: ""
      };
    }
    if (!this.dummyDOM) {
      this.dummyDOM = document.getElementById(cnvId).parentNode;
    }
    let cIdT, container, inner;
    let query = "";
    if (display2 === "Fallback") {
      cIdT = cnvId + type3;
      container = cnvId + "accessibleOutput";
      if (!this.dummyDOM.querySelector(`#${container}`)) {
        if (!this.dummyDOM.querySelector(`#${cnvId}_Description`)) {
          this.dummyDOM.querySelector(
            `#${cnvId}`
          ).innerHTML = `<div id="${container}" role="region" aria-label="Canvas Outputs"></div>`;
        } else {
          this.dummyDOM.querySelector(`#${cnvId}_Description`).insertAdjacentHTML(
            "afterend",
            `<div id="${container}" role="region" aria-label="Canvas Outputs"></div>`
          );
        }
      }
    } else if (display2 === "Label") {
      query = display2;
      cIdT = cnvId + type3 + display2;
      container = cnvId + "accessibleOutput" + display2;
      if (!this.dummyDOM.querySelector(`#${container}`)) {
        if (!this.dummyDOM.querySelector(`#${cnvId}_Label`)) {
          this.dummyDOM.querySelector(`#${cnvId}`).insertAdjacentHTML("afterend", `<div id="${container}"></div>`);
        } else {
          this.dummyDOM.querySelector(`#${cnvId}_Label`).insertAdjacentHTML("afterend", `<div id="${container}"></div>`);
        }
      }
    }
    this._accessibleOutputs[cIdT] = {};
    if (type3 === "textOutput") {
      query = `#${cnvId}gridOutput${query}`;
      inner = `<div id="${cIdT}">Text Output<div id="${cIdT}Summary" aria-label="text output summary"><p id="${cIdT}_summary"></p><ul id="${cIdT}_list"></ul></div><table id="${cIdT}_shapeDetails" summary="text output shape details"></table></div>`;
      if (this.dummyDOM.querySelector(query)) {
        this.dummyDOM.querySelector(query).insertAdjacentHTML("beforebegin", inner);
      } else {
        this.dummyDOM.querySelector(`#${container}`).innerHTML = inner;
      }
      this._accessibleOutputs[cIdT].list = this.dummyDOM.querySelector(
        `#${cIdT}_list`
      );
    } else if (type3 === "gridOutput") {
      query = `#${cnvId}textOutput${query}`;
      inner = `<div id="${cIdT}">Grid Output<p id="${cIdT}_summary" aria-label="grid output summary"><table id="${cIdT}_map" summary="grid output content"></table><ul id="${cIdT}_shapeDetails" aria-label="grid output shape details"></ul></div>`;
      if (this.dummyDOM.querySelector(query)) {
        this.dummyDOM.querySelector(query).insertAdjacentHTML("afterend", inner);
      } else {
        this.dummyDOM.querySelector(`#${container}`).innerHTML = inner;
      }
      this._accessibleOutputs[cIdT].map = this.dummyDOM.querySelector(
        `#${cIdT}_map`
      );
    }
    this._accessibleOutputs[cIdT].shapeDetails = this.dummyDOM.querySelector(
      `#${cIdT}_shapeDetails`
    );
    this._accessibleOutputs[cIdT].summary = this.dummyDOM.querySelector(
      `#${cIdT}_summary`
    );
  };
  fn2._updateAccsOutput = function() {
    let cnvId = this.canvas.id;
    if (JSON.stringify(this.ingredients.shapes) !== this.ingredients.pShapes || this.ingredients.colors.background !== this.ingredients.pBackground) {
      this.ingredients.pShapes = JSON.stringify(this.ingredients.shapes);
      if (this._accessibleOutputs.text) {
        this._updateTextOutput(cnvId + "textOutput");
      }
      if (this._accessibleOutputs.grid) {
        this._updateGridOutput(cnvId + "gridOutput");
      }
      if (this._accessibleOutputs.textLabel) {
        this._updateTextOutput(cnvId + "textOutputLabel");
      }
      if (this._accessibleOutputs.gridLabel) {
        this._updateGridOutput(cnvId + "gridOutputLabel");
      }
    }
  };
  fn2._accsBackground = function(args) {
    this.ingredients.pShapes = JSON.stringify(this.ingredients.shapes);
    this.ingredients.pBackground = this.ingredients.colors.background;
    this.ingredients.shapes = {};
    if (this.ingredients.colors.backgroundRGBA !== args) {
      this.ingredients.colors.backgroundRGBA = args;
      this.ingredients.colors.background = this._rgbColorName(args);
    }
  };
  fn2._accsCanvasColors = function(f, args) {
    if (f === "fill") {
      if (this.ingredients.colors.fillRGBA !== args) {
        this.ingredients.colors.fillRGBA = args;
        this.ingredients.colors.fill = this._rgbColorName(args);
      }
    } else if (f === "stroke") {
      if (this.ingredients.colors.strokeRGBA !== args) {
        this.ingredients.colors.strokeRGBA = args;
        this.ingredients.colors.stroke = this._rgbColorName(args);
      }
    }
  };
  fn2._accsOutput = function(f, args) {
    if (f === "ellipse" && args[2] === args[3]) {
      f = "circle";
    } else if (f === "rectangle" && args[2] === args[3]) {
      f = "square";
    }
    let include = {};
    let add = true;
    let middle = _getMiddle(f, args);
    if (f === "line") {
      include.color = this.ingredients.colors.stroke;
      include.length = Math.round(
        Math.hypot(args[2] - args[0], args[3] - args[1])
      );
      let p1 = this._getPos(args[0], [1]);
      let p2 = this._getPos(args[2], [3]);
      include.loc = _canvasLocator(middle, this.width, this.height);
      if (p1 === p2) {
        include.pos = `at ${p1}`;
      } else {
        include.pos = `from ${p1} to ${p2}`;
      }
    } else {
      if (f === "point") {
        include.color = this.ingredients.colors.stroke;
      } else {
        include.color = this.ingredients.colors.fill;
        include.area = this._getArea(f, args);
      }
      include.pos = this._getPos(...middle);
      include.loc = _canvasLocator(middle, this.width, this.height);
    }
    if (!this.ingredients.shapes[f]) {
      this.ingredients.shapes[f] = [include];
    } else {
      for (let y in this.ingredients.shapes[f]) {
        if (JSON.stringify(this.ingredients.shapes[f][y]) === JSON.stringify(include)) {
          add = false;
        }
      }
      if (add === true) {
        this.ingredients.shapes[f].push(include);
      }
    }
  };
  function _getMiddle(f, args) {
    let x, y;
    if (f === "rectangle" || f === "ellipse" || f === "arc" || f === "circle" || f === "square") {
      x = Math.round(args[0] + args[2] / 2);
      y = Math.round(args[1] + args[3] / 2);
    } else if (f === "triangle") {
      x = (args[0] + args[2] + args[4]) / 3;
      y = (args[1] + args[3] + args[5]) / 3;
    } else if (f === "quadrilateral") {
      x = (args[0] + args[2] + args[4] + args[6]) / 4;
      y = (args[1] + args[3] + args[5] + args[7]) / 4;
    } else if (f === "line") {
      x = (args[0] + args[2]) / 2;
      y = (args[1] + args[3]) / 2;
    } else {
      x = args[0];
      y = args[1];
    }
    return [x, y];
  }
  fn2._getPos = function(x, y) {
    const { x: transformedX, y: transformedY } = this.worldToScreen(new p53.Vector(x, y));
    const canvasWidth = this.width;
    const canvasHeight = this.height;
    if (transformedX < 0.4 * canvasWidth) {
      if (transformedY < 0.4 * canvasHeight) {
        return "top left";
      } else if (transformedY > 0.6 * canvasHeight) {
        return "bottom left";
      } else {
        return "mid left";
      }
    } else if (transformedX > 0.6 * canvasWidth) {
      if (transformedY < 0.4 * canvasHeight) {
        return "top right";
      } else if (transformedY > 0.6 * canvasHeight) {
        return "bottom right";
      } else {
        return "mid right";
      }
    } else {
      if (transformedY < 0.4 * canvasHeight) {
        return "top middle";
      } else if (transformedY > 0.6 * canvasHeight) {
        return "bottom middle";
      } else {
        return "middle";
      }
    }
  };
  function _canvasLocator(args, canvasWidth, canvasHeight) {
    const noRows = 10;
    const noCols = 10;
    let locX = Math.floor(args[0] / canvasWidth * noRows);
    let locY = Math.floor(args[1] / canvasHeight * noCols);
    if (locX === noRows) {
      locX = locX - 1;
    }
    if (locY === noCols) {
      locY = locY - 1;
    }
    return {
      locX,
      locY
    };
  }
  fn2._getArea = function(objectType, shapeArgs) {
    let objectArea = 0;
    if (objectType === "arc") {
      const arcSizeInRadians = ((shapeArgs[5] - shapeArgs[4]) % (Math.PI * 2) + Math.PI * 2) % (Math.PI * 2);
      objectArea = arcSizeInRadians * shapeArgs[2] * shapeArgs[3] / 8;
      if (shapeArgs[6] === "open" || shapeArgs[6] === "chord") {
        const Ax = shapeArgs[0];
        const Ay = shapeArgs[1];
        const Bx = shapeArgs[0] + shapeArgs[2] / 2 * Math.cos(shapeArgs[4]).toFixed(2);
        const By = shapeArgs[1] + shapeArgs[3] / 2 * Math.sin(shapeArgs[4]).toFixed(2);
        const Cx = shapeArgs[0] + shapeArgs[2] / 2 * Math.cos(shapeArgs[5]).toFixed(2);
        const Cy = shapeArgs[1] + shapeArgs[3] / 2 * Math.sin(shapeArgs[5]).toFixed(2);
        const areaOfExtraTriangle = Math.abs(Ax * (By - Cy) + Bx * (Cy - Ay) + Cx * (Ay - By)) / 2;
        if (arcSizeInRadians > Math.PI) {
          objectArea = objectArea + areaOfExtraTriangle;
        } else {
          objectArea = objectArea - areaOfExtraTriangle;
        }
      }
    } else if (objectType === "ellipse" || objectType === "circle") {
      objectArea = 3.14 * shapeArgs[2] / 2 * shapeArgs[3] / 2;
    } else if (objectType === "line") {
      objectArea = 0;
    } else if (objectType === "point") {
      objectArea = 0;
    } else if (objectType === "quadrilateral") {
      objectArea = Math.abs(
        (shapeArgs[6] + shapeArgs[0]) * (shapeArgs[7] - shapeArgs[1]) + (shapeArgs[0] + shapeArgs[2]) * (shapeArgs[1] - shapeArgs[3]) + (shapeArgs[2] + shapeArgs[4]) * (shapeArgs[3] - shapeArgs[5]) + (shapeArgs[4] + shapeArgs[6]) * (shapeArgs[5] - shapeArgs[7])
      ) / 2;
    } else if (objectType === "rectangle" || objectType === "square") {
      objectArea = shapeArgs[2] * shapeArgs[3];
    } else if (objectType === "triangle") {
      objectArea = Math.abs(
        shapeArgs[0] * (shapeArgs[3] - shapeArgs[5]) + shapeArgs[2] * (shapeArgs[5] - shapeArgs[1]) + shapeArgs[4] * (shapeArgs[1] - shapeArgs[3])
      ) / 2;
    }
    const canvasWidth = this.width * this._renderer._pixelDensity;
    const canvasHeight = this.height * this._renderer._pixelDensity;
    const canvasCorners = [
      new DOMPoint(0, 0),
      new DOMPoint(canvasWidth, 0),
      new DOMPoint(canvasWidth, canvasHeight),
      new DOMPoint(0, canvasHeight)
    ];
    const currentTransform = this._renderer.isP3D ? new DOMMatrix(this._renderer.uMVMatrix.mat4) : this.drawingContext.getTransform();
    const invertedTransform = currentTransform.inverse();
    const tc = canvasCorners.map(
      (corner) => corner.matrixTransform(invertedTransform)
    );
    const transformedCanvasArea = Math.abs(
      (tc[3].x + tc[0].x) * (tc[3].y - tc[0].y) + (tc[0].x + tc[1].x) * (tc[0].y - tc[1].y) + (tc[1].x + tc[2].x) * (tc[1].y - tc[2].y) + (tc[2].x + tc[3].x) * (tc[2].y - tc[3].y)
    ) / 2;
    const untransformedArea = Math.round(
      objectArea * 100 / transformedCanvasArea
    );
    return untransformedArea;
  };
}
if (typeof p5 !== "undefined") {
  outputs(p5, p5.prototype);
}

// node_modules/p5/dist/color/color_conversion.js
var import_file_saver5 = __toESM(require_FileSaver());
var import_omggif2 = __toESM(require_omggif());
var import_libtess3 = __toESM(require_libtess_min());
p52.ColorConversion = {
  /**
   * Convert an HSBA array to HSLA.
   */
  _hsbaToHSLA(hsba) {
    const hue = hsba[0];
    let sat = hsba[1];
    const val2 = hsba[2];
    const li = (2 - sat) * val2 / 2;
    if (li !== 0) {
      if (li === 1) {
        sat = 0;
      } else if (li < 0.5) {
        sat = sat / (2 - sat);
      } else {
        sat = sat * val2 / (2 - li * 2);
      }
    }
    return [hue, sat, li, hsba[3]];
  },
  /**
   * Convert an HSBA array to RGBA.
   */
  _hsbaToRGBA(hsba) {
    const hue = hsba[0] * 6;
    const sat = hsba[1];
    const val2 = hsba[2];
    let RGBA2 = [];
    if (sat === 0) {
      RGBA2 = [val2, val2, val2, hsba[3]];
    } else {
      const sector = Math.floor(hue);
      const tint1 = val2 * (1 - sat);
      const tint2 = val2 * (1 - sat * (hue - sector));
      const tint3 = val2 * (1 - sat * (1 + sector - hue));
      let red, green, blue;
      if (sector === 1) {
        red = tint2;
        green = val2;
        blue = tint1;
      } else if (sector === 2) {
        red = tint1;
        green = val2;
        blue = tint3;
      } else if (sector === 3) {
        red = tint1;
        green = tint2;
        blue = val2;
      } else if (sector === 4) {
        red = tint3;
        green = tint1;
        blue = val2;
      } else if (sector === 5) {
        red = val2;
        green = tint1;
        blue = tint2;
      } else {
        red = val2;
        green = tint3;
        blue = tint1;
      }
      RGBA2 = [red, green, blue, hsba[3]];
    }
    return RGBA2;
  },
  /**
   * Convert an HSLA array to HSBA.
   */
  _hslaToHSBA(hsla) {
    const hue = hsla[0];
    let sat = hsla[1];
    const li = hsla[2];
    let val2;
    if (li < 0.5) {
      val2 = (1 + sat) * li;
    } else {
      val2 = li + sat - li * sat;
    }
    sat = 2 * (val2 - li) / val2;
    return [hue, sat, val2, hsla[3]];
  },
  /**
   * Convert an HSLA array to RGBA.
   *
   * We need to change basis from HSLA to something that can be more easily be
   * projected onto RGBA. We will choose hue and brightness as our first two
   * components, and pick a convenient third one ('zest') so that we don't need
   * to calculate formal HSBA saturation.
   */
  _hslaToRGBA(hsla) {
    const hue = hsla[0] * 6;
    const sat = hsla[1];
    const li = hsla[2];
    let RGBA2 = [];
    if (sat === 0) {
      RGBA2 = [li, li, li, hsla[3]];
    } else {
      let val2;
      if (li < 0.5) {
        val2 = (1 + sat) * li;
      } else {
        val2 = li + sat - li * sat;
      }
      const zest = 2 * li - val2;
      const hzvToRGB = (hue2, zest2, val3) => {
        if (hue2 < 0) {
          hue2 += 6;
        } else if (hue2 >= 6) {
          hue2 -= 6;
        }
        if (hue2 < 1) {
          return zest2 + (val3 - zest2) * hue2;
        } else if (hue2 < 3) {
          return val3;
        } else if (hue2 < 4) {
          return zest2 + (val3 - zest2) * (4 - hue2);
        } else {
          return zest2;
        }
      };
      RGBA2 = [
        hzvToRGB(hue + 2, zest, val2),
        hzvToRGB(hue, zest, val2),
        hzvToRGB(hue - 2, zest, val2),
        hsla[3]
      ];
    }
    return RGBA2;
  },
  /**
   * Convert an RGBA array to HSBA.
   */
  _rgbaToHSBA(rgba) {
    const red = rgba[0];
    const green = rgba[1];
    const blue = rgba[2];
    const val2 = Math.max(red, green, blue);
    const chroma = val2 - Math.min(red, green, blue);
    let hue, sat;
    if (chroma === 0) {
      hue = 0;
      sat = 0;
    } else {
      sat = chroma / val2;
      if (red === val2) {
        hue = (green - blue) / chroma;
      } else if (green === val2) {
        hue = 2 + (blue - red) / chroma;
      } else if (blue === val2) {
        hue = 4 + (red - green) / chroma;
      }
      if (hue < 0) {
        hue += 6;
      } else if (hue >= 6) {
        hue -= 6;
      }
    }
    return [hue / 6, sat, val2, rgba[3]];
  },
  /**
   * Convert an RGBA array to HSLA.
   */
  _rgbaToHSLA(rgba) {
    const red = rgba[0];
    const green = rgba[1];
    const blue = rgba[2];
    const val2 = Math.max(red, green, blue);
    const min = Math.min(red, green, blue);
    const li = val2 + min;
    const chroma = val2 - min;
    let hue, sat;
    if (chroma === 0) {
      hue = 0;
      sat = 0;
    } else {
      if (li < 1) {
        sat = chroma / li;
      } else {
        sat = chroma / (2 - li);
      }
      if (red === val2) {
        hue = (green - blue) / chroma;
      } else if (green === val2) {
        hue = 2 + (blue - red) / chroma;
      } else if (blue === val2) {
        hue = 4 + (red - green) / chroma;
      }
      if (hue < 0) {
        hue += 6;
      } else if (hue >= 6) {
        hue -= 6;
      }
    }
    return [hue / 6, sat, li / 2, rgba[3]];
  }
};
var color_conversion = p52.ColorConversion;

// node_modules/p5/dist/accessibility/color_namer.js
var import_file_saver6 = __toESM(require_FileSaver());
var import_omggif3 = __toESM(require_omggif());
var import_libtess4 = __toESM(require_libtess_min());
function colorNamer(p53, fn2) {
  let originalHSB;
  const colorExceptions = [
    {
      h: 0,
      s: 0,
      b: 0.8275,
      name: "gray"
    },
    {
      h: 0,
      s: 0,
      b: 0.8627,
      name: "gray"
    },
    {
      h: 0,
      s: 0,
      b: 0.7529,
      name: "gray"
    },
    {
      h: 0.0167,
      s: 0.1176,
      b: 1,
      name: "light pink"
    }
  ];
  const colorLookUp = [
    {
      h: 0,
      s: 0,
      b: 0,
      name: "black"
    },
    {
      h: 0,
      s: 0,
      b: 0.5,
      name: "gray"
    },
    {
      h: 0,
      s: 0,
      b: 1,
      name: "white"
    },
    {
      h: 0,
      s: 0.5,
      b: 0.5,
      name: "dark maroon"
    },
    {
      h: 0,
      s: 0.5,
      b: 1,
      name: "salmon pink"
    },
    {
      h: 0,
      s: 1,
      b: 0,
      name: "black"
    },
    {
      h: 0,
      s: 1,
      b: 0.5,
      name: "dark red"
    },
    {
      h: 0,
      s: 1,
      b: 1,
      name: "red"
    },
    {
      h: 5,
      s: 0,
      b: 1,
      name: "very light peach"
    },
    {
      h: 5,
      s: 0.5,
      b: 0.5,
      name: "brown"
    },
    {
      h: 5,
      s: 0.5,
      b: 1,
      name: "peach"
    },
    {
      h: 5,
      s: 1,
      b: 0.5,
      name: "brick red"
    },
    {
      h: 5,
      s: 1,
      b: 1,
      name: "crimson"
    },
    {
      h: 10,
      s: 0,
      b: 1,
      name: "light peach"
    },
    {
      h: 10,
      s: 0.5,
      b: 0.5,
      name: "brown"
    },
    {
      h: 10,
      s: 0.5,
      b: 1,
      name: "light orange"
    },
    {
      h: 10,
      s: 1,
      b: 0.5,
      name: "brown"
    },
    {
      h: 10,
      s: 1,
      b: 1,
      name: "orange"
    },
    {
      h: 15,
      s: 0,
      b: 1,
      name: "very light yellow"
    },
    {
      h: 15,
      s: 0.5,
      b: 0.5,
      name: "olive green"
    },
    {
      h: 15,
      s: 0.5,
      b: 1,
      name: "light yellow"
    },
    {
      h: 15,
      s: 1,
      b: 0,
      name: "dark olive green"
    },
    {
      h: 15,
      s: 1,
      b: 0.5,
      name: "olive green"
    },
    {
      h: 15,
      s: 1,
      b: 1,
      name: "yellow"
    },
    {
      h: 20,
      s: 0,
      b: 1,
      name: "very light yellow"
    },
    {
      h: 20,
      s: 0.5,
      b: 0.5,
      name: "olive green"
    },
    {
      h: 20,
      s: 0.5,
      b: 1,
      name: "light yellow green"
    },
    {
      h: 20,
      s: 1,
      b: 0,
      name: "dark olive green"
    },
    {
      h: 20,
      s: 1,
      b: 0.5,
      name: "dark yellow green"
    },
    {
      h: 20,
      s: 1,
      b: 1,
      name: "yellow green"
    },
    {
      h: 25,
      s: 0.5,
      b: 0.5,
      name: "dark yellow green"
    },
    {
      h: 25,
      s: 0.5,
      b: 1,
      name: "light green"
    },
    {
      h: 25,
      s: 1,
      b: 0.5,
      name: "dark green"
    },
    {
      h: 25,
      s: 1,
      b: 1,
      name: "green"
    },
    {
      h: 30,
      s: 0.5,
      b: 1,
      name: "light green"
    },
    {
      h: 30,
      s: 1,
      b: 0.5,
      name: "dark green"
    },
    {
      h: 30,
      s: 1,
      b: 1,
      name: "green"
    },
    {
      h: 35,
      s: 0,
      b: 0.5,
      name: "light green"
    },
    {
      h: 35,
      s: 0,
      b: 1,
      name: "very light green"
    },
    {
      h: 35,
      s: 0.5,
      b: 0.5,
      name: "dark green"
    },
    {
      h: 35,
      s: 0.5,
      b: 1,
      name: "light green"
    },
    {
      h: 35,
      s: 1,
      b: 0,
      name: "very dark green"
    },
    {
      h: 35,
      s: 1,
      b: 0.5,
      name: "dark green"
    },
    {
      h: 35,
      s: 1,
      b: 1,
      name: "green"
    },
    {
      h: 40,
      s: 0,
      b: 1,
      name: "very light green"
    },
    {
      h: 40,
      s: 0.5,
      b: 0.5,
      name: "dark green"
    },
    {
      h: 40,
      s: 0.5,
      b: 1,
      name: "light green"
    },
    {
      h: 40,
      s: 1,
      b: 0.5,
      name: "dark green"
    },
    {
      h: 40,
      s: 1,
      b: 1,
      name: "green"
    },
    {
      h: 45,
      s: 0.5,
      b: 1,
      name: "light turquoise"
    },
    {
      h: 45,
      s: 1,
      b: 0.5,
      name: "dark turquoise"
    },
    {
      h: 45,
      s: 1,
      b: 1,
      name: "turquoise"
    },
    {
      h: 50,
      s: 0,
      b: 1,
      name: "light sky blue"
    },
    {
      h: 50,
      s: 0.5,
      b: 0.5,
      name: "dark cyan"
    },
    {
      h: 50,
      s: 0.5,
      b: 1,
      name: "light cyan"
    },
    {
      h: 50,
      s: 1,
      b: 0.5,
      name: "dark cyan"
    },
    {
      h: 50,
      s: 1,
      b: 1,
      name: "cyan"
    },
    {
      h: 55,
      s: 0,
      b: 1,
      name: "light sky blue"
    },
    {
      h: 55,
      s: 0.5,
      b: 1,
      name: "light sky blue"
    },
    {
      h: 55,
      s: 1,
      b: 0.5,
      name: "dark blue"
    },
    {
      h: 55,
      s: 1,
      b: 1,
      name: "sky blue"
    },
    {
      h: 60,
      s: 0,
      b: 0.5,
      name: "gray"
    },
    {
      h: 60,
      s: 0,
      b: 1,
      name: "very light blue"
    },
    {
      h: 60,
      s: 0.5,
      b: 0.5,
      name: "blue"
    },
    {
      h: 60,
      s: 0.5,
      b: 1,
      name: "light blue"
    },
    {
      h: 60,
      s: 1,
      b: 0.5,
      name: "navy blue"
    },
    {
      h: 60,
      s: 1,
      b: 1,
      name: "blue"
    },
    {
      h: 65,
      s: 0,
      b: 1,
      name: "lavender"
    },
    {
      h: 65,
      s: 0.5,
      b: 0.5,
      name: "navy blue"
    },
    {
      h: 65,
      s: 0.5,
      b: 1,
      name: "light purple"
    },
    {
      h: 65,
      s: 1,
      b: 0.5,
      name: "dark navy blue"
    },
    {
      h: 65,
      s: 1,
      b: 1,
      name: "blue"
    },
    {
      h: 70,
      s: 0,
      b: 1,
      name: "lavender"
    },
    {
      h: 70,
      s: 0.5,
      b: 0.5,
      name: "navy blue"
    },
    {
      h: 70,
      s: 0.5,
      b: 1,
      name: "lavender blue"
    },
    {
      h: 70,
      s: 1,
      b: 0.5,
      name: "dark navy blue"
    },
    {
      h: 70,
      s: 1,
      b: 1,
      name: "blue"
    },
    {
      h: 75,
      s: 0.5,
      b: 1,
      name: "lavender"
    },
    {
      h: 75,
      s: 1,
      b: 0.5,
      name: "dark purple"
    },
    {
      h: 75,
      s: 1,
      b: 1,
      name: "purple"
    },
    {
      h: 80,
      s: 0.5,
      b: 1,
      name: "pinkish purple"
    },
    {
      h: 80,
      s: 1,
      b: 0.5,
      name: "dark purple"
    },
    {
      h: 80,
      s: 1,
      b: 1,
      name: "purple"
    },
    {
      h: 85,
      s: 0,
      b: 1,
      name: "light pink"
    },
    {
      h: 85,
      s: 0.5,
      b: 0.5,
      name: "purple"
    },
    {
      h: 85,
      s: 0.5,
      b: 1,
      name: "light fuchsia"
    },
    {
      h: 85,
      s: 1,
      b: 0.5,
      name: "dark fuchsia"
    },
    {
      h: 85,
      s: 1,
      b: 1,
      name: "fuchsia"
    },
    {
      h: 90,
      s: 0.5,
      b: 0.5,
      name: "dark fuchsia"
    },
    {
      h: 90,
      s: 0.5,
      b: 1,
      name: "hot pink"
    },
    {
      h: 90,
      s: 1,
      b: 0.5,
      name: "dark fuchsia"
    },
    {
      h: 90,
      s: 1,
      b: 1,
      name: "fuchsia"
    },
    {
      h: 95,
      s: 0,
      b: 1,
      name: "pink"
    },
    {
      h: 95,
      s: 0.5,
      b: 1,
      name: "light pink"
    },
    {
      h: 95,
      s: 1,
      b: 0.5,
      name: "dark magenta"
    },
    {
      h: 95,
      s: 1,
      b: 1,
      name: "magenta"
    }
  ];
  function _calculateColor(hsb) {
    let colortext;
    if (hsb[0] !== 0) {
      hsb[0] = Math.round(hsb[0] * 100);
      let hue = hsb[0].toString().split("");
      const last2 = hue.length - 1;
      hue[last2] = parseInt(hue[last2]);
      if (hue[last2] < 2.5) {
        hue[last2] = 0;
      } else if (hue[last2] >= 2.5 && hue[last2] < 7.5) {
        hue[last2] = 5;
      }
      if (hue.length === 2) {
        hue[0] = parseInt(hue[0]);
        if (hue[last2] >= 7.5) {
          hue[last2] = 0;
          hue[0] = hue[0] + 1;
        }
        hsb[0] = hue[0] * 10 + hue[1];
      } else {
        if (hue[last2] >= 7.5) {
          hsb[0] = 10;
        } else {
          hsb[0] = hue[last2];
        }
      }
    }
    hsb[2] = hsb[2] / 255;
    for (let i = hsb.length - 1; i >= 1; i--) {
      if (hsb[i] <= 0.25) {
        hsb[i] = 0;
      } else if (hsb[i] > 0.25 && hsb[i] < 0.75) {
        hsb[i] = 0.5;
      } else {
        hsb[i] = 1;
      }
    }
    if (hsb[0] === 0 && hsb[1] === 0 && hsb[2] === 1) {
      for (let i = 2; i >= 0; i--) {
        originalHSB[i] = Math.round(originalHSB[i] * 1e4) / 1e4;
      }
      for (let e2 = 0; e2 < colorExceptions.length; e2++) {
        if (colorExceptions[e2].h === originalHSB[0] && colorExceptions[e2].s === originalHSB[1] && colorExceptions[e2].b === originalHSB[2]) {
          colortext = colorExceptions[e2].name;
          break;
        } else {
          colortext = "white";
        }
      }
    } else {
      for (let i = 0; i < colorLookUp.length; i++) {
        if (colorLookUp[i].h === hsb[0] && colorLookUp[i].s === hsb[1] && colorLookUp[i].b === hsb[2]) {
          colortext = colorLookUp[i].name;
          break;
        }
      }
    }
    return colortext;
  }
  fn2._rgbColorName = function(arg) {
    let hsb = color_conversion._rgbaToHSBA(arg);
    originalHSB = hsb;
    return _calculateColor([hsb[0], hsb[1], hsb[2]]);
  };
}
if (typeof p5 !== "undefined") {
  colorNamer(p5, p5.prototype);
}

// node_modules/p5/dist/accessibility/index.js
var import_file_saver7 = __toESM(require_FileSaver());
var import_omggif4 = __toESM(require_omggif());
var import_libtess5 = __toESM(require_libtess_min());
function accessibility(p53) {
  p53.registerAddon(describe);
  p53.registerAddon(gridOutput);
  p53.registerAddon(textOutput);
  p53.registerAddon(outputs);
  p53.registerAddon(colorNamer);
}

// node_modules/p5/dist/color/index.js
function color2(p53) {
  p53.registerAddon(creatingReading);
  p53.registerAddon(color);
  p53.registerAddon(setting);
}

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e2 = t[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i = e2.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function toPropertyKey(t) {
  var i = toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(e2, r, t) {
  return (r = toPropertyKey(r)) in e2 ? Object.defineProperty(e2, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e2[r] = t, e2;
}

// node_modules/@babel/runtime/helpers/esm/objectSpread.js
function _objectSpread(e2) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? Object(arguments[r]) : {}, o = Object.keys(t);
    "function" == typeof Object.getOwnPropertySymbols && o.push.apply(o, Object.getOwnPropertySymbols(t).filter(function(e3) {
      return Object.getOwnPropertyDescriptor(t, e3).enumerable;
    })), o.forEach(function(r2) {
      _defineProperty(e2, r2, t[r2]);
    });
  }
  return e2;
}

// node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(a2, n3) {
  if (!(a2 instanceof n3)) throw new TypeError("Cannot call a class as a function");
}

// node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(e2, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e2, toPropertyKey(o.key), o);
  }
}
function _createClass(e2, r, t) {
  return r && _defineProperties(e2.prototype, r), t && _defineProperties(e2, t), Object.defineProperty(e2, "prototype", {
    writable: false
  }), e2;
}

// node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(e2) {
  if (void 0 === e2) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e2;
}

// node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js
function _possibleConstructorReturn(t, e2) {
  if (e2 && ("object" == _typeof(e2) || "function" == typeof e2)) return e2;
  if (void 0 !== e2) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}

// node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
    return t2.__proto__ || Object.getPrototypeOf(t2);
  }, _getPrototypeOf(t);
}

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(t, e2) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e3) {
    return t2.__proto__ = e3, t2;
  }, _setPrototypeOf(t, e2);
}

// node_modules/@babel/runtime/helpers/esm/inherits.js
function _inherits(t, e2) {
  if ("function" != typeof e2 && null !== e2) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e2 && e2.prototype, {
    constructor: {
      value: t,
      writable: true,
      configurable: true
    }
  }), Object.defineProperty(t, "prototype", {
    writable: false
  }), e2 && _setPrototypeOf(t, e2);
}

// node_modules/i18next/dist/esm/i18next.js
var consoleLogger = {
  type: "logger",
  log: function log(args) {
    this.output("log", args);
  },
  warn: function warn2(args) {
    this.output("warn", args);
  },
  error: function error2(args) {
    this.output("error", args);
  },
  output: function output(type3, args) {
    if (console && console[type3]) console[type3].apply(console, args);
  }
};
var Logger = function() {
  function Logger2(concreteLogger) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Logger2);
    this.init(concreteLogger, options2);
  }
  _createClass(Logger2, [{
    key: "init",
    value: function init(concreteLogger) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      this.prefix = options2.prefix || "i18next:";
      this.logger = concreteLogger || consoleLogger;
      this.options = options2;
      this.debug = options2.debug;
    }
  }, {
    key: "setDebug",
    value: function setDebug(bool) {
      this.debug = bool;
    }
  }, {
    key: "log",
    value: function log2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return this.forward(args, "log", "", true);
    }
  }, {
    key: "warn",
    value: function warn3() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      return this.forward(args, "warn", "", true);
    }
  }, {
    key: "error",
    value: function error42() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }
      return this.forward(args, "error", "");
    }
  }, {
    key: "deprecate",
    value: function deprecate() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }
      return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
    }
  }, {
    key: "forward",
    value: function forward(args, lvl, prefix, debugOnly) {
      if (debugOnly && !this.debug) return null;
      if (typeof args[0] === "string") args[0] = "".concat(prefix).concat(this.prefix, " ").concat(args[0]);
      return this.logger[lvl](args);
    }
  }, {
    key: "create",
    value: function create3(moduleName) {
      return new Logger2(this.logger, _objectSpread({}, {
        prefix: "".concat(this.prefix, ":").concat(moduleName, ":")
      }, this.options));
    }
  }]);
  return Logger2;
}();
var baseLogger = new Logger();
var EventEmitter = function() {
  function EventEmitter2() {
    _classCallCheck(this, EventEmitter2);
    this.observers = {};
  }
  _createClass(EventEmitter2, [{
    key: "on",
    value: function on(events2, listener) {
      var _this = this;
      events2.split(" ").forEach(function(event) {
        _this.observers[event] = _this.observers[event] || [];
        _this.observers[event].push(listener);
      });
      return this;
    }
  }, {
    key: "off",
    value: function off(event, listener) {
      if (!this.observers[event]) return;
      if (!listener) {
        delete this.observers[event];
        return;
      }
      this.observers[event] = this.observers[event].filter(function(l) {
        return l !== listener;
      });
    }
  }, {
    key: "emit",
    value: function emit(event) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (this.observers[event]) {
        var cloned = [].concat(this.observers[event]);
        cloned.forEach(function(observer) {
          observer.apply(void 0, args);
        });
      }
      if (this.observers["*"]) {
        var _cloned = [].concat(this.observers["*"]);
        _cloned.forEach(function(observer) {
          observer.apply(observer, [event].concat(args));
        });
      }
    }
  }]);
  return EventEmitter2;
}();
function defer() {
  var res;
  var rej;
  var promise2 = new Promise(function(resolve, reject) {
    res = resolve;
    rej = reject;
  });
  promise2.resolve = res;
  promise2.reject = rej;
  return promise2;
}
function makeString(object2) {
  if (object2 == null) return "";
  return "" + object2;
}
function copy(a2, s, t) {
  a2.forEach(function(m3) {
    if (s[m3]) t[m3] = s[m3];
  });
}
function getLastOfPath(object2, path2, Empty) {
  function cleanKey(key2) {
    return key2 && key2.indexOf("###") > -1 ? key2.replace(/###/g, ".") : key2;
  }
  function canNotTraverseDeeper() {
    return !object2 || typeof object2 === "string";
  }
  var stack = typeof path2 !== "string" ? [].concat(path2) : path2.split(".");
  while (stack.length > 1) {
    if (canNotTraverseDeeper()) return {};
    var key = cleanKey(stack.shift());
    if (!object2[key] && Empty) object2[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object2, key)) {
      object2 = object2[key];
    } else {
      object2 = {};
    }
  }
  if (canNotTraverseDeeper()) return {};
  return {
    obj: object2,
    k: cleanKey(stack.shift())
  };
}
function setPath(object2, path2, newValue) {
  var _getLastOfPath = getLastOfPath(object2, path2, Object), obj = _getLastOfPath.obj, k = _getLastOfPath.k;
  obj[k] = newValue;
}
function pushPath(object2, path2, newValue, concat) {
  var _getLastOfPath2 = getLastOfPath(object2, path2, Object), obj = _getLastOfPath2.obj, k = _getLastOfPath2.k;
  obj[k] = obj[k] || [];
  if (concat) obj[k] = obj[k].concat(newValue);
  if (!concat) obj[k].push(newValue);
}
function getPath2(object2, path2) {
  var _getLastOfPath3 = getLastOfPath(object2, path2), obj = _getLastOfPath3.obj, k = _getLastOfPath3.k;
  if (!obj) return void 0;
  return obj[k];
}
function getPathWithDefaults(data3, defaultData, key) {
  var value = getPath2(data3, key);
  if (value !== void 0) {
    return value;
  }
  return getPath2(defaultData, key);
}
function deepExtend(target, source, overwrite) {
  for (var prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
}
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape(data3) {
  if (typeof data3 === "string") {
    return data3.replace(/[&<>"'\/]/g, function(s) {
      return _entityMap[s];
    });
  }
  return data3;
}
var isIE10 = typeof window !== "undefined" && window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf("MSIE") > -1;
var ResourceStore = function(_EventEmitter) {
  _inherits(ResourceStore2, _EventEmitter);
  function ResourceStore2(data3) {
    var _this;
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    _classCallCheck(this, ResourceStore2);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(ResourceStore2).call(this));
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.data = data3 || {};
    _this.options = options2;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    return _this;
  }
  _createClass(ResourceStore2, [{
    key: "addNamespaces",
    value: function addNamespaces(ns) {
      if (this.options.ns.indexOf(ns) < 0) {
        this.options.ns.push(ns);
      }
    }
  }, {
    key: "removeNamespaces",
    value: function removeNamespaces(ns) {
      var index = this.options.ns.indexOf(ns);
      if (index > -1) {
        this.options.ns.splice(index, 1);
      }
    }
  }, {
    key: "getResource",
    value: function getResource(lng, ns, key) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
      var path2 = [lng, ns];
      if (key && typeof key !== "string") path2 = path2.concat(key);
      if (key && typeof key === "string") path2 = path2.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path2 = lng.split(".");
      }
      return getPath2(this.data, path2);
    }
  }, {
    key: "addResource",
    value: function addResource(lng, ns, key, value) {
      var options2 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
        silent: false
      };
      var keySeparator = this.options.keySeparator;
      if (keySeparator === void 0) keySeparator = ".";
      var path2 = [lng, ns];
      if (key) path2 = path2.concat(keySeparator ? key.split(keySeparator) : key);
      if (lng.indexOf(".") > -1) {
        path2 = lng.split(".");
        value = ns;
        ns = path2[1];
      }
      this.addNamespaces(ns);
      setPath(this.data, path2, value);
      if (!options2.silent) this.emit("added", lng, ns, key, value);
    }
  }, {
    key: "addResources",
    value: function addResources(lng, ns, resources) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
        silent: false
      };
      for (var m3 in resources) {
        if (typeof resources[m3] === "string" || Object.prototype.toString.apply(resources[m3]) === "[object Array]") this.addResource(lng, ns, m3, resources[m3], {
          silent: true
        });
      }
      if (!options2.silent) this.emit("added", lng, ns, resources);
    }
  }, {
    key: "addResourceBundle",
    value: function addResourceBundle(lng, ns, resources, deep, overwrite) {
      var options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
        silent: false
      };
      var path2 = [lng, ns];
      if (lng.indexOf(".") > -1) {
        path2 = lng.split(".");
        deep = resources;
        resources = ns;
        ns = path2[1];
      }
      this.addNamespaces(ns);
      var pack = getPath2(this.data, path2) || {};
      if (deep) {
        deepExtend(pack, resources, overwrite);
      } else {
        pack = _objectSpread({}, pack, resources);
      }
      setPath(this.data, path2, pack);
      if (!options2.silent) this.emit("added", lng, ns, resources);
    }
  }, {
    key: "removeResourceBundle",
    value: function removeResourceBundle(lng, ns) {
      if (this.hasResourceBundle(lng, ns)) {
        delete this.data[lng][ns];
      }
      this.removeNamespaces(ns);
      this.emit("removed", lng, ns);
    }
  }, {
    key: "hasResourceBundle",
    value: function hasResourceBundle(lng, ns) {
      return this.getResource(lng, ns) !== void 0;
    }
  }, {
    key: "getResourceBundle",
    value: function getResourceBundle(lng, ns) {
      if (!ns) ns = this.options.defaultNS;
      if (this.options.compatibilityAPI === "v1") return _objectSpread({}, {}, this.getResource(lng, ns));
      return this.getResource(lng, ns);
    }
  }, {
    key: "getDataByLanguage",
    value: function getDataByLanguage(lng) {
      return this.data[lng];
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.data;
    }
  }]);
  return ResourceStore2;
}(EventEmitter);
var postProcessor = {
  processors: {},
  addPostProcessor: function addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle: function handle(processors, value, key, options2, translator2) {
    var _this = this;
    processors.forEach(function(processor) {
      if (_this.processors[processor]) value = _this.processors[processor].process(value, key, options2, translator2);
    });
    return value;
  }
};
var checkedLoadedFor = {};
var Translator = function(_EventEmitter) {
  _inherits(Translator2, _EventEmitter);
  function Translator2(services) {
    var _this;
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Translator2);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(Translator2).call(this));
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, _assertThisInitialized(_this));
    _this.options = options2;
    if (_this.options.keySeparator === void 0) {
      _this.options.keySeparator = ".";
    }
    _this.logger = baseLogger.create("translator");
    return _this;
  }
  _createClass(Translator2, [{
    key: "changeLanguage",
    value: function changeLanguage(lng) {
      if (lng) this.language = lng;
    }
  }, {
    key: "exists",
    value: function exists(key) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
        interpolation: {}
      };
      var resolved = this.resolve(key, options2);
      return resolved && resolved.res !== void 0;
    }
  }, {
    key: "extractFromKey",
    value: function extractFromKey(key, options2) {
      var nsSeparator = options2.nsSeparator !== void 0 ? options2.nsSeparator : this.options.nsSeparator;
      if (nsSeparator === void 0) nsSeparator = ":";
      var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
      var namespaces = options2.ns || this.options.defaultNS;
      if (nsSeparator && key.indexOf(nsSeparator) > -1) {
        var m3 = key.match(this.interpolator.nestingRegexp);
        if (m3 && m3.length > 0) {
          return {
            key,
            namespaces
          };
        }
        var parts = key.split(nsSeparator);
        if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
        key = parts.join(keySeparator);
      }
      if (typeof namespaces === "string") namespaces = [namespaces];
      return {
        key,
        namespaces
      };
    }
  }, {
    key: "translate",
    value: function translate(keys, options2, lastKey) {
      var _this2 = this;
      if (_typeof(options2) !== "object" && this.options.overloadTranslationOptionHandler) {
        options2 = this.options.overloadTranslationOptionHandler(arguments);
      }
      if (!options2) options2 = {};
      if (keys === void 0 || keys === null) return "";
      if (!Array.isArray(keys)) keys = [String(keys)];
      var keySeparator = options2.keySeparator !== void 0 ? options2.keySeparator : this.options.keySeparator;
      var _this$extractFromKey = this.extractFromKey(keys[keys.length - 1], options2), key = _this$extractFromKey.key, namespaces = _this$extractFromKey.namespaces;
      var namespace = namespaces[namespaces.length - 1];
      var lng = options2.lng || this.language;
      var appendNamespaceToCIMode = options2.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if (lng && lng.toLowerCase() === "cimode") {
        if (appendNamespaceToCIMode) {
          var nsSeparator = options2.nsSeparator || this.options.nsSeparator;
          return namespace + nsSeparator + key;
        }
        return key;
      }
      var resolved = this.resolve(keys, options2);
      var res = resolved && resolved.res;
      var resUsedKey = resolved && resolved.usedKey || key;
      var resExactUsedKey = resolved && resolved.exactUsedKey || key;
      var resType = Object.prototype.toString.apply(res);
      var noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
      var joinArrays = options2.joinArrays !== void 0 ? options2.joinArrays : this.options.joinArrays;
      var handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
      var handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
      if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
        if (!options2.returnObjects && !this.options.returnObjects) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
          return this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, options2) : "key '".concat(key, " (").concat(this.language, ")' returned an object instead of string.");
        }
        if (keySeparator) {
          var resTypeIsArray = resType === "[object Array]";
          var copy2 = resTypeIsArray ? [] : {};
          var newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
          for (var m3 in res) {
            if (Object.prototype.hasOwnProperty.call(res, m3)) {
              var deepKey = "".concat(newKeyToUse).concat(keySeparator).concat(m3);
              copy2[m3] = this.translate(deepKey, _objectSpread({}, options2, {
                joinArrays: false,
                ns: namespaces
              }));
              if (copy2[m3] === deepKey) copy2[m3] = res[m3];
            }
          }
          res = copy2;
        }
      } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
        res = res.join(joinArrays);
        if (res) res = this.extendTranslation(res, keys, options2, lastKey);
      } else {
        var usedDefault = false;
        var usedKey = false;
        var needsPluralHandling = options2.count !== void 0 && typeof options2.count !== "string";
        var hasDefaultValue = Translator2.hasDefaultValue(options2);
        var defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options2.count) : "";
        var defaultValue = options2["defaultValue".concat(defaultValueSuffix)] || options2.defaultValue;
        if (!this.isValidLookup(res) && hasDefaultValue) {
          usedDefault = true;
          res = defaultValue;
        }
        if (!this.isValidLookup(res)) {
          usedKey = true;
          res = key;
        }
        var updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
        if (usedKey || usedDefault || updateMissing) {
          this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
          if (keySeparator) {
            var fk = this.resolve(key, _objectSpread({}, options2, {
              keySeparator: false
            }));
            if (fk && fk.res) this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
          }
          var lngs = [];
          var fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options2.lng || this.language);
          if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
            for (var i = 0; i < fallbackLngs.length; i++) {
              lngs.push(fallbackLngs[i]);
            }
          } else if (this.options.saveMissingTo === "all") {
            lngs = this.languageUtils.toResolveHierarchy(options2.lng || this.language);
          } else {
            lngs.push(options2.lng || this.language);
          }
          var send = function send2(l, k, fallbackValue) {
            if (_this2.options.missingKeyHandler) {
              _this2.options.missingKeyHandler(l, namespace, k, updateMissing ? fallbackValue : res, updateMissing, options2);
            } else if (_this2.backendConnector && _this2.backendConnector.saveMissing) {
              _this2.backendConnector.saveMissing(l, namespace, k, updateMissing ? fallbackValue : res, updateMissing, options2);
            }
            _this2.emit("missingKey", l, namespace, k, res);
          };
          if (this.options.saveMissing) {
            if (this.options.saveMissingPlurals && needsPluralHandling) {
              lngs.forEach(function(language) {
                _this2.pluralResolver.getSuffixes(language).forEach(function(suffix) {
                  send([language], key + suffix, options2["defaultValue".concat(suffix)] || defaultValue);
                });
              });
            } else {
              send(lngs, key, defaultValue);
            }
          }
        }
        res = this.extendTranslation(res, keys, options2, resolved, lastKey);
        if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = "".concat(namespace, ":").concat(key);
        if (usedKey && this.options.parseMissingKeyHandler) res = this.options.parseMissingKeyHandler(res);
      }
      return res;
    }
  }, {
    key: "extendTranslation",
    value: function extendTranslation(res, key, options2, resolved, lastKey) {
      var _this3 = this;
      if (this.i18nFormat && this.i18nFormat.parse) {
        res = this.i18nFormat.parse(res, options2, resolved.usedLng, resolved.usedNS, resolved.usedKey, {
          resolved
        });
      } else if (!options2.skipInterpolation) {
        if (options2.interpolation) this.interpolator.init(_objectSpread({}, options2, {
          interpolation: _objectSpread({}, this.options.interpolation, options2.interpolation)
        }));
        var skipOnVariables = options2.interpolation && options2.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;
        var nestBef;
        if (skipOnVariables) {
          var nb = res.match(this.interpolator.nestingRegexp);
          nestBef = nb && nb.length;
        }
        var data3 = options2.replace && typeof options2.replace !== "string" ? options2.replace : options2;
        if (this.options.interpolation.defaultVariables) data3 = _objectSpread({}, this.options.interpolation.defaultVariables, data3);
        res = this.interpolator.interpolate(res, data3, options2.lng || this.language, options2);
        if (skipOnVariables) {
          var na = res.match(this.interpolator.nestingRegexp);
          var nestAft = na && na.length;
          if (nestBef < nestAft) options2.nest = false;
        }
        if (options2.nest !== false) res = this.interpolator.nest(res, function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (lastKey && lastKey[0] === args[0] && !options2.context) {
            _this3.logger.warn("It seems you are nesting recursively key: ".concat(args[0], " in key: ").concat(key[0]));
            return null;
          }
          return _this3.translate.apply(_this3, args.concat([key]));
        }, options2);
        if (options2.interpolation) this.interpolator.reset();
      }
      var postProcess = options2.postProcess || this.options.postProcess;
      var postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
      if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options2.applyPostProcessor !== false) {
        res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? _objectSpread({
          i18nResolved: resolved
        }, options2) : options2, this);
      }
      return res;
    }
  }, {
    key: "resolve",
    value: function resolve(keys) {
      var _this4 = this;
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var found;
      var usedKey;
      var exactUsedKey;
      var usedLng;
      var usedNS;
      if (typeof keys === "string") keys = [keys];
      keys.forEach(function(k) {
        if (_this4.isValidLookup(found)) return;
        var extracted = _this4.extractFromKey(k, options2);
        var key = extracted.key;
        usedKey = key;
        var namespaces = extracted.namespaces;
        if (_this4.options.fallbackNS) namespaces = namespaces.concat(_this4.options.fallbackNS);
        var needsPluralHandling = options2.count !== void 0 && typeof options2.count !== "string";
        var needsContextHandling = options2.context !== void 0 && typeof options2.context === "string" && options2.context !== "";
        var codes = options2.lngs ? options2.lngs : _this4.languageUtils.toResolveHierarchy(options2.lng || _this4.language, options2.fallbackLng);
        namespaces.forEach(function(ns) {
          if (_this4.isValidLookup(found)) return;
          usedNS = ns;
          if (!checkedLoadedFor["".concat(codes[0], "-").concat(ns)] && _this4.utils && _this4.utils.hasLoadedNamespace && !_this4.utils.hasLoadedNamespace(usedNS)) {
            checkedLoadedFor["".concat(codes[0], "-").concat(ns)] = true;
            _this4.logger.warn('key "'.concat(usedKey, '" for languages "').concat(codes.join(", "), `" won't get resolved as namespace "`).concat(usedNS, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
          }
          codes.forEach(function(code) {
            if (_this4.isValidLookup(found)) return;
            usedLng = code;
            var finalKey = key;
            var finalKeys = [finalKey];
            if (_this4.i18nFormat && _this4.i18nFormat.addLookupKeys) {
              _this4.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options2);
            } else {
              var pluralSuffix;
              if (needsPluralHandling) pluralSuffix = _this4.pluralResolver.getSuffix(code, options2.count);
              if (needsPluralHandling && needsContextHandling) finalKeys.push(finalKey + pluralSuffix);
              if (needsContextHandling) finalKeys.push(finalKey += "".concat(_this4.options.contextSeparator).concat(options2.context));
              if (needsPluralHandling) finalKeys.push(finalKey += pluralSuffix);
            }
            var possibleKey;
            while (possibleKey = finalKeys.pop()) {
              if (!_this4.isValidLookup(found)) {
                exactUsedKey = possibleKey;
                found = _this4.getResource(code, ns, possibleKey, options2);
              }
            }
          });
        });
      });
      return {
        res: found,
        usedKey,
        exactUsedKey,
        usedLng,
        usedNS
      };
    }
  }, {
    key: "isValidLookup",
    value: function isValidLookup(res) {
      return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
    }
  }, {
    key: "getResource",
    value: function getResource(code, ns, key) {
      var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      if (this.i18nFormat && this.i18nFormat.getResource) return this.i18nFormat.getResource(code, ns, key, options2);
      return this.resourceStore.getResource(code, ns, key, options2);
    }
  }], [{
    key: "hasDefaultValue",
    value: function hasDefaultValue(options2) {
      var prefix = "defaultValue";
      for (var option in options2) {
        if (Object.prototype.hasOwnProperty.call(options2, option) && prefix === option.substring(0, prefix.length) && void 0 !== options2[option]) {
          return true;
        }
      }
      return false;
    }
  }]);
  return Translator2;
}(EventEmitter);
function capitalize(string4) {
  return string4.charAt(0).toUpperCase() + string4.slice(1);
}
var LanguageUtil = function() {
  function LanguageUtil2(options2) {
    _classCallCheck(this, LanguageUtil2);
    this.options = options2;
    this.whitelist = this.options.supportedLngs || false;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  _createClass(LanguageUtil2, [{
    key: "getScriptPartFromCode",
    value: function getScriptPartFromCode(code) {
      if (!code || code.indexOf("-") < 0) return null;
      var p2 = code.split("-");
      if (p2.length === 2) return null;
      p2.pop();
      if (p2[p2.length - 1].toLowerCase() === "x") return null;
      return this.formatLanguageCode(p2.join("-"));
    }
  }, {
    key: "getLanguagePartFromCode",
    value: function getLanguagePartFromCode(code) {
      if (!code || code.indexOf("-") < 0) return code;
      var p2 = code.split("-");
      return this.formatLanguageCode(p2[0]);
    }
  }, {
    key: "formatLanguageCode",
    value: function formatLanguageCode(code) {
      if (typeof code === "string" && code.indexOf("-") > -1) {
        var specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
        var p2 = code.split("-");
        if (this.options.lowerCaseLng) {
          p2 = p2.map(function(part) {
            return part.toLowerCase();
          });
        } else if (p2.length === 2) {
          p2[0] = p2[0].toLowerCase();
          p2[1] = p2[1].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1) p2[1] = capitalize(p2[1].toLowerCase());
        } else if (p2.length === 3) {
          p2[0] = p2[0].toLowerCase();
          if (p2[1].length === 2) p2[1] = p2[1].toUpperCase();
          if (p2[0] !== "sgn" && p2[2].length === 2) p2[2] = p2[2].toUpperCase();
          if (specialCases.indexOf(p2[1].toLowerCase()) > -1) p2[1] = capitalize(p2[1].toLowerCase());
          if (specialCases.indexOf(p2[2].toLowerCase()) > -1) p2[2] = capitalize(p2[2].toLowerCase());
        }
        return p2.join("-");
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
    }
  }, {
    key: "isWhitelisted",
    value: function isWhitelisted(code) {
      this.logger.deprecate("languageUtils.isWhitelisted", `function "isWhitelisted" will be renamed to "isSupportedCode" in the next major - please make sure to rename it's usage asap.`);
      return this.isSupportedCode(code);
    }
  }, {
    key: "isSupportedCode",
    value: function isSupportedCode(code) {
      if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
        code = this.getLanguagePartFromCode(code);
      }
      return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
    }
  }, {
    key: "getBestMatchFromCodes",
    value: function getBestMatchFromCodes(codes) {
      var _this = this;
      if (!codes) return null;
      var found;
      codes.forEach(function(code) {
        if (found) return;
        var cleanedLng = _this.formatLanguageCode(code);
        if (!_this.options.supportedLngs || _this.isSupportedCode(cleanedLng)) found = cleanedLng;
      });
      if (!found && this.options.supportedLngs) {
        codes.forEach(function(code) {
          if (found) return;
          var lngOnly = _this.getLanguagePartFromCode(code);
          if (_this.isSupportedCode(lngOnly)) return found = lngOnly;
          found = _this.options.supportedLngs.find(function(supportedLng) {
            if (supportedLng.indexOf(lngOnly) === 0) return supportedLng;
          });
        });
      }
      if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
      return found;
    }
  }, {
    key: "getFallbackCodes",
    value: function getFallbackCodes(fallbacks, code) {
      if (!fallbacks) return [];
      if (typeof fallbacks === "function") fallbacks = fallbacks(code);
      if (typeof fallbacks === "string") fallbacks = [fallbacks];
      if (Object.prototype.toString.apply(fallbacks) === "[object Array]") return fallbacks;
      if (!code) return fallbacks["default"] || [];
      var found = fallbacks[code];
      if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
      if (!found) found = fallbacks[this.formatLanguageCode(code)];
      if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
      if (!found) found = fallbacks["default"];
      return found || [];
    }
  }, {
    key: "toResolveHierarchy",
    value: function toResolveHierarchy(code, fallbackCode) {
      var _this2 = this;
      var fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
      var codes = [];
      var addCode = function addCode2(c4) {
        if (!c4) return;
        if (_this2.isSupportedCode(c4)) {
          codes.push(c4);
        } else {
          _this2.logger.warn("rejecting language code not found in supportedLngs: ".concat(c4));
        }
      };
      if (typeof code === "string" && code.indexOf("-") > -1) {
        if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code));
        if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code));
        if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code));
      } else if (typeof code === "string") {
        addCode(this.formatLanguageCode(code));
      }
      fallbackCodes.forEach(function(fc) {
        if (codes.indexOf(fc) < 0) addCode(_this2.formatLanguageCode(fc));
      });
      return codes;
    }
  }]);
  return LanguageUtil2;
}();
var sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "kk", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function _(n3) {
    return Number(n3 > 1);
  },
  2: function _2(n3) {
    return Number(n3 != 1);
  },
  3: function _3(n3) {
    return 0;
  },
  4: function _4(n3) {
    return Number(n3 % 10 == 1 && n3 % 100 != 11 ? 0 : n3 % 10 >= 2 && n3 % 10 <= 4 && (n3 % 100 < 10 || n3 % 100 >= 20) ? 1 : 2);
  },
  5: function _5(n3) {
    return Number(n3 == 0 ? 0 : n3 == 1 ? 1 : n3 == 2 ? 2 : n3 % 100 >= 3 && n3 % 100 <= 10 ? 3 : n3 % 100 >= 11 ? 4 : 5);
  },
  6: function _6(n3) {
    return Number(n3 == 1 ? 0 : n3 >= 2 && n3 <= 4 ? 1 : 2);
  },
  7: function _7(n3) {
    return Number(n3 == 1 ? 0 : n3 % 10 >= 2 && n3 % 10 <= 4 && (n3 % 100 < 10 || n3 % 100 >= 20) ? 1 : 2);
  },
  8: function _8(n3) {
    return Number(n3 == 1 ? 0 : n3 == 2 ? 1 : n3 != 8 && n3 != 11 ? 2 : 3);
  },
  9: function _9(n3) {
    return Number(n3 >= 2);
  },
  10: function _10(n3) {
    return Number(n3 == 1 ? 0 : n3 == 2 ? 1 : n3 < 7 ? 2 : n3 < 11 ? 3 : 4);
  },
  11: function _11(n3) {
    return Number(n3 == 1 || n3 == 11 ? 0 : n3 == 2 || n3 == 12 ? 1 : n3 > 2 && n3 < 20 ? 2 : 3);
  },
  12: function _12(n3) {
    return Number(n3 % 10 != 1 || n3 % 100 == 11);
  },
  13: function _13(n3) {
    return Number(n3 !== 0);
  },
  14: function _14(n3) {
    return Number(n3 == 1 ? 0 : n3 == 2 ? 1 : n3 == 3 ? 2 : 3);
  },
  15: function _15(n3) {
    return Number(n3 % 10 == 1 && n3 % 100 != 11 ? 0 : n3 % 10 >= 2 && (n3 % 100 < 10 || n3 % 100 >= 20) ? 1 : 2);
  },
  16: function _16(n3) {
    return Number(n3 % 10 == 1 && n3 % 100 != 11 ? 0 : n3 !== 0 ? 1 : 2);
  },
  17: function _17(n3) {
    return Number(n3 == 1 || n3 % 10 == 1 && n3 % 100 != 11 ? 0 : 1);
  },
  18: function _18(n3) {
    return Number(n3 == 0 ? 0 : n3 == 1 ? 1 : 2);
  },
  19: function _19(n3) {
    return Number(n3 == 1 ? 0 : n3 == 0 || n3 % 100 > 1 && n3 % 100 < 11 ? 1 : n3 % 100 > 10 && n3 % 100 < 20 ? 2 : 3);
  },
  20: function _20(n3) {
    return Number(n3 == 1 ? 0 : n3 == 0 || n3 % 100 > 0 && n3 % 100 < 20 ? 1 : 2);
  },
  21: function _21(n3) {
    return Number(n3 % 100 == 1 ? 1 : n3 % 100 == 2 ? 2 : n3 % 100 == 3 || n3 % 100 == 4 ? 3 : 0);
  },
  22: function _22(n3) {
    return Number(n3 == 1 ? 0 : n3 == 2 ? 1 : (n3 < 0 || n3 > 10) && n3 % 10 == 0 ? 2 : 3);
  }
};
function createRules() {
  var rules = {};
  sets.forEach(function(set3) {
    set3.lngs.forEach(function(l) {
      rules[l] = {
        numbers: set3.nr,
        plurals: _rulesPluralsTypes[set3.fc]
      };
    });
  });
  return rules;
}
var PluralResolver = function() {
  function PluralResolver2(languageUtils) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, PluralResolver2);
    this.languageUtils = languageUtils;
    this.options = options2;
    this.logger = baseLogger.create("pluralResolver");
    this.rules = createRules();
  }
  _createClass(PluralResolver2, [{
    key: "addRule",
    value: function addRule(lng, obj) {
      this.rules[lng] = obj;
    }
  }, {
    key: "getRule",
    value: function getRule(code) {
      return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
    }
  }, {
    key: "needsPlural",
    value: function needsPlural(code) {
      var rule = this.getRule(code);
      return rule && rule.numbers.length > 1;
    }
  }, {
    key: "getPluralFormsOfKey",
    value: function getPluralFormsOfKey(code, key) {
      return this.getSuffixes(code).map(function(suffix) {
        return key + suffix;
      });
    }
  }, {
    key: "getSuffixes",
    value: function getSuffixes(code) {
      var _this = this;
      var rule = this.getRule(code);
      if (!rule) {
        return [];
      }
      return rule.numbers.map(function(number4) {
        return _this.getSuffix(code, number4);
      });
    }
  }, {
    key: "getSuffix",
    value: function getSuffix(code, count) {
      var _this2 = this;
      var rule = this.getRule(code);
      if (rule) {
        var idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
        var suffix = rule.numbers[idx];
        if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
          if (suffix === 2) {
            suffix = "plural";
          } else if (suffix === 1) {
            suffix = "";
          }
        }
        var returnSuffix = function returnSuffix2() {
          return _this2.options.prepend && suffix.toString() ? _this2.options.prepend + suffix.toString() : suffix.toString();
        };
        if (this.options.compatibilityJSON === "v1") {
          if (suffix === 1) return "";
          if (typeof suffix === "number") return "_plural_".concat(suffix.toString());
          return returnSuffix();
        } else if (this.options.compatibilityJSON === "v2") {
          return returnSuffix();
        } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
          return returnSuffix();
        }
        return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
      }
      this.logger.warn("no plural rule found for: ".concat(code));
      return "";
    }
  }]);
  return PluralResolver2;
}();
var Interpolator = function() {
  function Interpolator2() {
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    _classCallCheck(this, Interpolator2);
    this.logger = baseLogger.create("interpolator");
    this.options = options2;
    this.format = options2.interpolation && options2.interpolation.format || function(value) {
      return value;
    };
    this.init(options2);
  }
  _createClass(Interpolator2, [{
    key: "init",
    value: function init() {
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      if (!options2.interpolation) options2.interpolation = {
        escapeValue: true
      };
      var iOpts = options2.interpolation;
      this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape;
      this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
      this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
      this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
      this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
      this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
      this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
      this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
      this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
      this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
      this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
      this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
      this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : false;
      this.resetRegExp();
    }
  }, {
    key: "reset",
    value: function reset2() {
      if (this.options) this.init(this.options);
    }
  }, {
    key: "resetRegExp",
    value: function resetRegExp() {
      var regexpStr = "".concat(this.prefix, "(.+?)").concat(this.suffix);
      this.regexp = new RegExp(regexpStr, "g");
      var regexpUnescapeStr = "".concat(this.prefix).concat(this.unescapePrefix, "(.+?)").concat(this.unescapeSuffix).concat(this.suffix);
      this.regexpUnescape = new RegExp(regexpUnescapeStr, "g");
      var nestingRegexpStr = "".concat(this.nestingPrefix, "(.+?)").concat(this.nestingSuffix);
      this.nestingRegexp = new RegExp(nestingRegexpStr, "g");
    }
  }, {
    key: "interpolate",
    value: function interpolate2(str, data3, lng, options2) {
      var _this = this;
      var match;
      var value;
      var replaces;
      var defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
      function regexSafe(val2) {
        return val2.replace(/\$/g, "$$$$");
      }
      var handleFormat = function handleFormat2(key) {
        if (key.indexOf(_this.formatSeparator) < 0) {
          var path2 = getPathWithDefaults(data3, defaultData, key);
          return _this.alwaysFormat ? _this.format(path2, void 0, lng) : path2;
        }
        var p2 = key.split(_this.formatSeparator);
        var k = p2.shift().trim();
        var f = p2.join(_this.formatSeparator).trim();
        return _this.format(getPathWithDefaults(data3, defaultData, k), f, lng, options2);
      };
      this.resetRegExp();
      var missingInterpolationHandler = options2 && options2.missingInterpolationHandler || this.options.missingInterpolationHandler;
      var skipOnVariables = options2 && options2.interpolation && options2.interpolation.skipOnVariables || this.options.interpolation.skipOnVariables;
      var todos = [{
        regex: this.regexpUnescape,
        safeValue: function safeValue(val2) {
          return regexSafe(val2);
        }
      }, {
        regex: this.regexp,
        safeValue: function safeValue(val2) {
          return _this.escapeValue ? regexSafe(_this.escape(val2)) : regexSafe(val2);
        }
      }];
      todos.forEach(function(todo) {
        replaces = 0;
        while (match = todo.regex.exec(str)) {
          value = handleFormat(match[1].trim());
          if (value === void 0) {
            if (typeof missingInterpolationHandler === "function") {
              var temp = missingInterpolationHandler(str, match, options2);
              value = typeof temp === "string" ? temp : "";
            } else if (skipOnVariables) {
              value = match[0];
              continue;
            } else {
              _this.logger.warn("missed to pass in variable ".concat(match[1], " for interpolating ").concat(str));
              value = "";
            }
          } else if (typeof value !== "string" && !_this.useRawValueToEscape) {
            value = makeString(value);
          }
          str = str.replace(match[0], todo.safeValue(value));
          todo.regex.lastIndex = 0;
          replaces++;
          if (replaces >= _this.maxReplaces) {
            break;
          }
        }
      });
      return str;
    }
  }, {
    key: "nest",
    value: function nest(str, fc) {
      var _this2 = this;
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var match;
      var value;
      var clonedOptions = _objectSpread({}, options2);
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      function handleHasOptions(key, inheritedOptions) {
        var sep = this.nestingOptionsSeparator;
        if (key.indexOf(sep) < 0) return key;
        var c4 = key.split(new RegExp("".concat(sep, "[ ]*{")));
        var optionsString = "{".concat(c4[1]);
        key = c4[0];
        optionsString = this.interpolate(optionsString, clonedOptions);
        optionsString = optionsString.replace(/'/g, '"');
        try {
          clonedOptions = JSON.parse(optionsString);
          if (inheritedOptions) clonedOptions = _objectSpread({}, inheritedOptions, clonedOptions);
        } catch (e2) {
          this.logger.warn("failed parsing options string in nesting for key ".concat(key), e2);
          return "".concat(key).concat(sep).concat(optionsString);
        }
        delete clonedOptions.defaultValue;
        return key;
      }
      while (match = this.nestingRegexp.exec(str)) {
        var formatters = [];
        var doReduce = false;
        if (match[0].includes(this.formatSeparator) && !/{.*}/.test(match[1])) {
          var r = match[1].split(this.formatSeparator).map(function(elem) {
            return elem.trim();
          });
          match[1] = r.shift();
          formatters = r;
          doReduce = true;
        }
        value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
        if (value && match[0] === str && typeof value !== "string") return value;
        if (typeof value !== "string") value = makeString(value);
        if (!value) {
          this.logger.warn("missed to resolve ".concat(match[1], " for nesting ").concat(str));
          value = "";
        }
        if (doReduce) {
          value = formatters.reduce(function(v, f) {
            return _this2.format(v, f, options2.lng, options2);
          }, value.trim());
        }
        str = str.replace(match[0], value);
        this.regexp.lastIndex = 0;
      }
      return str;
    }
  }]);
  return Interpolator2;
}();
function remove(arr2, what) {
  var found = arr2.indexOf(what);
  while (found !== -1) {
    arr2.splice(found, 1);
    found = arr2.indexOf(what);
  }
}
var Connector = function(_EventEmitter) {
  _inherits(Connector2, _EventEmitter);
  function Connector2(backend, store, services) {
    var _this;
    var options2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    _classCallCheck(this, Connector2);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(Connector2).call(this));
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.backend = backend;
    _this.store = store;
    _this.services = services;
    _this.languageUtils = services.languageUtils;
    _this.options = options2;
    _this.logger = baseLogger.create("backendConnector");
    _this.state = {};
    _this.queue = [];
    if (_this.backend && _this.backend.init) {
      _this.backend.init(services, options2.backend, options2);
    }
    return _this;
  }
  _createClass(Connector2, [{
    key: "queueLoad",
    value: function queueLoad(languages2, namespaces, options2, callback) {
      var _this2 = this;
      var toLoad = [];
      var pending = [];
      var toLoadLanguages = [];
      var toLoadNamespaces = [];
      languages2.forEach(function(lng) {
        var hasAllNamespaces = true;
        namespaces.forEach(function(ns) {
          var name = "".concat(lng, "|").concat(ns);
          if (!options2.reload && _this2.store.hasResourceBundle(lng, ns)) {
            _this2.state[name] = 2;
          } else if (_this2.state[name] < 0) ;
          else if (_this2.state[name] === 1) {
            if (pending.indexOf(name) < 0) pending.push(name);
          } else {
            _this2.state[name] = 1;
            hasAllNamespaces = false;
            if (pending.indexOf(name) < 0) pending.push(name);
            if (toLoad.indexOf(name) < 0) toLoad.push(name);
            if (toLoadNamespaces.indexOf(ns) < 0) toLoadNamespaces.push(ns);
          }
        });
        if (!hasAllNamespaces) toLoadLanguages.push(lng);
      });
      if (toLoad.length || pending.length) {
        this.queue.push({
          pending,
          loaded: {},
          errors: [],
          callback
        });
      }
      return {
        toLoad,
        pending,
        toLoadLanguages,
        toLoadNamespaces
      };
    }
  }, {
    key: "loaded",
    value: function loaded(name, err2, data3) {
      var s = name.split("|");
      var lng = s[0];
      var ns = s[1];
      if (err2) this.emit("failedLoading", lng, ns, err2);
      if (data3) {
        this.store.addResourceBundle(lng, ns, data3);
      }
      this.state[name] = err2 ? -1 : 2;
      var loaded2 = {};
      this.queue.forEach(function(q) {
        pushPath(q.loaded, [lng], ns);
        remove(q.pending, name);
        if (err2) q.errors.push(err2);
        if (q.pending.length === 0 && !q.done) {
          Object.keys(q.loaded).forEach(function(l) {
            if (!loaded2[l]) loaded2[l] = [];
            if (q.loaded[l].length) {
              q.loaded[l].forEach(function(ns2) {
                if (loaded2[l].indexOf(ns2) < 0) loaded2[l].push(ns2);
              });
            }
          });
          q.done = true;
          if (q.errors.length) {
            q.callback(q.errors);
          } else {
            q.callback();
          }
        }
      });
      this.emit("loaded", loaded2);
      this.queue = this.queue.filter(function(q) {
        return !q.done;
      });
    }
  }, {
    key: "read",
    value: function read2(lng, ns, fcName) {
      var _this3 = this;
      var tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
      var wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 350;
      var callback = arguments.length > 5 ? arguments[5] : void 0;
      if (!lng.length) return callback(null, {});
      return this.backend[fcName](lng, ns, function(err2, data3) {
        if (err2 && data3 && tried < 5) {
          setTimeout(function() {
            _this3.read.call(_this3, lng, ns, fcName, tried + 1, wait * 2, callback);
          }, wait);
          return;
        }
        callback(err2, data3);
      });
    }
  }, {
    key: "prepareLoading",
    value: function prepareLoading(languages2, namespaces) {
      var _this4 = this;
      var options2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var callback = arguments.length > 3 ? arguments[3] : void 0;
      if (!this.backend) {
        this.logger.warn("No backend was added via i18next.use. Will not load resources.");
        return callback && callback();
      }
      if (typeof languages2 === "string") languages2 = this.languageUtils.toResolveHierarchy(languages2);
      if (typeof namespaces === "string") namespaces = [namespaces];
      var toLoad = this.queueLoad(languages2, namespaces, options2, callback);
      if (!toLoad.toLoad.length) {
        if (!toLoad.pending.length) callback();
        return null;
      }
      toLoad.toLoad.forEach(function(name) {
        _this4.loadOne(name);
      });
    }
  }, {
    key: "load",
    value: function load(languages2, namespaces, callback) {
      this.prepareLoading(languages2, namespaces, {}, callback);
    }
  }, {
    key: "reload",
    value: function reload(languages2, namespaces, callback) {
      this.prepareLoading(languages2, namespaces, {
        reload: true
      }, callback);
    }
  }, {
    key: "loadOne",
    value: function loadOne(name) {
      var _this5 = this;
      var prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var s = name.split("|");
      var lng = s[0];
      var ns = s[1];
      this.read(lng, ns, "read", void 0, void 0, function(err2, data3) {
        if (err2) _this5.logger.warn("".concat(prefix, "loading namespace ").concat(ns, " for language ").concat(lng, " failed"), err2);
        if (!err2 && data3) _this5.logger.log("".concat(prefix, "loaded namespace ").concat(ns, " for language ").concat(lng), data3);
        _this5.loaded(name, err2, data3);
      });
    }
  }, {
    key: "saveMissing",
    value: function saveMissing(languages2, namespace, key, fallbackValue, isUpdate) {
      var options2 = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
      if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
        this.logger.warn('did not save key "'.concat(key, '" as the namespace "').concat(namespace, '" was not yet loaded'), "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        return;
      }
      if (key === void 0 || key === null || key === "") return;
      if (this.backend && this.backend.create) {
        this.backend.create(languages2, namespace, key, fallbackValue, null, _objectSpread({}, options2, {
          isUpdate
        }));
      }
      if (!languages2 || !languages2[0]) return;
      this.store.addResource(languages2[0], namespace, key, fallbackValue);
    }
  }]);
  return Connector2;
}(EventEmitter);
function get2() {
  return {
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    whitelist: false,
    nonExplicitWhitelist: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: true,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle2(args) {
      var ret = {};
      if (_typeof(args[1]) === "object") ret = args[1];
      if (typeof args[1] === "string") ret.defaultValue = args[1];
      if (typeof args[2] === "string") ret.tDescription = args[2];
      if (_typeof(args[2]) === "object" || _typeof(args[3]) === "object") {
        var options2 = args[3] || args[2];
        Object.keys(options2).forEach(function(key) {
          ret[key] = options2[key];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: function format(value, _format, lng, options2) {
        return value;
      },
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: false
    }
  };
}
function transformOptions(options2) {
  if (typeof options2.ns === "string") options2.ns = [options2.ns];
  if (typeof options2.fallbackLng === "string") options2.fallbackLng = [options2.fallbackLng];
  if (typeof options2.fallbackNS === "string") options2.fallbackNS = [options2.fallbackNS];
  if (options2.whitelist) {
    if (options2.whitelist && options2.whitelist.indexOf("cimode") < 0) {
      options2.whitelist = options2.whitelist.concat(["cimode"]);
    }
    options2.supportedLngs = options2.whitelist;
  }
  if (options2.nonExplicitWhitelist) {
    options2.nonExplicitSupportedLngs = options2.nonExplicitWhitelist;
  }
  if (options2.supportedLngs && options2.supportedLngs.indexOf("cimode") < 0) {
    options2.supportedLngs = options2.supportedLngs.concat(["cimode"]);
  }
  return options2;
}
function noop() {
}
var I18n = function(_EventEmitter) {
  _inherits(I18n2, _EventEmitter);
  function I18n2() {
    var _this;
    var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var callback = arguments.length > 1 ? arguments[1] : void 0;
    _classCallCheck(this, I18n2);
    _this = _possibleConstructorReturn(this, _getPrototypeOf(I18n2).call(this));
    if (isIE10) {
      EventEmitter.call(_assertThisInitialized(_this));
    }
    _this.options = transformOptions(options2);
    _this.services = {};
    _this.logger = baseLogger;
    _this.modules = {
      external: []
    };
    if (callback && !_this.isInitialized && !options2.isClone) {
      if (!_this.options.initImmediate) {
        _this.init(options2, callback);
        return _possibleConstructorReturn(_this, _assertThisInitialized(_this));
      }
      setTimeout(function() {
        _this.init(options2, callback);
      }, 0);
    }
    return _this;
  }
  _createClass(I18n2, [{
    key: "init",
    value: function init() {
      var _this2 = this;
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : void 0;
      if (typeof options2 === "function") {
        callback = options2;
        options2 = {};
      }
      if (options2.whitelist && !options2.supportedLngs) {
        this.logger.deprecate("whitelist", 'option "whitelist" will be renamed to "supportedLngs" in the next major - please make sure to rename this option asap.');
      }
      if (options2.nonExplicitWhitelist && !options2.nonExplicitSupportedLngs) {
        this.logger.deprecate("whitelist", 'options "nonExplicitWhitelist" will be renamed to "nonExplicitSupportedLngs" in the next major - please make sure to rename this option asap.');
      }
      this.options = _objectSpread({}, get2(), this.options, transformOptions(options2));
      this.format = this.options.interpolation.format;
      if (!callback) callback = noop;
      function createClassOnDemand(ClassOrObject) {
        if (!ClassOrObject) return null;
        if (typeof ClassOrObject === "function") return new ClassOrObject();
        return ClassOrObject;
      }
      if (!this.options.isClone) {
        if (this.modules.logger) {
          baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
        } else {
          baseLogger.init(null, this.options);
        }
        var lu = new LanguageUtil(this.options);
        this.store = new ResourceStore(this.options.resources, this.options);
        var s = this.services;
        s.logger = baseLogger;
        s.resourceStore = this.store;
        s.languageUtils = lu;
        s.pluralResolver = new PluralResolver(lu, {
          prepend: this.options.pluralSeparator,
          compatibilityJSON: this.options.compatibilityJSON,
          simplifyPluralSuffix: this.options.simplifyPluralSuffix
        });
        s.interpolator = new Interpolator(this.options);
        s.utils = {
          hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
        };
        s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
        s.backendConnector.on("*", function(event) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        if (this.modules.languageDetector) {
          s.languageDetector = createClassOnDemand(this.modules.languageDetector);
          s.languageDetector.init(s, this.options.detection, this.options);
        }
        if (this.modules.i18nFormat) {
          s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
          if (s.i18nFormat.init) s.i18nFormat.init(this);
        }
        this.translator = new Translator(this.services, this.options);
        this.translator.on("*", function(event) {
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          _this2.emit.apply(_this2, [event].concat(args));
        });
        this.modules.external.forEach(function(m3) {
          if (m3.init) m3.init(_this2);
        });
      }
      if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
        var codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        if (codes.length > 0 && codes[0] !== "dev") this.options.lng = codes[0];
      }
      if (!this.services.languageDetector && !this.options.lng) {
        this.logger.warn("init: no languageDetector is used and no lng is defined");
      }
      var storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
      storeApi.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store;
          return (_this2$store = _this2.store)[fcName].apply(_this2$store, arguments);
        };
      });
      var storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
      storeApiChained.forEach(function(fcName) {
        _this2[fcName] = function() {
          var _this2$store2;
          (_this2$store2 = _this2.store)[fcName].apply(_this2$store2, arguments);
          return _this2;
        };
      });
      var deferred = defer();
      var load = function load2() {
        var finish = function finish2(err2, t) {
          if (_this2.isInitialized) _this2.logger.warn("init: i18next is already initialized. You should call init just once!");
          _this2.isInitialized = true;
          if (!_this2.options.isClone) _this2.logger.log("initialized", _this2.options);
          _this2.emit("initialized", _this2.options);
          deferred.resolve(t);
          callback(err2, t);
        };
        if (_this2.languages && _this2.options.compatibilityAPI !== "v1" && !_this2.isInitialized) return finish(null, _this2.t.bind(_this2));
        _this2.changeLanguage(_this2.options.lng, finish);
      };
      if (this.options.resources || !this.options.initImmediate) {
        load();
      } else {
        setTimeout(load, 0);
      }
      return deferred;
    }
  }, {
    key: "loadResources",
    value: function loadResources(language) {
      var _this3 = this;
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
      var usedCallback = callback;
      var usedLng = typeof language === "string" ? language : this.language;
      if (typeof language === "function") usedCallback = language;
      if (!this.options.resources || this.options.partialBundledLanguages) {
        if (usedLng && usedLng.toLowerCase() === "cimode") return usedCallback();
        var toLoad = [];
        var append = function append2(lng) {
          if (!lng) return;
          var lngs = _this3.services.languageUtils.toResolveHierarchy(lng);
          lngs.forEach(function(l) {
            if (toLoad.indexOf(l) < 0) toLoad.push(l);
          });
        };
        if (!usedLng) {
          var fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
          fallbacks.forEach(function(l) {
            return append(l);
          });
        } else {
          append(usedLng);
        }
        if (this.options.preload) {
          this.options.preload.forEach(function(l) {
            return append(l);
          });
        }
        this.services.backendConnector.load(toLoad, this.options.ns, usedCallback);
      } else {
        usedCallback(null);
      }
    }
  }, {
    key: "reloadResources",
    value: function reloadResources(lngs, ns, callback) {
      var deferred = defer();
      if (!lngs) lngs = this.languages;
      if (!ns) ns = this.options.ns;
      if (!callback) callback = noop;
      this.services.backendConnector.reload(lngs, ns, function(err2) {
        deferred.resolve();
        callback(err2);
      });
      return deferred;
    }
  }, {
    key: "use",
    value: function use(module) {
      if (!module) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!module.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      if (module.type === "backend") {
        this.modules.backend = module;
      }
      if (module.type === "logger" || module.log && module.warn && module.error) {
        this.modules.logger = module;
      }
      if (module.type === "languageDetector") {
        this.modules.languageDetector = module;
      }
      if (module.type === "i18nFormat") {
        this.modules.i18nFormat = module;
      }
      if (module.type === "postProcessor") {
        postProcessor.addPostProcessor(module);
      }
      if (module.type === "3rdParty") {
        this.modules.external.push(module);
      }
      return this;
    }
  }, {
    key: "changeLanguage",
    value: function changeLanguage(lng, callback) {
      var _this4 = this;
      this.isLanguageChangingTo = lng;
      var deferred = defer();
      this.emit("languageChanging", lng);
      var done = function done2(err2, l) {
        if (l) {
          _this4.language = l;
          _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
          _this4.translator.changeLanguage(l);
          _this4.isLanguageChangingTo = void 0;
          _this4.emit("languageChanged", l);
          _this4.logger.log("languageChanged", l);
        } else {
          _this4.isLanguageChangingTo = void 0;
        }
        deferred.resolve(function() {
          return _this4.t.apply(_this4, arguments);
        });
        if (callback) callback(err2, function() {
          return _this4.t.apply(_this4, arguments);
        });
      };
      var setLng = function setLng2(lngs) {
        var l = typeof lngs === "string" ? lngs : _this4.services.languageUtils.getBestMatchFromCodes(lngs);
        if (l) {
          if (!_this4.language) {
            _this4.language = l;
            _this4.languages = _this4.services.languageUtils.toResolveHierarchy(l);
          }
          if (!_this4.translator.language) _this4.translator.changeLanguage(l);
          if (_this4.services.languageDetector) _this4.services.languageDetector.cacheUserLanguage(l);
        }
        _this4.loadResources(l, function(err2) {
          done(err2, l);
        });
      };
      if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
        setLng(this.services.languageDetector.detect());
      } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
        this.services.languageDetector.detect(setLng);
      } else {
        setLng(lng);
      }
      return deferred;
    }
  }, {
    key: "getFixedT",
    value: function getFixedT(lng, ns) {
      var _this5 = this;
      var fixedT = function fixedT2(key, opts) {
        var options2;
        if (_typeof(opts) !== "object") {
          for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
            rest[_key3 - 2] = arguments[_key3];
          }
          options2 = _this5.options.overloadTranslationOptionHandler([key, opts].concat(rest));
        } else {
          options2 = _objectSpread({}, opts);
        }
        options2.lng = options2.lng || fixedT2.lng;
        options2.lngs = options2.lngs || fixedT2.lngs;
        options2.ns = options2.ns || fixedT2.ns;
        return _this5.t(key, options2);
      };
      if (typeof lng === "string") {
        fixedT.lng = lng;
      } else {
        fixedT.lngs = lng;
      }
      fixedT.ns = ns;
      return fixedT;
    }
  }, {
    key: "t",
    value: function t() {
      var _this$translator;
      return this.translator && (_this$translator = this.translator).translate.apply(_this$translator, arguments);
    }
  }, {
    key: "exists",
    value: function exists() {
      var _this$translator2;
      return this.translator && (_this$translator2 = this.translator).exists.apply(_this$translator2, arguments);
    }
  }, {
    key: "setDefaultNamespace",
    value: function setDefaultNamespace(ns) {
      this.options.defaultNS = ns;
    }
  }, {
    key: "hasLoadedNamespace",
    value: function hasLoadedNamespace(ns) {
      var _this6 = this;
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.isInitialized) {
        this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
        return false;
      }
      if (!this.languages || !this.languages.length) {
        this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
        return false;
      }
      var lng = this.languages[0];
      var fallbackLng = this.options ? this.options.fallbackLng : false;
      var lastLng = this.languages[this.languages.length - 1];
      if (lng.toLowerCase() === "cimode") return true;
      var loadNotPending = function loadNotPending2(l, n3) {
        var loadState = _this6.services.backendConnector.state["".concat(l, "|").concat(n3)];
        return loadState === -1 || loadState === 2;
      };
      if (options2.precheck) {
        var preResult = options2.precheck(this, loadNotPending);
        if (preResult !== void 0) return preResult;
      }
      if (this.hasResourceBundle(lng, ns)) return true;
      if (!this.services.backendConnector.backend) return true;
      if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
      return false;
    }
  }, {
    key: "loadNamespaces",
    value: function loadNamespaces(ns, callback) {
      var _this7 = this;
      var deferred = defer();
      if (!this.options.ns) {
        callback && callback();
        return Promise.resolve();
      }
      if (typeof ns === "string") ns = [ns];
      ns.forEach(function(n3) {
        if (_this7.options.ns.indexOf(n3) < 0) _this7.options.ns.push(n3);
      });
      this.loadResources(function(err2) {
        deferred.resolve();
        if (callback) callback(err2);
      });
      return deferred;
    }
  }, {
    key: "loadLanguages",
    value: function loadLanguages(lngs, callback) {
      var deferred = defer();
      if (typeof lngs === "string") lngs = [lngs];
      var preloaded = this.options.preload || [];
      var newLngs = lngs.filter(function(lng) {
        return preloaded.indexOf(lng) < 0;
      });
      if (!newLngs.length) {
        if (callback) callback();
        return Promise.resolve();
      }
      this.options.preload = preloaded.concat(newLngs);
      this.loadResources(function(err2) {
        deferred.resolve();
        if (callback) callback(err2);
      });
      return deferred;
    }
  }, {
    key: "dir",
    value: function dir(lng) {
      if (!lng) lng = this.languages && this.languages.length > 0 ? this.languages[0] : this.language;
      if (!lng) return "rtl";
      var rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam"];
      return rtlLngs.indexOf(this.services.languageUtils.getLanguagePartFromCode(lng)) >= 0 ? "rtl" : "ltr";
    }
  }, {
    key: "createInstance",
    value: function createInstance() {
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 ? arguments[1] : void 0;
      return new I18n2(options2, callback);
    }
  }, {
    key: "cloneInstance",
    value: function cloneInstance() {
      var _this8 = this;
      var options2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
      var mergedOptions = _objectSpread({}, this.options, options2, {
        isClone: true
      });
      var clone3 = new I18n2(mergedOptions);
      var membersToCopy = ["store", "services", "language"];
      membersToCopy.forEach(function(m3) {
        clone3[m3] = _this8[m3];
      });
      clone3.services = _objectSpread({}, this.services);
      clone3.services.utils = {
        hasLoadedNamespace: clone3.hasLoadedNamespace.bind(clone3)
      };
      clone3.translator = new Translator(clone3.services, clone3.options);
      clone3.translator.on("*", function(event) {
        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          args[_key4 - 1] = arguments[_key4];
        }
        clone3.emit.apply(clone3, [event].concat(args));
      });
      clone3.init(mergedOptions, callback);
      clone3.translator.options = clone3.options;
      clone3.translator.backendConnector.services.utils = {
        hasLoadedNamespace: clone3.hasLoadedNamespace.bind(clone3)
      };
      return clone3;
    }
  }]);
  return I18n2;
}(EventEmitter);
var i18next = new I18n();
var i18next_default = i18next;

// node_modules/i18next-browser-languagedetector/dist/esm/i18nextBrowserLanguageDetector.js
var arr = [];
var each = arr.forEach;
var slice = arr.slice;
function defaults(obj) {
  each.call(slice.call(arguments, 1), function(source) {
    if (source) {
      for (var prop in source) {
        if (obj[prop] === void 0) obj[prop] = source[prop];
      }
    }
  });
  return obj;
}
var cookie = {
  create: function create(name, value, minutes, domain2) {
    var cookieOptions = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      path: "/"
    };
    var expires;
    if (minutes) {
      var date5 = /* @__PURE__ */ new Date();
      date5.setTime(date5.getTime() + minutes * 60 * 1e3);
      expires = "; expires=" + date5.toUTCString();
    } else expires = "";
    domain2 = domain2 ? "domain=" + domain2 + ";" : "";
    cookieOptions = Object.keys(cookieOptions).reduce(function(acc, key) {
      return acc + ";" + key.replace(/([A-Z])/g, function($1) {
        return "-" + $1.toLowerCase();
      }) + "=" + cookieOptions[key];
    }, "");
    document.cookie = name + "=" + encodeURIComponent(value) + expires + ";" + domain2 + cookieOptions;
  },
  read: function read(name) {
    var nameEQ = name + "=";
    var ca = document.cookie.split(";");
    for (var i = 0; i < ca.length; i++) {
      var c4 = ca[i];
      while (c4.charAt(0) === " ") {
        c4 = c4.substring(1, c4.length);
      }
      if (c4.indexOf(nameEQ) === 0) return c4.substring(nameEQ.length, c4.length);
    }
    return null;
  },
  remove: function remove2(name) {
    this.create(name, "", -1);
  }
};
var cookie$1 = {
  name: "cookie",
  lookup: function lookup(options2) {
    var found;
    if (options2.lookupCookie && typeof document !== "undefined") {
      var c4 = cookie.read(options2.lookupCookie);
      if (c4) found = c4;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage(lng, options2) {
    if (options2.lookupCookie && typeof document !== "undefined") {
      cookie.create(options2.lookupCookie, lng, options2.cookieMinutes, options2.cookieDomain, options2.cookieOptions);
    }
  }
};
var querystring = {
  name: "querystring",
  lookup: function lookup2(options2) {
    var found;
    if (typeof window !== "undefined") {
      var query = window.location.search.substring(1);
      var params = query.split("&");
      for (var i = 0; i < params.length; i++) {
        var pos = params[i].indexOf("=");
        if (pos > 0) {
          var key = params[i].substring(0, pos);
          if (key === options2.lookupQuerystring) {
            found = params[i].substring(pos + 1);
          }
        }
      }
    }
    return found;
  }
};
var hasLocalStorageSupport;
try {
  hasLocalStorageSupport = window !== "undefined" && window.localStorage !== null;
  testKey = "i18next.translate.boo";
  window.localStorage.setItem(testKey, "foo");
  window.localStorage.removeItem(testKey);
} catch (e2) {
  hasLocalStorageSupport = false;
}
var testKey;
var localStorage2 = {
  name: "localStorage",
  lookup: function lookup3(options2) {
    var found;
    if (options2.lookupLocalStorage && hasLocalStorageSupport) {
      var lng = window.localStorage.getItem(options2.lookupLocalStorage);
      if (lng) found = lng;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage2(lng, options2) {
    if (options2.lookupLocalStorage && hasLocalStorageSupport) {
      window.localStorage.setItem(options2.lookupLocalStorage, lng);
    }
  }
};
var hasSessionStorageSupport;
try {
  hasSessionStorageSupport = window !== "undefined" && window.sessionStorage !== null;
  testKey$1 = "i18next.translate.boo";
  window.sessionStorage.setItem(testKey$1, "foo");
  window.sessionStorage.removeItem(testKey$1);
} catch (e2) {
  hasSessionStorageSupport = false;
}
var testKey$1;
var sessionStorage = {
  name: "sessionStorage",
  lookup: function lookup4(options2) {
    var found;
    if (options2.lookupsessionStorage && hasSessionStorageSupport) {
      var lng = window.sessionStorage.getItem(options2.lookupsessionStorage);
      if (lng) found = lng;
    }
    return found;
  },
  cacheUserLanguage: function cacheUserLanguage3(lng, options2) {
    if (options2.lookupsessionStorage && hasSessionStorageSupport) {
      window.sessionStorage.setItem(options2.lookupsessionStorage, lng);
    }
  }
};
var navigator$1 = {
  name: "navigator",
  lookup: function lookup5(options2) {
    var found = [];
    if (typeof navigator !== "undefined") {
      if (navigator.languages) {
        for (var i = 0; i < navigator.languages.length; i++) {
          found.push(navigator.languages[i]);
        }
      }
      if (navigator.userLanguage) {
        found.push(navigator.userLanguage);
      }
      if (navigator.language) {
        found.push(navigator.language);
      }
    }
    return found.length > 0 ? found : void 0;
  }
};
var htmlTag = {
  name: "htmlTag",
  lookup: function lookup6(options2) {
    var found;
    var htmlTag2 = options2.htmlTag || (typeof document !== "undefined" ? document.documentElement : null);
    if (htmlTag2 && typeof htmlTag2.getAttribute === "function") {
      found = htmlTag2.getAttribute("lang");
    }
    return found;
  }
};
var path = {
  name: "path",
  lookup: function lookup7(options2) {
    var found;
    if (typeof window !== "undefined") {
      var language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
      if (language instanceof Array) {
        if (typeof options2.lookupFromPathIndex === "number") {
          if (typeof language[options2.lookupFromPathIndex] !== "string") {
            return void 0;
          }
          found = language[options2.lookupFromPathIndex].replace("/", "");
        } else {
          found = language[0].replace("/", "");
        }
      }
    }
    return found;
  }
};
var subdomain = {
  name: "subdomain",
  lookup: function lookup8(options2) {
    var found;
    if (typeof window !== "undefined") {
      var language = window.location.href.match(/(?:http[s]*\:\/\/)*(.*?)\.(?=[^\/]*\..{2,5})/gi);
      if (language instanceof Array) {
        if (typeof options2.lookupFromSubdomainIndex === "number") {
          found = language[options2.lookupFromSubdomainIndex].replace("http://", "").replace("https://", "").replace(".", "");
        } else {
          found = language[0].replace("http://", "").replace("https://", "").replace(".", "");
        }
      }
    }
    return found;
  }
};
function getDefaults() {
  return {
    order: ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"],
    lookupQuerystring: "lng",
    lookupCookie: "i18next",
    lookupLocalStorage: "i18nextLng",
    // cache user language
    caches: ["localStorage"],
    excludeCacheFor: ["cimode"],
    //cookieMinutes: 10,
    //cookieDomain: 'myDomain'
    checkWhitelist: true,
    checkForSimilarInWhitelist: false
  };
}
var Browser = function() {
  function Browser2(services) {
    var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    _classCallCheck(this, Browser2);
    this.type = "languageDetector";
    this.detectors = {};
    this.init(services, options2);
  }
  _createClass(Browser2, [{
    key: "init",
    value: function init(services) {
      var options2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var i18nOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      this.services = services;
      this.options = defaults(options2, this.options || {}, getDefaults());
      if (this.options.checkForSimilarInWhitelist) this.options.checkWhitelist = true;
      if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;
      this.i18nOptions = i18nOptions;
      this.addDetector(cookie$1);
      this.addDetector(querystring);
      this.addDetector(localStorage2);
      this.addDetector(sessionStorage);
      this.addDetector(navigator$1);
      this.addDetector(htmlTag);
      this.addDetector(path);
      this.addDetector(subdomain);
    }
  }, {
    key: "addDetector",
    value: function addDetector(detector) {
      this.detectors[detector.name] = detector;
    }
  }, {
    key: "detect",
    value: function detect(detectionOrder) {
      var _this = this;
      if (!detectionOrder) detectionOrder = this.options.order;
      var detected = [];
      detectionOrder.forEach(function(detectorName) {
        if (_this.detectors[detectorName]) {
          var lookup9 = _this.detectors[detectorName].lookup(_this.options);
          if (lookup9 && typeof lookup9 === "string") lookup9 = [lookup9];
          if (lookup9) detected = detected.concat(lookup9);
        }
      });
      var found;
      detected.forEach(function(lng) {
        if (found) return;
        var cleanedLng = _this.services.languageUtils.formatLanguageCode(lng);
        if (!_this.options.checkWhitelist || _this.services.languageUtils.isWhitelisted(cleanedLng)) found = cleanedLng;
        if (!found && _this.options.checkForSimilarInWhitelist) {
          found = _this.getSimilarInWhitelist(cleanedLng);
        }
      });
      if (!found) {
        var fallbacks = this.i18nOptions.fallbackLng;
        if (typeof fallbacks === "string") fallbacks = [fallbacks];
        if (!fallbacks) fallbacks = [];
        if (Object.prototype.toString.apply(fallbacks) === "[object Array]") {
          found = fallbacks[0];
        } else {
          found = fallbacks[0] || fallbacks["default"] && fallbacks["default"][0];
        }
      }
      return found;
    }
  }, {
    key: "cacheUserLanguage",
    value: function cacheUserLanguage4(lng, caches) {
      var _this2 = this;
      if (!caches) caches = this.options.caches;
      if (!caches) return;
      if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;
      caches.forEach(function(cacheName) {
        if (_this2.detectors[cacheName]) _this2.detectors[cacheName].cacheUserLanguage(lng, _this2.options);
      });
    }
  }, {
    key: "getSimilarInWhitelist",
    value: function getSimilarInWhitelist(cleanedLng) {
      var _this3 = this;
      if (!this.i18nOptions.whitelist) return;
      if (cleanedLng.includes("-")) {
        var prefix = cleanedLng.split("-")[0];
        var cleanedPrefix = this.services.languageUtils.formatLanguageCode(prefix);
        if (this.services.languageUtils.isWhitelisted(cleanedPrefix)) return cleanedPrefix;
        cleanedLng = cleanedPrefix;
      }
      var similar = this.i18nOptions.whitelist.find(function(whitelistLng) {
        var cleanedWhitelistLng = _this3.services.languageUtils.formatLanguageCode(whitelistLng);
        if (cleanedWhitelistLng.startsWith(cleanedLng)) return cleanedWhitelistLng;
      });
      if (similar) return similar;
    }
  }]);
  return Browser2;
}();
Browser.type = "languageDetector";
var i18nextBrowserLanguageDetector_default = Browser;

// node_modules/p5/dist/core/internationalization.js
var fes = {
  autoplay: "The media that tried to play (with '{{src}}') wasn't allowed to by this browser, most likely due to the browser's autoplay policy.\n\n+ More info: {{url}}",
  checkUserDefinedFns: "It seems that you may have accidentally written {{name}} instead of {{actualName}}. Please correct it if it's not intentional.",
  fileLoadError: {
    bytes: "It looks like there was a problem loading your file. {{suggestion}}",
    font: "It looks like there was a problem loading your font. {{suggestion}}",
    gif: "There was some trouble loading your GIF. Make sure that your GIF is using 87a or 89a encoding.",
    image: "It looks like there was a problem loading your image. {{suggestion}}",
    json: "It looks like there was a problem loading your JSON file. {{suggestion}}",
    large: "If your large file isn't fetched successfully, we recommend splitting the file into smaller segments and fetching those.",
    strings: "It looks like there was a problem loading your text file. {{suggestion}}",
    suggestion: "Try checking if the file path ({{filePath}}) is correct, hosting the file online, or running a local server.\n\n+ More info: {{url}}",
    table: "It looks like there was a problem loading your table file. {{suggestion}}",
    xml: "It looks like there was a problem loading your XML file. {{suggestion}}"
  },
  friendlyParamError: {
    type_EMPTY_VAR: "{{location}} {{func}}() was expecting {{formatType}} for the {{position}} parameter, received an empty variable instead. If not intentional, this is often a problem with scope.\n\n+ More info: {{url}}",
    type_TOO_FEW_ARGUMENTS: "{{location}} {{func}}() was expecting at least {{minParams}} arguments, but received only {{argCount}}.",
    type_TOO_MANY_ARGUMENTS: "{{location}} {{func}}() was expecting no more than {{maxParams}} arguments, but received {{argCount}}.",
    type_WRONG_TYPE: "{{location}} {{func}}() was expecting {{formatType}} for the {{position}} parameter, received {{argType}} instead."
  },
  globalErrors: {
    reference: {
      cannotAccess: '\n{{location}} "{{symbol}}" is used before declaration. Make sure you have declared the variable before using it.\n\n+ More info: {{url}}',
      notDefined: '\n{{location}} "{{symbol}}" is not defined in the current scope. If you have defined it in your code, you should check its scope, spelling, and letter-casing (JavaScript is case-sensitive).\n\n+ More info: {{url}}'
    },
    stackSubseq: "└[{{location}}] \n	 Called from line {{line}} in {{func}}()\n",
    stackTop: "┌[{{location}}] \n	 Error at line {{line}} in {{func}}()\n",
    syntax: {
      badReturnOrYield: "\nSyntax Error - return lies outside of a function. Make sure you’re not missing any brackets, so that return lies inside a function.\n\n+ More info: {{url}}",
      invalidToken: "\nSyntax Error - Found a symbol that JavaScript doesn't recognize or didn't expect at it's place.\n\n+ More info: {{url}}",
      missingInitializer: "\nSyntax Error - A const variable is declared but not initialized. In JavaScript, an initializer for a const is required. A value must be specified in the same statement in which the variable is declared. Check the line number in the error and assign the const variable a value.\n\n+ More info: {{url}}",
      redeclaredVariable: `
Syntax Error - "{{symbol}}" is being redeclared. JavaScript doesn't allow declaring a variable more than once. Check the line number in error for redeclaration of the variable.

+ More info: {{url}}`,
      unexpectedToken: "\nSyntax Error - Symbol present at a place that wasn't expected.\nUsually this is due to a typo. Check the line number in the error for anything missing/extra.\n\n+ More info: {{url}}"
    },
    type: {
      constAssign: "\n{{location}} A const variable is being re-assigned. In javascript, re-assigning a value to a constant is not allowed. If you want to re-assign new values to a variable, make sure it is declared as var or let.\n\n+ More info: {{url}}",
      notfunc: '\n{{location}} "{{symbol}}" could not be called as a function.\nCheck the spelling, letter-casing (JavaScript is case-sensitive) and its type.\n\n+ More info: {{url}}',
      notfuncObj: '\n{{location}} "{{symbol}}" could not be called as a function.\nVerify whether "{{obj}}" has "{{symbol}}" in it and check the spelling, letter-casing (JavaScript is case-sensitive) and its type.\n\n+ More info: {{url}}',
      readFromNull: "\n{{location}} The property of null can't be read. In javascript the value null indicates that an object has no value.\n\n+ More info: {{url}}",
      readFromUndefined: "\n{{location}} Cannot read property of undefined. Check the line number in error and make sure the variable which is being operated is not undefined.\n\n + More info: {{url}}"
    }
  },
  libraryError: '{{location}} An error with message "{{error}}" occurred inside the p5js library when {{func}} was called. If not stated otherwise, it might be an issue with the arguments passed to {{func}}.',
  location: "[{{file}}, line {{line}}]",
  misspelling: '{{location}} It seems that you may have accidentally written "{{name}}" instead of "{{actualName}}". Please correct it to {{actualName}} if you wish to use the {{type}} from p5.js.',
  misspelling_plural: '{{location}} It seems that you may have accidentally written "{{name}}".\nYou may have meant one of the following: \n{{suggestions}}',
  misusedTopLevel: "Did you just try to use p5.js's {{symbolName}} {{symbolType}}? If so, you may want to move it into your sketch's setup() function.\n\n+ More info: {{url}}",
  preloadDisabled: "The preload() function has been removed in p5.js 2.0. Please load assets in setup() using async / await keywords or callbacks instead. See https://dev.to/limzykenneth/asynchronous-p5js-20-458f for more information.",
  positions: {
    p_1: "first",
    p_10: "tenth",
    p_11: "eleventh",
    p_12: "twelfth",
    p_2: "second",
    p_3: "third",
    p_4: "fourth",
    p_5: "fifth",
    p_6: "sixth",
    p_7: "seventh",
    p_8: "eighth",
    p_9: "ninth"
  },
  pre: "\n🌸 p5.js says: {{message}}",
  sketchReaderErrors: {
    reservedConst: 'you have used a p5.js reserved variable "{{symbol}}" make sure you change the variable name to something else.\n\n+ More info: {{url}}',
    reservedFunc: 'you have used a p5.js reserved function "{{symbol}}" make sure you change the function name to something else.\n\n+ More info: {{url}}'
  },
  welcome: "Welcome! This is your friendly debugger. To turn me off, switch to using p5.min.js.",
  wrongPreload: '{{location}} An error with message "{{error}}" occurred inside the p5js library when "{{func}}" was called. If not stated otherwise, it might be due to "{{func}}" being called from preload. Nothing besides load calls (loadImage, loadJSON, loadFont, loadStrings, etc.) should be inside the preload function.'
};
var en = {
  fes
};
var fallbackResources = {
  en: {
    translation: en
  }
};
var languages = [
  "en",
  "es",
  "ko",
  "zh",
  "hi",
  "ja"
];
if (typeof IS_MINIFIED === "undefined") {
  if (typeof P5_DEV_BUILD !== "undefined") {
    let completeResources = (init_dev(), __toCommonJS(dev_exports));
    for (const language of Object.keys(completeResources)) {
      const parts = language.split("_");
      const lng = parts.slice(0, parts.length - 1).join("-");
      const ns = parts[parts.length - 1];
      fallbackResources[lng] = fallbackResources[lng] || {};
      fallbackResources[lng][ns] = completeResources[language];
    }
  }
}
var FetchResources = class {
  constructor(services, options2) {
    this.init(services, options2);
  }
  // run fetch with a timeout. Automatically rejects on timeout
  // default timeout = 2000 ms
  fetchWithTimeout(url2, options2, timeout = 2e3) {
    return Promise.race([
      fetch(url2, options2),
      new Promise(
        (_23, reject) => setTimeout(() => reject(new Error("timeout")), timeout)
      )
    ]);
  }
  init(services, options2 = {}) {
    this.services = services;
    this.options = options2;
  }
  read(language, namespace, callback) {
    const loadPath = this.options.loadPath;
    if (language === this.options.fallback) {
      callback(null, fallbackResources[language][namespace]);
    } else if (languages.includes(language)) {
      const url2 = this.services.interpolator.interpolate(loadPath, {
        lng: language,
        ns: namespace
      });
      this.loadUrl(url2, callback);
    } else {
      callback("Not found", false);
    }
  }
  loadUrl(url2, callback) {
    this.fetchWithTimeout(url2).then(
      (response) => {
        const ok = response.ok;
        if (!ok) {
          throw new Error(`failed loading ${url2}`);
        }
        return response.json();
      },
      () => {
        throw new Error(`failed loading ${url2}`);
      }
    ).then((data3) => {
      return callback(null, data3);
    }).catch(callback);
  }
};
FetchResources.type = "backend";
var translator = (key, values) => {
  console.debug("p5.js translator called before translations were loaded");
  i18next_default.t(key, values);
};
var initialize = () => {
  let i18init = i18next_default.use(i18nextBrowserLanguageDetector_default).use(FetchResources).init({
    fallbackLng: "en",
    nestingPrefix: "$tr(",
    nestingSuffix: ")",
    defaultNS: "translation",
    returnEmptyString: false,
    interpolation: {
      escapeValue: false
    },
    detection: {
      checkWhitelist: false,
      // prevent storing or locating language from cookie or localStorage
      // more info on https://github.com/processing/p5.js/issues/4862
      order: ["querystring", "navigator", "htmlTag", "path", "subdomain"],
      caches: []
    },
    backend: {
      fallback: "en",
      loadPath: "https://cdn.jsdelivr.net/npm/p5/translations/{{lng}}/{{ns}}.json"
    },
    partialBundledLanguages: true,
    resources: fallbackResources
  }).then(
    (translateFn) => {
      translator = translateFn;
    },
    (e2) => console.debug(`Translations failed to load (${e2})`)
  );
  return i18init;
};

// node_modules/p5/dist/core/friendly_errors/browser_errors.js
var strings = {
  ReferenceError: [
    {
      msg: "{{}} is not defined",
      type: "NOTDEFINED",
      browser: "all"
    },
    {
      msg: "Can't find variable: {{}}",
      type: "NOTDEFINED",
      browser: "Safari"
    },
    {
      msg: "Cannot access '{{.}}' before initialization",
      type: "CANNOTACCESS",
      browser: "Chrome"
    },
    {
      msg: "can't access lexical declaration '{{.}}' before initialization",
      type: "CANNOTACCESS",
      browser: "Firefox"
    }
  ],
  SyntaxError: [
    {
      msg: "illegal character",
      type: "INVALIDTOKEN",
      browser: "Firefox"
    },
    {
      msg: "Invalid character",
      type: "INVALIDTOKEN",
      browser: "Safari"
    },
    {
      msg: "Invalid or unexpected token",
      type: "INVALIDTOKEN",
      browser: "Chrome"
    },
    {
      msg: "Unexpected token '{{.}}'",
      type: "UNEXPECTEDTOKEN",
      browser: "Chrome"
    },
    {
      msg: "expected {{.}}, got '{{.}}'",
      type: "UNEXPECTEDTOKEN",
      browser: "Chrome"
    },
    {
      msg: "Identifier '{{.}}' has already been declared",
      type: "REDECLAREDVARIABLE",
      browser: "Chrome"
    },
    {
      msg: "redeclaration of {} {{.}}",
      type: "REDECLAREDVARIABLE",
      browser: "Firefox"
    },
    {
      msg: "Missing initializer in const declaration",
      type: "MISSINGINITIALIZER",
      browser: "Chrome"
    },
    {
      msg: "missing = in const declaration",
      type: "MISSINGINITIALIZER",
      browser: "Firefox"
    },
    {
      msg: "Illegal return statement",
      type: "BADRETURNORYIELD",
      browser: "Chrome"
    },
    {
      msg: "return not in function",
      type: "BADRETURNORYIELD",
      browser: "Firefox"
    }
  ],
  TypeError: [
    {
      msg: "{{.}} is not a function",
      type: "NOTFUNC",
      browser: "all"
    },
    {
      msg: "Cannot read {{.}} null",
      type: "READNULL",
      browser: "Chrome"
    },
    {
      msg: "{{.}} is null",
      type: "READNULL",
      browser: "Firefox"
    },
    {
      msg: "Cannot read {{.}} undefined",
      type: "READUDEFINED",
      browser: "Chrome"
    },
    {
      msg: "{{.}} is undefined",
      type: "READUDEFINED",
      browser: "Firefox"
    },
    {
      msg: "Assignment to constant variable",
      type: "CONSTASSIGN",
      browser: "Chrome"
    },
    {
      msg: "invalid assignment to const '{{.}}'",
      type: "CONSTASSIGN",
      browser: "Firefox"
    }
  ]
};

// node_modules/p5/dist/core/friendly_errors/fes_core.js
function fesCore(p53, fn2) {
  const typeColors = ["#2D7BB6", "#EE9900", "#4DB200", "#C83C00"];
  let misusedAtTopLevelCode = null;
  let defineMisusedAtTopLevelCode = null;
  const EDIT_DIST_THRESHOLD = 2;
  class FESError extends Error {
  }
  if (typeof IS_MINIFIED !== "undefined") {
    p53._friendlyError = p53._checkForUserDefinedFunctions = p53._fesErrorMonitor = () => {
    };
  } else {
    const class2type = {};
    const toString3 = class2type.toString;
    const names = [
      "Boolean",
      "Number",
      "String",
      "Function",
      "Array",
      "Date",
      "RegExp",
      "Object",
      "Error"
    ];
    for (let n3 = 0; n3 < names.length; n3++) {
      class2type[`[object ${names[n3]}]`] = names[n3].toLowerCase();
    }
    const getType = (obj) => {
      if (obj == null) {
        return `${obj}`;
      }
      return typeof obj === "object" || typeof obj === "function" ? class2type[toString3.call(obj)] || "object" : typeof obj;
    };
    const entryPoints = [
      "setup",
      "draw",
      "deviceMoved",
      "deviceTurned",
      "deviceShaken",
      "doubleClicked",
      "mousePressed",
      "mouseReleased",
      "mouseMoved",
      "mouseDragged",
      "mouseClicked",
      "mouseWheel",
      "touchStarted",
      "touchMoved",
      "touchEnded",
      "keyPressed",
      "keyReleased",
      "keyTyped",
      "windowResized"
    ];
    const mapToReference = (message, func) => {
      let msgWithReference = "";
      if (func == null || func.substring(0, 4) === "load") {
        msgWithReference = message;
      } else {
        const methodParts = func.split(".");
        const referenceSection = methodParts.length > 1 ? `${methodParts[0]}.${methodParts[1]}` : "p5";
        const funcName = methodParts.length === 1 ? func : methodParts.slice(2).join("/");
        funcName.startsWith("p5.") ? msgWithReference = `${message} (https://p5js.org/reference/${referenceSection}.${funcName})` : msgWithReference = `${message} (https://p5js.org/reference/${referenceSection}/${funcName})`;
      }
      return msgWithReference;
    };
    p53._report = (message, func, color3) => {
      const log2 = p53._fesLogger == null ? console.log.bind(console) : p53._fesLogger;
      if ("undefined" === getType(color3)) {
        color3 = "#B40033";
      } else if (getType(color3) === "number") {
        color3 = typeColors[color3];
      }
      message = mapToReference(message, func);
      const prefixedMsg = translator("fes.pre", { message });
      {
        log2(prefixedMsg);
      }
    };
    p53._error = (context, message, func) => {
      p53._report(message, func);
      context.hitCriticalError = true;
      throw new FESError("Stopping sketch to prevent more errors");
    };
    p53._friendlyError = function(message, func, color3) {
      p53._report(message, func, color3);
    };
    p53._friendlyAutoplayError = function(src) {
      const message = translator("fes.autoplay", {
        src,
        url: "https://developer.mozilla.org/docs/Web/Media/Autoplay_guide"
      });
      console.log(translator("fes.pre", { message }));
    };
    const computeEditDistance = (w1, w2) => {
      const l1 = w1.length, l2 = w2.length;
      if (l1 === 0) return w2;
      if (l2 === 0) return w1;
      let prev = [];
      let cur = [];
      for (let j2 = 0; j2 < l2 + 1; j2++) {
        cur[j2] = j2;
      }
      prev = cur;
      for (let i = 1; i < l1 + 1; i++) {
        cur = [];
        for (let j2 = 0; j2 < l2 + 1; j2++) {
          if (j2 === 0) {
            cur[j2] = i;
          } else {
            let a1 = w1[i - 1], a2 = w2[j2 - 1];
            let temp = 999999;
            let cost = a1.toLowerCase() === a2.toLowerCase() ? 0 : 1;
            temp = temp > cost + prev[j2 - 1] ? cost + prev[j2 - 1] : temp;
            temp = temp > 1 + cur[j2 - 1] ? 1 + cur[j2 - 1] : temp;
            temp = temp > 1 + prev[j2] ? 1 + prev[j2] : temp;
            cur[j2] = temp;
          }
        }
        prev = cur;
      }
      return cur[l2];
    };
    p53.isPreloadSupported = function() {
      return false;
    };
    const checkForUserDefinedFunctions = (context) => {
      if (p53.disableFriendlyErrors) return;
      const instanceMode = context instanceof p53;
      context = instanceMode ? context : window;
      const fnNames = entryPoints;
      if (context.preload && !p53.isPreloadSupported()) {
        p53._error(context, translator("fes.preloadDisabled"));
      }
      const fxns = {};
      fnNames.forEach((symbol2) => {
        fxns[symbol2.toLowerCase()] = symbol2;
      });
      for (const prop of Object.keys(context)) {
        const lowercase2 = prop.toLowerCase();
        if (fxns.hasOwnProperty(lowercase2) && !context[fxns[lowercase2]] && typeof context[prop] === "function") {
          const msg = translator("fes.checkUserDefinedFns", {
            name: prop,
            actualName: fxns[lowercase2]
          });
          p53._friendlyError(msg, fxns[lowercase2]);
        }
      }
    };
    const handleMisspelling = (errSym, error42) => {
      if (!misusedAtTopLevelCode) {
        defineMisusedAtTopLevelCode();
      }
      const distanceMap = {};
      let min = 999999;
      misusedAtTopLevelCode.forEach((symbol2) => {
        let dist = computeEditDistance(errSym, symbol2.name);
        if (distanceMap[dist]) distanceMap[dist].push(symbol2);
        else distanceMap[dist] = [symbol2];
        if (dist < min) min = dist;
      });
      if (min > Math.min(EDIT_DIST_THRESHOLD, errSym.length)) return false;
      const matchedSymbols = distanceMap[min].filter(
        (symbol2) => symbol2.name !== errSym
      );
      if (matchedSymbols.length !== 0) {
        const parsed = p53._getErrorStackParser().parse(error42);
        let locationObj;
        if (parsed && parsed[0] && parsed[0].fileName && parsed[0].lineNumber && parsed[0].columnNumber) {
          locationObj = {
            location: `${parsed[0].fileName}:${parsed[0].lineNumber}:${parsed[0].columnNumber}`,
            file: parsed[0].fileName.split("/").slice(-1),
            line: parsed[0].lineNumber
          };
        }
        let msg;
        if (matchedSymbols.length === 1) {
          msg = translator("fes.misspelling", {
            name: errSym,
            actualName: matchedSymbols[0].name,
            type: matchedSymbols[0].type,
            location: locationObj ? translator("fes.location", locationObj) : "",
            count: matchedSymbols.length
          });
        } else {
          const suggestions = matchedSymbols.map((symbol2) => {
            const message = "▶️ " + symbol2.name + (symbol2.type === "function" ? "()" : "");
            return mapToReference(message, symbol2.name);
          }).join("\n");
          msg = translator("fes.misspelling", {
            name: errSym,
            suggestions,
            location: locationObj ? translator("fes.location", locationObj) : "",
            count: matchedSymbols.length
          });
        }
        p53._friendlyError(
          msg,
          matchedSymbols.length === 1 ? matchedSymbols[0].name : void 0
        );
        return true;
      }
      return false;
    };
    const printFriendlyStack = (friendlyStack) => {
      const log2 = p53._fesLogger && typeof p53._fesLogger === "function" ? p53._fesLogger : console.log.bind(console);
      if (friendlyStack.length > 1) {
        let stacktraceMsg = "";
        friendlyStack.forEach((frame, idx) => {
          const location2 = `${frame.fileName}:${frame.lineNumber}:${frame.columnNumber}`;
          let frameMsg, translationObj = {
            func: frame.functionName,
            line: frame.lineNumber,
            location: location2,
            file: frame.fileName.split("/").slice(-1)
          };
          if (idx === 0) {
            frameMsg = translator("fes.globalErrors.stackTop", translationObj);
          } else {
            frameMsg = translator("fes.globalErrors.stackSubseq", translationObj);
          }
          stacktraceMsg += frameMsg;
        });
        log2(stacktraceMsg);
      }
    };
    const processStack = (error42, stacktrace2) => {
      if (!stacktrace2) return [false, null];
      stacktrace2.forEach((frame) => {
        frame.functionName = frame.functionName || "";
      });
      let isInternal = false;
      let p5FileName, friendlyStack, currentEntryPoint;
      try {
        throw new Error();
      } catch (testError) {
        const testStacktrace = p53._getErrorStackParser().parse(testError);
        p5FileName = testStacktrace[0].fileName;
      }
      for (let i = stacktrace2.length - 1; i >= 0; i--) {
        let splitted = stacktrace2[i].functionName.split(".");
        if (entryPoints.includes(splitted[splitted.length - 1])) {
          friendlyStack = stacktrace2.slice(0, i + 1);
          currentEntryPoint = splitted[splitted.length - 1];
          if (stacktrace2[0].fileName === p5FileName) {
            isInternal = true;
            break;
          }
          break;
        }
      }
      if (!friendlyStack) friendlyStack = stacktrace2;
      if (isInternal) {
        friendlyStack = friendlyStack.map((frame, index) => {
          frame.frameIndex = index;
          return frame;
        }).filter((frame) => frame.fileName !== p5FileName);
        if (friendlyStack.length === 0) return [true, null];
        const func = stacktrace2[friendlyStack[0].frameIndex - 2].functionName.split(".").slice(-1)[0];
        let locationObj;
        if (friendlyStack[0].fileName && friendlyStack[0].lineNumber && friendlyStack[0].columnNumber) {
          locationObj = {
            location: `${friendlyStack[0].fileName}:${friendlyStack[0].lineNumber}:${friendlyStack[0].columnNumber}`,
            file: friendlyStack[0].fileName.split("/").slice(-1),
            line: friendlyStack[0].lineNumber
          };
          if (p53._fesLogCache[locationObj.location]) return [true, null];
        }
        if (currentEntryPoint === "preload" && fn2._preloadMethods[func] == null) {
          p53._friendlyError(
            translator("fes.wrongPreload", {
              func,
              location: locationObj ? translator("fes.location", locationObj) : "",
              error: error42.message
            }),
            "preload"
          );
        } else {
          p53._friendlyError(
            translator("fes.libraryError", {
              func,
              location: locationObj ? translator("fes.location", locationObj) : "",
              error: error42.message
            }),
            func
          );
        }
        if (friendlyStack && friendlyStack.length) {
          printFriendlyStack(friendlyStack);
        }
      }
      return [isInternal, friendlyStack];
    };
    const fesErrorMonitor = (e2) => {
      if (p53.disableFriendlyErrors) return;
      if (e2 && (e2 instanceof FESError || e2.reason instanceof FESError)) return;
      let error42;
      if (e2 instanceof Error) {
        error42 = e2;
      } else if (e2 instanceof ErrorEvent) {
        error42 = e2.error;
      } else if (e2 instanceof PromiseRejectionEvent) {
        error42 = e2.reason;
        if (!(error42 instanceof Error)) return;
      }
      if (!error42) return;
      let stacktrace2 = p53._getErrorStackParser().parse(error42);
      let [isInternal, friendlyStack] = processStack(error42, stacktrace2);
      if (isInternal) {
        return;
      }
      const errList = strings[error42.name];
      if (!errList) return;
      let matchedError;
      for (const obj of errList) {
        let string4 = obj.msg;
        string4 = string4.replace(new RegExp("{{}}", "g"), "([a-zA-Z0-9_]+)");
        string4 = string4.replace(new RegExp("{{.}}", "g"), "(.+)");
        string4 = string4.replace(new RegExp("{}", "g"), "(?:[a-zA-Z0-9_]+)");
        let matched = error42.message.match(string4);
        if (matched) {
          matchedError = Object.assign({}, obj);
          matchedError.match = matched;
          break;
        }
      }
      if (!matchedError) return;
      let locationObj;
      if (stacktrace2 && stacktrace2[0].fileName && stacktrace2[0].lineNumber && stacktrace2[0].columnNumber) {
        locationObj = {
          location: `${stacktrace2[0].fileName}:${stacktrace2[0].lineNumber}:${stacktrace2[0].columnNumber}`,
          file: stacktrace2[0].fileName.split("/").slice(-1),
          line: friendlyStack[0].lineNumber
        };
      }
      switch (error42.name) {
        case "SyntaxError": {
          switch (matchedError.type) {
            case "INVALIDTOKEN": {
              let url2 = "https://developer.mozilla.org/docs/Web/JavaScript/Reference/Errors/Illegal_character#What_went_wrong";
              p53._friendlyError(
                translator("fes.globalErrors.syntax.invalidToken", {
                  url: url2
                })
              );
              break;
            }
            case "UNEXPECTEDTOKEN": {
              let url2 = "https://developer.mozilla.org/docs/Web/JavaScript/Reference/Errors/Unexpected_token#What_went_wrong";
              p53._friendlyError(
                translator("fes.globalErrors.syntax.unexpectedToken", {
                  url: url2
                })
              );
              break;
            }
            case "REDECLAREDVARIABLE": {
              let errSym = matchedError.match[1];
              let url2 = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Redeclared_parameter#what_went_wrong";
              p53._friendlyError(
                translator("fes.globalErrors.syntax.redeclaredVariable", {
                  symbol: errSym,
                  url: url2
                })
              );
              break;
            }
            case "MISSINGINITIALIZER": {
              let url2 = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Missing_initializer_in_const#what_went_wrong";
              p53._friendlyError(
                translator("fes.globalErrors.syntax.missingInitializer", {
                  url: url2
                })
              );
              break;
            }
            case "BADRETURNORYIELD": {
              let url2 = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Bad_return_or_yield#what_went_wrong";
              p53._friendlyError(
                translator("fes.globalErrors.syntax.badReturnOrYield", {
                  url: url2
                })
              );
              break;
            }
          }
          break;
        }
        case "ReferenceError": {
          switch (matchedError.type) {
            case "NOTDEFINED": {
              let errSym = matchedError.match[1];
              if (errSym && handleMisspelling(errSym, error42)) {
                break;
              }
              let url2 = "https://p5js.org/examples/data-variable-scope.html";
              p53._friendlyError(
                translator("fes.globalErrors.reference.notDefined", {
                  url: url2,
                  symbol: errSym,
                  location: locationObj ? translator("fes.location", locationObj) : ""
                })
              );
              if (friendlyStack) printFriendlyStack(friendlyStack);
              break;
            }
            case "CANNOTACCESS": {
              let errSym = matchedError.match[1];
              let url2 = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cant_access_lexical_declaration_before_init#what_went_wrong";
              p53._friendlyError(
                translator("fes.globalErrors.reference.cannotAccess", {
                  url: url2,
                  symbol: errSym,
                  location: locationObj ? translator("fes.location", locationObj) : ""
                })
              );
              if (friendlyStack) printFriendlyStack(friendlyStack);
              break;
            }
          }
          break;
        }
        case "TypeError": {
          switch (matchedError.type) {
            case "NOTFUNC": {
              let errSym = matchedError.match[1];
              let splitSym = errSym.split(".");
              let url2 = "https://developer.mozilla.org/docs/Web/JavaScript/Reference/Errors/Not_a_function#What_went_wrong";
              let translationObj = {
                url: url2,
                symbol: splitSym[splitSym.length - 1],
                obj: splitSym.slice(0, splitSym.length - 1).join("."),
                location: locationObj ? translator("fes.location", locationObj) : ""
              };
              if (splitSym.length > 1) {
                p53._friendlyError(
                  translator("fes.globalErrors.type.notfuncObj", translationObj)
                );
              } else {
                p53._friendlyError(
                  translator("fes.globalErrors.type.notfunc", translationObj)
                );
              }
              if (friendlyStack) printFriendlyStack(friendlyStack);
              break;
            }
            case "READNULL": {
              let errSym = matchedError.match[1];
              let url2 = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cant_access_property#what_went_wrong";
              p53._friendlyError(
                translator("fes.globalErrors.type.readFromNull", {
                  url: url2,
                  symbol: errSym,
                  location: locationObj ? translator("fes.location", locationObj) : ""
                })
              );
              if (friendlyStack) printFriendlyStack(friendlyStack);
              break;
            }
            case "READUDEFINED": {
              let errSym = matchedError.match[1];
              let url2 = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cant_access_property#what_went_wrong";
              p53._friendlyError(
                translator("fes.globalErrors.type.readFromUndefined", {
                  url: url2,
                  symbol: errSym,
                  location: locationObj ? translator("fes.location", locationObj) : ""
                })
              );
              if (friendlyStack) printFriendlyStack(friendlyStack);
              break;
            }
            case "CONSTASSIGN": {
              let url2 = "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Invalid_const_assignment#what_went_wrong";
              p53._friendlyError(
                translator("fes.globalErrors.type.constAssign", {
                  url: url2,
                  location: locationObj ? translator("fes.location", locationObj) : ""
                })
              );
              if (friendlyStack) printFriendlyStack(friendlyStack);
              break;
            }
          }
        }
      }
    };
    p53._fesErrorMonitor = fesErrorMonitor;
    p53._checkForUserDefinedFunctions = checkForUserDefinedFunctions;
    p53._fesLogger = null;
    p53._fesLogCache = {};
    window.addEventListener("load", checkForUserDefinedFunctions, false);
    window.addEventListener("error", p53._fesErrorMonitor, false);
    window.addEventListener("unhandledrejection", p53._fesErrorMonitor, false);
  }
  misusedAtTopLevelCode = null;
  const FAQ_URL = "https://github.com/processing/p5.js/wiki/p5.js-overview#why-cant-i-assign-variables-using-p5-functions-and-variables-before-setup";
  defineMisusedAtTopLevelCode = () => {
    const uniqueNamesFound = {};
    const getSymbols = (obj) => Object.getOwnPropertyNames(obj).filter((name) => {
      if (name[0] === "_") {
        return false;
      }
      if (name in uniqueNamesFound) {
        return false;
      }
      uniqueNamesFound[name] = true;
      return true;
    }).map((name) => {
      let type3;
      if (typeof obj[name] === "function") {
        type3 = "function";
      } else if (name === name.toUpperCase()) {
        type3 = "constant";
      } else {
        type3 = "variable";
      }
      return { name, type: type3 };
    });
    misusedAtTopLevelCode = [].concat(
      getSymbols(fn2),
      // At present, p5 only adds its constants to fn during
      // construction, which may not have happened at the time a
      // ReferenceError is thrown, so we'll manually add them to our list.
      getSymbols(constants)
    );
    misusedAtTopLevelCode.sort((a2, b3) => b3.name.length - a2.name.length);
  };
  const helpForMisusedAtTopLevelCode = (e2, log2) => {
    if (!log2) {
      log2 = console.log.bind(console);
    }
    if (!misusedAtTopLevelCode) {
      defineMisusedAtTopLevelCode();
    }
    misusedAtTopLevelCode.some((symbol2) => {
      if (e2.message && e2.message.match(`\\W?${symbol2.name}\\W`) !== null) {
        const symbolName = symbol2.type === "function" ? `${symbol2.name}()` : symbol2.name;
        if (typeof IS_MINIFIED !== "undefined") {
          log2(
            `Did you just try to use p5.js's ${symbolName} ${symbol2.type}? If so, you may want to move it into your sketch's setup() function.

For more details, see: ${FAQ_URL}`
          );
        } else {
          log2(
            translator("fes.misusedTopLevel", {
              symbolName,
              symbolType: symbol2.type,
              url: FAQ_URL
            })
          );
        }
        return true;
      }
    });
  };
  fn2._helpForMisusedAtTopLevelCode = helpForMisusedAtTopLevelCode;
  if (document.readyState !== "complete") {
    window.addEventListener("error", helpForMisusedAtTopLevelCode, false);
    window.addEventListener("load", () => {
      window.removeEventListener("error", helpForMisusedAtTopLevelCode, false);
    });
  }
}
if (typeof p5 !== "undefined") {
  fesCore(p5, p5.prototype);
}

// node_modules/p5/dist/core/friendly_errors/stacktrace.js
function ErrorStackParser() {
  let FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\S+:\d+/;
  let CHROME_IE_STACK_REGEXP = /^\s*at .*(\S+:\d+|\(native\))/m;
  let SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\[native code])?$/;
  return {
    /**
     * Given an Error object, extract the most information from it.
     * @private
     * @param {Error} error object
     * @return {Array} of stack frames
     */
    parse: function ErrorStackParser$$parse(error42) {
      if (typeof error42.stacktrace !== "undefined" || typeof error42["opera#sourceloc"] !== "undefined") {
        return this.parseOpera(error42);
      } else if (error42.stack && error42.stack.match(CHROME_IE_STACK_REGEXP)) {
        return this.parseV8OrIE(error42);
      } else if (error42.stack) {
        return this.parseFFOrSafari(error42);
      } else ;
    },
    // Separate line and column numbers from a string of the form: (URI:Line:Column)
    extractLocation: function ErrorStackParser$$extractLocation(urlLike) {
      if (urlLike.indexOf(":") === -1) {
        return [urlLike];
      }
      let regExp = /(.+?)(?::(\d+))?(?::(\d+))?$/;
      let parts = regExp.exec(urlLike.replace(/[()]/g, ""));
      return [parts[1], parts[2] || void 0, parts[3] || void 0];
    },
    parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error42) {
      let filtered = error42.stack.split("\n").filter(function(line) {
        return !!line.match(CHROME_IE_STACK_REGEXP);
      }, this);
      return filtered.map(function(line) {
        if (line.indexOf("(eval ") > -1) {
          line = line.replace(/eval code/g, "eval").replace(/(\(eval at [^()]*)|(\),.*$)/g, "");
        }
        let sanitizedLine = line.replace(/^\s+/, "").replace(/\(eval code/g, "(");
        let location2 = sanitizedLine.match(/ (\((.+):(\d+):(\d+)\)$)/);
        sanitizedLine = location2 ? sanitizedLine.replace(location2[0], "") : sanitizedLine;
        let tokens = sanitizedLine.split(/\s+/).slice(1);
        let locationParts = this.extractLocation(
          location2 ? location2[1] : tokens.pop()
        );
        let functionName = tokens.join(" ") || void 0;
        let fileName = ["eval", "<anonymous>"].indexOf(locationParts[0]) > -1 ? void 0 : locationParts[0];
        return {
          functionName,
          fileName,
          lineNumber: locationParts[1],
          columnNumber: locationParts[2],
          source: line
        };
      }, this);
    },
    parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error42) {
      let filtered = error42.stack.split("\n").filter(function(line) {
        return !line.match(SAFARI_NATIVE_CODE_REGEXP);
      }, this);
      return filtered.map(function(line) {
        if (line.indexOf(" > eval") > -1) {
          line = line.replace(
            / line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g,
            ":$1"
          );
        }
        if (line.indexOf("@") === -1 && line.indexOf(":") === -1) {
          return {
            functionName: line
          };
        } else {
          let functionNameRegex = /((.*".+"[^@]*)?[^@]*)(?:@)/;
          let matches = line.match(functionNameRegex);
          let functionName = matches && matches[1] ? matches[1] : void 0;
          let locationParts = this.extractLocation(
            line.replace(functionNameRegex, "")
          );
          return {
            functionName,
            fileName: locationParts[0],
            lineNumber: locationParts[1],
            columnNumber: locationParts[2],
            source: line
          };
        }
      }, this);
    },
    parseOpera: function ErrorStackParser$$parseOpera(e2) {
      if (!e2.stacktrace || e2.message.indexOf("\n") > -1 && e2.message.split("\n").length > e2.stacktrace.split("\n").length) {
        return this.parseOpera9(e2);
      } else if (!e2.stack) {
        return this.parseOpera10(e2);
      } else {
        return this.parseOpera11(e2);
      }
    },
    parseOpera9: function ErrorStackParser$$parseOpera9(e2) {
      let lineRE = /Line (\d+).*script (?:in )?(\S+)/i;
      let lines = e2.message.split("\n");
      let result = [];
      for (let i = 2, len = lines.length; i < len; i += 2) {
        let match = lineRE.exec(lines[i]);
        if (match) {
          result.push({
            fileName: match[2],
            lineNumber: match[1],
            source: lines[i]
          });
        }
      }
      return result;
    },
    parseOpera10: function ErrorStackParser$$parseOpera10(e2) {
      let lineRE = /Line (\d+).*script (?:in )?(\S+)(?:: In function (\S+))?$/i;
      let lines = e2.stacktrace.split("\n");
      let result = [];
      for (let i = 0, len = lines.length; i < len; i += 2) {
        let match = lineRE.exec(lines[i]);
        if (match) {
          result.push({
            functionName: match[3] || void 0,
            fileName: match[2],
            lineNumber: match[1],
            source: lines[i]
          });
        }
      }
      return result;
    },
    // Opera 10.65+ Error.stack very similar to FF/Safari
    parseOpera11: function ErrorStackParser$$parseOpera11(error42) {
      let filtered = error42.stack.split("\n").filter(function(line) {
        return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);
      }, this);
      return filtered.map(function(line) {
        let tokens = line.split("@");
        let locationParts = this.extractLocation(tokens.pop());
        let functionCall = tokens.shift() || "";
        let functionName = functionCall.replace(/<anonymous function(: (\w+))?>/, "$2").replace(/\([^)]*\)/g, "") || void 0;
        let argsRaw;
        if (functionCall.match(/\(([^)]*)\)/)) {
          argsRaw = functionCall.replace(/^[^(]+\(([^)]*)\)$/, "$1");
        }
        let args = argsRaw === void 0 || argsRaw === "[arguments not available]" ? void 0 : argsRaw.split(",");
        return {
          functionName,
          args,
          fileName: locationParts[0],
          lineNumber: locationParts[1],
          columnNumber: locationParts[2],
          source: line
        };
      }, this);
    }
  };
}
function stacktrace(p53, fn2) {
  p53._getErrorStackParser = function getErrorStackParser() {
    return new ErrorStackParser();
  };
}
if (typeof p5 !== "undefined") {
  stacktrace(p5, p5.prototype);
}

// node_modules/zod/v4/classic/external.js
var external_exports = {};
__export(external_exports, {
  $brand: () => $brand,
  $input: () => $input,
  $output: () => $output,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFile: () => ZodFile,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRealError: () => ZodRealError,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  clone: () => clone2,
  coerce: () => coerce_exports,
  config: () => config,
  core: () => core_exports2,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  endsWith: () => _endsWith,
  enum: () => _enum2,
  file: () => file2,
  flattenError: () => flattenError,
  float32: () => float32,
  float64: () => float64,
  formatError: () => formatError,
  function: () => _function,
  getErrorMap: () => getErrorMap,
  globalRegistry: () => globalRegistry,
  gt: () => _gt,
  gte: () => _gte,
  guid: () => guid2,
  includes: () => _includes,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  iso: () => iso_exports,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  length: () => _length,
  literal: () => literal,
  locales: () => locales_exports,
  looseObject: () => looseObject,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  map: () => map2,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  negative: () => _negative,
  never: () => never,
  nonnegative: () => _nonnegative,
  nonoptional: () => nonoptional,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  overwrite: () => _overwrite,
  parse: () => parse4,
  parseAsync: () => parseAsync2,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  positive: () => _positive,
  prefault: () => prefault,
  preprocess: () => preprocess,
  prettifyError: () => prettifyError,
  promise: () => promise,
  property: () => _property,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  regex: () => _regex,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeParse: () => safeParse2,
  safeParseAsync: () => safeParseAsync2,
  set: () => set2,
  setErrorMap: () => setErrorMap,
  size: () => _size,
  startsWith: () => _startsWith,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  toJSONSchema: () => toJSONSchema,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  transform: () => transform2,
  treeifyError: () => treeifyError,
  trim: () => _trim,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  uppercase: () => _uppercase,
  url: () => url,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2
});

// node_modules/zod/v4/core/index.js
var core_exports2 = {};
__export(core_exports2, {
  $ZodAny: () => $ZodAny,
  $ZodArray: () => $ZodArray,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodBase64: () => $ZodBase64,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBoolean: () => $ZodBoolean,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCUID: () => $ZodCUID,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCatch: () => $ZodCatch,
  $ZodCheck: () => $ZodCheck,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCustom: () => $ZodCustom,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodDate: () => $ZodDate,
  $ZodDefault: () => $ZodDefault,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodE164: () => $ZodE164,
  $ZodEmail: () => $ZodEmail,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEnum: () => $ZodEnum,
  $ZodError: () => $ZodError,
  $ZodFile: () => $ZodFile,
  $ZodFunction: () => $ZodFunction,
  $ZodGUID: () => $ZodGUID,
  $ZodIPv4: () => $ZodIPv4,
  $ZodIPv6: () => $ZodIPv6,
  $ZodISODate: () => $ZodISODate,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISOTime: () => $ZodISOTime,
  $ZodIntersection: () => $ZodIntersection,
  $ZodJWT: () => $ZodJWT,
  $ZodKSUID: () => $ZodKSUID,
  $ZodLazy: () => $ZodLazy,
  $ZodLiteral: () => $ZodLiteral,
  $ZodMap: () => $ZodMap,
  $ZodNaN: () => $ZodNaN,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNever: () => $ZodNever,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNull: () => $ZodNull,
  $ZodNullable: () => $ZodNullable,
  $ZodNumber: () => $ZodNumber,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodObject: () => $ZodObject,
  $ZodOptional: () => $ZodOptional,
  $ZodPipe: () => $ZodPipe,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPromise: () => $ZodPromise,
  $ZodReadonly: () => $ZodReadonly,
  $ZodRealError: () => $ZodRealError,
  $ZodRecord: () => $ZodRecord,
  $ZodRegistry: () => $ZodRegistry,
  $ZodSet: () => $ZodSet,
  $ZodString: () => $ZodString,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodSuccess: () => $ZodSuccess,
  $ZodSymbol: () => $ZodSymbol,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodTransform: () => $ZodTransform,
  $ZodTuple: () => $ZodTuple,
  $ZodType: () => $ZodType,
  $ZodULID: () => $ZodULID,
  $ZodURL: () => $ZodURL,
  $ZodUUID: () => $ZodUUID,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUnion: () => $ZodUnion,
  $ZodUnknown: () => $ZodUnknown,
  $ZodVoid: () => $ZodVoid,
  $ZodXID: () => $ZodXID,
  $brand: () => $brand,
  $constructor: () => $constructor,
  $input: () => $input,
  $output: () => $output,
  Doc: () => Doc,
  JSONSchema: () => json_schema_exports,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  _any: () => _any,
  _array: () => _array,
  _base64: () => _base64,
  _base64url: () => _base64url,
  _bigint: () => _bigint,
  _boolean: () => _boolean,
  _catch: () => _catch,
  _cidrv4: () => _cidrv4,
  _cidrv6: () => _cidrv6,
  _coercedBigint: () => _coercedBigint,
  _coercedBoolean: () => _coercedBoolean,
  _coercedDate: () => _coercedDate,
  _coercedNumber: () => _coercedNumber,
  _coercedString: () => _coercedString,
  _cuid: () => _cuid,
  _cuid2: () => _cuid2,
  _custom: () => _custom,
  _date: () => _date,
  _default: () => _default,
  _discriminatedUnion: () => _discriminatedUnion,
  _e164: () => _e164,
  _email: () => _email,
  _emoji: () => _emoji2,
  _endsWith: () => _endsWith,
  _enum: () => _enum,
  _file: () => _file,
  _float32: () => _float32,
  _float64: () => _float64,
  _gt: () => _gt,
  _gte: () => _gte,
  _guid: () => _guid,
  _includes: () => _includes,
  _int: () => _int,
  _int32: () => _int32,
  _int64: () => _int64,
  _intersection: () => _intersection,
  _ipv4: () => _ipv4,
  _ipv6: () => _ipv6,
  _isoDate: () => _isoDate,
  _isoDateTime: () => _isoDateTime,
  _isoDuration: () => _isoDuration,
  _isoTime: () => _isoTime,
  _jwt: () => _jwt,
  _ksuid: () => _ksuid,
  _lazy: () => _lazy,
  _length: () => _length,
  _literal: () => _literal,
  _lowercase: () => _lowercase,
  _lt: () => _lt,
  _lte: () => _lte,
  _map: () => _map,
  _max: () => _lte,
  _maxLength: () => _maxLength,
  _maxSize: () => _maxSize,
  _mime: () => _mime,
  _min: () => _gte,
  _minLength: () => _minLength,
  _minSize: () => _minSize,
  _multipleOf: () => _multipleOf,
  _nan: () => _nan,
  _nanoid: () => _nanoid,
  _nativeEnum: () => _nativeEnum,
  _negative: () => _negative,
  _never: () => _never,
  _nonnegative: () => _nonnegative,
  _nonoptional: () => _nonoptional,
  _nonpositive: () => _nonpositive,
  _normalize: () => _normalize,
  _null: () => _null2,
  _nullable: () => _nullable,
  _number: () => _number,
  _optional: () => _optional,
  _overwrite: () => _overwrite,
  _parse: () => _parse,
  _parseAsync: () => _parseAsync,
  _pipe: () => _pipe,
  _positive: () => _positive,
  _promise: () => _promise,
  _property: () => _property,
  _readonly: () => _readonly,
  _record: () => _record,
  _refine: () => _refine,
  _regex: () => _regex,
  _safeParse: () => _safeParse,
  _safeParseAsync: () => _safeParseAsync,
  _set: () => _set,
  _size: () => _size,
  _startsWith: () => _startsWith,
  _string: () => _string,
  _stringFormat: () => _stringFormat,
  _stringbool: () => _stringbool,
  _success: () => _success,
  _symbol: () => _symbol,
  _templateLiteral: () => _templateLiteral,
  _toLowerCase: () => _toLowerCase,
  _toUpperCase: () => _toUpperCase,
  _transform: () => _transform,
  _trim: () => _trim,
  _tuple: () => _tuple,
  _uint32: () => _uint32,
  _uint64: () => _uint64,
  _ulid: () => _ulid,
  _undefined: () => _undefined2,
  _union: () => _union,
  _unknown: () => _unknown,
  _uppercase: () => _uppercase,
  _url: () => _url,
  _uuid: () => _uuid,
  _uuidv4: () => _uuidv4,
  _uuidv6: () => _uuidv6,
  _uuidv7: () => _uuidv7,
  _void: () => _void,
  _xid: () => _xid,
  clone: () => clone2,
  config: () => config,
  flattenError: () => flattenError,
  formatError: () => formatError,
  function: () => _function,
  globalConfig: () => globalConfig,
  globalRegistry: () => globalRegistry,
  isValidBase64: () => isValidBase64,
  isValidBase64URL: () => isValidBase64URL,
  isValidJWT: () => isValidJWT,
  locales: () => locales_exports,
  parse: () => parse3,
  parseAsync: () => parseAsync,
  prettifyError: () => prettifyError,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  toDotPath: () => toDotPath,
  toJSONSchema: () => toJSONSchema,
  treeifyError: () => treeifyError,
  util: () => util_exports2,
  version: () => version
});

// node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
function $constructor(name, initializer3, params) {
  function init(inst, def) {
    var _a2;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a2 = inst._zod).traits ?? (_a2.traits = /* @__PURE__ */ new Set());
    inst._zod.traits.add(name);
    initializer3(inst, def);
    for (const k in _23.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _23.prototype[k].bind(inst) });
    }
    inst._zod.constr = _23;
    inst._zod.def = def;
  }
  const Parent = (params == null ? void 0 : params.Parent) ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _23(def) {
    var _a2;
    const inst = (params == null ? void 0 : params.Parent) ? new Definition() : this;
    init(inst, def);
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (const fn2 of inst._zod.deferred) {
      fn2();
    }
    return inst;
  }
  Object.defineProperty(_23, "init", { value: init });
  Object.defineProperty(_23, Symbol.hasInstance, {
    value: (inst) => {
      var _a2, _b2;
      if ((params == null ? void 0 : params.Parent) && inst instanceof params.Parent)
        return true;
      return (_b2 = (_a2 = inst == null ? void 0 : inst._zod) == null ? void 0 : _a2.traits) == null ? void 0 : _b2.has(name);
    }
  });
  Object.defineProperty(_23, "name", { value: name });
  return _23;
}
var $brand = Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}

// node_modules/zod/v4/core/util.js
var util_exports2 = {};
__export(util_exports2, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone2,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  stringifyPrimitive: () => stringifyPrimitive,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val2) {
  return val2;
}
function assertNotEqual(val2) {
  return val2;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error();
}
function assert(_23) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _23]) => numericValues.indexOf(+k) === -1).map(([_23, v]) => v);
  return values;
}
function joinValues(array2, separator = "|") {
  return array2.map((val2) => stringifyPrimitive(val2)).join(separator);
}
function jsonStringifyReplacer(_23, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set3 = false;
  return {
    get value() {
      if (!set3) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val2, step) {
  const valDecCount = (val2.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val2.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object2, key, getter) {
  const set3 = false;
  Object.defineProperty(object2, key, {
    get() {
      if (!set3) {
        const value = getter();
        object2[key] = value;
        return value;
      }
      throw new Error("cached value already set");
    },
    set(v) {
      Object.defineProperty(object2, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function getElementAtPath(obj, path2) {
  if (!path2)
    return obj;
  return path2.reduce((acc, key) => acc == null ? void 0 : acc[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
var captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {
};
function isObject(data3) {
  return typeof data3 === "object" && data3 !== null && !Array.isArray(data3);
}
var allowsEval = cached(() => {
  var _a2;
  if (typeof navigator !== "undefined" && ((_a2 = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : _a2.includes("Cloudflare"))) {
    return false;
  }
  try {
    const F2 = Function;
    new F2("");
    return true;
  } catch (_23) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function numKeys(data3) {
  let keyCount = 0;
  for (const key in data3) {
    if (Object.prototype.hasOwnProperty.call(data3, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data3) => {
  const t = typeof data3;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data3) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data3)) {
        return "array";
      }
      if (data3 === null) {
        return "null";
      }
      if (data3.then && typeof data3.then === "function" && data3.catch && typeof data3.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data3 instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data3 instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data3 instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data3 instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone2(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || (params == null ? void 0 : params.parent))
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if ((params == null ? void 0 : params.message) !== void 0) {
    if ((params == null ? void 0 : params.error) !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_23, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_23, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_23, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_23, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_23) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_23, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_23, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape2) {
  return Object.keys(shape2).filter((k) => {
    return shape2[k]._zod.optin === "optional" && shape2[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")],
  uint64: [BigInt(0), BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const newShape = {};
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    newShape[key] = currDef.shape[key];
  }
  return clone2(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function omit(schema, mask) {
  const newShape = { ...schema._zod.def.shape };
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    delete newShape[key];
  }
  return clone2(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function extend(schema, shape2) {
  if (!isPlainObject(shape2)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape2 };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
    // delete existing checks
  };
  return clone2(schema, def);
}
function merge(a2, b3) {
  return clone2(a2, {
    ...a2._zod.def,
    get shape() {
      const _shape = { ...a2._zod.def.shape, ...b3._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    catchall: b3._zod.def.catchall,
    checks: []
    // delete existing checks
  });
}
function partial(Class2, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape2 = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in oldShape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape2[key] = Class2 ? new Class2({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  } else {
    for (const key in oldShape) {
      shape2[key] = Class2 ? new Class2({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  }
  return clone2(schema, {
    ...schema._zod.def,
    shape: shape2,
    checks: []
  });
}
function required(Class2, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape2 = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in shape2)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape2[key] = new Class2({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  } else {
    for (const key in oldShape) {
      shape2[key] = new Class2({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  }
  return clone2(schema, {
    ...schema._zod.def,
    shape: shape2,
    // optional: [],
    checks: []
  });
}
function aborted(x, startIndex = 0) {
  var _a2;
  for (let i = startIndex; i < x.issues.length; i++) {
    if (((_a2 = x.issues[i]) == null ? void 0 : _a2.continue) !== true)
      return true;
  }
  return false;
}
function prefixIssues(path2, issues) {
  return issues.map((iss) => {
    var _a2;
    (_a2 = iss).path ?? (_a2.path = []);
    iss.path.unshift(path2);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message == null ? void 0 : message.message;
}
function finalizeIssue(iss, ctx, config2) {
  var _a2, _b2, _c2, _d, _e, _f;
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage((_c2 = (_b2 = (_a2 = iss.inst) == null ? void 0 : _a2._zod.def) == null ? void 0 : _b2.error) == null ? void 0 : _c2.call(_b2, iss)) ?? unwrapMessage((_d = ctx == null ? void 0 : ctx.error) == null ? void 0 : _d.call(ctx, iss)) ?? unwrapMessage((_e = config2.customError) == null ? void 0 : _e.call(config2, iss)) ?? unwrapMessage((_f = config2.localeError) == null ? void 0 : _f.call(config2, iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!(ctx == null ? void 0 : ctx.reportInput)) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _23]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
var Class = class {
  constructor(..._args) {
  }
};

// node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  Object.defineProperty(inst, "message", {
    get() {
      return JSON.stringify(def, jsonStringifyReplacer, 2);
    },
    enumerable: true
    // configurable: false,
  });
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error42, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error42.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error42, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error43) => {
    for (const issue2 of error43.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error42);
  return fieldErrors;
}
function treeifyError(error42, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const result = { errors: [] };
  const processError = (error43, path2 = []) => {
    var _a2, _b2;
    for (const issue2 of error43.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path2, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a2 = curr.properties)[el] ?? (_a2[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b2 = curr.items)[el] ?? (_b2[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  };
  processError(error42);
  return result;
}
function toDotPath(path2) {
  const segs = [];
  for (const seg of path2) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error42) {
  var _a2;
  const lines = [];
  const issues = [...error42.issues].sort((a2, b3) => a2.path.length - b3.path.length);
  for (const issue2 of issues) {
    lines.push(`✖ ${issue2.message}`);
    if ((_a2 = issue2.path) == null ? void 0 : _a2.length)
      lines.push(`  → at ${toDotPath(issue2.path)}`);
  }
  return lines.join("\n");
}

// node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e2 = new ((_params == null ? void 0 : _params.Err) ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e2, _params == null ? void 0 : _params.callee);
    throw e2;
  }
  return result.value;
};
var parse3 = _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e2 = new ((params == null ? void 0 : params.Err) ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e2, params == null ? void 0 : params.callee);
    throw e2;
  }
  return result.value;
};
var parseAsync = _parseAsync($ZodRealError);
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = _safeParseAsync($ZodRealError);

// node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  _emoji: () => _emoji,
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hostname: () => hostname,
  html5Email: () => html5Email,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  string: () => string,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version3) => {
  if (!version3)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version3}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid4 = uuid(4);
var uuid6 = uuid(6);
var uuid7 = uuid(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time3 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-]\\d{2}:\\d{2})`);
  const timeRegex = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${(params == null ? void 0 : params.minimum) ?? 0},${(params == null ? void 0 : params.maximum) ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint = /^\d+n?$/;
var integer = /^\d+$/;
var number = /^-?\d+(?:\.\d+)?/i;
var boolean = /true|false/i;
var _null = /null/i;
var _undefined = /undefined/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;

// node_modules/zod/v4/core/checks.js
var $ZodCheck = $constructor("$ZodCheck", (inst, def) => {
  var _a2;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a2;
    (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = $constructor("$ZodCheckNumberFormat", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = (_a2 = def.format) == null ? void 0 : _a2.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckBigIntFormat = $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckMaxSize = $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val2 = payload.value;
    return !nullish(val2) && val2.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val2 = payload.value;
    return !nullish(val2) && val2.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val2 = payload.value;
    return !nullish(val2) && val2.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val2 = payload.value;
    return !nullish(val2) && val2.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val2 = payload.value;
    return !nullish(val2) && val2.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val2 = payload.value;
    return !nullish(val2) && val2.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a2, _b2;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b2 = inst._zod).check ?? (_b2.check = () => {
    });
});
var $ZodCheckRegex = $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheckProperty = $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst
    });
  };
});
var $ZodCheckOverwrite = $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/zod/v4/core/doc.js
var Doc = class {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn2) {
    this.indent += 1;
    fn2(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F2 = Function;
    const args = this == null ? void 0 : this.args;
    const content = (this == null ? void 0 : this.content) ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F2(...args, lines.join("\n"));
  }
};

// node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 0,
  patch: 0
};

// node_modules/zod/v4/core/schemas.js
var $ZodType = $constructor("$ZodType", (inst, def) => {
  var _a3;
  var _a2;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn2 of ch._zod.onattach) {
      fn2(inst);
    }
  }
  if (checks.length === 0) {
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    (_a3 = inst._zod.deferred) == null ? void 0 : _a3.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _23 = ch._zod.check(payload);
        if (_23 instanceof Promise && (ctx == null ? void 0 : ctx.async) === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _23 instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _23;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    inst._zod.run = (payload, ctx) => {
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      var _a4;
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: (_a4 = r.error) == null ? void 0 : _a4.issues };
      } catch (_23) {
        return safeParseAsync(inst, value).then((r) => {
          var _a5;
          return r.success ? { value: r.data } : { issues: (_a5 = r.error) == null ? void 0 : _a5.issues };
        });
      }
    },
    vendor: "zod",
    version: 1
  };
});
var $ZodString = $constructor("$ZodString", (inst, def) => {
  var _a2;
  $ZodType.init(inst, def);
  inst._zod.pattern = [...((_a2 = inst == null ? void 0 : inst._zod.bag) == null ? void 0 : _a2.patterns) ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _23) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_24) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const orig = payload.value;
      const url2 = new URL(orig);
      const href = url2.href;
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url2.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (!orig.endsWith("/") && href.endsWith("/")) {
        payload.value = href.slice(0, -1);
      } else {
        payload.value = href;
      }
      return;
    } catch (_23) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv6 = $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv4 = $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const [address, prefix] = payload.value.split("/");
    try {
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data3) {
  if (data3 === "")
    return true;
  if (data3.length % 4 !== 0)
    return false;
  try {
    atob(data3);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data3) {
  if (!base64url.test(data3))
    return false;
  const base643 = data3.replace(/[-_]/g, (c4) => c4 === "-" ? "+" : "/");
  const padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && (parsedHeader == null ? void 0 : parsedHeader.typ) !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_23) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = $constructor("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_23) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_23) {
      }
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = $constructor("$ZodBigInt", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = /* @__PURE__ */ new Set([void 0]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = /* @__PURE__ */ new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {
      }
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handleObjectResult(result, final, key) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  final.value[key] = result.value;
}
function handleOptionalObjectResult(result, final, key, input) {
  if (result.issues.length) {
    if (input[key] === void 0) {
      if (key in input) {
        final.value[key] = void 0;
      } else {
        final.value[key] = result.value;
      }
    } else {
      final.issues.push(...prefixIssues(key, result.issues));
    }
  } else if (result.value === void 0) {
    if (key in input)
      final.value[key] = void 0;
  } else {
    final.value[key] = result.value;
  }
}
var $ZodObject = $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const _normalized = cached(() => {
    const keys = Object.keys(def.shape);
    for (const k of keys) {
      if (!(def.shape[k] instanceof $ZodType)) {
        throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
      }
    }
    const okeys = optionalKeys(def.shape);
    return {
      shape: def.shape,
      keys,
      keySet: new Set(keys),
      numKeys: keys.length,
      optionalKeys: new Set(okeys)
    };
  });
  defineLazy(inst._zod, "propValues", () => {
    const shape2 = def.shape;
    const propValues = {};
    for (const key in shape2) {
      const field = shape2[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const generateFastpass = (shape2) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {}`);
    for (const key of normalized.keys) {
      if (normalized.optionalKeys.has(key)) {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        const k = esc(key);
        doc.write(`
        if (${id}.issues.length) {
          if (input[${k}] === undefined) {
            if (${k} in input) {
              newResult[${k}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${id}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${k}, ...iss.path] : [${k}],
              }))
            );
          }
        } else if (${id}.value === undefined) {
          if (${k} in input) newResult[${k}] = undefined;
        } else {
          newResult[${k}] = ${id}.value;
        }
        `);
      } else {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        doc.write(`
          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]
          })));`);
        doc.write(`newResult[${esc(key)}] = ${id}.value`);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn2 = doc.compile();
    return (payload, ctx) => fn2(shape2, payload, ctx);
  };
  let fastpass;
  const isObject2 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (jit && fastEnabled && (ctx == null ? void 0 : ctx.async) === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
    } else {
      payload.value = {};
      const shape2 = value.shape;
      for (const key of value.keys) {
        const el = shape2[key];
        const r = el._zod.run({ value: input[key], issues: [] }, ctx);
        const isOptional = el._zod.optin === "optional" && el._zod.optout === "optional";
        if (r instanceof Promise) {
          proms.push(r.then((r2) => isOptional ? handleOptionalObjectResult(r2, payload, key, input) : handleObjectResult(r2, payload, key)));
        } else if (isOptional) {
          handleOptionalObjectResult(r, payload, key, input);
        } else {
          handleObjectResult(r, payload, key);
        }
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    const unrecognized = [];
    const keySet = value.keySet;
    const _catchall = catchall._zod;
    const t = _catchall.def.type;
    for (const key of Object.keys(input)) {
      if (keySet.has(key))
        continue;
      if (t === "never") {
        unrecognized.push(key);
        continue;
      }
      const r = _catchall.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handleObjectResult(r2, payload, key)));
      } else {
        handleObjectResult(r, payload, key);
      }
    }
    if (unrecognized.length) {
      payload.issues.push({
        code: "unrecognized_keys",
        keys: unrecognized,
        input,
        inst
      });
    }
    if (!proms.length)
      return payload;
    return Promise.all(proms).then(() => {
      return payload;
    });
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p2) => cleanRegex(p2.source)).join("|")})$`);
    }
    return void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = /* @__PURE__ */ new Set();
        for (const val2 of v) {
          propValues[k].add(val2);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map3 = /* @__PURE__ */ new Map();
    for (const o of opts) {
      const values = o._zod.propValues[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map3.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map3.set(v, o);
      }
    }
    return map3;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input == null ? void 0 : input[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a2, b3) {
  if (a2 === b3) {
    return { valid: true, data: a2 };
  }
  if (a2 instanceof Date && b3 instanceof Date && +a2 === +b3) {
    return { valid: true, data: a2 };
  }
  if (isPlainObject(a2) && isPlainObject(b3)) {
    const bKeys = Object.keys(b3);
    const sharedKeys = Object.keys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b3 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b3[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a2) && Array.isArray(b3)) {
    if (a2.length !== b3.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a2.length; index++) {
      const itemA = a2[index];
      const itemB = b3[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple = $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          input,
          inst,
          origin: "array",
          ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length }
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
      } else {
        handleTupleResult(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord = $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values = def.keyType._zod.values;
      payload.value = {};
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            origin: "record",
            code: "invalid_key",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
            input: key,
            path: [key],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_key",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum = $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  inst._zod.values = new Set(values);
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? o.toString() : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const _out = def.transform(payload.value, payload);
    if (_ctx.async) {
      const output2 = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output2.then((output3) => {
        payload.value = output3;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
var $ZodOptional = $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess = $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def, ctx));
    }
    return handlePipeResult(left, def, ctx);
  };
});
function handlePipeResult(left, def, ctx) {
  if (aborted(left)) {
    return left;
  }
  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodReadonly = $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral = $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (part instanceof $ZodType) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "template_literal",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPromise = $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy = $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
  defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
  defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _23) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}

// node_modules/zod/v4/locales/index.js
var locales_exports = {};
__export(locales_exports, {
  ar: () => ar_default,
  az: () => az_default,
  be: () => be_default,
  ca: () => ca_default,
  cs: () => cs_default,
  de: () => de_default,
  en: () => en_default,
  eo: () => eo_default,
  es: () => es_default,
  fa: () => fa_default,
  fi: () => fi_default,
  fr: () => fr_default,
  frCA: () => fr_CA_default,
  he: () => he_default,
  hu: () => hu_default,
  id: () => id_default,
  it: () => it_default,
  ja: () => ja_default,
  kh: () => kh_default,
  ko: () => ko_default,
  mk: () => mk_default,
  ms: () => ms_default,
  nl: () => nl_default,
  no: () => no_default,
  ota: () => ota_default,
  pl: () => pl_default,
  ps: () => ps_default,
  pt: () => pt_default,
  ru: () => ru_default,
  sl: () => sl_default,
  sv: () => sv_default,
  ta: () => ta_default,
  th: () => th_default,
  tr: () => tr_default,
  ua: () => ua_default,
  ur: () => ur_default,
  vi: () => vi_default,
  zhCN: () => zh_CN_default,
  zhTW: () => zh_TW_default
});

// node_modules/zod/v4/locales/ar.js
var error3 = () => {
  const Sizable = {
    string: { unit: "حرف", verb: "أن يحوي" },
    file: { unit: "بايت", verb: "أن يحوي" },
    array: { unit: "عنصر", verb: "أن يحوي" },
    set: { unit: "عنصر", verb: "أن يحوي" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "array";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "مدخل",
    email: "بريد إلكتروني",
    url: "رابط",
    emoji: "إيموجي",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "تاريخ ووقت بمعيار ISO",
    date: "تاريخ بمعيار ISO",
    time: "وقت بمعيار ISO",
    duration: "مدة بمعيار ISO",
    ipv4: "عنوان IPv4",
    ipv6: "عنوان IPv6",
    cidrv4: "مدى عناوين بصيغة IPv4",
    cidrv6: "مدى عناوين بصيغة IPv6",
    base64: "نَص بترميز base64-encoded",
    base64url: "نَص بترميز base64url-encoded",
    json_string: "نَص على هيئة JSON",
    e164: "رقم هاتف بمعيار E.164",
    jwt: "JWT",
    template_literal: "مدخل"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `مدخلات غير مقبولة: يفترض إدخال ${issue2.expected}، ولكن تم إدخال ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `مدخلات غير مقبولة: يفترض إدخال ${stringifyPrimitive(issue2.values[0])}`;
        return `اختيار غير مقبول: يتوقع انتقاء أحد هذه الخيارات: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` أكبر من اللازم: يفترض أن تكون ${issue2.origin ?? "القيمة"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "عنصر"}`;
        return `أكبر من اللازم: يفترض أن تكون ${issue2.origin ?? "القيمة"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `أصغر من اللازم: يفترض لـ ${issue2.origin} أن يكون ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `أصغر من اللازم: يفترض لـ ${issue2.origin} أن يكون ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `نَص غير مقبول: يجب أن يبدأ بـ "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `نَص غير مقبول: يجب أن ينتهي بـ "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `نَص غير مقبول: يجب أن يتضمَّن "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `نَص غير مقبول: يجب أن يطابق النمط ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} غير مقبول`;
      }
      case "not_multiple_of":
        return `رقم غير مقبول: يجب أن يكون من مضاعفات ${issue2.divisor}`;
      case "unrecognized_keys":
        return `معرف${issue2.keys.length > 1 ? "ات" : ""} غريب${issue2.keys.length > 1 ? "ة" : ""}: ${joinValues(issue2.keys, "، ")}`;
      case "invalid_key":
        return `معرف غير مقبول في ${issue2.origin}`;
      case "invalid_union":
        return "مدخل غير مقبول";
      case "invalid_element":
        return `مدخل غير مقبول في ${issue2.origin}`;
      default:
        return "مدخل غير مقبول";
    }
  };
};
function ar_default() {
  return {
    localeError: error3()
  };
}

// node_modules/zod/v4/locales/az.js
var error4 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmalıdır" },
    file: { unit: "bayt", verb: "olmalıdır" },
    array: { unit: "element", verb: "olmalıdır" },
    set: { unit: "element", verb: "olmalıdır" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "array";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Yanlış dəyər: gözlənilən ${issue2.expected}, daxil olan ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanlış dəyər: gözlənilən ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanlış seçim: aşağıdakılardan biri olmalıdır: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Çox böyük: gözlənilən ${issue2.origin ?? "dəyər"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `Çox böyük: gözlənilən ${issue2.origin ?? "dəyər"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Çox kiçik: gözlənilən ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `Çox kiçik: gözlənilən ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanlış mətn: "${_issue.prefix}" ilə başlamalıdır`;
        if (_issue.format === "ends_with")
          return `Yanlış mətn: "${_issue.suffix}" ilə bitməlidir`;
        if (_issue.format === "includes")
          return `Yanlış mətn: "${_issue.includes}" daxil olmalıdır`;
        if (_issue.format === "regex")
          return `Yanlış mətn: ${_issue.pattern} şablonuna uyğun olmalıdır`;
        return `Yanlış ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanlış ədəd: ${issue2.divisor} ilə bölünə bilən olmalıdır`;
      case "unrecognized_keys":
        return `Tanınmayan açar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilində yanlış açar`;
      case "invalid_union":
        return "Yanlış dəyər";
      case "invalid_element":
        return `${issue2.origin} daxilində yanlış dəyər`;
      default:
        return `Yanlış dəyər`;
    }
  };
};
function az_default() {
  return {
    localeError: error4()
  };
}

// node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error5 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "сімвал",
        few: "сімвалы",
        many: "сімвалаў"
      },
      verb: "мець"
    },
    array: {
      unit: {
        one: "элемент",
        few: "элементы",
        many: "элементаў"
      },
      verb: "мець"
    },
    set: {
      unit: {
        one: "элемент",
        few: "элементы",
        many: "элементаў"
      },
      verb: "мець"
    },
    file: {
      unit: {
        one: "байт",
        few: "байты",
        many: "байтаў"
      },
      verb: "мець"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "лік";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "масіў";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "увод",
    email: "email адрас",
    url: "URL",
    emoji: "эмодзі",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO дата і час",
    date: "ISO дата",
    time: "ISO час",
    duration: "ISO працягласць",
    ipv4: "IPv4 адрас",
    ipv6: "IPv6 адрас",
    cidrv4: "IPv4 дыяпазон",
    cidrv6: "IPv6 дыяпазон",
    base64: "радок у фармаце base64",
    base64url: "радок у фармаце base64url",
    json_string: "JSON радок",
    e164: "нумар E.164",
    jwt: "JWT",
    template_literal: "увод"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Няправільны ўвод: чакаўся ${issue2.expected}, атрымана ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Няправільны ўвод: чакалася ${stringifyPrimitive(issue2.values[0])}`;
        return `Няправільны варыянт: чакаўся адзін з ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Занадта вялікі: чакалася, што ${issue2.origin ?? "значэнне"} павінна ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `Занадта вялікі: чакалася, што ${issue2.origin ?? "значэнне"} павінна быць ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Занадта малы: чакалася, што ${issue2.origin} павінна ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `Занадта малы: чакалася, што ${issue2.origin} павінна быць ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Няправільны радок: павінен пачынацца з "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Няправільны радок: павінен заканчвацца на "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Няправільны радок: павінен змяшчаць "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Няправільны радок: павінен адпавядаць шаблону ${_issue.pattern}`;
        return `Няправільны ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Няправільны лік: павінен быць кратным ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Нераспазнаны ${issue2.keys.length > 1 ? "ключы" : "ключ"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Няправільны ключ у ${issue2.origin}`;
      case "invalid_union":
        return "Няправільны ўвод";
      case "invalid_element":
        return `Няправільнае значэнне ў ${issue2.origin}`;
      default:
        return `Няправільны ўвод`;
    }
  };
};
function be_default() {
  return {
    localeError: error5()
  };
}

// node_modules/zod/v4/locales/ca.js
var error6 = () => {
  const Sizable = {
    string: { unit: "caràcters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "array";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "adreça electrònica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adreça IPv4",
    ipv6: "adreça IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipus invàlid: s'esperava ${issue2.expected}, s'ha rebut ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor invàlid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opció invàlida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a màxim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingués ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a mínim" : "més de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingués ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format invàlid: ha de començar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format invàlid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format invàlid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format invàlid: ha de coincidir amb el patró ${_issue.pattern}`;
        return `Format invàlid per a ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Número invàlid: ha de ser múltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau invàlida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada invàlida";
      case "invalid_element":
        return `Element invàlid a ${issue2.origin}`;
      default:
        return `Entrada invàlida`;
    }
  };
};
function ca_default() {
  return {
    localeError: error6()
  };
}

// node_modules/zod/v4/locales/cs.js
var error7 = () => {
  const Sizable = {
    string: { unit: "znaků", verb: "mít" },
    file: { unit: "bajtů", verb: "mít" },
    array: { unit: "prvků", verb: "mít" },
    set: { unit: "prvků", verb: "mít" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "číslo";
      }
      case "string": {
        return "řetězec";
      }
      case "boolean": {
        return "boolean";
      }
      case "bigint": {
        return "bigint";
      }
      case "function": {
        return "funkce";
      }
      case "symbol": {
        return "symbol";
      }
      case "undefined": {
        return "undefined";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "pole";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "regulární výraz",
    email: "e-mailová adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a čas ve formátu ISO",
    date: "datum ve formátu ISO",
    time: "čas ve formátu ISO",
    duration: "doba trvání ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "řetězec zakódovaný ve formátu base64",
    base64url: "řetězec zakódovaný ve formátu base64url",
    json_string: "řetězec ve formátu JSON",
    e164: "číslo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neplatný vstup: očekáváno ${issue2.expected}, obdrženo ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatný vstup: očekáváno ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatná možnost: očekávána jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je příliš velká: ${issue2.origin ?? "hodnota"} musí mít ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvků"}`;
        }
        return `Hodnota je příliš velká: ${issue2.origin ?? "hodnota"} musí být ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je příliš malá: ${issue2.origin ?? "hodnota"} musí mít ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvků"}`;
        }
        return `Hodnota je příliš malá: ${issue2.origin ?? "hodnota"} musí být ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatný řetězec: musí začínat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatný řetězec: musí končit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatný řetězec: musí obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatný řetězec: musí odpovídat vzoru ${_issue.pattern}`;
        return `Neplatný formát ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatné číslo: musí být násobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neznámé klíče: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatný klíč v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatný vstup";
      case "invalid_element":
        return `Neplatná hodnota v ${issue2.origin}`;
      default:
        return `Neplatný vstup`;
    }
  };
};
function cs_default() {
  return {
    localeError: error7()
  };
}

// node_modules/zod/v4/locales/de.js
var error8 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "Zahl";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "Array";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ungültige Eingabe: erwartet ${issue2.expected}, erhalten ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ungültige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ungültige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu groß: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu groß: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ungültiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ungültiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ungültiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ungültiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ungültig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ungültige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schlüssel" : "Unbekannter Schlüssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ungültiger Schlüssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ungültige Eingabe";
      case "invalid_element":
        return `Ungültiger Wert in ${issue2.origin}`;
      default:
        return `Ungültige Eingabe`;
    }
  };
};
function de_default() {
  return {
    localeError: error8()
  };
}

// node_modules/zod/v4/locales/en.js
var parsedType = (data3) => {
  const t = typeof data3;
  switch (t) {
    case "number": {
      return Number.isNaN(data3) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data3)) {
        return "array";
      }
      if (data3 === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
        return data3.constructor.name;
      }
    }
  }
  return t;
};
var error9 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue2.expected}, received ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default() {
  return {
    localeError: error9()
  };
}

// node_modules/zod/v4/locales/eo.js
var parsedType2 = (data3) => {
  const t = typeof data3;
  switch (t) {
    case "number": {
      return Number.isNaN(data3) ? "NaN" : "nombro";
    }
    case "object": {
      if (Array.isArray(data3)) {
        return "tabelo";
      }
      if (data3 === null) {
        return "senvalora";
      }
      if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
        return data3.constructor.name;
      }
    }
  }
  return t;
};
var error10 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emoĝio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-daŭro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nevalida enigo: atendiĝis ${issue2.expected}, riceviĝis ${parsedType2(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendiĝis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendiĝis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendiĝis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendiĝis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendiĝis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendiĝis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komenciĝi per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas finiĝi per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} ŝlosilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida ŝlosilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default() {
  return {
    localeError: error10()
  };
}

// node_modules/zod/v4/locales/es.js
var error11 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "número";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "arreglo";
        }
        if (data3 === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "dirección de correo electrónico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duración ISO",
    ipv4: "dirección IPv4",
    ipv6: "dirección IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entrada inválida: se esperaba ${issue2.expected}, recibido ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inválida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opción inválida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Demasiado grande: se esperaba que ${issue2.origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${issue2.origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Demasiado pequeño: se esperaba que ${issue2.origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado pequeño: se esperaba que ${issue2.origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena inválida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena inválida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena inválida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena inválida: debe coincidir con el patrón ${_issue.pattern}`;
        return `Inválido ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Número inválido: debe ser múltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave inválida en ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inválida";
      case "invalid_element":
        return `Valor inválido en ${issue2.origin}`;
      default:
        return `Entrada inválida`;
    }
  };
};
function es_default() {
  return {
    localeError: error11()
  };
}

// node_modules/zod/v4/locales/fa.js
var error12 = () => {
  const Sizable = {
    string: { unit: "کاراکتر", verb: "داشته باشد" },
    file: { unit: "بایت", verb: "داشته باشد" },
    array: { unit: "آیتم", verb: "داشته باشد" },
    set: { unit: "آیتم", verb: "داشته باشد" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "عدد";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "آرایه";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ورودی",
    email: "آدرس ایمیل",
    url: "URL",
    emoji: "ایموجی",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "تاریخ و زمان ایزو",
    date: "تاریخ ایزو",
    time: "زمان ایزو",
    duration: "مدت زمان ایزو",
    ipv4: "IPv4 آدرس",
    ipv6: "IPv6 آدرس",
    cidrv4: "IPv4 دامنه",
    cidrv6: "IPv6 دامنه",
    base64: "base64-encoded رشته",
    base64url: "base64url-encoded رشته",
    json_string: "JSON رشته",
    e164: "E.164 عدد",
    jwt: "JWT",
    template_literal: "ورودی"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `ورودی نامعتبر: می‌بایست ${issue2.expected} می‌بود، ${parsedType4(issue2.input)} دریافت شد`;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `ورودی نامعتبر: می‌بایست ${stringifyPrimitive(issue2.values[0])} می‌بود`;
        }
        return `گزینه نامعتبر: می‌بایست یکی از ${joinValues(issue2.values, "|")} می‌بود`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `خیلی بزرگ: ${issue2.origin ?? "مقدار"} باید ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "عنصر"} باشد`;
        }
        return `خیلی بزرگ: ${issue2.origin ?? "مقدار"} باید ${adj}${issue2.maximum.toString()} باشد`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `خیلی کوچک: ${issue2.origin} باید ${adj}${issue2.minimum.toString()} ${sizing.unit} باشد`;
        }
        return `خیلی کوچک: ${issue2.origin} باید ${adj}${issue2.minimum.toString()} باشد`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `رشته نامعتبر: باید با "${_issue.prefix}" شروع شود`;
        }
        if (_issue.format === "ends_with") {
          return `رشته نامعتبر: باید با "${_issue.suffix}" تمام شود`;
        }
        if (_issue.format === "includes") {
          return `رشته نامعتبر: باید شامل "${_issue.includes}" باشد`;
        }
        if (_issue.format === "regex") {
          return `رشته نامعتبر: باید با الگوی ${_issue.pattern} مطابقت داشته باشد`;
        }
        return `${Nouns[_issue.format] ?? issue2.format} نامعتبر`;
      }
      case "not_multiple_of":
        return `عدد نامعتبر: باید مضرب ${issue2.divisor} باشد`;
      case "unrecognized_keys":
        return `کلید${issue2.keys.length > 1 ? "های" : ""} ناشناس: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `کلید ناشناس در ${issue2.origin}`;
      case "invalid_union":
        return `ورودی نامعتبر`;
      case "invalid_element":
        return `مقدار نامعتبر در ${issue2.origin}`;
      default:
        return `ورودی نامعتبر`;
    }
  };
};
function fa_default() {
  return {
    localeError: error12()
  };
}

// node_modules/zod/v4/locales/fi.js
var error13 = () => {
  const Sizable = {
    string: { unit: "merkkiä", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "päivämäärän" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "array";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "säännöllinen lauseke",
    email: "sähköpostiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-päivämäärä",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${issue2.expected}, oli ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen syöte: täytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: täytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} täytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon täytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} täytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon täytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen syöte: täytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen syöte: täytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen syöte: täytyy sisältää "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen syöte: täytyy vastata säännöllistä lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: täytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen syöte`;
    }
  };
};
function fi_default() {
  return {
    localeError: error13()
  };
}

// node_modules/zod/v4/locales/fr.js
var error14 = () => {
  const Sizable = {
    string: { unit: "caractères", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "éléments", verb: "avoir" },
    set: { unit: "éléments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "nombre";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "tableau";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrée",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "durée ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chaîne encodée en base64",
    base64url: "chaîne encodée en base64url",
    json_string: "chaîne JSON",
    e164: "numéro E.164",
    jwt: "JWT",
    template_literal: "entrée"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entrée invalide : ${issue2.expected} attendu, ${parsedType4(issue2.input)} reçu`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrée invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "élément(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit être ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit être ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chaîne invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chaîne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chaîne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chaîne invalide : doit correspondre au modèle ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit être un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clé${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clé invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entrée invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entrée invalide`;
    }
  };
};
function fr_default() {
  return {
    localeError: error14()
  };
}

// node_modules/zod/v4/locales/fr-CA.js
var error15 = () => {
  const Sizable = {
    string: { unit: "caractères", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "éléments", verb: "avoir" },
    set: { unit: "éléments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "array";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrée",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "durée ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chaîne encodée en base64",
    base64url: "chaîne encodée en base64url",
    json_string: "chaîne JSON",
    e164: "numéro E.164",
    jwt: "JWT",
    template_literal: "entrée"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entrée invalide : attendu ${issue2.expected}, reçu ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrée invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "≤" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "≥" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Chaîne invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Chaîne invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chaîne invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chaîne invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit être un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clé${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clé invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entrée invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entrée invalide`;
    }
  };
};
function fr_CA_default() {
  return {
    localeError: error15()
  };
}

// node_modules/zod/v4/locales/he.js
var error16 = () => {
  const Sizable = {
    string: { unit: "אותיות", verb: "לכלול" },
    file: { unit: "בייטים", verb: "לכלול" },
    array: { unit: "פריטים", verb: "לכלול" },
    set: { unit: "פריטים", verb: "לכלול" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "array";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "קלט",
    email: "כתובת אימייל",
    url: "כתובת רשת",
    emoji: "אימוג'י",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "תאריך וזמן ISO",
    date: "תאריך ISO",
    time: "זמן ISO",
    duration: "משך זמן ISO",
    ipv4: "כתובת IPv4",
    ipv6: "כתובת IPv6",
    cidrv4: "טווח IPv4",
    cidrv6: "טווח IPv6",
    base64: "מחרוזת בבסיס 64",
    base64url: "מחרוזת בבסיס 64 לכתובות רשת",
    json_string: "מחרוזת JSON",
    e164: "מספר E.164",
    jwt: "JWT",
    template_literal: "קלט"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `קלט לא תקין: צריך ${issue2.expected}, התקבל ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `קלט לא תקין: צריך ${stringifyPrimitive(issue2.values[0])}`;
        return `קלט לא תקין: צריך אחת מהאפשרויות  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `גדול מדי: ${issue2.origin ?? "value"} צריך להיות ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `גדול מדי: ${issue2.origin ?? "value"} צריך להיות ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `קטן מדי: ${issue2.origin} צריך להיות ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `קטן מדי: ${issue2.origin} צריך להיות ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `מחרוזת לא תקינה: חייבת להתחיל ב"${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `מחרוזת לא תקינה: חייבת להסתיים ב "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `מחרוזת לא תקינה: חייבת לכלול "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `מחרוזת לא תקינה: חייבת להתאים לתבנית ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} לא תקין`;
      }
      case "not_multiple_of":
        return `מספר לא תקין: חייב להיות מכפלה של ${issue2.divisor}`;
      case "unrecognized_keys":
        return `מפתח${issue2.keys.length > 1 ? "ות" : ""} לא מזוה${issue2.keys.length > 1 ? "ים" : "ה"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `מפתח לא תקין ב${issue2.origin}`;
      case "invalid_union":
        return "קלט לא תקין";
      case "invalid_element":
        return `ערך לא תקין ב${issue2.origin}`;
      default:
        return `קלט לא תקין`;
    }
  };
};
function he_default() {
  return {
    localeError: error16()
  };
}

// node_modules/zod/v4/locales/hu.js
var error17 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "szám";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "tömb";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "bemenet",
    email: "email cím",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO időbélyeg",
    date: "ISO dátum",
    time: "ISO idő",
    duration: "ISO időintervallum",
    ipv4: "IPv4 cím",
    ipv6: "IPv6 cím",
    cidrv4: "IPv4 tartomány",
    cidrv6: "IPv6 tartomány",
    base64: "base64-kódolt string",
    base64url: "base64url-kódolt string",
    json_string: "JSON string",
    e164: "E.164 szám",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Érvénytelen bemenet: a várt érték ${issue2.expected}, a kapott érték ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Érvénytelen bemenet: a várt érték ${stringifyPrimitive(issue2.values[0])}`;
        return `Érvénytelen opció: valamelyik érték várt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Túl nagy: ${issue2.origin ?? "érték"} mérete túl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `Túl nagy: a bemeneti érték ${issue2.origin ?? "érték"} túl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Túl kicsi: a bemeneti érték ${issue2.origin} mérete túl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Túl kicsi: a bemeneti érték ${issue2.origin} túl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Érvénytelen string: "${_issue.prefix}" értékkel kell kezdődnie`;
        if (_issue.format === "ends_with")
          return `Érvénytelen string: "${_issue.suffix}" értékkel kell végződnie`;
        if (_issue.format === "includes")
          return `Érvénytelen string: "${_issue.includes}" értéket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `Érvénytelen string: ${_issue.pattern} mintának kell megfelelnie`;
        return `Érvénytelen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Érvénytelen szám: ${issue2.divisor} többszörösének kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Érvénytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "Érvénytelen bemenet";
      case "invalid_element":
        return `Érvénytelen érték: ${issue2.origin}`;
      default:
        return `Érvénytelen bemenet`;
    }
  };
};
function hu_default() {
  return {
    localeError: error17()
  };
}

// node_modules/zod/v4/locales/id.js
var error18 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "array";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${issue2.expected}, diterima ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default() {
  return {
    localeError: error18()
  };
}

// node_modules/zod/v4/locales/it.js
var error19 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "numero";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "vettore";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input non valido: atteso ${issue2.expected}, ricevuto ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default() {
  return {
    localeError: error19()
  };
}

// node_modules/zod/v4/locales/ja.js
var error20 = () => {
  const Sizable = {
    string: { unit: "文字", verb: "である" },
    file: { unit: "バイト", verb: "である" },
    array: { unit: "要素", verb: "である" },
    set: { unit: "要素", verb: "である" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "数値";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "配列";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "入力値",
    email: "メールアドレス",
    url: "URL",
    emoji: "絵文字",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO日時",
    date: "ISO日付",
    time: "ISO時刻",
    duration: "ISO期間",
    ipv4: "IPv4アドレス",
    ipv6: "IPv6アドレス",
    cidrv4: "IPv4範囲",
    cidrv6: "IPv6範囲",
    base64: "base64エンコード文字列",
    base64url: "base64urlエンコード文字列",
    json_string: "JSON文字列",
    e164: "E.164番号",
    jwt: "JWT",
    template_literal: "入力値"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `無効な入力: ${issue2.expected}が期待されましたが、${parsedType4(issue2.input)}が入力されました`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `無効な入力: ${stringifyPrimitive(issue2.values[0])}が期待されました`;
        return `無効な選択: ${joinValues(issue2.values, "、")}のいずれかである必要があります`;
      case "too_big": {
        const adj = issue2.inclusive ? "以下である" : "より小さい";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `大きすぎる値: ${issue2.origin ?? "値"}は${issue2.maximum.toString()}${sizing.unit ?? "要素"}${adj}必要があります`;
        return `大きすぎる値: ${issue2.origin ?? "値"}は${issue2.maximum.toString()}${adj}必要があります`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "以上である" : "より大きい";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `小さすぎる値: ${issue2.origin}は${issue2.minimum.toString()}${sizing.unit}${adj}必要があります`;
        return `小さすぎる値: ${issue2.origin}は${issue2.minimum.toString()}${adj}必要があります`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `無効な文字列: "${_issue.prefix}"で始まる必要があります`;
        if (_issue.format === "ends_with")
          return `無効な文字列: "${_issue.suffix}"で終わる必要があります`;
        if (_issue.format === "includes")
          return `無効な文字列: "${_issue.includes}"を含む必要があります`;
        if (_issue.format === "regex")
          return `無効な文字列: パターン${_issue.pattern}に一致する必要があります`;
        return `無効な${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `無効な数値: ${issue2.divisor}の倍数である必要があります`;
      case "unrecognized_keys":
        return `認識されていないキー${issue2.keys.length > 1 ? "群" : ""}: ${joinValues(issue2.keys, "、")}`;
      case "invalid_key":
        return `${issue2.origin}内の無効なキー`;
      case "invalid_union":
        return "無効な入力";
      case "invalid_element":
        return `${issue2.origin}内の無効な値`;
      default:
        return `無効な入力`;
    }
  };
};
function ja_default() {
  return {
    localeError: error20()
  };
}

// node_modules/zod/v4/locales/kh.js
var error21 = () => {
  const Sizable = {
    string: { unit: "តួអក្សរ", verb: "គួរមាន" },
    file: { unit: "បៃ", verb: "គួរមាន" },
    array: { unit: "ធាតុ", verb: "គួរមាន" },
    set: { unit: "ធាតុ", verb: "គួរមាន" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "មិនមែនជាលេខ (NaN)" : "លេខ";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "អារេ (Array)";
        }
        if (data3 === null) {
          return "គ្មានតម្លៃ (null)";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ទិន្នន័យបញ្ចូល",
    email: "អាសយដ្ឋានអ៊ីមែល",
    url: "URL",
    emoji: "សញ្ញាអារម្មណ៍",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "កាលបរិច្ឆេទ និងម៉ោង ISO",
    date: "កាលបរិច្ឆេទ ISO",
    time: "ម៉ោង ISO",
    duration: "រយៈពេល ISO",
    ipv4: "អាសយដ្ឋាន IPv4",
    ipv6: "អាសយដ្ឋាន IPv6",
    cidrv4: "ដែនអាសយដ្ឋាន IPv4",
    cidrv6: "ដែនអាសយដ្ឋាន IPv6",
    base64: "ខ្សែអក្សរអ៊ិកូដ base64",
    base64url: "ខ្សែអក្សរអ៊ិកូដ base64url",
    json_string: "ខ្សែអក្សរ JSON",
    e164: "លេខ E.164",
    jwt: "JWT",
    template_literal: "ទិន្នន័យបញ្ចូល"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${issue2.expected} ប៉ុន្តែទទួលបាន ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `ទិន្នន័យបញ្ចូលមិនត្រឹមត្រូវ៖ ត្រូវការ ${stringifyPrimitive(issue2.values[0])}`;
        return `ជម្រើសមិនត្រឹមត្រូវ៖ ត្រូវជាមួយក្នុងចំណោម ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ធំពេក៖ ត្រូវការ ${issue2.origin ?? "តម្លៃ"} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "ធាតុ"}`;
        return `ធំពេក៖ ត្រូវការ ${issue2.origin ?? "តម្លៃ"} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `តូចពេក៖ ត្រូវការ ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `តូចពេក៖ ត្រូវការ ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវចាប់ផ្តើមដោយ "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវបញ្ចប់ដោយ "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវមាន "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `ខ្សែអក្សរមិនត្រឹមត្រូវ៖ ត្រូវតែផ្គូផ្គងនឹងទម្រង់ដែលបានកំណត់ ${_issue.pattern}`;
        return `មិនត្រឹមត្រូវ៖ ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `លេខមិនត្រឹមត្រូវ៖ ត្រូវតែជាពហុគុណនៃ ${issue2.divisor}`;
      case "unrecognized_keys":
        return `រកឃើញសោមិនស្គាល់៖ ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `សោមិនត្រឹមត្រូវនៅក្នុង ${issue2.origin}`;
      case "invalid_union":
        return `ទិន្នន័យមិនត្រឹមត្រូវ`;
      case "invalid_element":
        return `ទិន្នន័យមិនត្រឹមត្រូវនៅក្នុង ${issue2.origin}`;
      default:
        return `ទិន្នន័យមិនត្រឹមត្រូវ`;
    }
  };
};
function kh_default() {
  return {
    localeError: error21()
  };
}

// node_modules/zod/v4/locales/ko.js
var error22 = () => {
  const Sizable = {
    string: { unit: "문자", verb: "to have" },
    file: { unit: "바이트", verb: "to have" },
    array: { unit: "개", verb: "to have" },
    set: { unit: "개", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "array";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "입력",
    email: "이메일 주소",
    url: "URL",
    emoji: "이모지",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO 날짜시간",
    date: "ISO 날짜",
    time: "ISO 시간",
    duration: "ISO 기간",
    ipv4: "IPv4 주소",
    ipv6: "IPv6 주소",
    cidrv4: "IPv4 범위",
    cidrv6: "IPv6 범위",
    base64: "base64 인코딩 문자열",
    base64url: "base64url 인코딩 문자열",
    json_string: "JSON 문자열",
    e164: "E.164 번호",
    jwt: "JWT",
    template_literal: "입력"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `잘못된 입력: 예상 타입은 ${issue2.expected}, 받은 타입은 ${parsedType4(issue2.input)}입니다`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `잘못된 입력: 값은 ${stringifyPrimitive(issue2.values[0])} 이어야 합니다`;
        return `잘못된 옵션: ${joinValues(issue2.values, "또는 ")} 중 하나여야 합니다`;
      case "too_big": {
        const adj = issue2.inclusive ? "이하" : "미만";
        const suffix = adj === "미만" ? "이어야 합니다" : "여야 합니다";
        const sizing = getSizing(issue2.origin);
        const unit = (sizing == null ? void 0 : sizing.unit) ?? "요소";
        if (sizing)
          return `${issue2.origin ?? "값"}이 너무 큽니다: ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? "값"}이 너무 큽니다: ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "이상" : "초과";
        const suffix = adj === "이상" ? "이어야 합니다" : "여야 합니다";
        const sizing = getSizing(issue2.origin);
        const unit = (sizing == null ? void 0 : sizing.unit) ?? "요소";
        if (sizing) {
          return `${issue2.origin ?? "값"}이 너무 작습니다: ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? "값"}이 너무 작습니다: ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `잘못된 문자열: "${_issue.prefix}"(으)로 시작해야 합니다`;
        }
        if (_issue.format === "ends_with")
          return `잘못된 문자열: "${_issue.suffix}"(으)로 끝나야 합니다`;
        if (_issue.format === "includes")
          return `잘못된 문자열: "${_issue.includes}"을(를) 포함해야 합니다`;
        if (_issue.format === "regex")
          return `잘못된 문자열: 정규식 ${_issue.pattern} 패턴과 일치해야 합니다`;
        return `잘못된 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `잘못된 숫자: ${issue2.divisor}의 배수여야 합니다`;
      case "unrecognized_keys":
        return `인식할 수 없는 키: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `잘못된 키: ${issue2.origin}`;
      case "invalid_union":
        return `잘못된 입력`;
      case "invalid_element":
        return `잘못된 값: ${issue2.origin}`;
      default:
        return `잘못된 입력`;
    }
  };
};
function ko_default() {
  return {
    localeError: error22()
  };
}

// node_modules/zod/v4/locales/mk.js
var error23 = () => {
  const Sizable = {
    string: { unit: "знаци", verb: "да имаат" },
    file: { unit: "бајти", verb: "да имаат" },
    array: { unit: "ставки", verb: "да имаат" },
    set: { unit: "ставки", verb: "да имаат" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "број";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "низа";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "внес",
    email: "адреса на е-пошта",
    url: "URL",
    emoji: "емоџи",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO датум и време",
    date: "ISO датум",
    time: "ISO време",
    duration: "ISO времетраење",
    ipv4: "IPv4 адреса",
    ipv6: "IPv6 адреса",
    cidrv4: "IPv4 опсег",
    cidrv6: "IPv6 опсег",
    base64: "base64-енкодирана низа",
    base64url: "base64url-енкодирана низа",
    json_string: "JSON низа",
    e164: "E.164 број",
    jwt: "JWT",
    template_literal: "внес"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Грешен внес: се очекува ${issue2.expected}, примено ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Грешана опција: се очекува една ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Премногу голем: се очекува ${issue2.origin ?? "вредноста"} да има ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "елементи"}`;
        return `Премногу голем: се очекува ${issue2.origin ?? "вредноста"} да биде ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Премногу мал: се очекува ${issue2.origin} да има ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Премногу мал: се очекува ${issue2.origin} да биде ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Неважечка низа: мора да започнува со "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Неважечка низа: мора да завршува со "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Неважечка низа: мора да вклучува "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Неважечка низа: мора да одгоара на патернот ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Грешен број: мора да биде делив со ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Непрепознаени клучеви" : "Непрепознаен клуч"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Грешен клуч во ${issue2.origin}`;
      case "invalid_union":
        return "Грешен внес";
      case "invalid_element":
        return `Грешна вредност во ${issue2.origin}`;
      default:
        return `Грешен внес`;
    }
  };
};
function mk_default() {
  return {
    localeError: error23()
  };
}

// node_modules/zod/v4/locales/ms.js
var error24 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "nombor";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "array";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${issue2.expected}, diterima ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default() {
  return {
    localeError: error24()
  };
}

// node_modules/zod/v4/locales/nl.js
var error25 = () => {
  const Sizable = {
    string: { unit: "tekens" },
    file: { unit: "bytes" },
    array: { unit: "elementen" },
    set: { unit: "elementen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "getal";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "array";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${issue2.expected}, ontving ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht één van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} bevat`;
        return `Te lang: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} bevat`;
        }
        return `Te kort: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default() {
  return {
    localeError: error25()
  };
}

// node_modules/zod/v4/locales/no.js
var error26 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "å ha" },
    file: { unit: "bytes", verb: "å ha" },
    array: { unit: "elementer", verb: "å inneholde" },
    set: { unit: "elementer", verb: "å inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "tall";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "liste";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-område",
    ipv6: "IPv6-område",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${issue2.expected}, fikk ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til å ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til å ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til å ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til å ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: må starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: må ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: må inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: må matche mønsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: må være et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente nøkler" : "Ukjent nøkkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nøkkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default() {
  return {
    localeError: error26()
  };
}

// node_modules/zod/v4/locales/ota.js
var error27 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmalıdır" },
    file: { unit: "bayt", verb: "olmalıdır" },
    array: { unit: "unsur", verb: "olmalıdır" },
    set: { unit: "unsur", verb: "olmalıdır" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "numara";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "saf";
        }
        if (data3 === null) {
          return "gayb";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "giren",
    email: "epostagâh",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO hengâmı",
    date: "ISO tarihi",
    time: "ISO zamanı",
    duration: "ISO müddeti",
    ipv4: "IPv4 nişânı",
    ipv6: "IPv6 nişânı",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-şifreli metin",
    base64url: "base64url-şifreli metin",
    json_string: "JSON metin",
    e164: "E.164 sayısı",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Fâsit giren: umulan ${issue2.expected}, alınan ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Fâsit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `Fâsit tercih: mûteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla büyük: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmalıydı.`;
        return `Fazla büyük: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmalıydı.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla küçük: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmalıydı.`;
        }
        return `Fazla küçük: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmalıydı.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Fâsit metin: "${_issue.prefix}" ile başlamalı.`;
        if (_issue.format === "ends_with")
          return `Fâsit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `Fâsit metin: "${_issue.includes}" ihtivâ etmeli.`;
        if (_issue.format === "regex")
          return `Fâsit metin: ${_issue.pattern} nakşına uymalı.`;
        return `Fâsit ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Fâsit sayı: ${issue2.divisor} katı olmalıydı.`;
      case "unrecognized_keys":
        return `Tanınmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} için tanınmayan anahtar var.`;
      case "invalid_union":
        return "Giren tanınamadı.";
      case "invalid_element":
        return `${issue2.origin} için tanınmayan kıymet var.`;
      default:
        return `Kıymet tanınamadı.`;
    }
  };
};
function ota_default() {
  return {
    localeError: error27()
  };
}

// node_modules/zod/v4/locales/ps.js
var error28 = () => {
  const Sizable = {
    string: { unit: "توکي", verb: "ولري" },
    file: { unit: "بایټس", verb: "ولري" },
    array: { unit: "توکي", verb: "ولري" },
    set: { unit: "توکي", verb: "ولري" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "عدد";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "ارې";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ورودي",
    email: "بریښنالیک",
    url: "یو آر ال",
    emoji: "ایموجي",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "نیټه او وخت",
    date: "نېټه",
    time: "وخت",
    duration: "موده",
    ipv4: "د IPv4 پته",
    ipv6: "د IPv6 پته",
    cidrv4: "د IPv4 ساحه",
    cidrv6: "د IPv6 ساحه",
    base64: "base64-encoded متن",
    base64url: "base64url-encoded متن",
    json_string: "JSON متن",
    e164: "د E.164 شمېره",
    jwt: "JWT",
    template_literal: "ورودي"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `ناسم ورودي: باید ${issue2.expected} وای, مګر ${parsedType4(issue2.input)} ترلاسه شو`;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return `ناسم ورودي: باید ${stringifyPrimitive(issue2.values[0])} وای`;
        }
        return `ناسم انتخاب: باید یو له ${joinValues(issue2.values, "|")} څخه وای`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `ډیر لوی: ${issue2.origin ?? "ارزښت"} باید ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "عنصرونه"} ولري`;
        }
        return `ډیر لوی: ${issue2.origin ?? "ارزښت"} باید ${adj}${issue2.maximum.toString()} وي`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `ډیر کوچنی: ${issue2.origin} باید ${adj}${issue2.minimum.toString()} ${sizing.unit} ولري`;
        }
        return `ډیر کوچنی: ${issue2.origin} باید ${adj}${issue2.minimum.toString()} وي`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `ناسم متن: باید د "${_issue.prefix}" سره پیل شي`;
        }
        if (_issue.format === "ends_with") {
          return `ناسم متن: باید د "${_issue.suffix}" سره پای ته ورسيږي`;
        }
        if (_issue.format === "includes") {
          return `ناسم متن: باید "${_issue.includes}" ولري`;
        }
        if (_issue.format === "regex") {
          return `ناسم متن: باید د ${_issue.pattern} سره مطابقت ولري`;
        }
        return `${Nouns[_issue.format] ?? issue2.format} ناسم دی`;
      }
      case "not_multiple_of":
        return `ناسم عدد: باید د ${issue2.divisor} مضرب وي`;
      case "unrecognized_keys":
        return `ناسم ${issue2.keys.length > 1 ? "کلیډونه" : "کلیډ"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `ناسم کلیډ په ${issue2.origin} کې`;
      case "invalid_union":
        return `ناسمه ورودي`;
      case "invalid_element":
        return `ناسم عنصر په ${issue2.origin} کې`;
      default:
        return `ناسمه ورودي`;
    }
  };
};
function ps_default() {
  return {
    localeError: error28()
  };
}

// node_modules/zod/v4/locales/pl.js
var error29 = () => {
  const Sizable = {
    string: { unit: "znaków", verb: "mieć" },
    file: { unit: "bajtów", verb: "mieć" },
    array: { unit: "elementów", verb: "mieć" },
    set: { unit: "elementów", verb: "mieć" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "liczba";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "tablica";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "wyrażenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "ciąg znaków zakodowany w formacie base64",
    base64url: "ciąg znaków zakodowany w formacie base64url",
    json_string: "ciąg znaków w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wejście"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nieprawidłowe dane wejściowe: oczekiwano ${issue2.expected}, otrzymano ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawidłowe dane wejściowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawidłowa opcja: oczekiwano jednej z wartości ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za duża wartość: oczekiwano, że ${issue2.origin ?? "wartość"} będzie mieć ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementów"}`;
        }
        return `Zbyt duż(y/a/e): oczekiwano, że ${issue2.origin ?? "wartość"} będzie wynosić ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za mała wartość: oczekiwano, że ${issue2.origin ?? "wartość"} będzie mieć ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "elementów"}`;
        }
        return `Zbyt mał(y/a/e): oczekiwano, że ${issue2.origin ?? "wartość"} będzie wynosić ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawidłowy ciąg znaków: musi zaczynać się od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawidłowy ciąg znaków: musi kończyć się na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawidłowy ciąg znaków: musi zawierać "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawidłowy ciąg znaków: musi odpowiadać wzorcowi ${_issue.pattern}`;
        return `Nieprawidłow(y/a/e) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidłowa liczba: musi być wielokrotnością ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidłowy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawidłowe dane wejściowe";
      case "invalid_element":
        return `Nieprawidłowa wartość w ${issue2.origin}`;
      default:
        return `Nieprawidłowe dane wejściowe`;
    }
  };
};
function pl_default() {
  return {
    localeError: error29()
  };
}

// node_modules/zod/v4/locales/pt.js
var error30 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "número";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "array";
        }
        if (data3 === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "padrão",
    email: "endereço de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "duração ISO",
    ipv4: "endereço IPv4",
    ipv6: "endereço IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "número E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipo inválido: esperado ${issue2.expected}, recebido ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada inválida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Opção inválida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto inválido: deve começar com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto inválido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto inválido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto inválido: deve corresponder ao padrão ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} inválido`;
      }
      case "not_multiple_of":
        return `Número inválido: deve ser múltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave inválida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada inválida";
      case "invalid_element":
        return `Valor inválido em ${issue2.origin}`;
      default:
        return `Campo inválido`;
    }
  };
};
function pt_default() {
  return {
    localeError: error30()
  };
}

// node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error31 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "символ",
        few: "символа",
        many: "символов"
      },
      verb: "иметь"
    },
    file: {
      unit: {
        one: "байт",
        few: "байта",
        many: "байт"
      },
      verb: "иметь"
    },
    array: {
      unit: {
        one: "элемент",
        few: "элемента",
        many: "элементов"
      },
      verb: "иметь"
    },
    set: {
      unit: {
        one: "элемент",
        few: "элемента",
        many: "элементов"
      },
      verb: "иметь"
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "число";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "массив";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ввод",
    email: "email адрес",
    url: "URL",
    emoji: "эмодзи",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO дата и время",
    date: "ISO дата",
    time: "ISO время",
    duration: "ISO длительность",
    ipv4: "IPv4 адрес",
    ipv6: "IPv6 адрес",
    cidrv4: "IPv4 диапазон",
    cidrv6: "IPv6 диапазон",
    base64: "строка в формате base64",
    base64url: "строка в формате base64url",
    json_string: "JSON строка",
    e164: "номер E.164",
    jwt: "JWT",
    template_literal: "ввод"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Неверный ввод: ожидалось ${issue2.expected}, получено ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Неверный ввод: ожидалось ${stringifyPrimitive(issue2.values[0])}`;
        return `Неверный вариант: ожидалось одно из ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Слишком большое значение: ожидалось, что ${issue2.origin ?? "значение"} будет иметь ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `Слишком большое значение: ожидалось, что ${issue2.origin ?? "значение"} будет ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `Слишком маленькое значение: ожидалось, что ${issue2.origin} будет иметь ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `Слишком маленькое значение: ожидалось, что ${issue2.origin} будет ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Неверная строка: должна начинаться с "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Неверная строка: должна заканчиваться на "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Неверная строка: должна содержать "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Неверная строка: должна соответствовать шаблону ${_issue.pattern}`;
        return `Неверный ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Неверное число: должно быть кратным ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Нераспознанн${issue2.keys.length > 1 ? "ые" : "ый"} ключ${issue2.keys.length > 1 ? "и" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Неверный ключ в ${issue2.origin}`;
      case "invalid_union":
        return "Неверные входные данные";
      case "invalid_element":
        return `Неверное значение в ${issue2.origin}`;
      default:
        return `Неверные входные данные`;
    }
  };
};
function ru_default() {
  return {
    localeError: error31()
  };
}

// node_modules/zod/v4/locales/sl.js
var error32 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "število";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "tabela";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "vnos",
    email: "e-poštni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in čas",
    date: "ISO datum",
    time: "ISO čas",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 številka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neveljaven vnos: pričakovano ${issue2.expected}, prejeto ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: pričakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna možnost: pričakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: pričakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: pričakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: pričakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: pričakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se začeti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se končati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno število: mora biti večkratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i ključi" : " ključ"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven ključ v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default() {
  return {
    localeError: error32()
  };
}

// node_modules/zod/v4/locales/sv.js
var error33 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att innehålla" },
    set: { unit: "objekt", verb: "att innehålla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "antal";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "lista";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "reguljärt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad sträng",
    base64url: "base64url-kodad sträng",
    json_string: "JSON-sträng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ogiltig inmatning: förväntat ${issue2.expected}, fick ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: förväntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: förväntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `För stor(t): förväntade ${issue2.origin ?? "värdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `För stor(t): förväntat ${issue2.origin ?? "värdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `För lite(t): förväntade ${issue2.origin ?? "värdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `För lite(t): förväntade ${issue2.origin ?? "värdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig sträng: måste börja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig sträng: måste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig sträng: måste innehålla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig sträng: måste matcha mönstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: måste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Okända nycklar" : "Okänd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "värdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt värde i ${issue2.origin ?? "värdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default() {
  return {
    localeError: error33()
  };
}

// node_modules/zod/v4/locales/ta.js
var error34 = () => {
  const Sizable = {
    string: { unit: "எழுத்துக்கள்", verb: "கொண்டிருக்க வேண்டும்" },
    file: { unit: "பைட்டுகள்", verb: "கொண்டிருக்க வேண்டும்" },
    array: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" },
    set: { unit: "உறுப்புகள்", verb: "கொண்டிருக்க வேண்டும்" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "எண் அல்லாதது" : "எண்";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "அணி";
        }
        if (data3 === null) {
          return "வெறுமை";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "உள்ளீடு",
    email: "மின்னஞ்சல் முகவரி",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO தேதி நேரம்",
    date: "ISO தேதி",
    time: "ISO நேரம்",
    duration: "ISO கால அளவு",
    ipv4: "IPv4 முகவரி",
    ipv6: "IPv6 முகவரி",
    cidrv4: "IPv4 வரம்பு",
    cidrv6: "IPv6 வரம்பு",
    base64: "base64-encoded சரம்",
    base64url: "base64url-encoded சரம்",
    json_string: "JSON சரம்",
    e164: "E.164 எண்",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${issue2.expected}, பெறப்பட்டது ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `தவறான உள்ளீடு: எதிர்பார்க்கப்பட்டது ${stringifyPrimitive(issue2.values[0])}`;
        return `தவறான விருப்பம்: எதிர்பார்க்கப்பட்டது ${joinValues(issue2.values, "|")} இல் ஒன்று`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${issue2.origin ?? "மதிப்பு"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "உறுப்புகள்"} ஆக இருக்க வேண்டும்`;
        }
        return `மிக பெரியது: எதிர்பார்க்கப்பட்டது ${issue2.origin ?? "மதிப்பு"} ${adj}${issue2.maximum.toString()} ஆக இருக்க வேண்டும்`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ஆக இருக்க வேண்டும்`;
        }
        return `மிகச் சிறியது: எதிர்பார்க்கப்பட்டது ${issue2.origin} ${adj}${issue2.minimum.toString()} ஆக இருக்க வேண்டும்`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `தவறான சரம்: "${_issue.prefix}" இல் தொடங்க வேண்டும்`;
        if (_issue.format === "ends_with")
          return `தவறான சரம்: "${_issue.suffix}" இல் முடிவடைய வேண்டும்`;
        if (_issue.format === "includes")
          return `தவறான சரம்: "${_issue.includes}" ஐ உள்ளடக்க வேண்டும்`;
        if (_issue.format === "regex")
          return `தவறான சரம்: ${_issue.pattern} முறைபாட்டுடன் பொருந்த வேண்டும்`;
        return `தவறான ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `தவறான எண்: ${issue2.divisor} இன் பலமாக இருக்க வேண்டும்`;
      case "unrecognized_keys":
        return `அடையாளம் தெரியாத விசை${issue2.keys.length > 1 ? "கள்" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} இல் தவறான விசை`;
      case "invalid_union":
        return "தவறான உள்ளீடு";
      case "invalid_element":
        return `${issue2.origin} இல் தவறான மதிப்பு`;
      default:
        return `தவறான உள்ளீடு`;
    }
  };
};
function ta_default() {
  return {
    localeError: error34()
  };
}

// node_modules/zod/v4/locales/th.js
var error35 = () => {
  const Sizable = {
    string: { unit: "ตัวอักษร", verb: "ควรมี" },
    file: { unit: "ไบต์", verb: "ควรมี" },
    array: { unit: "รายการ", verb: "ควรมี" },
    set: { unit: "รายการ", verb: "ควรมี" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "ไม่ใช่ตัวเลข (NaN)" : "ตัวเลข";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "อาร์เรย์ (Array)";
        }
        if (data3 === null) {
          return "ไม่มีค่า (null)";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ข้อมูลที่ป้อน",
    email: "ที่อยู่อีเมล",
    url: "URL",
    emoji: "อิโมจิ",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "วันที่เวลาแบบ ISO",
    date: "วันที่แบบ ISO",
    time: "เวลาแบบ ISO",
    duration: "ช่วงเวลาแบบ ISO",
    ipv4: "ที่อยู่ IPv4",
    ipv6: "ที่อยู่ IPv6",
    cidrv4: "ช่วง IP แบบ IPv4",
    cidrv6: "ช่วง IP แบบ IPv6",
    base64: "ข้อความแบบ Base64",
    base64url: "ข้อความแบบ Base64 สำหรับ URL",
    json_string: "ข้อความแบบ JSON",
    e164: "เบอร์โทรศัพท์ระหว่างประเทศ (E.164)",
    jwt: "โทเคน JWT",
    template_literal: "ข้อมูลที่ป้อน"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `ประเภทข้อมูลไม่ถูกต้อง: ควรเป็น ${issue2.expected} แต่ได้รับ ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `ค่าไม่ถูกต้อง: ควรเป็น ${stringifyPrimitive(issue2.values[0])}`;
        return `ตัวเลือกไม่ถูกต้อง: ควรเป็นหนึ่งใน ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "ไม่เกิน" : "น้อยกว่า";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `เกินกำหนด: ${issue2.origin ?? "ค่า"} ควรมี${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "รายการ"}`;
        return `เกินกำหนด: ${issue2.origin ?? "ค่า"} ควรมี${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "อย่างน้อย" : "มากกว่า";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `น้อยกว่ากำหนด: ${issue2.origin} ควรมี${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `น้อยกว่ากำหนด: ${issue2.origin} ควรมี${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `รูปแบบไม่ถูกต้อง: ข้อความต้องขึ้นต้นด้วย "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `รูปแบบไม่ถูกต้อง: ข้อความต้องลงท้ายด้วย "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `รูปแบบไม่ถูกต้อง: ข้อความต้องมี "${_issue.includes}" อยู่ในข้อความ`;
        if (_issue.format === "regex")
          return `รูปแบบไม่ถูกต้อง: ต้องตรงกับรูปแบบที่กำหนด ${_issue.pattern}`;
        return `รูปแบบไม่ถูกต้อง: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `ตัวเลขไม่ถูกต้อง: ต้องเป็นจำนวนที่หารด้วย ${issue2.divisor} ได้ลงตัว`;
      case "unrecognized_keys":
        return `พบคีย์ที่ไม่รู้จัก: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `คีย์ไม่ถูกต้องใน ${issue2.origin}`;
      case "invalid_union":
        return "ข้อมูลไม่ถูกต้อง: ไม่ตรงกับรูปแบบยูเนียนที่กำหนดไว้";
      case "invalid_element":
        return `ข้อมูลไม่ถูกต้องใน ${issue2.origin}`;
      default:
        return `ข้อมูลไม่ถูกต้อง`;
    }
  };
};
function th_default() {
  return {
    localeError: error35()
  };
}

// node_modules/zod/v4/locales/tr.js
var parsedType3 = (data3) => {
  const t = typeof data3;
  switch (t) {
    case "number": {
      return Number.isNaN(data3) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data3)) {
        return "array";
      }
      if (data3 === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
        return data3.constructor.name;
      }
    }
  }
  return t;
};
var error36 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmalı" },
    file: { unit: "bayt", verb: "olmalı" },
    array: { unit: "öğe", verb: "olmalı" },
    set: { unit: "öğe", verb: "olmalı" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO süre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aralığı",
    cidrv6: "IPv6 aralığı",
    base64: "base64 ile şifrelenmiş metin",
    base64url: "base64url ile şifrelenmiş metin",
    json_string: "JSON dizesi",
    e164: "E.164 sayısı",
    jwt: "JWT",
    template_literal: "Şablon dizesi"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Geçersiz değer: beklenen ${issue2.expected}, alınan ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Geçersiz değer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Geçersiz seçenek: aşağıdakilerden biri olmalı: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Çok büyük: beklenen ${issue2.origin ?? "değer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "öğe"}`;
        return `Çok büyük: beklenen ${issue2.origin ?? "değer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Çok küçük: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `Çok küçük: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Geçersiz metin: "${_issue.prefix}" ile başlamalı`;
        if (_issue.format === "ends_with")
          return `Geçersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Geçersiz metin: "${_issue.includes}" içermeli`;
        if (_issue.format === "regex")
          return `Geçersiz metin: ${_issue.pattern} desenine uymalı`;
        return `Geçersiz ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Geçersiz sayı: ${issue2.divisor} ile tam bölünebilmeli`;
      case "unrecognized_keys":
        return `Tanınmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} içinde geçersiz anahtar`;
      case "invalid_union":
        return "Geçersiz değer";
      case "invalid_element":
        return `${issue2.origin} içinde geçersiz değer`;
      default:
        return `Geçersiz değer`;
    }
  };
};
function tr_default() {
  return {
    localeError: error36()
  };
}

// node_modules/zod/v4/locales/ua.js
var error37 = () => {
  const Sizable = {
    string: { unit: "символів", verb: "матиме" },
    file: { unit: "байтів", verb: "матиме" },
    array: { unit: "елементів", verb: "матиме" },
    set: { unit: "елементів", verb: "матиме" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "число";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "масив";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "вхідні дані",
    email: "адреса електронної пошти",
    url: "URL",
    emoji: "емодзі",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "дата та час ISO",
    date: "дата ISO",
    time: "час ISO",
    duration: "тривалість ISO",
    ipv4: "адреса IPv4",
    ipv6: "адреса IPv6",
    cidrv4: "діапазон IPv4",
    cidrv6: "діапазон IPv6",
    base64: "рядок у кодуванні base64",
    base64url: "рядок у кодуванні base64url",
    json_string: "рядок JSON",
    e164: "номер E.164",
    jwt: "JWT",
    template_literal: "вхідні дані"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Неправильні вхідні дані: очікується ${issue2.expected}, отримано ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Неправильні вхідні дані: очікується ${stringifyPrimitive(issue2.values[0])}`;
        return `Неправильна опція: очікується одне з ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Занадто велике: очікується, що ${issue2.origin ?? "значення"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "елементів"}`;
        return `Занадто велике: очікується, що ${issue2.origin ?? "значення"} буде ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Занадто мале: очікується, що ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Занадто мале: очікується, що ${issue2.origin} буде ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Неправильний рядок: повинен починатися з "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Неправильний рядок: повинен закінчуватися на "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Неправильний рядок: повинен містити "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Неправильний рядок: повинен відповідати шаблону ${_issue.pattern}`;
        return `Неправильний ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Неправильне число: повинно бути кратним ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Нерозпізнаний ключ${issue2.keys.length > 1 ? "і" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Неправильний ключ у ${issue2.origin}`;
      case "invalid_union":
        return "Неправильні вхідні дані";
      case "invalid_element":
        return `Неправильне значення у ${issue2.origin}`;
      default:
        return `Неправильні вхідні дані`;
    }
  };
};
function ua_default() {
  return {
    localeError: error37()
  };
}

// node_modules/zod/v4/locales/ur.js
var error38 = () => {
  const Sizable = {
    string: { unit: "حروف", verb: "ہونا" },
    file: { unit: "بائٹس", verb: "ہونا" },
    array: { unit: "آئٹمز", verb: "ہونا" },
    set: { unit: "آئٹمز", verb: "ہونا" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "نمبر";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "آرے";
        }
        if (data3 === null) {
          return "نل";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "ان پٹ",
    email: "ای میل ایڈریس",
    url: "یو آر ایل",
    emoji: "ایموجی",
    uuid: "یو یو آئی ڈی",
    uuidv4: "یو یو آئی ڈی وی 4",
    uuidv6: "یو یو آئی ڈی وی 6",
    nanoid: "نینو آئی ڈی",
    guid: "جی یو آئی ڈی",
    cuid: "سی یو آئی ڈی",
    cuid2: "سی یو آئی ڈی 2",
    ulid: "یو ایل آئی ڈی",
    xid: "ایکس آئی ڈی",
    ksuid: "کے ایس یو آئی ڈی",
    datetime: "آئی ایس او ڈیٹ ٹائم",
    date: "آئی ایس او تاریخ",
    time: "آئی ایس او وقت",
    duration: "آئی ایس او مدت",
    ipv4: "آئی پی وی 4 ایڈریس",
    ipv6: "آئی پی وی 6 ایڈریس",
    cidrv4: "آئی پی وی 4 رینج",
    cidrv6: "آئی پی وی 6 رینج",
    base64: "بیس 64 ان کوڈڈ سٹرنگ",
    base64url: "بیس 64 یو آر ایل ان کوڈڈ سٹرنگ",
    json_string: "جے ایس او این سٹرنگ",
    e164: "ای 164 نمبر",
    jwt: "جے ڈبلیو ٹی",
    template_literal: "ان پٹ"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `غلط ان پٹ: ${issue2.expected} متوقع تھا، ${parsedType4(issue2.input)} موصول ہوا`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `غلط ان پٹ: ${stringifyPrimitive(issue2.values[0])} متوقع تھا`;
        return `غلط آپشن: ${joinValues(issue2.values, "|")} میں سے ایک متوقع تھا`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `بہت بڑا: ${issue2.origin ?? "ویلیو"} کے ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "عناصر"} ہونے متوقع تھے`;
        return `بہت بڑا: ${issue2.origin ?? "ویلیو"} کا ${adj}${issue2.maximum.toString()} ہونا متوقع تھا`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `بہت چھوٹا: ${issue2.origin} کے ${adj}${issue2.minimum.toString()} ${sizing.unit} ہونے متوقع تھے`;
        }
        return `بہت چھوٹا: ${issue2.origin} کا ${adj}${issue2.minimum.toString()} ہونا متوقع تھا`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `غلط سٹرنگ: "${_issue.prefix}" سے شروع ہونا چاہیے`;
        }
        if (_issue.format === "ends_with")
          return `غلط سٹرنگ: "${_issue.suffix}" پر ختم ہونا چاہیے`;
        if (_issue.format === "includes")
          return `غلط سٹرنگ: "${_issue.includes}" شامل ہونا چاہیے`;
        if (_issue.format === "regex")
          return `غلط سٹرنگ: پیٹرن ${_issue.pattern} سے میچ ہونا چاہیے`;
        return `غلط ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `غلط نمبر: ${issue2.divisor} کا مضاعف ہونا چاہیے`;
      case "unrecognized_keys":
        return `غیر تسلیم شدہ کی${issue2.keys.length > 1 ? "ز" : ""}: ${joinValues(issue2.keys, "، ")}`;
      case "invalid_key":
        return `${issue2.origin} میں غلط کی`;
      case "invalid_union":
        return "غلط ان پٹ";
      case "invalid_element":
        return `${issue2.origin} میں غلط ویلیو`;
      default:
        return `غلط ان پٹ`;
    }
  };
};
function ur_default() {
  return {
    localeError: error38()
  };
}

// node_modules/zod/v4/locales/vi.js
var error39 = () => {
  const Sizable = {
    string: { unit: "ký tự", verb: "có" },
    file: { unit: "byte", verb: "có" },
    array: { unit: "phần tử", verb: "có" },
    set: { unit: "phần tử", verb: "có" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "số";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "mảng";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "đầu vào",
    email: "địa chỉ email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ngày giờ ISO",
    date: "ngày ISO",
    time: "giờ ISO",
    duration: "khoảng thời gian ISO",
    ipv4: "địa chỉ IPv4",
    ipv6: "địa chỉ IPv6",
    cidrv4: "dải IPv4",
    cidrv6: "dải IPv6",
    base64: "chuỗi mã hóa base64",
    base64url: "chuỗi mã hóa base64url",
    json_string: "chuỗi JSON",
    e164: "số E.164",
    jwt: "JWT",
    template_literal: "đầu vào"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Đầu vào không hợp lệ: mong đợi ${issue2.expected}, nhận được ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Đầu vào không hợp lệ: mong đợi ${stringifyPrimitive(issue2.values[0])}`;
        return `Tùy chọn không hợp lệ: mong đợi một trong các giá trị ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Quá lớn: mong đợi ${issue2.origin ?? "giá trị"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "phần tử"}`;
        return `Quá lớn: mong đợi ${issue2.origin ?? "giá trị"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Quá nhỏ: mong đợi ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Quá nhỏ: mong đợi ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chuỗi không hợp lệ: phải bắt đầu bằng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chuỗi không hợp lệ: phải kết thúc bằng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chuỗi không hợp lệ: phải bao gồm "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chuỗi không hợp lệ: phải khớp với mẫu ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} không hợp lệ`;
      }
      case "not_multiple_of":
        return `Số không hợp lệ: phải là bội số của ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Khóa không được nhận dạng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Khóa không hợp lệ trong ${issue2.origin}`;
      case "invalid_union":
        return "Đầu vào không hợp lệ";
      case "invalid_element":
        return `Giá trị không hợp lệ trong ${issue2.origin}`;
      default:
        return `Đầu vào không hợp lệ`;
    }
  };
};
function vi_default() {
  return {
    localeError: error39()
  };
}

// node_modules/zod/v4/locales/zh-CN.js
var error40 = () => {
  const Sizable = {
    string: { unit: "字符", verb: "包含" },
    file: { unit: "字节", verb: "包含" },
    array: { unit: "项", verb: "包含" },
    set: { unit: "项", verb: "包含" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "非数字(NaN)" : "数字";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "数组";
        }
        if (data3 === null) {
          return "空值(null)";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "输入",
    email: "电子邮件",
    url: "URL",
    emoji: "表情符号",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO日期时间",
    date: "ISO日期",
    time: "ISO时间",
    duration: "ISO时长",
    ipv4: "IPv4地址",
    ipv6: "IPv6地址",
    cidrv4: "IPv4网段",
    cidrv6: "IPv6网段",
    base64: "base64编码字符串",
    base64url: "base64url编码字符串",
    json_string: "JSON字符串",
    e164: "E.164号码",
    jwt: "JWT",
    template_literal: "输入"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `无效输入：期望 ${issue2.expected}，实际接收 ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `无效输入：期望 ${stringifyPrimitive(issue2.values[0])}`;
        return `无效选项：期望以下之一 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `数值过大：期望 ${issue2.origin ?? "值"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "个元素"}`;
        return `数值过大：期望 ${issue2.origin ?? "值"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `数值过小：期望 ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `数值过小：期望 ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `无效字符串：必须以 "${_issue.prefix}" 开头`;
        if (_issue.format === "ends_with")
          return `无效字符串：必须以 "${_issue.suffix}" 结尾`;
        if (_issue.format === "includes")
          return `无效字符串：必须包含 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `无效字符串：必须满足正则表达式 ${_issue.pattern}`;
        return `无效${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `无效数字：必须是 ${issue2.divisor} 的倍数`;
      case "unrecognized_keys":
        return `出现未知的键(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} 中的键(key)无效`;
      case "invalid_union":
        return "无效输入";
      case "invalid_element":
        return `${issue2.origin} 中包含无效值(value)`;
      default:
        return `无效输入`;
    }
  };
};
function zh_CN_default() {
  return {
    localeError: error40()
  };
}

// node_modules/zod/v4/locales/zh-TW.js
var error41 = () => {
  const Sizable = {
    string: { unit: "字元", verb: "擁有" },
    file: { unit: "位元組", verb: "擁有" },
    array: { unit: "項目", verb: "擁有" },
    set: { unit: "項目", verb: "擁有" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType4 = (data3) => {
    const t = typeof data3;
    switch (t) {
      case "number": {
        return Number.isNaN(data3) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data3)) {
          return "array";
        }
        if (data3 === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data3) !== Object.prototype && data3.constructor) {
          return data3.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "輸入",
    email: "郵件地址",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO 日期時間",
    date: "ISO 日期",
    time: "ISO 時間",
    duration: "ISO 期間",
    ipv4: "IPv4 位址",
    ipv6: "IPv6 位址",
    cidrv4: "IPv4 範圍",
    cidrv6: "IPv6 範圍",
    base64: "base64 編碼字串",
    base64url: "base64url 編碼字串",
    json_string: "JSON 字串",
    e164: "E.164 數值",
    jwt: "JWT",
    template_literal: "輸入"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `無效的輸入值：預期為 ${issue2.expected}，但收到 ${parsedType4(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `無效的輸入值：預期為 ${stringifyPrimitive(issue2.values[0])}`;
        return `無效的選項：預期為以下其中之一 ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `數值過大：預期 ${issue2.origin ?? "值"} 應為 ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "個元素"}`;
        return `數值過大：預期 ${issue2.origin ?? "值"} 應為 ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `數值過小：預期 ${issue2.origin} 應為 ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `數值過小：預期 ${issue2.origin} 應為 ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `無效的字串：必須以 "${_issue.prefix}" 開頭`;
        }
        if (_issue.format === "ends_with")
          return `無效的字串：必須以 "${_issue.suffix}" 結尾`;
        if (_issue.format === "includes")
          return `無效的字串：必須包含 "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `無效的字串：必須符合格式 ${_issue.pattern}`;
        return `無效的 ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `無效的數字：必須為 ${issue2.divisor} 的倍數`;
      case "unrecognized_keys":
        return `無法識別的鍵值${issue2.keys.length > 1 ? "們" : ""}：${joinValues(issue2.keys, "、")}`;
      case "invalid_key":
        return `${issue2.origin} 中有無效的鍵值`;
      case "invalid_union":
        return "無效的輸入值";
      case "invalid_element":
        return `${issue2.origin} 中有無效的值`;
      default:
        return `無效的輸入值`;
    }
  };
};
function zh_TW_default() {
  return {
    localeError: error41()
  };
}

// node_modules/zod/v4/core/registries.js
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");
var $ZodRegistry = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p2 = schema._zod.parent;
    if (p2) {
      const pm = { ...this.get(p2) ?? {} };
      delete pm.id;
      return { ...pm, ...this._map.get(schema) };
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
var globalRegistry = registry();

// node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
function _mime(types2, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types2,
    ...normalizeParams(params)
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class2, element2, params) {
  return new Class2({
    type: "array",
    element: element2,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
function _union(Class2, options2, params) {
  return new Class2({
    type: "union",
    options: options2,
    ...normalizeParams(params)
  });
}
function _discriminatedUnion(Class2, discriminator, options2, params) {
  return new Class2({
    type: "union",
    options: options2,
    discriminator,
    ...normalizeParams(params)
  });
}
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
function _transform(Class2, fn2) {
  return new Class2({
    type: "transform",
    transform: fn2
  });
}
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
function _custom(Class2, fn2, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn: fn2,
    ...norm
  });
  return schema;
}
function _refine(Class2, fn2, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn: fn2,
    ...normalizeParams(_params)
  });
  return schema;
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Pipe = Classes.Pipe ?? $ZodPipe;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const _Transform = Classes.Transform ?? $ZodTransform;
  const tx = new _Transform({
    type: "transform",
    transform: (input, payload) => {
      let data3 = input;
      if (params.case !== "sensitive")
        data3 = data3.toLowerCase();
      if (truthySet.has(data3)) {
        return true;
      } else if (falsySet.has(data3)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: tx
        });
        return {};
      }
    },
    error: params.error
  });
  const innerPipe = new _Pipe({
    type: "pipe",
    in: new _String({ type: "string", error: params.error }),
    out: tx,
    error: params.error
  });
  const outerPipe = new _Pipe({
    type: "pipe",
    in: innerPipe,
    out: new _Boolean({
      type: "boolean",
      error: params.error
    }),
    error: params.error
  });
  return outerPipe;
}
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val2) => fnOrRegex.test(val2),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}

// node_modules/zod/v4/core/function.js
var $ZodFunction = class {
  constructor(def) {
    this._def = def;
    this.def = def;
  }
  implement(func) {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    const impl = (...args) => {
      const parsedArgs = this._def.input ? parse3(this._def.input, args, void 0, { callee: impl }) : args;
      if (!Array.isArray(parsedArgs)) {
        throw new Error("Invalid arguments schema: not an array or tuple schema.");
      }
      const output2 = func(...parsedArgs);
      return this._def.output ? parse3(this._def.output, output2, void 0, { callee: impl }) : output2;
    };
    return impl;
  }
  implementAsync(func) {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    const impl = async (...args) => {
      const parsedArgs = this._def.input ? await parseAsync(this._def.input, args, void 0, { callee: impl }) : args;
      if (!Array.isArray(parsedArgs)) {
        throw new Error("Invalid arguments schema: not an array or tuple schema.");
      }
      const output2 = await func(...parsedArgs);
      return this._def.output ? parseAsync(this._def.output, output2, void 0, { callee: impl }) : output2;
    };
    return impl;
  }
  input(...args) {
    const F2 = this.constructor;
    if (Array.isArray(args[0])) {
      return new F2({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: this._def.output
      });
    }
    return new F2({
      type: "function",
      input: args[0],
      output: this._def.output
    });
  }
  output(output2) {
    const F2 = this.constructor;
    return new F2({
      type: "function",
      input: this._def.input,
      output: output2
    });
  }
};
function _function(params) {
  return new $ZodFunction({
    type: "function",
    input: Array.isArray(params == null ? void 0 : params.input) ? _tuple($ZodTuple, params == null ? void 0 : params.input) : (params == null ? void 0 : params.input) ?? _array($ZodArray, _unknown($ZodUnknown)),
    output: (params == null ? void 0 : params.output) ?? _unknown($ZodUnknown)
  });
}

// node_modules/zod/v4/core/to-json-schema.js
var JSONSchemaGenerator = class {
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = (params == null ? void 0 : params.metadata) ?? globalRegistry;
    this.target = (params == null ? void 0 : params.target) ?? "draft-2020-12";
    this.unrepresentable = (params == null ? void 0 : params.unrepresentable) ?? "throw";
    this.override = (params == null ? void 0 : params.override) ?? (() => {
    });
    this.io = (params == null ? void 0 : params.io) ?? "output";
    this.seen = /* @__PURE__ */ new Map();
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    var _a3, _b2, _c2;
    var _a2;
    const def = schema._zod.def;
    const formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
      // do not set
    };
    const seen = this.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
    this.seen.set(schema, result);
    const overrideSchema = (_b2 = (_a3 = schema._zod).toJSONSchema) == null ? void 0 : _b2.call(_a3);
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema],
        path: _params.path
      };
      const parent = schema._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json2 = _json;
            json2.type = "string";
            const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
            if (typeof minimum === "number")
              json2.minLength = minimum;
            if (typeof maximum === "number")
              json2.maxLength = maximum;
            if (format) {
              json2.format = formatMap[format] ?? format;
              if (json2.format === "")
                delete json2.format;
            }
            if (contentEncoding)
              json2.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [...patterns];
              if (regexes.length === 1)
                json2.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex) => ({
                    ...this.target === "draft-7" ? { type: "string" } : {},
                    pattern: regex.source
                  }))
                ];
              }
            }
            break;
          }
          case "number": {
            const json2 = _json;
            const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
            if (typeof format === "string" && format.includes("int"))
              json2.type = "integer";
            else
              json2.type = "number";
            if (typeof exclusiveMinimum === "number")
              json2.exclusiveMinimum = exclusiveMinimum;
            if (typeof minimum === "number") {
              json2.minimum = minimum;
              if (typeof exclusiveMinimum === "number") {
                if (exclusiveMinimum >= minimum)
                  delete json2.minimum;
                else
                  delete json2.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number")
              json2.exclusiveMaximum = exclusiveMaximum;
            if (typeof maximum === "number") {
              json2.maximum = maximum;
              if (typeof exclusiveMaximum === "number") {
                if (exclusiveMaximum <= maximum)
                  delete json2.maximum;
                else
                  delete json2.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number")
              json2.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json2 = _json;
            json2.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json2 = _json;
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json2.minItems = minimum;
            if (typeof maximum === "number")
              json2.maxItems = maximum;
            json2.type = "array";
            json2.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
            break;
          }
          case "object": {
            const json2 = _json;
            json2.type = "object";
            json2.properties = {};
            const shape2 = def.shape;
            for (const key in shape2) {
              json2.properties[key] = this.process(shape2[key], {
                ...params,
                path: [...params.path, "properties", key]
              });
            }
            const allKeys = new Set(Object.keys(shape2));
            const requiredKeys = new Set([...allKeys].filter((key) => {
              const v = def.shape[key]._zod;
              if (this.io === "input") {
                return v.optin === void 0;
              } else {
                return v.optout === void 0;
              }
            }));
            if (requiredKeys.size > 0) {
              json2.required = Array.from(requiredKeys);
            }
            if (((_c2 = def.catchall) == null ? void 0 : _c2._zod.def.type) === "never") {
              json2.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output")
                json2.additionalProperties = false;
            } else if (def.catchall) {
              json2.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [...params.path, "additionalProperties"]
              });
            }
            break;
          }
          case "union": {
            const json2 = _json;
            json2.anyOf = def.options.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, "anyOf", i]
            }));
            break;
          }
          case "intersection": {
            const json2 = _json;
            const a2 = this.process(def.left, {
              ...params,
              path: [...params.path, "allOf", 0]
            });
            const b3 = this.process(def.right, {
              ...params,
              path: [...params.path, "allOf", 1]
            });
            const isSimpleIntersection = (val2) => "allOf" in val2 && Object.keys(val2).length === 1;
            const allOf = [
              ...isSimpleIntersection(a2) ? a2.allOf : [a2],
              ...isSimpleIntersection(b3) ? b3.allOf : [b3]
            ];
            json2.allOf = allOf;
            break;
          }
          case "tuple": {
            const json2 = _json;
            json2.type = "array";
            const prefixItems = def.items.map((x, i) => this.process(x, { ...params, path: [...params.path, "prefixItems", i] }));
            if (this.target === "draft-2020-12") {
              json2.prefixItems = prefixItems;
            } else {
              json2.items = prefixItems;
            }
            if (def.rest) {
              const rest = this.process(def.rest, {
                ...params,
                path: [...params.path, "items"]
              });
              if (this.target === "draft-2020-12") {
                json2.items = rest;
              } else {
                json2.additionalItems = rest;
              }
            }
            if (def.rest) {
              json2.items = this.process(def.rest, {
                ...params,
                path: [...params.path, "items"]
              });
            }
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json2.minItems = minimum;
            if (typeof maximum === "number")
              json2.maxItems = maximum;
            break;
          }
          case "record": {
            const json2 = _json;
            json2.type = "object";
            json2.propertyNames = this.process(def.keyType, { ...params, path: [...params.path, "propertyNames"] });
            json2.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [...params.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json2 = _json;
            const values = getEnumValues(def.entries);
            if (values.every((v) => typeof v === "number"))
              json2.type = "number";
            if (values.every((v) => typeof v === "string"))
              json2.type = "string";
            json2.enum = values;
            break;
          }
          case "literal": {
            const json2 = _json;
            const vals = [];
            for (const val2 of def.values) {
              if (val2 === void 0) {
                if (this.unrepresentable === "throw") {
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                } else {
                }
              } else if (typeof val2 === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                } else {
                  vals.push(Number(val2));
                }
              } else {
                vals.push(val2);
              }
            }
            if (vals.length === 0) {
            } else if (vals.length === 1) {
              const val2 = vals[0];
              json2.type = val2 === null ? "null" : typeof val2;
              json2.const = val2;
            } else {
              if (vals.every((v) => typeof v === "number"))
                json2.type = "number";
              if (vals.every((v) => typeof v === "string"))
                json2.type = "string";
              if (vals.every((v) => typeof v === "boolean"))
                json2.type = "string";
              if (vals.every((v) => v === null))
                json2.type = "null";
              json2.enum = vals;
            }
            break;
          }
          case "file": {
            const json2 = _json;
            const file3 = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            };
            const { minimum, maximum, mime } = schema._zod.bag;
            if (minimum !== void 0)
              file3.minLength = minimum;
            if (maximum !== void 0)
              file3.maxLength = maximum;
            if (mime) {
              if (mime.length === 1) {
                file3.contentMediaType = mime[0];
                Object.assign(json2, file3);
              } else {
                json2.anyOf = mime.map((m3) => {
                  const mFile = { ...file3, contentMediaType: m3 };
                  return mFile;
                });
              }
            } else {
              Object.assign(json2, file3);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error("Transforms cannot be represented in JSON Schema");
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            _json.anyOf = [inner, { type: "null" }];
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json2 = _json;
            json2.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input")
              _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(void 0);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json2 = _json;
            const pattern = schema._zod.pattern;
            if (!pattern)
              throw new Error("Pattern not found in template literal");
            json2.type = "string";
            json2.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error("Custom types cannot be represented in JSON Schema");
            }
            break;
          }
          default: {
            def;
          }
        }
      }
    }
    const meta = this.metadataRegistry.get(schema);
    if (meta)
      Object.assign(result.schema, meta);
    if (this.io === "input" && isTransforming(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault)
      (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema);
    return _result.schema;
  }
  emit(schema, _params) {
    var _a2, _b2, _c2, _d, _e, _f;
    const params = {
      cycles: (_params == null ? void 0 : _params.cycles) ?? "ref",
      reused: (_params == null ? void 0 : _params.reused) ?? "inline",
      // unrepresentable: _params?.unrepresentable ?? "throw",
      // uri: _params?.uri ?? ((id) => `${id}`),
      external: (_params == null ? void 0 : _params.external) ?? void 0
    };
    const root = this.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = (entry) => {
      var _a3;
      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = (_a3 = params.external.registry.get(entry[0])) == null ? void 0 : _a3.id;
        const uriGenerator = params.external.uri ?? ((id2) => id2);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
        entry[1].defId = id;
        return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
      }
      if (entry[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    };
    const extractToDef = (entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref: ref2, defId } = makeURI(entry);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref2;
    };
    if (params.cycles === "throw") {
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error(`Cycle detected: #/${(_a2 = seen.cycle) == null ? void 0 : _a2.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
        }
      }
    }
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (params.external) {
        const ext = (_b2 = params.external.registry.get(entry[0])) == null ? void 0 : _b2.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id = (_c2 = this.metadataRegistry.get(entry[0])) == null ? void 0 : _c2.id;
      if (id) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
    const flattenRef = (zodSchema, params2) => {
      const seen = this.seen.get(zodSchema);
      const schema2 = seen.def ?? seen.schema;
      const _cached = { ...schema2 };
      if (seen.ref === null) {
        return;
      }
      const ref2 = seen.ref;
      seen.ref = null;
      if (ref2) {
        flattenRef(ref2, params2);
        const refSchema = this.seen.get(ref2).schema;
        if (refSchema.$ref && params2.target === "draft-7") {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
          Object.assign(schema2, _cached);
        }
      }
      if (!seen.isParent)
        this.override({
          zodSchema,
          jsonSchema: schema2,
          path: seen.path ?? []
        });
    };
    for (const entry of [...this.seen.entries()].reverse()) {
      flattenRef(entry[0], { target: this.target });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if ((_d = params.external) == null ? void 0 : _d.uri) {
      const id = (_e = params.external.registry.get(schema)) == null ? void 0 : _e.id;
      if (!id)
        throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id);
    }
    Object.assign(result, root.def);
    const defs = ((_f = params.external) == null ? void 0 : _f.defs) ?? {};
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) {
    } else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
};
function toJSONSchema(input, _params) {
  if (input instanceof $ZodRegistry) {
    const gen2 = new JSONSchemaGenerator(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_23, schema] = entry;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params == null ? void 0 : _params.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema] = entry;
      schemas[key] = gen2.emit(schema, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const schema = _schema;
  const def = schema._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming(option, ctx))
          return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming(item, ctx))
          return true;
      }
      if (def.rest && isTransforming(def.rest, ctx))
        return true;
      return false;
    }
    case "record": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "map": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "set": {
      return isTransforming(def.valueType, ctx);
    }
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming(def.innerType, ctx);
    case "lazy":
      return isTransforming(def.getter(), ctx);
    case "default": {
      return isTransforming(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    default:
      def;
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}

// node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};

// node_modules/zod/v4/classic/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date2,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
var ZodISODateTime = $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue2) => inst.issues.push(issue2)
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => inst.issues.push(...issues2)
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
};
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/zod/v4/classic/parse.js
var parse4 = _parse(ZodRealError);
var parseAsync2 = _parseAsync(ZodRealError);
var safeParse2 = _safeParse(ZodRealError);
var safeParseAsync2 = _safeParseAsync(ZodRealError);

// node_modules/zod/v4/classic/schemas.js
var ZodType = $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(
      {
        ...def,
        checks: [
          ...def.checks ?? [],
          ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
        ]
      }
      // { parent: true }
    );
  };
  inst.clone = (def2, params) => clone2(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta) => {
    reg.add(inst, meta);
    return inst;
  };
  inst.parse = (data3, params) => parse4(inst, data3, params, { callee: inst.parse });
  inst.safeParse = (data3, params) => safeParse2(inst, data3, params);
  inst.parseAsync = async (data3, params) => parseAsync2(inst, data3, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data3, params) => safeParseAsync2(inst, data3, params);
  inst.spa = inst.safeParseAsync;
  inst.refine = (check2, params) => inst.check(refine(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn2) => inst.check(_overwrite(fn2));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform2(tx));
  inst.default = (def2) => _default2(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch2(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      var _a2;
      return (_a2 = globalRegistry.get(inst)) == null ? void 0 : _a2.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
var _ZodString = $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
});
var ZodString = $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time2(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
var ZodEmoji = $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
var ZodNanoID = $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodIPv6 = $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
var ZodNumber = $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
var ZodNumberFormat = $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean = $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
});
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
var ZodBigInt = $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
var ZodBigIntFormat = $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol = $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
});
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
var ZodUndefined = $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
var ZodNull = $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
});
function _null3(params) {
  return _null2(ZodNull, params);
}
var ZodAny = $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
});
function any() {
  return _any(ZodAny);
}
var ZodUnknown = $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown);
}
var ZodNever = $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodVoid = $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
});
function _void2(params) {
  return _void(ZodVoid, params);
}
var ZodDate = $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c4 = inst._zod.bag;
  inst.minDate = c4.minimum ? new Date(c4.minimum) : null;
  inst.maxDate = c4.maximum ? new Date(c4.maximum) : null;
});
function date3(params) {
  return _date(ZodDate, params);
}
var ZodArray = $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element2, params) {
  return _array(ZodArray, element2, params);
}
function keyof(schema) {
  const shape2 = schema._zod.def.shape;
  return literal(Object.keys(shape2));
}
var ZodObject = $constructor("ZodObject", (inst, def) => {
  $ZodObject.init(inst, def);
  ZodType.init(inst, def);
  util_exports2.defineLazy(inst, "shape", () => def.shape);
  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return util_exports2.extend(inst, incoming);
  };
  inst.merge = (other) => util_exports2.merge(inst, other);
  inst.pick = (mask) => util_exports2.pick(inst, mask);
  inst.omit = (mask) => util_exports2.omit(inst, mask);
  inst.partial = (...args) => util_exports2.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => util_exports2.required(ZodNonOptional, inst, args[0]);
});
function object(shape2, params) {
  const def = {
    type: "object",
    get shape() {
      util_exports2.assignProp(this, "shape", { ...shape2 });
      return this.shape;
    },
    ...util_exports2.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape2, params) {
  return new ZodObject({
    type: "object",
    get shape() {
      util_exports2.assignProp(this, "shape", { ...shape2 });
      return this.shape;
    },
    catchall: never(),
    ...util_exports2.normalizeParams(params)
  });
}
function looseObject(shape2, params) {
  return new ZodObject({
    type: "object",
    get shape() {
      util_exports2.assignProp(this, "shape", { ...shape2 });
      return this.shape;
    },
    catchall: unknown(),
    ...util_exports2.normalizeParams(params)
  });
}
var ZodUnion = $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst.options = def.options;
});
function union(options2, params) {
  return new ZodUnion({
    type: "union",
    options: options2,
    ...util_exports2.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion = $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options2, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options: options2,
    discriminator,
    ...util_exports2.normalizeParams(params)
  });
}
var ZodIntersection = $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple = $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...util_exports2.normalizeParams(params)
  });
}
var ZodRecord = $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports2.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType: union([keyType, never()]),
    valueType,
    ...util_exports2.normalizeParams(params)
  });
}
var ZodMap = $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function map2(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...util_exports2.normalizeParams(params)
  });
}
var ZodSet = $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function set2(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...util_exports2.normalizeParams(params)
  });
}
var ZodEnum = $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports2.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports2.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports2.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports2.normalizeParams(params)
  });
}
var ZodLiteral = $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports2.normalizeParams(params)
  });
}
var ZodFile = $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (size, params) => inst.check(_minSize(size, params));
  inst.max = (size, params) => inst.check(_maxSize(size, params));
  inst.mime = (types2, params) => inst.check(_mime(Array.isArray(types2) ? types2 : [types2], params));
});
function file2(params) {
  return _file(ZodFile, params);
}
var ZodTransform = $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports2.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        _issue.continue ?? (_issue.continue = true);
        payload.issues.push(util_exports2.issue(_issue));
      }
    };
    const output2 = def.transform(payload.value, payload);
    if (output2 instanceof Promise) {
      return output2.then((output3) => {
        payload.value = output3;
        return payload;
      });
    }
    payload.value = output2;
    return payload;
  };
});
function transform2(fn2) {
  return new ZodTransform({
    type: "transform",
    transform: fn2
  });
}
var ZodOptional = $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable = $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodDefault = $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
var ZodPrefault = $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
var ZodNonOptional = $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports2.normalizeParams(params)
  });
}
var ZodSuccess = $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
var ZodCatch = $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN = $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
});
function nan(params) {
  return _nan(ZodNaN, params);
}
var ZodPipe = $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
var ZodReadonly = $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType.init(inst, def);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports2.normalizeParams(params)
  });
}
var ZodLazy = $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
var ZodPromise = $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
var ZodCustom = $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
});
function check(fn2) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn2;
  return ch;
}
function custom(fn2, _params) {
  return _custom(ZodCustom, fn2 ?? (() => true), _params);
}
function refine(fn2, _params = {}) {
  return _refine(ZodCustom, fn2, _params);
}
function superRefine(fn2) {
  const ch = check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports2.issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(util_exports2.issue(_issue));
      }
    };
    return fn2(payload.value, payload);
  });
  return ch;
}
function _instanceof(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data3) => data3 instanceof cls,
    abort: true,
    ...util_exports2.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
var stringbool = (...args) => _stringbool({
  Pipe: ZodPipe,
  Boolean: ZodBoolean,
  String: ZodString,
  Transform: ZodTransform
}, ...args);
function json(params) {
  const jsonSchema = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn2, schema) {
  return pipe(transform2(fn2), schema);
}

// node_modules/zod/v4/classic/compat.js
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map3) {
  config({
    customError: map3
  });
}
function getErrorMap() {
  return config().customError;
}

// node_modules/zod/v4/classic/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint3,
  boolean: () => boolean3,
  date: () => date4,
  number: () => number3,
  string: () => string3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}

// node_modules/zod/v4/classic/external.js
config(en_default());

// node_modules/p5/dist/core/friendly_errors/param_validator.js
var p5$1 = {
  describe: {
    overloads: [
      [
        "String",
        "FALLBACK|LABEL?"
      ]
    ]
  },
  describeElement: {
    overloads: [
      [
        "String",
        "String",
        "FALLBACK|LABEL?"
      ]
    ]
  },
  textOutput: {
    overloads: [
      [
        "FALLBACK|LABEL?"
      ]
    ]
  },
  gridOutput: {
    overloads: [
      [
        "FALLBACK|LABEL?"
      ]
    ]
  },
  p5: {
    overloads: [
      [
        "Object",
        "String|HTMLElement"
      ]
    ]
  },
  color: {
    overloads: [
      [
        "Number",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "String"
      ],
      [
        "Number[]"
      ],
      [
        "p5.Color"
      ]
    ]
  },
  red: {
    overloads: [
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  green: {
    overloads: [
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  blue: {
    overloads: [
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  alpha: {
    overloads: [
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  hue: {
    overloads: [
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  saturation: {
    overloads: [
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  brightness: {
    overloads: [
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  lightness: {
    overloads: [
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  lerpColor: {
    overloads: [
      [
        "p5.Color",
        "p5.Color",
        "Number"
      ]
    ]
  },
  paletteLerp: {
    overloads: [
      [
        "[p5.Color|String|Number|Number[], Number][]",
        "Number"
      ]
    ]
  },
  beginClip: {
    overloads: [
      [
        "Object?"
      ]
    ]
  },
  endClip: {
    overloads: [
      []
    ]
  },
  clip: {
    overloads: [
      [
        "Function",
        "Object?"
      ]
    ]
  },
  background: {
    overloads: [
      [
        "p5.Color"
      ],
      [
        "String",
        "Number?"
      ],
      [
        "Number",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "Number[]"
      ],
      [
        "p5.Image",
        "Number?"
      ]
    ]
  },
  clear: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ],
      []
    ]
  },
  colorMode: {
    overloads: [
      [
        "RGB|HSB|HSL|RGBHDR|HWB|LAB|LCH|OKLAB|OKLCH",
        "Number?"
      ],
      [
        "RGB|HSB|HSL|RGBHDR|HWB|LAB|LCH|OKLAB|OKLCH",
        "Number",
        "Number",
        "Number",
        "Number?"
      ]
    ]
  },
  fill: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "String"
      ],
      [
        "Number",
        "Number?"
      ],
      [
        "Number[]"
      ],
      [
        "p5.Color"
      ]
    ]
  },
  noFill: {
    overloads: [
      []
    ]
  },
  noStroke: {
    overloads: [
      []
    ]
  },
  stroke: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "String"
      ],
      [
        "Number",
        "Number?"
      ],
      [
        "Number[]"
      ],
      [
        "p5.Color"
      ]
    ]
  },
  erase: {
    overloads: [
      [
        "Number?",
        "Number?"
      ]
    ]
  },
  noErase: {
    overloads: [
      []
    ]
  },
  blendMode: {
    overloads: [
      [
        "BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|REMOVE|SUBTRACT"
      ]
    ]
  },
  print: {
    overloads: [
      [
        "Any"
      ],
      [
        "String|Number|Array"
      ]
    ]
  },
  cursor: {
    overloads: [
      [
        "ARROW|CROSS|HAND|MOVE|TEXT|WAIT|String",
        "Number?",
        "Number?"
      ]
    ]
  },
  frameRate: {
    overloads: [
      [
        "Number"
      ],
      []
    ]
  },
  getTargetFrameRate: {
    overloads: [
      []
    ]
  },
  noCursor: {
    overloads: [
      []
    ]
  },
  windowResized: {
    overloads: [
      [
        "UIEvent?"
      ]
    ]
  },
  fullscreen: {
    overloads: [
      [
        "Boolean?"
      ]
    ]
  },
  pixelDensity: {
    overloads: [
      [
        "Number?"
      ],
      []
    ]
  },
  displayDensity: {
    overloads: [
      []
    ]
  },
  getURL: {
    overloads: [
      []
    ]
  },
  getURLPath: {
    overloads: [
      []
    ]
  },
  getURLParams: {
    overloads: [
      []
    ]
  },
  worldToScreen: {
    overloads: [
      [
        "Number|p5.Vector",
        "Number",
        "Number?"
      ]
    ]
  },
  screenToWorld: {
    overloads: [
      [
        "Number|p5.Vector",
        "Number",
        "Number?"
      ]
    ]
  },
  setup: {
    overloads: [
      []
    ]
  },
  draw: {
    overloads: [
      []
    ]
  },
  createCanvas: {
    overloads: [
      [
        "Number?",
        "Number?",
        "P2D|WEBGL|P2DHDR?",
        "HTMLCanvasElement?"
      ],
      [
        "Number?",
        "Number?",
        "HTMLCanvasElement?"
      ]
    ]
  },
  resizeCanvas: {
    overloads: [
      [
        "Number",
        "Number",
        "Boolean?"
      ]
    ]
  },
  noCanvas: {
    overloads: [
      []
    ]
  },
  createGraphics: {
    overloads: [
      [
        "Number",
        "Number",
        "P2D|WEBGL?",
        "HTMLCanvasElement?"
      ],
      [
        "Number",
        "Number",
        "HTMLCanvasElement?"
      ]
    ]
  },
  createFramebuffer: {
    overloads: [
      [
        "Object?"
      ]
    ]
  },
  clearDepth: {
    overloads: [
      [
        "Number?"
      ]
    ]
  },
  noLoop: {
    overloads: [
      []
    ]
  },
  loop: {
    overloads: [
      []
    ]
  },
  isLooping: {
    overloads: [
      []
    ]
  },
  redraw: {
    overloads: [
      [
        "Integer?"
      ]
    ]
  },
  applyMatrix: {
    overloads: [
      [
        "Array"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  resetMatrix: {
    overloads: [
      []
    ]
  },
  rotate: {
    overloads: [
      [
        "Number",
        "p5.Vector|Number[]?"
      ]
    ]
  },
  rotateX: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  rotateY: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  rotateZ: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  scale: {
    overloads: [
      [
        "Number|p5.Vector|Number[]",
        "Number?",
        "Number?"
      ],
      [
        "p5.Vector|Number[]"
      ]
    ]
  },
  shearX: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  shearY: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  translate: {
    overloads: [
      [
        "Number",
        "Number",
        "Number?"
      ],
      [
        "p5.Vector"
      ]
    ]
  },
  push: {
    overloads: [
      []
    ]
  },
  pop: {
    overloads: [
      []
    ]
  },
  storeItem: {
    overloads: [
      [
        "String",
        "String|Number|Boolean|Object|Array"
      ]
    ]
  },
  getItem: {
    overloads: [
      [
        "String"
      ]
    ]
  },
  clearStorage: {
    overloads: [
      []
    ]
  },
  removeItem: {
    overloads: [
      [
        "String"
      ]
    ]
  },
  select: {
    overloads: [
      [
        "String",
        "String|p5.Element|HTMLElement?"
      ]
    ]
  },
  selectAll: {
    overloads: [
      [
        "String",
        "String|p5.Element|HTMLElement?"
      ]
    ]
  },
  createElement: {
    overloads: [
      [
        "String",
        "String?"
      ]
    ]
  },
  removeElements: {
    overloads: [
      []
    ]
  },
  addElement: {
    overloads: [
      []
    ]
  },
  createDiv: {
    overloads: [
      [
        "String?"
      ]
    ]
  },
  createP: {
    overloads: [
      [
        "String?"
      ]
    ]
  },
  createSpan: {
    overloads: [
      [
        "String?"
      ]
    ]
  },
  createImg: {
    overloads: [
      [
        "String",
        "String"
      ],
      [
        "String",
        "String",
        "String?",
        "Function?"
      ]
    ]
  },
  createA: {
    overloads: [
      [
        "String",
        "String",
        "String?"
      ]
    ]
  },
  createSlider: {
    overloads: [
      [
        "Number",
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  createButton: {
    overloads: [
      [
        "String",
        "String?"
      ]
    ]
  },
  createCheckbox: {
    overloads: [
      [
        "String?",
        "Boolean?"
      ]
    ]
  },
  createSelect: {
    overloads: [
      [
        "Boolean?"
      ],
      [
        "Object"
      ]
    ]
  },
  createRadio: {
    overloads: [
      [
        "Object?"
      ],
      [
        "String?"
      ],
      []
    ]
  },
  createColorPicker: {
    overloads: [
      [
        "String|p5.Color?"
      ]
    ]
  },
  createInput: {
    overloads: [
      [
        "String?",
        "String?"
      ],
      [
        "String?"
      ]
    ]
  },
  createFileInput: {
    overloads: [
      [
        "Function",
        "Boolean?"
      ]
    ]
  },
  setMoveThreshold: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  setShakeThreshold: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  deviceMoved: {
    overloads: [
      []
    ]
  },
  deviceTurned: {
    overloads: [
      []
    ]
  },
  deviceShaken: {
    overloads: [
      []
    ]
  },
  keyPressed: {
    overloads: [
      [
        "KeyboardEvent?"
      ]
    ]
  },
  keyReleased: {
    overloads: [
      [
        "KeyboardEvent?"
      ]
    ]
  },
  keyTyped: {
    overloads: [
      [
        "KeyboardEvent?"
      ]
    ]
  },
  keyIsDown: {
    overloads: [
      [
        "Number|String"
      ]
    ]
  },
  mouseMoved: {
    overloads: [
      [
        "MouseEvent?"
      ]
    ]
  },
  mouseDragged: {
    overloads: [
      [
        "MouseEvent?"
      ]
    ]
  },
  mousePressed: {
    overloads: [
      [
        "MouseEvent?"
      ]
    ]
  },
  mouseReleased: {
    overloads: [
      [
        "MouseEvent?"
      ]
    ]
  },
  mouseClicked: {
    overloads: [
      [
        "MouseEvent?"
      ]
    ]
  },
  doubleClicked: {
    overloads: [
      [
        "MouseEvent?"
      ]
    ]
  },
  mouseWheel: {
    overloads: [
      [
        "WheelEvent?"
      ]
    ]
  },
  requestPointerLock: {
    overloads: [
      []
    ]
  },
  exitPointerLock: {
    overloads: [
      []
    ]
  },
  createImage: {
    overloads: [
      [
        "Integer",
        "Integer"
      ]
    ]
  },
  saveCanvas: {
    overloads: [
      [
        "p5.Framebuffer|p5.Element|HTMLCanvasElement",
        "String?",
        "String?"
      ],
      [
        "String?",
        "String?"
      ]
    ]
  },
  saveFrames: {
    overloads: [
      [
        "String",
        "String",
        "Number",
        "Number",
        "function(Array)?"
      ]
    ]
  },
  loadImage: {
    overloads: [
      [
        "String|Request",
        "function(p5.Image)?",
        "function(Event)?"
      ]
    ]
  },
  saveGif: {
    overloads: [
      [
        "String",
        "Number",
        "Object?"
      ]
    ]
  },
  image: {
    overloads: [
      [
        "p5.Image|p5.Element|p5.Texture|p5.Framebuffer|p5.FramebufferTexture|p5.Renderer|p5.Graphics",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ],
      [
        "p5.Image|p5.Element|p5.Texture|p5.Framebuffer|p5.FramebufferTexture",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?",
        "CONTAIN|COVER?",
        "LEFT|RIGHT|CENTER?",
        "TOP|BOTTOM|CENTER?"
      ]
    ]
  },
  tint: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "String"
      ],
      [
        "Number",
        "Number?"
      ],
      [
        "Number[]"
      ],
      [
        "p5.Color"
      ]
    ]
  },
  noTint: {
    overloads: [
      []
    ]
  },
  imageMode: {
    overloads: [
      [
        "CORNER|CORNERS|CENTER"
      ]
    ]
  },
  blend: {
    overloads: [
      [
        "p5.Image",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL"
      ],
      [
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL"
      ]
    ]
  },
  copy: {
    overloads: [
      [
        "p5.Image|p5.Element",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer"
      ],
      [
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer",
        "Integer"
      ]
    ]
  },
  filter: {
    overloads: [
      [
        "THRESHOLD|GRAY|OPAQUE|INVERT|POSTERIZE|BLUR|ERODE|DILATE|BLUR",
        "Number?",
        "Boolean?"
      ],
      [
        "p5.Shader"
      ]
    ]
  },
  get: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [],
      [
        "Number",
        "Number"
      ]
    ]
  },
  loadPixels: {
    overloads: [
      []
    ]
  },
  set: {
    overloads: [
      [
        "Number",
        "Number",
        "Number|Number[]|Object"
      ]
    ]
  },
  updatePixels: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ],
      []
    ]
  },
  loadJSON: {
    overloads: [
      [
        "String|Request",
        "Function?",
        "Function?"
      ]
    ]
  },
  loadStrings: {
    overloads: [
      [
        "String|Request",
        "Function?",
        "Function?"
      ]
    ]
  },
  loadTable: {
    overloads: [
      [
        "String|Request",
        "String?",
        "String?",
        "Function?",
        "Function?"
      ]
    ]
  },
  loadXML: {
    overloads: [
      [
        "String|Request",
        "Function?",
        "Function?"
      ]
    ]
  },
  loadBytes: {
    overloads: [
      [
        "String|Request",
        "Function?",
        "Function?"
      ]
    ]
  },
  loadBlob: {
    overloads: [
      [
        "String|Request",
        "Function?",
        "Function?"
      ]
    ]
  },
  httpGet: {
    overloads: [
      [
        "String|Request",
        "String?",
        "Function?",
        "Function?"
      ],
      [
        "String|Request",
        "Function",
        "Function?"
      ]
    ]
  },
  httpPost: {
    overloads: [
      [
        "String|Request",
        "Object|Boolean?",
        "String?",
        "Function?",
        "Function?"
      ],
      [
        "String|Request",
        "Object|Boolean",
        "Function?",
        "Function?"
      ],
      [
        "String|Request",
        "Function?",
        "Function?"
      ]
    ]
  },
  httpDo: {
    overloads: [
      [
        "String|Request",
        "String?",
        "String?",
        "Object?",
        "Function?",
        "Function?"
      ],
      [
        "String|Request",
        "Function?",
        "Function?"
      ]
    ]
  },
  createWriter: {
    overloads: [
      [
        "String",
        "String?"
      ]
    ]
  },
  write: {
    overloads: [
      [
        "String|Number|Array"
      ]
    ]
  },
  close: {
    overloads: [
      []
    ]
  },
  save: {
    overloads: [
      [
        "Object|String?",
        "String?",
        "Boolean|String?"
      ]
    ]
  },
  saveJSON: {
    overloads: [
      [
        "Array|Object",
        "String",
        "Boolean?"
      ]
    ]
  },
  saveStrings: {
    overloads: [
      [
        "String[]",
        "String",
        "String?",
        "Boolean?"
      ]
    ]
  },
  saveTable: {
    overloads: [
      [
        "p5.Table",
        "String",
        "String?"
      ]
    ]
  },
  abs: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  ceil: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  constrain: {
    overloads: [
      [
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  dist: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [
        "p5.Vector"
      ]
    ]
  },
  exp: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  floor: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  lerp: {
    overloads: [
      [
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  log: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  mag: {
    overloads: [
      [
        "Number",
        "Number"
      ]
    ]
  },
  map: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Boolean?"
      ]
    ]
  },
  max: {
    overloads: [
      [
        "Number",
        "Number"
      ],
      [
        "Number[]"
      ]
    ]
  },
  min: {
    overloads: [
      [
        "Number",
        "Number"
      ],
      [
        "Number[]"
      ]
    ]
  },
  norm: {
    overloads: [
      [
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  pow: {
    overloads: [
      [
        "Number",
        "Number"
      ]
    ]
  },
  round: {
    overloads: [
      [
        "Number",
        "Number?"
      ]
    ]
  },
  sq: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  sqrt: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  fract: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  createVector: {
    overloads: [
      [
        "...Number[]"
      ]
    ]
  },
  noise: {
    overloads: [
      [
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  noiseDetail: {
    overloads: [
      [
        "Number",
        "Number"
      ]
    ]
  },
  noiseSeed: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  randomSeed: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  random: {
    overloads: [
      [
        "Number?",
        "Number?"
      ],
      [
        "Array"
      ]
    ]
  },
  randomGaussian: {
    overloads: [
      [
        "Number?",
        "Number?"
      ]
    ]
  },
  acos: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  asin: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  atan: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  atan2: {
    overloads: [
      [
        "Number",
        "Number"
      ]
    ]
  },
  cos: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  sin: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  tan: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  degrees: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  radians: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  angleMode: {
    overloads: [
      [
        "RADIANS|DEGREES"
      ],
      []
    ]
  },
  arc: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "CHORD|PIE|OPEN?",
        "Integer?"
      ]
    ]
  },
  ellipse: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Integer?"
      ]
    ]
  },
  circle: {
    overloads: [
      [
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  line: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  point: {
    overloads: [
      [
        "Number",
        "Number",
        "Number?"
      ],
      [
        "p5.Vector"
      ]
    ]
  },
  quad: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Integer?",
        "Integer?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  rect: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  square: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ]
    ]
  },
  triangle: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  ellipseMode: {
    overloads: [
      [
        "CENTER|RADIUS|CORNER|CORNERS"
      ]
    ]
  },
  noSmooth: {
    overloads: [
      []
    ]
  },
  rectMode: {
    overloads: [
      [
        "CENTER|RADIUS|CORNER|CORNERS"
      ]
    ]
  },
  smooth: {
    overloads: [
      []
    ]
  },
  strokeCap: {
    overloads: [
      [
        "ROUND|SQUARE|PROJECT"
      ]
    ]
  },
  strokeJoin: {
    overloads: [
      [
        "MITER|BEVEL|ROUND"
      ]
    ]
  },
  strokeWeight: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  bezier: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  bezierPoint: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  bezierTangent: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  spline: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  splinePoint: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  splineTangent: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  bezierOrder: {
    overloads: [
      [
        "Number"
      ],
      []
    ]
  },
  splineVertex: {
    overloads: [
      [
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number?",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  splineProperty: {
    overloads: [
      [
        "String",
        null
      ],
      [
        "String"
      ]
    ]
  },
  splineProperties: {
    overloads: [
      [
        "Object"
      ],
      []
    ]
  },
  vertex: {
    overloads: [
      [
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number?",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  beginContour: {
    overloads: [
      []
    ]
  },
  endContour: {
    overloads: [
      [
        "OPEN|CLOSE?"
      ]
    ]
  },
  beginShape: {
    overloads: [
      [
        "POINTS|LINES|TRIANGLES|TRIANGLE_FAN|TRIANGLE_STRIP|QUADS|QUAD_STRIP|PATH?"
      ]
    ]
  },
  bezierVertex: {
    overloads: [
      [
        "Number",
        "Number",
        "Number?",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  endShape: {
    overloads: [
      [
        "CLOSE?",
        "Integer?"
      ]
    ]
  },
  normal: {
    overloads: [
      [
        "p5.Vector"
      ],
      [
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  vertexProperty: {
    overloads: [
      [
        "String",
        "Number|Number[]"
      ]
    ]
  },
  loadFont: {
    overloads: [
      [
        "String",
        "String?",
        "Object?",
        "Function?",
        "Function?"
      ],
      [
        "String",
        "Function?",
        "Function?"
      ]
    ]
  },
  text: {
    overloads: [
      [
        "String|Object|Array|Number|Boolean",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  textAlign: {
    overloads: [
      [
        "LEFT|CENTER|RIGHT",
        "TOP|BOTTOM|CENTER|BASELINE?"
      ]
    ]
  },
  textAscent: {
    overloads: [
      [
        "String?"
      ]
    ]
  },
  textDescent: {
    overloads: [
      [
        "String?"
      ]
    ]
  },
  textLeading: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  textFont: {
    overloads: [
      [
        "p5.Font|String|Object",
        "Number?"
      ]
    ]
  },
  textSize: {
    overloads: [
      [
        "Number"
      ],
      []
    ]
  },
  textStyle: {
    overloads: [
      [
        "NORMAL|ITALIC|BOLD|BOLDITALIC"
      ],
      []
    ]
  },
  textWidth: {
    overloads: [
      [
        "String"
      ]
    ]
  },
  textWrap: {
    overloads: [
      [
        "WORD|CHAR"
      ],
      []
    ]
  },
  textBounds: {
    overloads: [
      [
        "String",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  textDirection: {
    overloads: [
      [
        "String"
      ],
      []
    ]
  },
  textProperty: {
    overloads: [
      [
        "String",
        null
      ],
      [
        "String"
      ]
    ]
  },
  textProperties: {
    overloads: [
      [
        "Object"
      ],
      []
    ]
  },
  fontBounds: {
    overloads: [
      [
        "String",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  fontWidth: {
    overloads: [
      [
        "String"
      ]
    ]
  },
  fontAscent: {
    overloads: [
      []
    ]
  },
  fontDescent: {
    overloads: [
      []
    ]
  },
  textWeight: {
    overloads: [
      [
        "Number"
      ],
      []
    ]
  },
  float: {
    overloads: [
      [
        "String"
      ],
      [
        "String[]"
      ]
    ]
  },
  int: {
    overloads: [
      [
        "String|Boolean|Number"
      ],
      [
        "Array"
      ]
    ]
  },
  str: {
    overloads: [
      [
        "String|Boolean|Number"
      ]
    ]
  },
  boolean: {
    overloads: [
      [
        "String|Boolean|Number"
      ],
      [
        "Array"
      ]
    ]
  },
  byte: {
    overloads: [
      [
        "String|Boolean|Number"
      ],
      [
        "Array"
      ]
    ]
  },
  char: {
    overloads: [
      [
        "String|Number"
      ],
      [
        "Array"
      ]
    ]
  },
  unchar: {
    overloads: [
      [
        "String"
      ],
      [
        "String[]"
      ]
    ]
  },
  hex: {
    overloads: [
      [
        "Number",
        "Number?"
      ],
      [
        "Number[]",
        "Number?"
      ]
    ]
  },
  unhex: {
    overloads: [
      [
        "String"
      ],
      [
        "String[]"
      ]
    ]
  },
  day: {
    overloads: [
      []
    ]
  },
  hour: {
    overloads: [
      []
    ]
  },
  minute: {
    overloads: [
      []
    ]
  },
  millis: {
    overloads: [
      []
    ]
  },
  month: {
    overloads: [
      []
    ]
  },
  second: {
    overloads: [
      []
    ]
  },
  year: {
    overloads: [
      []
    ]
  },
  nf: {
    overloads: [
      [
        "Number|String",
        "Integer|String?",
        "Integer|String?"
      ],
      [
        "Number[]",
        "Integer|String?",
        "Integer|String?"
      ]
    ]
  },
  nfc: {
    overloads: [
      [
        "Number|String",
        "Integer|String?"
      ],
      [
        "Number[]",
        "Integer|String?"
      ]
    ]
  },
  nfp: {
    overloads: [
      [
        "Number",
        "Integer?",
        "Integer?"
      ],
      [
        "Number[]",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  nfs: {
    overloads: [
      [
        "Number",
        "Integer?",
        "Integer?"
      ],
      [
        "Array",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  splitTokens: {
    overloads: [
      [
        "String",
        "String?"
      ]
    ]
  },
  shuffle: {
    overloads: [
      [
        "Array",
        "Boolean?"
      ]
    ]
  },
  strokeMode: {
    overloads: [
      [
        "String"
      ]
    ]
  },
  buildGeometry: {
    overloads: [
      [
        "Function"
      ]
    ]
  },
  freeGeometry: {
    overloads: [
      [
        "p5.Geometry"
      ]
    ]
  },
  plane: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  box: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  sphere: {
    overloads: [
      [
        "Number?",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  cylinder: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Integer?",
        "Integer?",
        "Boolean?",
        "Boolean?"
      ]
    ]
  },
  cone: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Integer?",
        "Integer?",
        "Boolean?"
      ]
    ]
  },
  ellipsoid: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  torus: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Integer?",
        "Integer?"
      ]
    ]
  },
  curveDetail: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  orbitControl: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Object?"
      ]
    ]
  },
  debugMode: {
    overloads: [
      [],
      [
        "GRID|AXES"
      ],
      [
        "GRID|AXES",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ],
      [
        "GRID|AXES",
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ],
      [
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ]
    ]
  },
  noDebugMode: {
    overloads: [
      []
    ]
  },
  ambientLight: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "Number",
        "Number?"
      ],
      [
        "String"
      ],
      [
        "Number[]"
      ],
      [
        "p5.Color"
      ]
    ]
  },
  specularColor: {
    overloads: [
      [
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number"
      ],
      [
        "String"
      ],
      [
        "Number[]"
      ],
      [
        "p5.Color"
      ]
    ]
  },
  directionalLight: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number",
        "p5.Vector"
      ],
      [
        "p5.Color|Number[]|String",
        "Number",
        "Number",
        "Number"
      ],
      [
        "p5.Color|Number[]|String",
        "p5.Vector"
      ]
    ]
  },
  pointLight: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number",
        "Number",
        "Number",
        "p5.Vector"
      ],
      [
        "p5.Color|Number[]|String",
        "Number",
        "Number",
        "Number"
      ],
      [
        "p5.Color|Number[]|String",
        "p5.Vector"
      ]
    ]
  },
  imageLight: {
    overloads: [
      [
        "p5.image"
      ]
    ]
  },
  panorama: {
    overloads: [
      [
        "p5.Image"
      ]
    ]
  },
  lights: {
    overloads: [
      []
    ]
  },
  lightFalloff: {
    overloads: [
      [
        "Number",
        "Number",
        "Number"
      ]
    ]
  },
  spotLight: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ],
      [
        "p5.Color|Number[]|String",
        "p5.Vector",
        "p5.Vector",
        "Number?",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "p5.Vector",
        "p5.Vector",
        "Number?",
        "Number?"
      ],
      [
        "p5.Color|Number[]|String",
        "Number",
        "Number",
        "Number",
        "p5.Vector",
        "Number?",
        "Number?"
      ],
      [
        "p5.Color|Number[]|String",
        "p5.Vector",
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "p5.Vector",
        "Number?",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "p5.Vector",
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ],
      [
        "p5.Color|Number[]|String",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number",
        "Number?",
        "Number?"
      ]
    ]
  },
  noLights: {
    overloads: [
      []
    ]
  },
  loadModel: {
    overloads: [
      [
        "String|Request",
        "String?",
        "Boolean",
        "function(p5.Geometry)?",
        "function(Event)?"
      ],
      [
        "String|Request",
        "String?",
        "function(p5.Geometry)?",
        "function(Event)?"
      ],
      [
        "String|Request",
        "Object?"
      ]
    ]
  },
  model: {
    overloads: [
      [
        "p5.Geometry",
        "Number?"
      ]
    ]
  },
  createModel: {
    overloads: [
      [
        "String",
        "String?",
        "Boolean",
        "function(p5.Geometry)?",
        "function(Event)?"
      ],
      [
        "String",
        "String?",
        "function(p5.Geometry)?",
        "function(Event)?"
      ],
      [
        "String",
        "String?",
        "Object?"
      ]
    ]
  },
  loadShader: {
    overloads: [
      [
        "String|Request",
        "String|Request",
        "Function?",
        "Function?"
      ]
    ]
  },
  createShader: {
    overloads: [
      [
        "String",
        "String",
        "Object?"
      ]
    ]
  },
  loadFilterShader: {
    overloads: [
      [
        "String",
        "Function?",
        "Function?"
      ]
    ]
  },
  createFilterShader: {
    overloads: [
      [
        "String"
      ]
    ]
  },
  shader: {
    overloads: [
      [
        "p5.Shader"
      ]
    ]
  },
  strokeShader: {
    overloads: [
      [
        "p5.Shader"
      ]
    ]
  },
  imageShader: {
    overloads: [
      [
        "p5.Shader"
      ]
    ]
  },
  baseMaterialShader: {
    overloads: [
      []
    ]
  },
  baseFilterShader: {
    overloads: [
      []
    ]
  },
  baseNormalShader: {
    overloads: [
      []
    ]
  },
  baseColorShader: {
    overloads: [
      []
    ]
  },
  baseStrokeShader: {
    overloads: [
      []
    ]
  },
  resetShader: {
    overloads: [
      []
    ]
  },
  texture: {
    overloads: [
      [
        "p5.Image|p5.MediaElement|p5.Graphics|p5.Texture|p5.Framebuffer|p5.FramebufferTexture"
      ]
    ]
  },
  textureMode: {
    overloads: [
      [
        "IMAGE|NORMAL"
      ]
    ]
  },
  textureWrap: {
    overloads: [
      [
        "CLAMP|REPEAT|MIRROR",
        "CLAMP|REPEAT|MIRROR?"
      ]
    ]
  },
  normalMaterial: {
    overloads: [
      []
    ]
  },
  ambientMaterial: {
    overloads: [
      [
        "Number",
        "Number",
        "Number"
      ],
      [
        "Number"
      ],
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  emissiveMaterial: {
    overloads: [
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "Number"
      ],
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  specularMaterial: {
    overloads: [
      [
        "Number",
        "Number?"
      ],
      [
        "Number",
        "Number",
        "Number",
        "Number?"
      ],
      [
        "p5.Color|Number[]|String"
      ]
    ]
  },
  shininess: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  metalness: {
    overloads: [
      [
        "Number"
      ]
    ]
  },
  camera: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ]
    ]
  },
  perspective: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ]
    ]
  },
  linePerspective: {
    overloads: [
      [
        "Boolean"
      ],
      []
    ]
  },
  ortho: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ]
    ]
  },
  frustum: {
    overloads: [
      [
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?",
        "Number?"
      ]
    ]
  },
  createCamera: {
    overloads: [
      []
    ]
  },
  setCamera: {
    overloads: [
      [
        "p5.Camera"
      ]
    ]
  },
  saveObj: {
    overloads: [
      [
        "String?"
      ]
    ]
  },
  saveStl: {
    overloads: [
      [
        "String?",
        "Object?"
      ]
    ]
  },
  setAttributes: {
    overloads: [
      [
        "String",
        "Boolean"
      ],
      [
        "Object"
      ]
    ]
  },
  remove: {
    overloads: [
      []
    ]
  },
  createVideo: {
    overloads: [
      [
        "String|String[]",
        "Function?"
      ]
    ]
  },
  createAudio: {
    overloads: [
      [],
      [
        "String|String[]?",
        "Function?"
      ]
    ]
  },
  createCapture: {
    overloads: [
      [
        "AUDIO|VIDEO|Object?",
        "Object?",
        "Function?"
      ]
    ]
  }
};
var dataDoc = {
  p5: p5$1,
  "p5.Geometry": {
    flipV: {
      overloads: [
        []
      ]
    },
    calculateBoundingBox: {
      overloads: [
        []
      ]
    },
    clearColors: {
      overloads: [
        []
      ]
    },
    flipU: {
      overloads: [
        []
      ]
    },
    computeFaces: {
      overloads: [
        []
      ]
    },
    computeNormals: {
      overloads: [
        [
          "FLAT|SMOOTH?",
          "Object?"
        ]
      ]
    },
    makeEdgesFromFaces: {
      overloads: [
        []
      ]
    },
    normalize: {
      overloads: [
        []
      ]
    },
    vertexProperty: {
      overloads: [
        [
          "String",
          "Number|Number[]",
          "Number?"
        ]
      ]
    }
  },
  "p5.Color": {
    toString: {
      overloads: [
        [
          "String?"
        ]
      ]
    },
    setRed: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    setGreen: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    setBlue: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    setAlpha: {
      overloads: [
        [
          "Number"
        ]
      ]
    }
  },
  "p5.Graphics": {
    reset: {
      overloads: [
        []
      ]
    },
    remove: {
      overloads: [
        []
      ]
    },
    createFramebuffer: {
      overloads: [
        [
          "Object?"
        ]
      ]
    }
  },
  "p5.Element": {
    remove: {
      overloads: [
        []
      ]
    },
    parent: {
      overloads: [
        [
          "String|p5.Element|Object"
        ],
        []
      ]
    },
    child: {
      overloads: [
        [],
        [
          "String|p5.Element?"
        ]
      ]
    },
    html: {
      overloads: [
        [],
        [
          "String?",
          "Boolean?"
        ]
      ]
    },
    id: {
      overloads: [
        [
          "String"
        ],
        []
      ]
    },
    "class": {
      overloads: [
        [
          "String"
        ],
        []
      ]
    },
    addClass: {
      overloads: [
        [
          "String"
        ]
      ]
    },
    removeClass: {
      overloads: [
        [
          "String"
        ]
      ]
    },
    hasClass: {
      overloads: [
        [
          null
        ]
      ]
    },
    toggleClass: {
      overloads: [
        [
          null
        ]
      ]
    },
    center: {
      overloads: [
        [
          "String?"
        ]
      ]
    },
    position: {
      overloads: [
        [],
        [
          "Number?",
          "Number?",
          "String?"
        ]
      ]
    },
    show: {
      overloads: [
        []
      ]
    },
    hide: {
      overloads: [
        []
      ]
    },
    size: {
      overloads: [
        [],
        [
          "Number|AUTO?",
          "Number|AUTO?"
        ]
      ]
    },
    style: {
      overloads: [
        [
          "String"
        ],
        [
          "String",
          "String|p5.Color"
        ]
      ]
    },
    attribute: {
      overloads: [
        [],
        [
          "String",
          "String"
        ]
      ]
    },
    removeAttribute: {
      overloads: [
        [
          "String"
        ]
      ]
    },
    value: {
      overloads: [
        [],
        [
          "String|Number"
        ]
      ]
    },
    mousePressed: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    doubleClicked: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    mouseWheel: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    mouseReleased: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    mouseClicked: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    mouseMoved: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    mouseOver: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    mouseOut: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    dragOver: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    dragLeave: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    changed: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    input: {
      overloads: [
        [
          "Function|Boolean"
        ]
      ]
    },
    drop: {
      overloads: [
        [
          "Function",
          "Function?"
        ]
      ]
    },
    draggable: {
      overloads: [
        [
          "p5.Element?"
        ]
      ]
    }
  },
  "p5.MediaElement": {
    play: {
      overloads: [
        []
      ]
    },
    stop: {
      overloads: [
        []
      ]
    },
    pause: {
      overloads: [
        []
      ]
    },
    loop: {
      overloads: [
        []
      ]
    },
    noLoop: {
      overloads: [
        []
      ]
    },
    autoplay: {
      overloads: [
        [
          "Boolean?"
        ]
      ]
    },
    volume: {
      overloads: [
        [],
        [
          "Number"
        ]
      ]
    },
    speed: {
      overloads: [
        [],
        [
          "Number"
        ]
      ]
    },
    time: {
      overloads: [
        [],
        [
          "Number"
        ]
      ]
    },
    duration: {
      overloads: [
        []
      ]
    },
    onended: {
      overloads: [
        [
          "Function"
        ]
      ]
    },
    connect: {
      overloads: [
        [
          "AudioNode|Object"
        ]
      ]
    },
    disconnect: {
      overloads: [
        []
      ]
    },
    showControls: {
      overloads: [
        []
      ]
    },
    hideControls: {
      overloads: [
        []
      ]
    },
    addCue: {
      overloads: [
        [
          "Number",
          "Function",
          "Object?"
        ]
      ]
    },
    removeCue: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    clearCues: {
      overloads: [
        []
      ]
    }
  },
  "p5.Image": {
    pixelDensity: {
      overloads: [
        [
          "Number?"
        ]
      ]
    },
    loadPixels: {
      overloads: [
        []
      ]
    },
    updatePixels: {
      overloads: [
        [
          "Integer",
          "Integer",
          "Integer",
          "Integer"
        ]
      ]
    },
    get: {
      overloads: [
        [
          "Number",
          "Number",
          "Number",
          "Number"
        ],
        [],
        [
          "Number",
          "Number"
        ]
      ]
    },
    set: {
      overloads: [
        [
          "Number",
          "Number",
          "Number|Number[]|Object"
        ]
      ]
    },
    resize: {
      overloads: [
        [
          "Number",
          "Number"
        ]
      ]
    },
    copy: {
      overloads: [
        [
          "p5.Image|p5.Element",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer"
        ],
        [
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer"
        ]
      ]
    },
    mask: {
      overloads: [
        [
          "p5.Image"
        ]
      ]
    },
    filter: {
      overloads: [
        [
          "THRESHOLD|GRAY|OPAQUE|INVERT|POSTERIZE|ERODE|DILATE|BLUR",
          "Number?"
        ]
      ]
    },
    blend: {
      overloads: [
        [
          "p5.Image",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL"
        ],
        [
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "Integer",
          "BLEND|DARKEST|LIGHTEST|DIFFERENCE|MULTIPLY|EXCLUSION|SCREEN|REPLACE|OVERLAY|HARD_LIGHT|SOFT_LIGHT|DODGE|BURN|ADD|NORMAL"
        ]
      ]
    },
    save: {
      overloads: [
        [
          "String",
          "String?"
        ]
      ]
    },
    reset: {
      overloads: [
        []
      ]
    },
    getCurrentFrame: {
      overloads: [
        []
      ]
    },
    setFrame: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    numFrames: {
      overloads: [
        []
      ]
    },
    play: {
      overloads: [
        []
      ]
    },
    pause: {
      overloads: [
        []
      ]
    },
    delay: {
      overloads: [
        [
          "Number",
          "Number?"
        ]
      ]
    }
  },
  "p5.Table": {
    addRow: {
      overloads: [
        [
          "p5.TableRow?"
        ]
      ]
    },
    removeRow: {
      overloads: [
        [
          "Integer"
        ]
      ]
    },
    getRow: {
      overloads: [
        [
          "Integer"
        ]
      ]
    },
    getRows: {
      overloads: [
        []
      ]
    },
    findRow: {
      overloads: [
        [
          "String",
          "Integer|String"
        ]
      ]
    },
    findRows: {
      overloads: [
        [
          "String",
          "Integer|String"
        ]
      ]
    },
    matchRow: {
      overloads: [
        [
          "String|RegExp",
          "String|Integer"
        ]
      ]
    },
    matchRows: {
      overloads: [
        [
          "String",
          "String|Integer?"
        ]
      ]
    },
    getColumn: {
      overloads: [
        [
          "String|Number"
        ]
      ]
    },
    clearRows: {
      overloads: [
        []
      ]
    },
    addColumn: {
      overloads: [
        [
          "String?"
        ]
      ]
    },
    getColumnCount: {
      overloads: [
        []
      ]
    },
    getRowCount: {
      overloads: [
        []
      ]
    },
    removeTokens: {
      overloads: [
        [
          "String",
          "String|Integer?"
        ]
      ]
    },
    trim: {
      overloads: [
        [
          "String|Integer?"
        ]
      ]
    },
    removeColumn: {
      overloads: [
        [
          "String|Integer"
        ]
      ]
    },
    set: {
      overloads: [
        [
          "Integer",
          "String|Integer",
          "String|Number"
        ]
      ]
    },
    setNum: {
      overloads: [
        [
          "Integer",
          "String|Integer",
          "Number"
        ]
      ]
    },
    setString: {
      overloads: [
        [
          "Integer",
          "String|Integer",
          "String"
        ]
      ]
    },
    get: {
      overloads: [
        [
          "Integer",
          "String|Integer"
        ]
      ]
    },
    getNum: {
      overloads: [
        [
          "Integer",
          "String|Integer"
        ]
      ]
    },
    getString: {
      overloads: [
        [
          "Integer",
          "String|Integer"
        ]
      ]
    },
    getObject: {
      overloads: [
        [
          "String?"
        ]
      ]
    },
    getArray: {
      overloads: [
        []
      ]
    }
  },
  "p5.TableRow": {
    set: {
      overloads: [
        [
          "String|Integer",
          "String|Number"
        ]
      ]
    },
    setNum: {
      overloads: [
        [
          "String|Integer",
          "Number|String"
        ]
      ]
    },
    setString: {
      overloads: [
        [
          "String|Integer",
          "String|Number|Boolean|Object"
        ]
      ]
    },
    get: {
      overloads: [
        [
          "String|Integer"
        ]
      ]
    },
    getNum: {
      overloads: [
        [
          "String|Integer"
        ]
      ]
    },
    getString: {
      overloads: [
        [
          "String|Integer"
        ]
      ]
    }
  },
  "p5.XML": {
    getParent: {
      overloads: [
        []
      ]
    },
    getName: {
      overloads: [
        []
      ]
    },
    setName: {
      overloads: [
        [
          "String"
        ]
      ]
    },
    hasChildren: {
      overloads: [
        []
      ]
    },
    listChildren: {
      overloads: [
        []
      ]
    },
    getChildren: {
      overloads: [
        [
          "String?"
        ]
      ]
    },
    getChild: {
      overloads: [
        [
          "String|Integer"
        ]
      ]
    },
    addChild: {
      overloads: [
        [
          "p5.XML"
        ]
      ]
    },
    removeChild: {
      overloads: [
        [
          "String|Integer"
        ]
      ]
    },
    getAttributeCount: {
      overloads: [
        []
      ]
    },
    listAttributes: {
      overloads: [
        []
      ]
    },
    hasAttribute: {
      overloads: [
        [
          "String"
        ]
      ]
    },
    getNum: {
      overloads: [
        [
          "String",
          "Number?"
        ]
      ]
    },
    getString: {
      overloads: [
        [
          "String",
          "Number?"
        ]
      ]
    },
    setAttribute: {
      overloads: [
        [
          "String",
          "Number|String|Boolean"
        ]
      ]
    },
    getContent: {
      overloads: [
        [
          "String?"
        ]
      ]
    },
    serialize: {
      overloads: [
        []
      ]
    }
  },
  "p5.Vector": {
    getValue: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    setValue: {
      overloads: [
        [
          "Number",
          "Number"
        ]
      ]
    },
    set: {
      overloads: [
        [
          "Number?",
          "Number?",
          "Number?"
        ],
        [
          "p5.Vector|Number[]"
        ]
      ]
    },
    copy: {
      overloads: [
        [],
        [
          "p5.Vector"
        ]
      ]
    },
    add: {
      overloads: [
        [
          "Number|Array",
          "Number?",
          "Number?"
        ],
        [
          "p5.Vector|Number[]"
        ],
        [
          "p5.Vector",
          "p5.Vector",
          "p5.Vector?"
        ]
      ]
    },
    rem: {
      overloads: [
        [
          "Number",
          "Number",
          "Number"
        ],
        [
          "p5.Vector|Number[]"
        ],
        [
          "p5.Vector",
          "p5.Vector"
        ]
      ]
    },
    sub: {
      overloads: [
        [
          "Number",
          "Number?",
          "Number?"
        ],
        [
          "p5.Vector|Number[]"
        ],
        [
          "p5.Vector",
          "p5.Vector",
          "p5.Vector?"
        ]
      ]
    },
    mult: {
      overloads: [
        [
          "Number",
          "Number",
          "Number?"
        ],
        [
          "Number[]"
        ],
        [
          "p5.Vector"
        ],
        [],
        [
          "p5.Vector",
          "Number",
          "p5.Vector?"
        ],
        [
          "p5.Vector",
          "p5.Vector",
          "p5.Vector?"
        ],
        [
          "p5.Vector",
          "Number[]",
          "p5.Vector?"
        ]
      ]
    },
    div: {
      overloads: [
        [
          "Number"
        ],
        [
          "Number",
          "Number",
          "Number?"
        ],
        [
          "Number[]"
        ],
        [
          "p5.Vector"
        ],
        [],
        [
          "p5.Vector",
          "Number",
          "p5.Vector?"
        ],
        [
          "p5.Vector",
          "p5.Vector",
          "p5.Vector?"
        ],
        [
          "p5.Vector",
          "Number[]",
          "p5.Vector?"
        ]
      ]
    },
    mag: {
      overloads: [
        [],
        [
          "p5.Vector"
        ]
      ]
    },
    magSq: {
      overloads: [
        [],
        [
          "p5.Vector"
        ]
      ]
    },
    dot: {
      overloads: [
        [
          "Number",
          "Number?",
          "Number?"
        ],
        [
          "p5.Vector"
        ],
        [],
        [
          "p5.Vector",
          "p5.Vector"
        ]
      ]
    },
    cross: {
      overloads: [
        [
          "p5.Vector"
        ],
        [],
        [
          "p5.Vector",
          "p5.Vector"
        ]
      ]
    },
    normalize: {
      overloads: [
        [],
        [
          "p5.Vector",
          "p5.Vector?"
        ]
      ]
    },
    limit: {
      overloads: [
        [
          "Number"
        ],
        [],
        [
          "p5.Vector",
          "Number",
          "p5.Vector?"
        ]
      ]
    },
    setMag: {
      overloads: [
        [
          "Number"
        ],
        [],
        [
          "p5.Vector",
          "Number",
          "p5.Vector?"
        ]
      ]
    },
    heading: {
      overloads: [
        [],
        [
          "p5.Vector"
        ]
      ]
    },
    setHeading: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    rotate: {
      overloads: [
        [
          "Number"
        ],
        [],
        [
          "p5.Vector",
          "Number",
          "p5.Vector?"
        ]
      ]
    },
    angleBetween: {
      overloads: [
        [
          "p5.Vector"
        ],
        [],
        [
          "p5.Vector",
          "p5.Vector"
        ]
      ]
    },
    lerp: {
      overloads: [
        [
          "Number",
          "Number",
          "Number",
          "Number"
        ],
        [
          "p5.Vector",
          "Number"
        ],
        [],
        [
          "p5.Vector",
          "p5.Vector",
          "Number",
          "p5.Vector?"
        ]
      ]
    },
    slerp: {
      overloads: [
        [
          "p5.Vector",
          "Number"
        ],
        [],
        [
          "p5.Vector",
          "p5.Vector",
          "Number",
          "p5.Vector?"
        ]
      ]
    },
    reflect: {
      overloads: [
        [
          "p5.Vector"
        ],
        [],
        [
          "p5.Vector",
          "p5.Vector",
          "p5.Vector?"
        ]
      ]
    },
    array: {
      overloads: [
        [],
        [
          "p5.Vector"
        ]
      ]
    },
    equals: {
      overloads: [
        [
          "Number?",
          "Number?",
          "Number?"
        ],
        [
          "p5.Vector|Array"
        ],
        [],
        [
          "p5.Vector|Array",
          "p5.Vector|Array"
        ]
      ]
    },
    fromAngle: {
      overloads: [
        [
          "Number",
          "Number?"
        ]
      ]
    },
    fromAngles: {
      overloads: [
        [
          "Number",
          "Number",
          "Number?"
        ]
      ]
    },
    random2D: {
      overloads: [
        []
      ]
    },
    random3D: {
      overloads: [
        []
      ]
    },
    dist: {
      overloads: [
        [],
        [
          "p5.Vector",
          "p5.Vector"
        ]
      ]
    }
  },
  "p5.Font": {
    textToPaths: {
      overloads: [
        [
          "String",
          "Number",
          "Number",
          "Number?",
          "Number?",
          "Object?"
        ]
      ]
    },
    textToPoints: {
      overloads: [
        [
          "String",
          "Number",
          "Number",
          "Object?"
        ]
      ]
    },
    textToContours: {
      overloads: [
        [
          "String",
          "Number",
          "Number",
          "Object?"
        ]
      ]
    },
    textToModel: {
      overloads: [
        [
          "String",
          "Number",
          "Number",
          "Number",
          "Number",
          "Object?"
        ]
      ]
    }
  },
  "p5.Camera": {
    perspective: {
      overloads: [
        [
          "Number?",
          "Number?",
          "Number?",
          "Number?"
        ]
      ]
    },
    ortho: {
      overloads: [
        [
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?"
        ]
      ]
    },
    frustum: {
      overloads: [
        [
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?"
        ]
      ]
    },
    pan: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    tilt: {
      overloads: [
        [
          "Number"
        ]
      ]
    },
    lookAt: {
      overloads: [
        [
          "Number",
          "Number",
          "Number"
        ]
      ]
    },
    camera: {
      overloads: [
        [
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?",
          "Number?"
        ]
      ]
    },
    move: {
      overloads: [
        [
          "Number",
          "Number",
          "Number"
        ]
      ]
    },
    setPosition: {
      overloads: [
        [
          "Number",
          "Number",
          "Number"
        ]
      ]
    },
    set: {
      overloads: [
        [
          "p5.Camera"
        ]
      ]
    },
    slerp: {
      overloads: [
        [
          "p5.Camera",
          "p5.Camera",
          "Number"
        ]
      ]
    }
  },
  "p5.Framebuffer": {
    resize: {
      overloads: [
        [
          "Number",
          "Number"
        ]
      ]
    },
    pixelDensity: {
      overloads: [
        [
          "Number?"
        ]
      ]
    },
    autoSized: {
      overloads: [
        [
          "Boolean?"
        ]
      ]
    },
    createCamera: {
      overloads: [
        []
      ]
    },
    remove: {
      overloads: [
        []
      ]
    },
    begin: {
      overloads: [
        []
      ]
    },
    end: {
      overloads: [
        []
      ]
    },
    draw: {
      overloads: [
        [
          "Function"
        ]
      ]
    },
    get: {
      overloads: [
        [
          "Number",
          "Number",
          "Number",
          "Number"
        ],
        [],
        [
          "Number",
          "Number"
        ]
      ]
    }
  },
  "p5.Shader": {
    version: {
      overloads: [
        []
      ]
    },
    inspectHooks: {
      overloads: [
        []
      ]
    },
    modify: {
      overloads: [
        [
          "Object?"
        ]
      ]
    },
    copyToContext: {
      overloads: [
        [
          "p5|p5.Graphics"
        ]
      ]
    },
    setUniform: {
      overloads: [
        [
          "String",
          "Boolean|Number|Number[]|p5.Image|p5.Graphics|p5.MediaElement|p5.Texture"
        ]
      ]
    }
  }
};
function validateParams(p53, fn2, lifecycles) {
  let schemaRegistry = /* @__PURE__ */ new Map();
  const p5Constructors = Object.keys(p53).reduce((acc, val2) => {
    if (val2.match(/^[A-Z]/) && // Starts with a capital
    !val2.match(/^[A-Z][A-Z0-9]*$/) && // Is not an all caps constant
    p53[val2] instanceof Function) {
      acc[val2] = p53[val2];
    }
    return acc;
  }, {});
  function loadP5Constructors() {
    for (let key of Object.keys(p53)) {
      if (typeof p53[key] === "function" && key[0] !== key[0].toLowerCase()) {
        p5Constructors[key] = p53[key];
      }
    }
  }
  const constantsMap = {};
  for (const [key, value] of Object.entries(constants)) {
    constantsMap[key] = value;
  }
  const schemaMap = {
    "Any": external_exports.any(),
    "Array": external_exports.array(external_exports.any()),
    "Boolean": external_exports.boolean(),
    "Function": external_exports.function(),
    "Integer": external_exports.number().int(),
    "Number": external_exports.number(),
    "Object": external_exports.object({}),
    "String": external_exports.string()
  };
  const webAPIObjects = [
    "AudioNode",
    "HTMLCanvasElement",
    "HTMLElement",
    "KeyboardEvent",
    "MouseEvent",
    "RegExp",
    "TouchEvent",
    "UIEvent",
    "WheelEvent"
  ];
  function generateWebAPISchemas(apiObjects) {
    return apiObjects.reduce((acc, obj) => {
      acc[obj] = external_exports.custom((data3) => data3 instanceof globalThis[obj], {
        message: `Expected a ${obj}`
      });
      return acc;
    }, {});
  }
  const webAPISchemas = generateWebAPISchemas(webAPIObjects);
  Object.assign(schemaMap, webAPISchemas);
  const ordinals = ["first", "second", "third", "fourth", "fifth", "sixth", "seventh", "eighth", "ninth", "tenth"];
  function extractFuncNameAndClass(func) {
    const ichDot = func.lastIndexOf(".");
    const funcName = func.slice(ichDot + 1);
    const funcClass = func.slice(0, ichDot !== -1 ? ichDot : 0) || "p5";
    return { funcName, funcClass };
  }
  function validBracketNesting(type3) {
    let level = 0;
    for (let i = 0; i < type3.length; i++) {
      if (type3[i] === "[") {
        level++;
      } else if (type3[i] === "]") {
        level--;
        if (level < 0) return false;
      }
    }
    return level === 0;
  }
  fn2.generateZodSchemasForFunc = function(func) {
    const { funcName, funcClass } = extractFuncNameAndClass(func);
    let funcInfo = dataDoc[funcClass][funcName];
    if (!funcInfo) return;
    let overloads = [];
    if (funcInfo.hasOwnProperty("overloads")) {
      overloads = funcInfo.overloads;
    }
    const generateTypeSchema = (baseType) => {
      if (!baseType) return external_exports.any();
      let typeSchema;
      if (baseType in constantsMap) {
        typeSchema = external_exports.literal(constantsMap[baseType]);
      } else if (baseType.match(/^[A-Z][A-Z0-9]*$/) && baseType in fn2) {
        typeSchema = external_exports.literal(fn2[baseType]);
      } else if (baseType.startsWith("function")) {
        typeSchema = external_exports.function();
      } else if (/^p5\.[a-zA-Z0-9]+$/.exec(baseType) || baseType === "p5") {
        const className = baseType.substring(baseType.indexOf(".") + 1);
        typeSchema = external_exports.instanceof(p5Constructors[className]);
      } else if (schemaMap[baseType]) {
        typeSchema = schemaMap[baseType];
      } else if (baseType.startsWith("[") && baseType.endsWith("]") && validBracketNesting(baseType.slice(1, -1))) {
        typeSchema = external_exports.tuple(
          baseType.slice(1, -1).split(/, */g).map((entry) => generateTypeSchema(entry))
        );
      } else if (baseType.match(/^[A-Z]/) && baseType in window) {
        typeSchema = external_exports.instanceof(window[baseType]);
      } else if (baseType.includes("|") && baseType.split("|").every((t) => validBracketNesting(t))) {
        const types2 = baseType.split("|");
        typeSchema = external_exports.union(types2.map((t) => generateTypeSchema(t)).filter((s) => s !== void 0));
      } else if (baseType.endsWith("[]")) {
        typeSchema = external_exports.array(generateTypeSchema(baseType.slice(0, -2)));
      } else {
        throw new Error(`Unsupported type '${baseType}' in parameter validation. Please report this issue.`);
      }
      return typeSchema;
    };
    const generateParamSchema = (param) => {
      const isOptional = param == null ? void 0 : param.endsWith("?");
      param = param == null ? void 0 : param.replace(/\?$/, "");
      const isRest = (param == null ? void 0 : param.startsWith("...")) && (param == null ? void 0 : param.endsWith("[]"));
      param = param == null ? void 0 : param.replace(/^\.\.\.(.+)\[\]$/, "$1");
      let schema = generateTypeSchema(param);
      if (schema.def.type === "function") {
        schema = external_exports.custom((val2) => val2 instanceof Function);
      }
      if (isOptional) {
        schema = schema.optional();
      }
      return { schema, rest: isRest };
    };
    const generateOverloadCombinations = (params) => {
      if (!params.some((p2) => p2 == null ? void 0 : p2.endsWith("?"))) {
        return [params];
      }
      const requiredParamsCount = params.filter((p2) => p2 === null || !p2.endsWith("?")).length;
      const result = [];
      for (let i = requiredParamsCount; i <= params.length; i++) {
        result.push(params.slice(0, i));
      }
      return result;
    };
    const overloadSchemas = overloads.flatMap((overload) => {
      const combinations = generateOverloadCombinations(overload);
      return combinations.map((combo) => {
        var _a2;
        const params = combo.map((p2) => generateParamSchema(p2)).filter((s) => s.schema !== void 0);
        let rest;
        if ((_a2 = params.at(-1)) == null ? void 0 : _a2.rest) {
          rest = params.pop();
        }
        let combined = external_exports.tuple(params.map((s) => s.schema));
        if (rest) {
          combined = combined.rest(rest.schema);
        }
        return combined;
      });
    });
    return overloadSchemas.length === 1 ? overloadSchemas[0] : external_exports.union(overloadSchemas);
  };
  fn2.findClosestSchema = function(schema, args) {
    if (!(schema instanceof external_exports.ZodUnion)) {
      return schema;
    }
    const scoreSchema = (schema2) => {
      let score = Infinity;
      if (!(schema2 instanceof external_exports.ZodTuple)) {
        console.warn("Schema below is not a tuple: ");
        printZodSchema(schema2);
        return score;
      }
      const numArgs = args.length;
      const schemaItems = schema2.def.items;
      const numSchemaItems = schemaItems.length;
      const numRequiredSchemaItems = schemaItems.filter((item) => !item.isOptional()).length;
      if (numArgs >= numRequiredSchemaItems && numArgs <= numSchemaItems) {
        score = 0;
      } else {
        score = Math.abs(
          numArgs < numRequiredSchemaItems ? numRequiredSchemaItems - numArgs : numArgs - numSchemaItems
        ) * 4;
      }
      for (let i = 0; i < Math.min(schemaItems.length, args.length); i++) {
        const paramSchema = schemaItems[i];
        const arg = args[i];
        if (!paramSchema.safeParse(arg).success) score++;
      }
      return score;
    };
    let closestSchema = schema.def.options[0];
    let bestScore = Infinity;
    const schemaUnion = schema.def.options;
    schemaUnion.forEach((schema2) => {
      const score = scoreSchema(schema2);
      if (score < bestScore) {
        closestSchema = schema2;
        bestScore = score;
      }
    });
    return closestSchema;
  };
  fn2.friendlyParamError = function(zodErrorObj, func, args) {
    let message = "🌸 p5.js says: ";
    let isVersionError = false;
    let currentError = zodErrorObj.issues[0];
    const buildTypeMismatchMessage = (actualType, expectedTypeStr, position) => {
      const positionStr = position ? `at the ${ordinals[position]} parameter` : "";
      const actualTypeStr = actualType ? `, but received ${actualType}` : "";
      return `Expected ${expectedTypeStr} ${positionStr}${actualTypeStr}`;
    };
    const processUnionError = (error42) => {
      var _a2;
      const expectedTypes = /* @__PURE__ */ new Set();
      let actualType;
      error42.errors.forEach((err2) => {
        const issue2 = err2[0];
        if (issue2) {
          if (!actualType) {
            actualType = issue2.message;
          }
          if (issue2.code === "invalid_type") {
            actualType = issue2.message.split(", received ")[1];
            expectedTypes.add(issue2.expected);
          } else if (issue2.code === "invalid_value") {
            expectedTypes.add("constant (please refer to documentation for allowed values)");
            actualType = args[error42.path[0]];
          } else if (issue2.code === "custom") {
            const match = issue2.message.match(/Input not instance of (\w+)/);
            if (match) expectedTypes.add(match[1]);
            actualType = void 0;
          }
        }
      });
      if (expectedTypes.size > 0) {
        if (((_a2 = error42.path) == null ? void 0 : _a2.length) > 0 && args[error42.path[0]] instanceof Promise) {
          message += "Did you mean to put `await` before a loading function? An unexpected Promise was found. ";
          isVersionError = true;
        }
        const expectedTypesStr = Array.from(expectedTypes).join(" or ");
        const position = error42.path.join(".");
        message += buildTypeMismatchMessage(actualType, expectedTypesStr, position);
      }
      return message;
    };
    switch (currentError.code) {
      case "invalid_union": {
        processUnionError(currentError);
        break;
      }
      case "too_small": {
        const minArgs = currentError.minimum;
        message += `Expected at least ${minArgs} argument${minArgs > 1 ? "s" : ""}, but received fewer`;
        break;
      }
      case "invalid_type": {
        message += buildTypeMismatchMessage(currentError.message.split(", received ")[1], currentError.expected, currentError.path.join("."));
        break;
      }
      case "too_big": {
        const maxArgs = currentError.maximum;
        message += `Expected at most ${maxArgs} argument${maxArgs > 1 ? "s" : ""}, but received more`;
        break;
      }
      default: {
        console.log("Zod error object", currentError);
      }
    }
    message += ` in ${func}().`;
    const generateDocumentationLink = (func2) => {
      const { funcName, funcClass } = extractFuncNameAndClass(func2);
      const p5BaseUrl = "https://p5js.org/reference";
      const url2 = `${p5BaseUrl}/${funcClass}/${funcName}`;
      return url2;
    };
    if (currentError.code === "too_big" || currentError.code === "too_small") {
      const documentationLink = generateDocumentationLink(func);
      message += ` For more information, see ${documentationLink}.`;
    }
    if (isVersionError) {
      p53._error(this, message);
    } else {
      console.log(message);
    }
    return message;
  };
  fn2.validate = function(func, args) {
    if (p53.disableFriendlyErrors) {
      return;
    }
    if (!Array.isArray(args)) {
      args = Array.from(args);
    }
    if (Array.isArray(args) && args.length > 0 && args.every((arg) => arg === void 0)) {
      const undefinedErrorMessage = `🌸 p5.js says: All arguments for ${func}() are undefined. There is likely an error in the code.`;
      return {
        success: false,
        error: undefinedErrorMessage
      };
    }
    let funcSchemas = schemaRegistry.get(func);
    if (!funcSchemas) {
      funcSchemas = fn2.generateZodSchemasForFunc(func);
      if (!funcSchemas) return;
      schemaRegistry.set(func, funcSchemas);
    }
    try {
      return {
        success: true,
        data: funcSchemas.parse(args)
      };
    } catch (error42) {
      const closestSchema = fn2.findClosestSchema(funcSchemas, args);
      const zodError = closestSchema.safeParse(args).error;
      const errorMessage = fn2.friendlyParamError(zodError, func, args);
      return {
        success: false,
        error: errorMessage
      };
    }
  };
  lifecycles.presetup = function() {
    loadP5Constructors();
    if (p53.disableParameterValidator !== true) {
      const excludes = ["validate"];
      for (const f in this) {
        if (!excludes.includes(f) && !f.startsWith("_") && typeof this[f] === "function") {
          const copy2 = this[f];
          this[f] = function(...args) {
            this.validate(f, args);
            return copy2.call(this, ...args);
          };
        }
      }
    }
  };
}
if (typeof p5 !== "undefined") {
  validateParams(p5, p5.prototype);
}

// node_modules/acorn/dist/acorn.mjs
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 7, 9, 32, 4, 318, 1, 80, 3, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 68, 8, 2, 0, 3, 0, 2, 3, 2, 4, 2, 0, 15, 1, 83, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 7, 19, 58, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 343, 9, 54, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 10, 5350, 0, 7, 14, 11465, 27, 2343, 9, 87, 9, 39, 4, 60, 6, 26, 9, 535, 9, 470, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4178, 9, 519, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 245, 1, 2, 9, 726, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 4, 51, 13, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 39, 27, 10, 22, 251, 41, 7, 1, 17, 2, 60, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 31, 9, 2, 0, 3, 0, 2, 37, 2, 0, 26, 0, 2, 0, 45, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 200, 32, 32, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 26, 3994, 6, 582, 6842, 29, 1763, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 433, 44, 212, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 42, 9, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 229, 29, 3, 0, 496, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
var nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࢗ-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･";
var nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲊᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟍꟐꟑꟓꟕ-Ƛꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ";
var reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
};
var ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this";
var keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
};
var keywordRelationalOperator = /^in(stanceof)?$/;
var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(code, set3) {
  var pos = 65536;
  for (var i = 0; i < set3.length; i += 2) {
    pos += set3[i];
    if (pos > code) {
      return false;
    }
    pos += set3[i + 1];
    if (pos >= code) {
      return true;
    }
  }
  return false;
}
function isIdentifierStart(code, astral) {
  if (code < 65) {
    return code === 36;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes);
}
function isIdentifierChar(code, astral) {
  if (code < 48) {
    return code === 36;
  }
  if (code < 58) {
    return true;
  }
  if (code < 65) {
    return false;
  }
  if (code < 91) {
    return true;
  }
  if (code < 97) {
    return code === 95;
  }
  if (code < 123) {
    return true;
  }
  if (code <= 65535) {
    return code >= 170 && nonASCIIidentifier.test(String.fromCharCode(code));
  }
  if (astral === false) {
    return false;
  }
  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);
}
var TokenType = function TokenType2(label, conf) {
  if (conf === void 0) conf = {};
  this.label = label;
  this.keyword = conf.keyword;
  this.beforeExpr = !!conf.beforeExpr;
  this.startsExpr = !!conf.startsExpr;
  this.isLoop = !!conf.isLoop;
  this.isAssign = !!conf.isAssign;
  this.prefix = !!conf.prefix;
  this.postfix = !!conf.postfix;
  this.binop = conf.binop || null;
  this.updateContext = null;
};
function binop(name, prec) {
  return new TokenType(name, { beforeExpr: true, binop: prec });
}
var beforeExpr = { beforeExpr: true };
var startsExpr = { startsExpr: true };
var keywords = {};
function kw(name, options2) {
  if (options2 === void 0) options2 = {};
  options2.keyword = name;
  return keywords[name] = new TokenType(name, options2);
}
var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),
  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: true, startsExpr: true }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: true, startsExpr: true }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: true, startsExpr: true }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: true, startsExpr: true }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new TokenType("=", { beforeExpr: true, isAssign: true }),
  assign: new TokenType("_=", { beforeExpr: true, isAssign: true }),
  incDec: new TokenType("++/--", { prefix: true, postfix: true, startsExpr: true }),
  prefix: new TokenType("!/~", { beforeExpr: true, prefix: true, startsExpr: true }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: true, binop: 9, prefix: true, startsExpr: true }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: true }),
  coalesce: binop("??", 1),
  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: true, beforeExpr: true }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: true }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: true }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: true, startsExpr: true }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: true, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: true, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: true, prefix: true, startsExpr: true }),
  _void: kw("void", { beforeExpr: true, prefix: true, startsExpr: true }),
  _delete: kw("delete", { beforeExpr: true, prefix: true, startsExpr: true })
};
var lineBreak = /\r\n?|\n|\u2028|\u2029/;
var lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(code) {
  return code === 10 || code === 13 || code === 8232 || code === 8233;
}
function nextLineBreak(code, from, end) {
  if (end === void 0) end = code.length;
  for (var i = from; i < end; i++) {
    var next = code.charCodeAt(i);
    if (isNewLine(next)) {
      return i < end - 1 && next === 13 && code.charCodeAt(i + 1) === 10 ? i + 2 : i + 1;
    }
  }
  return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/;
var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
var ref = Object.prototype;
var hasOwnProperty = ref.hasOwnProperty;
var toString = ref.toString;
var hasOwn = Object.hasOwn || function(obj, propName) {
  return hasOwnProperty.call(obj, propName);
};
var isArray = Array.isArray || function(obj) {
  return toString.call(obj) === "[object Array]";
};
var regexpCache = /* @__PURE__ */ Object.create(null);
function wordsRegexp(words) {
  return regexpCache[words] || (regexpCache[words] = new RegExp("^(?:" + words.replace(/ /g, "|") + ")$"));
}
function codePointToString(code) {
  if (code <= 65535) {
    return String.fromCharCode(code);
  }
  code -= 65536;
  return String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/;
var Position = function Position2(line, col) {
  this.line = line;
  this.column = col;
};
Position.prototype.offset = function offset(n3) {
  return new Position(this.line, this.column + n3);
};
var SourceLocation = function SourceLocation2(p2, start, end) {
  this.start = start;
  this.end = end;
  if (p2.sourceFile !== null) {
    this.source = p2.sourceFile;
  }
};
function getLineInfo(input, offset2) {
  for (var line = 1, cur = 0; ; ) {
    var nextBreak = nextLineBreak(input, cur, offset2);
    if (nextBreak < 0) {
      return new Position(line, offset2 - cur);
    }
    ++line;
    cur = nextBreak;
  }
}
var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called when
  // a semicolon is automatically inserted. It will be passed the
  // position of the inserted semicolon as an offset, and if
  // `locations` is enabled, it is given the location as a `{line,
  // column}` object as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: false,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: false,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: false,
  // By default, the parser will verify that private properties are
  // only used in places where they are valid and have been declared.
  // Set this to false to turn such checks off.
  checkPrivateFields: true,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: false,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  // When this option has an array as value, objects representing the
  // comments are pushed to it.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: false,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: false
};
var warnedAboutEcmaVersion = false;
function getOptions(opts) {
  var options2 = {};
  for (var opt in defaultOptions) {
    options2[opt] = opts && hasOwn(opts, opt) ? opts[opt] : defaultOptions[opt];
  }
  if (options2.ecmaVersion === "latest") {
    options2.ecmaVersion = 1e8;
  } else if (options2.ecmaVersion == null) {
    if (!warnedAboutEcmaVersion && typeof console === "object" && console.warn) {
      warnedAboutEcmaVersion = true;
      console.warn("Since Acorn 8.0.0, options.ecmaVersion is required.\nDefaulting to 2020, but this will stop working in the future.");
    }
    options2.ecmaVersion = 11;
  } else if (options2.ecmaVersion >= 2015) {
    options2.ecmaVersion -= 2009;
  }
  if (options2.allowReserved == null) {
    options2.allowReserved = options2.ecmaVersion < 5;
  }
  if (!opts || opts.allowHashBang == null) {
    options2.allowHashBang = options2.ecmaVersion >= 14;
  }
  if (isArray(options2.onToken)) {
    var tokens = options2.onToken;
    options2.onToken = function(token) {
      return tokens.push(token);
    };
  }
  if (isArray(options2.onComment)) {
    options2.onComment = pushComment(options2, options2.onComment);
  }
  return options2;
}
function pushComment(options2, array2) {
  return function(block, text2, start, end, startLoc, endLoc) {
    var comment = {
      type: block ? "Block" : "Line",
      value: text2,
      start,
      end
    };
    if (options2.locations) {
      comment.loc = new SourceLocation(this, startLoc, endLoc);
    }
    if (options2.ranges) {
      comment.range = [start, end];
    }
    array2.push(comment);
  };
}
var SCOPE_TOP = 1;
var SCOPE_FUNCTION = 2;
var SCOPE_ASYNC = 4;
var SCOPE_GENERATOR = 8;
var SCOPE_ARROW = 16;
var SCOPE_SIMPLE_CATCH = 32;
var SCOPE_SUPER = 64;
var SCOPE_DIRECT_SUPER = 128;
var SCOPE_CLASS_STATIC_BLOCK = 256;
var SCOPE_CLASS_FIELD_INIT = 512;
var SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(async, generator) {
  return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0;
var BIND_VAR = 1;
var BIND_LEXICAL = 2;
var BIND_FUNCTION = 3;
var BIND_SIMPLE_CATCH = 4;
var BIND_OUTSIDE = 5;
var Parser = function Parser2(options2, input, startPos) {
  this.options = options2 = getOptions(options2);
  this.sourceFile = options2.sourceFile;
  this.keywords = wordsRegexp(keywords$1[options2.ecmaVersion >= 6 ? 6 : options2.sourceType === "module" ? "5module" : 5]);
  var reserved = "";
  if (options2.allowReserved !== true) {
    reserved = reservedWords[options2.ecmaVersion >= 6 ? 6 : options2.ecmaVersion === 5 ? 5 : 3];
    if (options2.sourceType === "module") {
      reserved += " await";
    }
  }
  this.reservedWords = wordsRegexp(reserved);
  var reservedStrict = (reserved ? reserved + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(reservedStrict);
  this.reservedWordsStrictBind = wordsRegexp(reservedStrict + " " + reservedWords.strictBind);
  this.input = String(input);
  this.containsEsc = false;
  if (startPos) {
    this.pos = startPos;
    this.lineStart = this.input.lastIndexOf("\n", startPos - 1) + 1;
    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;
  } else {
    this.pos = this.lineStart = 0;
    this.curLine = 1;
  }
  this.type = types$1.eof;
  this.value = null;
  this.start = this.end = this.pos;
  this.startLoc = this.endLoc = this.curPosition();
  this.lastTokEndLoc = this.lastTokStartLoc = null;
  this.lastTokStart = this.lastTokEnd = this.pos;
  this.context = this.initialContext();
  this.exprAllowed = true;
  this.inModule = options2.sourceType === "module";
  this.strict = this.inModule || this.strictDirective(this.pos);
  this.potentialArrowAt = -1;
  this.potentialArrowInForAwait = false;
  this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;
  this.labels = [];
  this.undefinedExports = /* @__PURE__ */ Object.create(null);
  if (this.pos === 0 && options2.allowHashBang && this.input.slice(0, 2) === "#!") {
    this.skipLineComment(2);
  }
  this.scopeStack = [];
  this.enterScope(SCOPE_TOP);
  this.regexpState = null;
  this.privateNameStack = [];
};
var prototypeAccessors = { inFunction: { configurable: true }, inGenerator: { configurable: true }, inAsync: { configurable: true }, canAwait: { configurable: true }, allowSuper: { configurable: true }, allowDirectSuper: { configurable: true }, treatFunctionsAsVar: { configurable: true }, allowNewDotTarget: { configurable: true }, inClassStaticBlock: { configurable: true } };
Parser.prototype.parse = function parse5() {
  var node = this.options.program || this.startNode();
  this.nextToken();
  return this.parseTopLevel(node);
};
prototypeAccessors.inFunction.get = function() {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0;
};
prototypeAccessors.inAsync.get = function() {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0;
};
prototypeAccessors.canAwait.get = function() {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var ref2 = this.scopeStack[i];
    var flags = ref2.flags;
    if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT)) {
      return false;
    }
    if (flags & SCOPE_FUNCTION) {
      return (flags & SCOPE_ASYNC) > 0;
    }
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
  var ref2 = this.currentThisScope();
  var flags = ref2.flags;
  return (flags & SCOPE_SUPER) > 0 || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
  for (var i = this.scopeStack.length - 1; i >= 0; i--) {
    var ref2 = this.scopeStack[i];
    var flags = ref2.flags;
    if (flags & (SCOPE_CLASS_STATIC_BLOCK | SCOPE_CLASS_FIELD_INIT) || flags & SCOPE_FUNCTION && !(flags & SCOPE_ARROW)) {
      return true;
    }
  }
  return false;
};
prototypeAccessors.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function extend2() {
  var plugins = [], len = arguments.length;
  while (len--) plugins[len] = arguments[len];
  var cls = this;
  for (var i = 0; i < plugins.length; i++) {
    cls = plugins[i](cls);
  }
  return cls;
};
Parser.parse = function parse6(input, options2) {
  return new this(options2, input).parse();
};
Parser.parseExpressionAt = function parseExpressionAt(input, pos, options2) {
  var parser = new this(options2, input, pos);
  parser.nextToken();
  return parser.parseExpression();
};
Parser.tokenizer = function tokenizer(input, options2) {
  return new this(options2, input);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype;
var literal2 = /^(?:'((?:\\[^]|[^'\\])*?)'|"((?:\\[^]|[^"\\])*?)")/;
pp$9.strictDirective = function(start) {
  if (this.options.ecmaVersion < 5) {
    return false;
  }
  for (; ; ) {
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    var match = literal2.exec(this.input.slice(start));
    if (!match) {
      return false;
    }
    if ((match[1] || match[2]) === "use strict") {
      skipWhiteSpace.lastIndex = start + match[0].length;
      var spaceAfter = skipWhiteSpace.exec(this.input), end = spaceAfter.index + spaceAfter[0].length;
      var next = this.input.charAt(end);
      return next === ";" || next === "}" || lineBreak.test(spaceAfter[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(next) || next === "!" && this.input.charAt(end + 1) === "=");
    }
    start += match[0].length;
    skipWhiteSpace.lastIndex = start;
    start += skipWhiteSpace.exec(this.input)[0].length;
    if (this.input[start] === ";") {
      start++;
    }
  }
};
pp$9.eat = function(type3) {
  if (this.type === type3) {
    this.next();
    return true;
  } else {
    return false;
  }
};
pp$9.isContextual = function(name) {
  return this.type === types$1.name && this.value === name && !this.containsEsc;
};
pp$9.eatContextual = function(name) {
  if (!this.isContextual(name)) {
    return false;
  }
  this.next();
  return true;
};
pp$9.expectContextual = function(name) {
  if (!this.eatContextual(name)) {
    this.unexpected();
  }
};
pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon()) {
    if (this.options.onInsertedSemicolon) {
      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);
    }
    return true;
  }
};
pp$9.semicolon = function() {
  if (!this.eat(types$1.semi) && !this.insertSemicolon()) {
    this.unexpected();
  }
};
pp$9.afterTrailingComma = function(tokType, notNext) {
  if (this.type === tokType) {
    if (this.options.onTrailingComma) {
      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);
    }
    if (!notNext) {
      this.next();
    }
    return true;
  }
};
pp$9.expect = function(type3) {
  this.eat(type3) || this.unexpected();
};
pp$9.unexpected = function(pos) {
  this.raise(pos != null ? pos : this.start, "Unexpected token");
};
var DestructuringErrors = function DestructuringErrors2() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(refDestructuringErrors, isAssign) {
  if (!refDestructuringErrors) {
    return;
  }
  if (refDestructuringErrors.trailingComma > -1) {
    this.raiseRecoverable(refDestructuringErrors.trailingComma, "Comma is not permitted after the rest element");
  }
  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;
  if (parens > -1) {
    this.raiseRecoverable(parens, isAssign ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
pp$9.checkExpressionErrors = function(refDestructuringErrors, andThrow) {
  if (!refDestructuringErrors) {
    return false;
  }
  var shorthandAssign = refDestructuringErrors.shorthandAssign;
  var doubleProto = refDestructuringErrors.doubleProto;
  if (!andThrow) {
    return shorthandAssign >= 0 || doubleProto >= 0;
  }
  if (shorthandAssign >= 0) {
    this.raise(shorthandAssign, "Shorthand property assignments are valid only in destructuring patterns");
  }
  if (doubleProto >= 0) {
    this.raiseRecoverable(doubleProto, "Redefinition of __proto__ property");
  }
};
pp$9.checkYieldAwaitInDefaultParams = function() {
  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {
    this.raise(this.yieldPos, "Yield expression cannot be a default value");
  }
  if (this.awaitPos) {
    this.raise(this.awaitPos, "Await expression cannot be a default value");
  }
};
pp$9.isSimpleAssignTarget = function(expr) {
  if (expr.type === "ParenthesizedExpression") {
    return this.isSimpleAssignTarget(expr.expression);
  }
  return expr.type === "Identifier" || expr.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(node) {
  var exports = /* @__PURE__ */ Object.create(null);
  if (!node.body) {
    node.body = [];
  }
  while (this.type !== types$1.eof) {
    var stmt = this.parseStatement(null, true, exports);
    node.body.push(stmt);
  }
  if (this.inModule) {
    for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1) {
      var name = list[i];
      this.raiseRecoverable(this.undefinedExports[name].start, "Export '" + name + "' is not defined");
    }
  }
  this.adaptDirectivePrologue(node.body);
  this.next();
  node.sourceType = this.options.sourceType;
  return this.finishNode(node, "Program");
};
var loopLabel = { kind: "loop" };
var switchLabel = { kind: "switch" };
pp$8.isLet = function(context) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
  if (nextCh === 91 || nextCh === 92) {
    return true;
  }
  if (context) {
    return false;
  }
  if (nextCh === 123 || nextCh > 55295 && nextCh < 56320) {
    return true;
  }
  if (isIdentifierStart(nextCh, true)) {
    var pos = next + 1;
    while (isIdentifierChar(nextCh = this.input.charCodeAt(pos), true)) {
      ++pos;
    }
    if (nextCh === 92 || nextCh > 55295 && nextCh < 56320) {
      return true;
    }
    var ident = this.input.slice(next, pos);
    if (!keywordRelationalOperator.test(ident)) {
      return true;
    }
  }
  return false;
};
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length, after;
  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === "function" && (next + 8 === this.input.length || !(isIdentifierChar(after = this.input.charCodeAt(next + 8)) || after > 55295 && after < 56320));
};
pp$8.isUsingKeyword = function(isAwaitUsing, isFor) {
  if (this.options.ecmaVersion < 17 || !this.isContextual(isAwaitUsing ? "await" : "using")) {
    return false;
  }
  skipWhiteSpace.lastIndex = this.pos;
  var skip = skipWhiteSpace.exec(this.input);
  var next = this.pos + skip[0].length;
  if (lineBreak.test(this.input.slice(this.pos, next))) {
    return false;
  }
  if (isAwaitUsing) {
    var awaitEndPos = next + 5, after;
    if (this.input.slice(next, awaitEndPos) !== "using" || awaitEndPos === this.input.length || isIdentifierChar(after = this.input.charCodeAt(awaitEndPos)) || after > 55295 && after < 56320) {
      return false;
    }
    skipWhiteSpace.lastIndex = awaitEndPos;
    var skipAfterUsing = skipWhiteSpace.exec(this.input);
    if (skipAfterUsing && lineBreak.test(this.input.slice(awaitEndPos, awaitEndPos + skipAfterUsing[0].length))) {
      return false;
    }
  }
  if (isFor) {
    var ofEndPos = next + 2, after$1;
    if (this.input.slice(next, ofEndPos) === "of") {
      if (ofEndPos === this.input.length || !isIdentifierChar(after$1 = this.input.charCodeAt(ofEndPos)) && !(after$1 > 55295 && after$1 < 56320)) {
        return false;
      }
    }
  }
  var ch = this.input.charCodeAt(next);
  return isIdentifierStart(ch, true) || ch === 92;
};
pp$8.isAwaitUsing = function(isFor) {
  return this.isUsingKeyword(true, isFor);
};
pp$8.isUsing = function(isFor) {
  return this.isUsingKeyword(false, isFor);
};
pp$8.parseStatement = function(context, topLevel, exports) {
  var starttype = this.type, node = this.startNode(), kind;
  if (this.isLet(context)) {
    starttype = types$1._var;
    kind = "let";
  }
  switch (starttype) {
    case types$1._break:
    case types$1._continue:
      return this.parseBreakContinueStatement(node, starttype.keyword);
    case types$1._debugger:
      return this.parseDebuggerStatement(node);
    case types$1._do:
      return this.parseDoStatement(node);
    case types$1._for:
      return this.parseForStatement(node);
    case types$1._function:
      if (context && (this.strict || context !== "if" && context !== "label") && this.options.ecmaVersion >= 6) {
        this.unexpected();
      }
      return this.parseFunctionStatement(node, false, !context);
    case types$1._class:
      if (context) {
        this.unexpected();
      }
      return this.parseClass(node, true);
    case types$1._if:
      return this.parseIfStatement(node);
    case types$1._return:
      return this.parseReturnStatement(node);
    case types$1._switch:
      return this.parseSwitchStatement(node);
    case types$1._throw:
      return this.parseThrowStatement(node);
    case types$1._try:
      return this.parseTryStatement(node);
    case types$1._const:
    case types$1._var:
      kind = kind || this.value;
      if (context && kind !== "var") {
        this.unexpected();
      }
      return this.parseVarStatement(node, kind);
    case types$1._while:
      return this.parseWhileStatement(node);
    case types$1._with:
      return this.parseWithStatement(node);
    case types$1.braceL:
      return this.parseBlock(true, node);
    case types$1.semi:
      return this.parseEmptyStatement(node);
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && starttype === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var skip = skipWhiteSpace.exec(this.input);
        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);
        if (nextCh === 40 || nextCh === 46) {
          return this.parseExpressionStatement(node, this.parseExpression());
        }
      }
      if (!this.options.allowImportExportEverywhere) {
        if (!topLevel) {
          this.raise(this.start, "'import' and 'export' may only appear at the top level");
        }
        if (!this.inModule) {
          this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'");
        }
      }
      return starttype === types$1._import ? this.parseImport(node) : this.parseExport(node, exports);
    default:
      if (this.isAsyncFunction()) {
        if (context) {
          this.unexpected();
        }
        this.next();
        return this.parseFunctionStatement(node, true, !context);
      }
      var usingKind = this.isAwaitUsing(false) ? "await using" : this.isUsing(false) ? "using" : null;
      if (usingKind) {
        if (topLevel && this.options.sourceType === "script") {
          this.raise(this.start, "Using declaration cannot appear in the top level when source type is `script`");
        }
        if (usingKind === "await using") {
          if (!this.canAwait) {
            this.raise(this.start, "Await using cannot appear outside of async function");
          }
          this.next();
        }
        this.next();
        this.parseVar(node, false, usingKind);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      }
      var maybeName = this.value, expr = this.parseExpression();
      if (starttype === types$1.name && expr.type === "Identifier" && this.eat(types$1.colon)) {
        return this.parseLabeledStatement(node, maybeName, expr, context);
      } else {
        return this.parseExpressionStatement(node, expr);
      }
  }
};
pp$8.parseBreakContinueStatement = function(node, keyword) {
  var isBreak = keyword === "break";
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.label = null;
  } else if (this.type !== types$1.name) {
    this.unexpected();
  } else {
    node.label = this.parseIdent();
    this.semicolon();
  }
  var i = 0;
  for (; i < this.labels.length; ++i) {
    var lab = this.labels[i];
    if (node.label == null || lab.name === node.label.name) {
      if (lab.kind != null && (isBreak || lab.kind === "loop")) {
        break;
      }
      if (node.label && isBreak) {
        break;
      }
    }
  }
  if (i === this.labels.length) {
    this.raise(node.start, "Unsyntactic " + keyword);
  }
  return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(node) {
  this.next();
  this.semicolon();
  return this.finishNode(node, "DebuggerStatement");
};
pp$8.parseDoStatement = function(node) {
  this.next();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("do");
  this.labels.pop();
  this.expect(types$1._while);
  node.test = this.parseParenExpression();
  if (this.options.ecmaVersion >= 6) {
    this.eat(types$1.semi);
  } else {
    this.semicolon();
  }
  return this.finishNode(node, "DoWhileStatement");
};
pp$8.parseForStatement = function(node) {
  this.next();
  var awaitAt = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  this.labels.push(loopLabel);
  this.enterScope(0);
  this.expect(types$1.parenL);
  if (this.type === types$1.semi) {
    if (awaitAt > -1) {
      this.unexpected(awaitAt);
    }
    return this.parseFor(node, null);
  }
  var isLet = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || isLet) {
    var init$1 = this.startNode(), kind = isLet ? "let" : this.value;
    this.next();
    this.parseVar(init$1, true, kind);
    this.finishNode(init$1, "VariableDeclaration");
    return this.parseForAfterInit(node, init$1, awaitAt);
  }
  var startsWithLet = this.isContextual("let"), isForOf = false;
  var usingKind = this.isUsing(true) ? "using" : this.isAwaitUsing(true) ? "await using" : null;
  if (usingKind) {
    var init$2 = this.startNode();
    this.next();
    if (usingKind === "await using") {
      this.next();
    }
    this.parseVar(init$2, true, usingKind);
    this.finishNode(init$2, "VariableDeclaration");
    return this.parseForAfterInit(node, init$2, awaitAt);
  }
  var containsEsc = this.containsEsc;
  var refDestructuringErrors = new DestructuringErrors();
  var initPos = this.start;
  var init = awaitAt > -1 ? this.parseExprSubscripts(refDestructuringErrors, "await") : this.parseExpression(true, refDestructuringErrors);
  if (this.type === types$1._in || (isForOf = this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
    if (awaitAt > -1) {
      if (this.type === types$1._in) {
        this.unexpected(awaitAt);
      }
      node.await = true;
    } else if (isForOf && this.options.ecmaVersion >= 8) {
      if (init.start === initPos && !containsEsc && init.type === "Identifier" && init.name === "async") {
        this.unexpected();
      } else if (this.options.ecmaVersion >= 9) {
        node.await = false;
      }
    }
    if (startsWithLet && isForOf) {
      this.raise(init.start, "The left-hand side of a for-of loop may not start with 'let'.");
    }
    this.toAssignable(init, false, refDestructuringErrors);
    this.checkLValPattern(init);
    return this.parseForIn(node, init);
  } else {
    this.checkExpressionErrors(refDestructuringErrors, true);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node, init);
};
pp$8.parseForAfterInit = function(node, init, awaitAt) {
  if ((this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && init.declarations.length === 1) {
    if (this.options.ecmaVersion >= 9) {
      if (this.type === types$1._in) {
        if (awaitAt > -1) {
          this.unexpected(awaitAt);
        }
      } else {
        node.await = awaitAt > -1;
      }
    }
    return this.parseForIn(node, init);
  }
  if (awaitAt > -1) {
    this.unexpected(awaitAt);
  }
  return this.parseFor(node, init);
};
pp$8.parseFunctionStatement = function(node, isAsync, declarationPosition) {
  this.next();
  return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync);
};
pp$8.parseIfStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  node.consequent = this.parseStatement("if");
  node.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null;
  return this.finishNode(node, "IfStatement");
};
pp$8.parseReturnStatement = function(node) {
  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {
    this.raise(this.start, "'return' outside of function");
  }
  this.next();
  if (this.eat(types$1.semi) || this.insertSemicolon()) {
    node.argument = null;
  } else {
    node.argument = this.parseExpression();
    this.semicolon();
  }
  return this.finishNode(node, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(node) {
  this.next();
  node.discriminant = this.parseParenExpression();
  node.cases = [];
  this.expect(types$1.braceL);
  this.labels.push(switchLabel);
  this.enterScope(0);
  var cur;
  for (var sawDefault = false; this.type !== types$1.braceR; ) {
    if (this.type === types$1._case || this.type === types$1._default) {
      var isCase = this.type === types$1._case;
      if (cur) {
        this.finishNode(cur, "SwitchCase");
      }
      node.cases.push(cur = this.startNode());
      cur.consequent = [];
      this.next();
      if (isCase) {
        cur.test = this.parseExpression();
      } else {
        if (sawDefault) {
          this.raiseRecoverable(this.lastTokStart, "Multiple default clauses");
        }
        sawDefault = true;
        cur.test = null;
      }
      this.expect(types$1.colon);
    } else {
      if (!cur) {
        this.unexpected();
      }
      cur.consequent.push(this.parseStatement(null));
    }
  }
  this.exitScope();
  if (cur) {
    this.finishNode(cur, "SwitchCase");
  }
  this.next();
  this.labels.pop();
  return this.finishNode(node, "SwitchStatement");
};
pp$8.parseThrowStatement = function(node) {
  this.next();
  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {
    this.raise(this.lastTokEnd, "Illegal newline after throw");
  }
  node.argument = this.parseExpression();
  this.semicolon();
  return this.finishNode(node, "ThrowStatement");
};
var empty$1 = [];
pp$8.parseCatchClauseParam = function() {
  var param = this.parseBindingAtom();
  var simple2 = param.type === "Identifier";
  this.enterScope(simple2 ? SCOPE_SIMPLE_CATCH : 0);
  this.checkLValPattern(param, simple2 ? BIND_SIMPLE_CATCH : BIND_LEXICAL);
  this.expect(types$1.parenR);
  return param;
};
pp$8.parseTryStatement = function(node) {
  this.next();
  node.block = this.parseBlock();
  node.handler = null;
  if (this.type === types$1._catch) {
    var clause = this.startNode();
    this.next();
    if (this.eat(types$1.parenL)) {
      clause.param = this.parseCatchClauseParam();
    } else {
      if (this.options.ecmaVersion < 10) {
        this.unexpected();
      }
      clause.param = null;
      this.enterScope(0);
    }
    clause.body = this.parseBlock(false);
    this.exitScope();
    node.handler = this.finishNode(clause, "CatchClause");
  }
  node.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null;
  if (!node.handler && !node.finalizer) {
    this.raise(node.start, "Missing catch or finally clause");
  }
  return this.finishNode(node, "TryStatement");
};
pp$8.parseVarStatement = function(node, kind, allowMissingInitializer) {
  this.next();
  this.parseVar(node, false, kind, allowMissingInitializer);
  this.semicolon();
  return this.finishNode(node, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(node) {
  this.next();
  node.test = this.parseParenExpression();
  this.labels.push(loopLabel);
  node.body = this.parseStatement("while");
  this.labels.pop();
  return this.finishNode(node, "WhileStatement");
};
pp$8.parseWithStatement = function(node) {
  if (this.strict) {
    this.raise(this.start, "'with' in strict mode");
  }
  this.next();
  node.object = this.parseParenExpression();
  node.body = this.parseStatement("with");
  return this.finishNode(node, "WithStatement");
};
pp$8.parseEmptyStatement = function(node) {
  this.next();
  return this.finishNode(node, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(node, maybeName, expr, context) {
  for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1) {
    var label = list[i$1];
    if (label.name === maybeName) {
      this.raise(expr.start, "Label '" + maybeName + "' is already declared");
    }
  }
  var kind = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null;
  for (var i = this.labels.length - 1; i >= 0; i--) {
    var label$1 = this.labels[i];
    if (label$1.statementStart === node.start) {
      label$1.statementStart = this.start;
      label$1.kind = kind;
    } else {
      break;
    }
  }
  this.labels.push({ name: maybeName, kind, statementStart: this.start });
  node.body = this.parseStatement(context ? context.indexOf("label") === -1 ? context + "label" : context : "label");
  this.labels.pop();
  node.label = expr;
  return this.finishNode(node, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(node, expr) {
  node.expression = expr;
  this.semicolon();
  return this.finishNode(node, "ExpressionStatement");
};
pp$8.parseBlock = function(createNewLexicalScope, node, exitStrict) {
  if (createNewLexicalScope === void 0) createNewLexicalScope = true;
  if (node === void 0) node = this.startNode();
  node.body = [];
  this.expect(types$1.braceL);
  if (createNewLexicalScope) {
    this.enterScope(0);
  }
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  if (exitStrict) {
    this.strict = false;
  }
  this.next();
  if (createNewLexicalScope) {
    this.exitScope();
  }
  return this.finishNode(node, "BlockStatement");
};
pp$8.parseFor = function(node, init) {
  node.init = init;
  this.expect(types$1.semi);
  node.test = this.type === types$1.semi ? null : this.parseExpression();
  this.expect(types$1.semi);
  node.update = this.type === types$1.parenR ? null : this.parseExpression();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, "ForStatement");
};
pp$8.parseForIn = function(node, init) {
  var isForIn = this.type === types$1._in;
  this.next();
  if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || this.options.ecmaVersion < 8 || this.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
    this.raise(
      init.start,
      (isForIn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
    );
  }
  node.left = init;
  node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();
  this.expect(types$1.parenR);
  node.body = this.parseStatement("for");
  this.exitScope();
  this.labels.pop();
  return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(node, isFor, kind, allowMissingInitializer) {
  node.declarations = [];
  node.kind = kind;
  for (; ; ) {
    var decl = this.startNode();
    this.parseVarId(decl, kind);
    if (this.eat(types$1.eq)) {
      decl.init = this.parseMaybeAssign(isFor);
    } else if (!allowMissingInitializer && kind === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of"))) {
      this.unexpected();
    } else if (!allowMissingInitializer && (kind === "using" || kind === "await using") && this.options.ecmaVersion >= 17 && this.type !== types$1._in && !this.isContextual("of")) {
      this.raise(this.lastTokEnd, "Missing initializer in " + kind + " declaration");
    } else if (!allowMissingInitializer && decl.id.type !== "Identifier" && !(isFor && (this.type === types$1._in || this.isContextual("of")))) {
      this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value");
    } else {
      decl.init = null;
    }
    node.declarations.push(this.finishNode(decl, "VariableDeclarator"));
    if (!this.eat(types$1.comma)) {
      break;
    }
  }
  return node;
};
pp$8.parseVarId = function(decl, kind) {
  decl.id = kind === "using" || kind === "await using" ? this.parseIdent() : this.parseBindingAtom();
  this.checkLValPattern(decl.id, kind === "var" ? BIND_VAR : BIND_LEXICAL, false);
};
var FUNC_STATEMENT = 1;
var FUNC_HANGING_STATEMENT = 2;
var FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(node, statement, allowExpressionBody, isAsync, forInit) {
  this.initFunction(node);
  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {
    if (this.type === types$1.star && statement & FUNC_HANGING_STATEMENT) {
      this.unexpected();
    }
    node.generator = this.eat(types$1.star);
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  if (statement & FUNC_STATEMENT) {
    node.id = statement & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent();
    if (node.id && !(statement & FUNC_HANGING_STATEMENT)) {
      this.checkLValSimple(node.id, this.strict || node.generator || node.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION);
    }
  }
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(node.async, node.generator));
  if (!(statement & FUNC_STATEMENT)) {
    node.id = this.type === types$1.name ? this.parseIdent() : null;
  }
  this.parseFunctionParams(node);
  this.parseFunctionBody(node, allowExpressionBody, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, statement & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(node) {
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(node, isStatement) {
  this.next();
  var oldStrict = this.strict;
  this.strict = true;
  this.parseClassId(node, isStatement);
  this.parseClassSuper(node);
  var privateNameMap = this.enterClassBody();
  var classBody = this.startNode();
  var hadConstructor = false;
  classBody.body = [];
  this.expect(types$1.braceL);
  while (this.type !== types$1.braceR) {
    var element2 = this.parseClassElement(node.superClass !== null);
    if (element2) {
      classBody.body.push(element2);
      if (element2.type === "MethodDefinition" && element2.kind === "constructor") {
        if (hadConstructor) {
          this.raiseRecoverable(element2.start, "Duplicate constructor in the same class");
        }
        hadConstructor = true;
      } else if (element2.key && element2.key.type === "PrivateIdentifier" && isPrivateNameConflicted(privateNameMap, element2)) {
        this.raiseRecoverable(element2.key.start, "Identifier '#" + element2.key.name + "' has already been declared");
      }
    }
  }
  this.strict = oldStrict;
  this.next();
  node.body = this.finishNode(classBody, "ClassBody");
  this.exitClassBody();
  return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(constructorAllowsSuper) {
  if (this.eat(types$1.semi)) {
    return null;
  }
  var ecmaVersion = this.options.ecmaVersion;
  var node = this.startNode();
  var keyName = "";
  var isGenerator = false;
  var isAsync = false;
  var kind = "method";
  var isStatic = false;
  if (this.eatContextual("static")) {
    if (ecmaVersion >= 13 && this.eat(types$1.braceL)) {
      this.parseClassStaticBlock(node);
      return node;
    }
    if (this.isClassElementNameStart() || this.type === types$1.star) {
      isStatic = true;
    } else {
      keyName = "static";
    }
  }
  node.static = isStatic;
  if (!keyName && ecmaVersion >= 8 && this.eatContextual("async")) {
    if ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon()) {
      isAsync = true;
    } else {
      keyName = "async";
    }
  }
  if (!keyName && (ecmaVersion >= 9 || !isAsync) && this.eat(types$1.star)) {
    isGenerator = true;
  }
  if (!keyName && !isAsync && !isGenerator) {
    var lastValue = this.value;
    if (this.eatContextual("get") || this.eatContextual("set")) {
      if (this.isClassElementNameStart()) {
        kind = lastValue;
      } else {
        keyName = lastValue;
      }
    }
  }
  if (keyName) {
    node.computed = false;
    node.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc);
    node.key.name = keyName;
    this.finishNode(node.key, "Identifier");
  } else {
    this.parseClassElementName(node);
  }
  if (ecmaVersion < 13 || this.type === types$1.parenL || kind !== "method" || isGenerator || isAsync) {
    var isConstructor = !node.static && checkKeyName(node, "constructor");
    var allowsDirectSuper = isConstructor && constructorAllowsSuper;
    if (isConstructor && kind !== "method") {
      this.raise(node.key.start, "Constructor can't have get/set modifier");
    }
    node.kind = isConstructor ? "constructor" : kind;
    this.parseClassMethod(node, isGenerator, isAsync, allowsDirectSuper);
  } else {
    this.parseClassField(node);
  }
  return node;
};
pp$8.isClassElementNameStart = function() {
  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(element2) {
  if (this.type === types$1.privateId) {
    if (this.value === "constructor") {
      this.raise(this.start, "Classes can't have an element named '#constructor'");
    }
    element2.computed = false;
    element2.key = this.parsePrivateIdent();
  } else {
    this.parsePropertyName(element2);
  }
};
pp$8.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {
  var key = method.key;
  if (method.kind === "constructor") {
    if (isGenerator) {
      this.raise(key.start, "Constructor can't be a generator");
    }
    if (isAsync) {
      this.raise(key.start, "Constructor can't be an async method");
    }
  } else if (method.static && checkKeyName(method, "prototype")) {
    this.raise(key.start, "Classes may not have a static property named prototype");
  }
  var value = method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);
  if (method.kind === "get" && value.params.length !== 0) {
    this.raiseRecoverable(value.start, "getter should have no params");
  }
  if (method.kind === "set" && value.params.length !== 1) {
    this.raiseRecoverable(value.start, "setter should have exactly one param");
  }
  if (method.kind === "set" && value.params[0].type === "RestElement") {
    this.raiseRecoverable(value.params[0].start, "Setter cannot use rest params");
  }
  return this.finishNode(method, "MethodDefinition");
};
pp$8.parseClassField = function(field) {
  if (checkKeyName(field, "constructor")) {
    this.raise(field.key.start, "Classes can't have a field named 'constructor'");
  } else if (field.static && checkKeyName(field, "prototype")) {
    this.raise(field.key.start, "Classes can't have a static field named 'prototype'");
  }
  if (this.eat(types$1.eq)) {
    this.enterScope(SCOPE_CLASS_FIELD_INIT | SCOPE_SUPER);
    field.value = this.parseMaybeAssign();
    this.exitScope();
  } else {
    field.value = null;
  }
  this.semicolon();
  return this.finishNode(field, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(node) {
  node.body = [];
  var oldLabels = this.labels;
  this.labels = [];
  this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER);
  while (this.type !== types$1.braceR) {
    var stmt = this.parseStatement(null);
    node.body.push(stmt);
  }
  this.next();
  this.exitScope();
  this.labels = oldLabels;
  return this.finishNode(node, "StaticBlock");
};
pp$8.parseClassId = function(node, isStatement) {
  if (this.type === types$1.name) {
    node.id = this.parseIdent();
    if (isStatement) {
      this.checkLValSimple(node.id, BIND_LEXICAL, false);
    }
  } else {
    if (isStatement === true) {
      this.unexpected();
    }
    node.id = null;
  }
};
pp$8.parseClassSuper = function(node) {
  node.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, false) : null;
};
pp$8.enterClassBody = function() {
  var element2 = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  this.privateNameStack.push(element2);
  return element2.declared;
};
pp$8.exitClassBody = function() {
  var ref2 = this.privateNameStack.pop();
  var declared = ref2.declared;
  var used = ref2.used;
  if (!this.options.checkPrivateFields) {
    return;
  }
  var len = this.privateNameStack.length;
  var parent = len === 0 ? null : this.privateNameStack[len - 1];
  for (var i = 0; i < used.length; ++i) {
    var id = used[i];
    if (!hasOwn(declared, id.name)) {
      if (parent) {
        parent.used.push(id);
      } else {
        this.raiseRecoverable(id.start, "Private field '#" + id.name + "' must be declared in an enclosing class");
      }
    }
  }
};
function isPrivateNameConflicted(privateNameMap, element2) {
  var name = element2.key.name;
  var curr = privateNameMap[name];
  var next = "true";
  if (element2.type === "MethodDefinition" && (element2.kind === "get" || element2.kind === "set")) {
    next = (element2.static ? "s" : "i") + element2.kind;
  }
  if (curr === "iget" && next === "iset" || curr === "iset" && next === "iget" || curr === "sget" && next === "sset" || curr === "sset" && next === "sget") {
    privateNameMap[name] = "true";
    return false;
  } else if (!curr) {
    privateNameMap[name] = next;
    return false;
  } else {
    return true;
  }
}
function checkKeyName(node, name) {
  var computed = node.computed;
  var key = node.key;
  return !computed && (key.type === "Identifier" && key.name === name || key.type === "Literal" && key.value === name);
}
pp$8.parseExportAllDeclaration = function(node, exports) {
  if (this.options.ecmaVersion >= 11) {
    if (this.eatContextual("as")) {
      node.exported = this.parseModuleExportName();
      this.checkExport(exports, node.exported, this.lastTokStart);
    } else {
      node.exported = null;
    }
  }
  this.expectContextual("from");
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node.source = this.parseExprAtom();
  if (this.options.ecmaVersion >= 16) {
    node.attributes = this.parseWithClause();
  }
  this.semicolon();
  return this.finishNode(node, "ExportAllDeclaration");
};
pp$8.parseExport = function(node, exports) {
  this.next();
  if (this.eat(types$1.star)) {
    return this.parseExportAllDeclaration(node, exports);
  }
  if (this.eat(types$1._default)) {
    this.checkExport(exports, "default", this.lastTokStart);
    node.declaration = this.parseExportDefaultDeclaration();
    return this.finishNode(node, "ExportDefaultDeclaration");
  }
  if (this.shouldParseExportStatement()) {
    node.declaration = this.parseExportDeclaration(node);
    if (node.declaration.type === "VariableDeclaration") {
      this.checkVariableExport(exports, node.declaration.declarations);
    } else {
      this.checkExport(exports, node.declaration.id, node.declaration.id.start);
    }
    node.specifiers = [];
    node.source = null;
    if (this.options.ecmaVersion >= 16) {
      node.attributes = [];
    }
  } else {
    node.declaration = null;
    node.specifiers = this.parseExportSpecifiers(exports);
    if (this.eatContextual("from")) {
      if (this.type !== types$1.string) {
        this.unexpected();
      }
      node.source = this.parseExprAtom();
      if (this.options.ecmaVersion >= 16) {
        node.attributes = this.parseWithClause();
      }
    } else {
      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
        var spec = list[i];
        this.checkUnreserved(spec.local);
        this.checkLocalExport(spec.local);
        if (spec.local.type === "Literal") {
          this.raise(spec.local.start, "A string literal cannot be used as an exported binding without `from`.");
        }
      }
      node.source = null;
      if (this.options.ecmaVersion >= 16) {
        node.attributes = [];
      }
    }
    this.semicolon();
  }
  return this.finishNode(node, "ExportNamedDeclaration");
};
pp$8.parseExportDeclaration = function(node) {
  return this.parseStatement(null);
};
pp$8.parseExportDefaultDeclaration = function() {
  var isAsync;
  if (this.type === types$1._function || (isAsync = this.isAsyncFunction())) {
    var fNode = this.startNode();
    this.next();
    if (isAsync) {
      this.next();
    }
    return this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);
  } else if (this.type === types$1._class) {
    var cNode = this.startNode();
    return this.parseClass(cNode, "nullableID");
  } else {
    var declaration = this.parseMaybeAssign();
    this.semicolon();
    return declaration;
  }
};
pp$8.checkExport = function(exports, name, pos) {
  if (!exports) {
    return;
  }
  if (typeof name !== "string") {
    name = name.type === "Identifier" ? name.name : name.value;
  }
  if (hasOwn(exports, name)) {
    this.raiseRecoverable(pos, "Duplicate export '" + name + "'");
  }
  exports[name] = true;
};
pp$8.checkPatternExport = function(exports, pat) {
  var type3 = pat.type;
  if (type3 === "Identifier") {
    this.checkExport(exports, pat, pat.start);
  } else if (type3 === "ObjectPattern") {
    for (var i = 0, list = pat.properties; i < list.length; i += 1) {
      var prop = list[i];
      this.checkPatternExport(exports, prop);
    }
  } else if (type3 === "ArrayPattern") {
    for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {
      var elt = list$1[i$1];
      if (elt) {
        this.checkPatternExport(exports, elt);
      }
    }
  } else if (type3 === "Property") {
    this.checkPatternExport(exports, pat.value);
  } else if (type3 === "AssignmentPattern") {
    this.checkPatternExport(exports, pat.left);
  } else if (type3 === "RestElement") {
    this.checkPatternExport(exports, pat.argument);
  }
};
pp$8.checkVariableExport = function(exports, decls) {
  if (!exports) {
    return;
  }
  for (var i = 0, list = decls; i < list.length; i += 1) {
    var decl = list[i];
    this.checkPatternExport(exports, decl.id);
  }
};
pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifier = function(exports) {
  var node = this.startNode();
  node.local = this.parseModuleExportName();
  node.exported = this.eatContextual("as") ? this.parseModuleExportName() : node.local;
  this.checkExport(
    exports,
    node.exported,
    node.exported.start
  );
  return this.finishNode(node, "ExportSpecifier");
};
pp$8.parseExportSpecifiers = function(exports) {
  var nodes = [], first = true;
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseExportSpecifier(exports));
  }
  return nodes;
};
pp$8.parseImport = function(node) {
  this.next();
  if (this.type === types$1.string) {
    node.specifiers = empty$1;
    node.source = this.parseExprAtom();
  } else {
    node.specifiers = this.parseImportSpecifiers();
    this.expectContextual("from");
    node.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected();
  }
  if (this.options.ecmaVersion >= 16) {
    node.attributes = this.parseWithClause();
  }
  this.semicolon();
  return this.finishNode(node, "ImportDeclaration");
};
pp$8.parseImportSpecifier = function() {
  var node = this.startNode();
  node.imported = this.parseModuleExportName();
  if (this.eatContextual("as")) {
    node.local = this.parseIdent();
  } else {
    this.checkUnreserved(node.imported);
    node.local = node.imported;
  }
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportSpecifier");
};
pp$8.parseImportDefaultSpecifier = function() {
  var node = this.startNode();
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportDefaultSpecifier");
};
pp$8.parseImportNamespaceSpecifier = function() {
  var node = this.startNode();
  this.next();
  this.expectContextual("as");
  node.local = this.parseIdent();
  this.checkLValSimple(node.local, BIND_LEXICAL);
  return this.finishNode(node, "ImportNamespaceSpecifier");
};
pp$8.parseImportSpecifiers = function() {
  var nodes = [], first = true;
  if (this.type === types$1.name) {
    nodes.push(this.parseImportDefaultSpecifier());
    if (!this.eat(types$1.comma)) {
      return nodes;
    }
  }
  if (this.type === types$1.star) {
    nodes.push(this.parseImportNamespaceSpecifier());
    return nodes;
  }
  this.expect(types$1.braceL);
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    nodes.push(this.parseImportSpecifier());
  }
  return nodes;
};
pp$8.parseWithClause = function() {
  var nodes = [];
  if (!this.eat(types$1._with)) {
    return nodes;
  }
  this.expect(types$1.braceL);
  var attributeKeys = {};
  var first = true;
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var attr = this.parseImportAttribute();
    var keyName = attr.key.type === "Identifier" ? attr.key.name : attr.key.value;
    if (hasOwn(attributeKeys, keyName)) {
      this.raiseRecoverable(attr.key.start, "Duplicate attribute key '" + keyName + "'");
    }
    attributeKeys[keyName] = true;
    nodes.push(attr);
  }
  return nodes;
};
pp$8.parseImportAttribute = function() {
  var node = this.startNode();
  node.key = this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
  this.expect(types$1.colon);
  if (this.type !== types$1.string) {
    this.unexpected();
  }
  node.value = this.parseExprAtom();
  return this.finishNode(node, "ImportAttribute");
};
pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var stringLiteral = this.parseLiteral(this.value);
    if (loneSurrogate.test(stringLiteral.value)) {
      this.raise(stringLiteral.start, "An export name cannot include a lone surrogate.");
    }
    return stringLiteral;
  }
  return this.parseIdent(true);
};
pp$8.adaptDirectivePrologue = function(statements) {
  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {
    statements[i].directive = statements[i].expression.raw.slice(1, -1);
  }
};
pp$8.isDirectiveCandidate = function(statement) {
  return this.options.ecmaVersion >= 5 && statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && typeof statement.expression.value === "string" && // Reject parenthesized strings.
  (this.input[statement.start] === '"' || this.input[statement.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(node, isBinding, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 6 && node) {
    switch (node.type) {
      case "Identifier":
        if (this.inAsync && node.name === "await") {
          this.raise(node.start, "Cannot use 'await' as identifier inside an async function");
        }
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        node.type = "ObjectPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        for (var i = 0, list = node.properties; i < list.length; i += 1) {
          var prop = list[i];
          this.toAssignable(prop, isBinding);
          if (prop.type === "RestElement" && (prop.argument.type === "ArrayPattern" || prop.argument.type === "ObjectPattern")) {
            this.raise(prop.argument.start, "Unexpected token");
          }
        }
        break;
      case "Property":
        if (node.kind !== "init") {
          this.raise(node.key.start, "Object pattern can't contain getter or setter");
        }
        this.toAssignable(node.value, isBinding);
        break;
      case "ArrayExpression":
        node.type = "ArrayPattern";
        if (refDestructuringErrors) {
          this.checkPatternErrors(refDestructuringErrors, true);
        }
        this.toAssignableList(node.elements, isBinding);
        break;
      case "SpreadElement":
        node.type = "RestElement";
        this.toAssignable(node.argument, isBinding);
        if (node.argument.type === "AssignmentPattern") {
          this.raise(node.argument.start, "Rest elements cannot have a default value");
        }
        break;
      case "AssignmentExpression":
        if (node.operator !== "=") {
          this.raise(node.left.end, "Only '=' operator can be used for specifying default value.");
        }
        node.type = "AssignmentPattern";
        delete node.operator;
        this.toAssignable(node.left, isBinding);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(node.expression, isBinding, refDestructuringErrors);
        break;
      case "ChainExpression":
        this.raiseRecoverable(node.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!isBinding) {
          break;
        }
      default:
        this.raise(node.start, "Assigning to rvalue");
    }
  } else if (refDestructuringErrors) {
    this.checkPatternErrors(refDestructuringErrors, true);
  }
  return node;
};
pp$7.toAssignableList = function(exprList, isBinding) {
  var end = exprList.length;
  for (var i = 0; i < end; i++) {
    var elt = exprList[i];
    if (elt) {
      this.toAssignable(elt, isBinding);
    }
  }
  if (end) {
    var last2 = exprList[end - 1];
    if (this.options.ecmaVersion === 6 && isBinding && last2 && last2.type === "RestElement" && last2.argument.type !== "Identifier") {
      this.unexpected(last2.argument.start);
    }
  }
  return exprList;
};
pp$7.parseSpread = function(refDestructuringErrors) {
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);
  return this.finishNode(node, "SpreadElement");
};
pp$7.parseRestBinding = function() {
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion === 6 && this.type !== types$1.name) {
    this.unexpected();
  }
  node.argument = this.parseBindingAtom();
  return this.finishNode(node, "RestElement");
};
pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6) {
    switch (this.type) {
      case types$1.bracketL:
        var node = this.startNode();
        this.next();
        node.elements = this.parseBindingList(types$1.bracketR, true, true);
        return this.finishNode(node, "ArrayPattern");
      case types$1.braceL:
        return this.parseObj(true);
    }
  }
  return this.parseIdent();
};
pp$7.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowModifiers) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (first) {
      first = false;
    } else {
      this.expect(types$1.comma);
    }
    if (allowEmpty && this.type === types$1.comma) {
      elts.push(null);
    } else if (allowTrailingComma && this.afterTrailingComma(close)) {
      break;
    } else if (this.type === types$1.ellipsis) {
      var rest = this.parseRestBinding();
      this.parseBindingListItem(rest);
      elts.push(rest);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      this.expect(close);
      break;
    } else {
      elts.push(this.parseAssignableListItem(allowModifiers));
    }
  }
  return elts;
};
pp$7.parseAssignableListItem = function(allowModifiers) {
  var elem = this.parseMaybeDefault(this.start, this.startLoc);
  this.parseBindingListItem(elem);
  return elem;
};
pp$7.parseBindingListItem = function(param) {
  return param;
};
pp$7.parseMaybeDefault = function(startPos, startLoc, left) {
  left = left || this.parseBindingAtom();
  if (this.options.ecmaVersion < 6 || !this.eat(types$1.eq)) {
    return left;
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.right = this.parseMaybeAssign();
  return this.finishNode(node, "AssignmentPattern");
};
pp$7.checkLValSimple = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  var isBind = bindingType !== BIND_NONE;
  switch (expr.type) {
    case "Identifier":
      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {
        this.raiseRecoverable(expr.start, (isBind ? "Binding " : "Assigning to ") + expr.name + " in strict mode");
      }
      if (isBind) {
        if (bindingType === BIND_LEXICAL && expr.name === "let") {
          this.raiseRecoverable(expr.start, "let is disallowed as a lexically bound name");
        }
        if (checkClashes) {
          if (hasOwn(checkClashes, expr.name)) {
            this.raiseRecoverable(expr.start, "Argument name clash");
          }
          checkClashes[expr.name] = true;
        }
        if (bindingType !== BIND_OUTSIDE) {
          this.declareName(expr.name, bindingType, expr.start);
        }
      }
      break;
    case "ChainExpression":
      this.raiseRecoverable(expr.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding member expression");
      }
      break;
    case "ParenthesizedExpression":
      if (isBind) {
        this.raiseRecoverable(expr.start, "Binding parenthesized expression");
      }
      return this.checkLValSimple(expr.expression, bindingType, checkClashes);
    default:
      this.raise(expr.start, (isBind ? "Binding" : "Assigning to") + " rvalue");
  }
};
pp$7.checkLValPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  switch (expr.type) {
    case "ObjectPattern":
      for (var i = 0, list = expr.properties; i < list.length; i += 1) {
        var prop = list[i];
        this.checkLValInnerPattern(prop, bindingType, checkClashes);
      }
      break;
    case "ArrayPattern":
      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {
        var elem = list$1[i$1];
        if (elem) {
          this.checkLValInnerPattern(elem, bindingType, checkClashes);
        }
      }
      break;
    default:
      this.checkLValSimple(expr, bindingType, checkClashes);
  }
};
pp$7.checkLValInnerPattern = function(expr, bindingType, checkClashes) {
  if (bindingType === void 0) bindingType = BIND_NONE;
  switch (expr.type) {
    case "Property":
      this.checkLValInnerPattern(expr.value, bindingType, checkClashes);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(expr.left, bindingType, checkClashes);
      break;
    case "RestElement":
      this.checkLValPattern(expr.argument, bindingType, checkClashes);
      break;
    default:
      this.checkLValPattern(expr, bindingType, checkClashes);
  }
};
var TokContext = function TokContext2(token, isExpr, preserveSpace, override, generator) {
  this.token = token;
  this.isExpr = !!isExpr;
  this.preserveSpace = !!preserveSpace;
  this.override = override;
  this.generator = !!generator;
};
var types = {
  b_stat: new TokContext("{", false),
  b_expr: new TokContext("{", true),
  b_tmpl: new TokContext("${", false),
  p_stat: new TokContext("(", false),
  p_expr: new TokContext("(", true),
  q_tmpl: new TokContext("`", true, true, function(p2) {
    return p2.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", false),
  f_expr: new TokContext("function", true),
  f_expr_gen: new TokContext("function", true, false, null, true),
  f_gen: new TokContext("function", false, false, null, true)
};
var pp$6 = Parser.prototype;
pp$6.initialContext = function() {
  return [types.b_stat];
};
pp$6.curContext = function() {
  return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(prevType) {
  var parent = this.curContext();
  if (parent === types.f_expr || parent === types.f_stat) {
    return true;
  }
  if (prevType === types$1.colon && (parent === types.b_stat || parent === types.b_expr)) {
    return !parent.isExpr;
  }
  if (prevType === types$1._return || prevType === types$1.name && this.exprAllowed) {
    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
  }
  if (prevType === types$1._else || prevType === types$1.semi || prevType === types$1.eof || prevType === types$1.parenR || prevType === types$1.arrow) {
    return true;
  }
  if (prevType === types$1.braceL) {
    return parent === types.b_stat;
  }
  if (prevType === types$1._var || prevType === types$1._const || prevType === types$1.name) {
    return false;
  }
  return !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
  for (var i = this.context.length - 1; i >= 1; i--) {
    var context = this.context[i];
    if (context.token === "function") {
      return context.generator;
    }
  }
  return false;
};
pp$6.updateContext = function(prevType) {
  var update, type3 = this.type;
  if (type3.keyword && prevType === types$1.dot) {
    this.exprAllowed = false;
  } else if (update = type3.updateContext) {
    update.call(this, prevType);
  } else {
    this.exprAllowed = type3.beforeExpr;
  }
};
pp$6.overrideContext = function(tokenCtx) {
  if (this.curContext() !== tokenCtx) {
    this.context[this.context.length - 1] = tokenCtx;
  }
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = true;
    return;
  }
  var out = this.context.pop();
  if (out === types.b_stat && this.curContext().token === "function") {
    out = this.context.pop();
  }
  this.exprAllowed = !out.isExpr;
};
types$1.braceL.updateContext = function(prevType) {
  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr);
  this.exprAllowed = true;
};
types$1.dollarBraceL.updateContext = function() {
  this.context.push(types.b_tmpl);
  this.exprAllowed = true;
};
types$1.parenL.updateContext = function(prevType) {
  var statementParens = prevType === types$1._if || prevType === types$1._for || prevType === types$1._with || prevType === types$1._while;
  this.context.push(statementParens ? types.p_stat : types.p_expr);
  this.exprAllowed = true;
};
types$1.incDec.updateContext = function() {
};
types$1._function.updateContext = types$1._class.updateContext = function(prevType) {
  if (prevType.beforeExpr && prevType !== types$1._else && !(prevType === types$1.semi && this.curContext() !== types.p_stat) && !(prevType === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((prevType === types$1.colon || prevType === types$1.braceL) && this.curContext() === types.b_stat)) {
    this.context.push(types.f_expr);
  } else {
    this.context.push(types.f_stat);
  }
  this.exprAllowed = false;
};
types$1.colon.updateContext = function() {
  if (this.curContext().token === "function") {
    this.context.pop();
  }
  this.exprAllowed = true;
};
types$1.backQuote.updateContext = function() {
  if (this.curContext() === types.q_tmpl) {
    this.context.pop();
  } else {
    this.context.push(types.q_tmpl);
  }
  this.exprAllowed = false;
};
types$1.star.updateContext = function(prevType) {
  if (prevType === types$1._function) {
    var index = this.context.length - 1;
    if (this.context[index] === types.f_expr) {
      this.context[index] = types.f_expr_gen;
    } else {
      this.context[index] = types.f_gen;
    }
  }
  this.exprAllowed = true;
};
types$1.name.updateContext = function(prevType) {
  var allowed = false;
  if (this.options.ecmaVersion >= 6 && prevType !== types$1.dot) {
    if (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) {
      allowed = true;
    }
  }
  this.exprAllowed = allowed;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(prop, propHash, refDestructuringErrors) {
  if (this.options.ecmaVersion >= 9 && prop.type === "SpreadElement") {
    return;
  }
  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {
    return;
  }
  var key = prop.key;
  var name;
  switch (key.type) {
    case "Identifier":
      name = key.name;
      break;
    case "Literal":
      name = String(key.value);
      break;
    default:
      return;
  }
  var kind = prop.kind;
  if (this.options.ecmaVersion >= 6) {
    if (name === "__proto__" && kind === "init") {
      if (propHash.proto) {
        if (refDestructuringErrors) {
          if (refDestructuringErrors.doubleProto < 0) {
            refDestructuringErrors.doubleProto = key.start;
          }
        } else {
          this.raiseRecoverable(key.start, "Redefinition of __proto__ property");
        }
      }
      propHash.proto = true;
    }
    return;
  }
  name = "$" + name;
  var other = propHash[name];
  if (other) {
    var redefinition;
    if (kind === "init") {
      redefinition = this.strict && other.init || other.get || other.set;
    } else {
      redefinition = other.init || other[kind];
    }
    if (redefinition) {
      this.raiseRecoverable(key.start, "Redefinition of property");
    }
  } else {
    other = propHash[name] = {
      init: false,
      get: false,
      set: false
    };
  }
  other[kind] = true;
};
pp$5.parseExpression = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeAssign(forInit, refDestructuringErrors);
  if (this.type === types$1.comma) {
    var node = this.startNodeAt(startPos, startLoc);
    node.expressions = [expr];
    while (this.eat(types$1.comma)) {
      node.expressions.push(this.parseMaybeAssign(forInit, refDestructuringErrors));
    }
    return this.finishNode(node, "SequenceExpression");
  }
  return expr;
};
pp$5.parseMaybeAssign = function(forInit, refDestructuringErrors, afterLeftParse) {
  if (this.isContextual("yield")) {
    if (this.inGenerator) {
      return this.parseYield(forInit);
    } else {
      this.exprAllowed = false;
    }
  }
  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldDoubleProto = -1;
  if (refDestructuringErrors) {
    oldParenAssign = refDestructuringErrors.parenthesizedAssign;
    oldTrailingComma = refDestructuringErrors.trailingComma;
    oldDoubleProto = refDestructuringErrors.doubleProto;
    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;
  } else {
    refDestructuringErrors = new DestructuringErrors();
    ownDestructuringErrors = true;
  }
  var startPos = this.start, startLoc = this.startLoc;
  if (this.type === types$1.parenL || this.type === types$1.name) {
    this.potentialArrowAt = this.start;
    this.potentialArrowInForAwait = forInit === "await";
  }
  var left = this.parseMaybeConditional(forInit, refDestructuringErrors);
  if (afterLeftParse) {
    left = afterLeftParse.call(this, left, startPos, startLoc);
  }
  if (this.type.isAssign) {
    var node = this.startNodeAt(startPos, startLoc);
    node.operator = this.value;
    if (this.type === types$1.eq) {
      left = this.toAssignable(left, false, refDestructuringErrors);
    }
    if (!ownDestructuringErrors) {
      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.doubleProto = -1;
    }
    if (refDestructuringErrors.shorthandAssign >= left.start) {
      refDestructuringErrors.shorthandAssign = -1;
    }
    if (this.type === types$1.eq) {
      this.checkLValPattern(left);
    } else {
      this.checkLValSimple(left);
    }
    node.left = left;
    this.next();
    node.right = this.parseMaybeAssign(forInit);
    if (oldDoubleProto > -1) {
      refDestructuringErrors.doubleProto = oldDoubleProto;
    }
    return this.finishNode(node, "AssignmentExpression");
  } else {
    if (ownDestructuringErrors) {
      this.checkExpressionErrors(refDestructuringErrors, true);
    }
  }
  if (oldParenAssign > -1) {
    refDestructuringErrors.parenthesizedAssign = oldParenAssign;
  }
  if (oldTrailingComma > -1) {
    refDestructuringErrors.trailingComma = oldTrailingComma;
  }
  return left;
};
pp$5.parseMaybeConditional = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprOps(forInit, refDestructuringErrors);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  if (this.eat(types$1.question)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.test = expr;
    node.consequent = this.parseMaybeAssign();
    this.expect(types$1.colon);
    node.alternate = this.parseMaybeAssign(forInit);
    return this.finishNode(node, "ConditionalExpression");
  }
  return expr;
};
pp$5.parseExprOps = function(forInit, refDestructuringErrors) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseMaybeUnary(refDestructuringErrors, false, false, forInit);
  if (this.checkExpressionErrors(refDestructuringErrors)) {
    return expr;
  }
  return expr.start === startPos && expr.type === "ArrowFunctionExpression" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, forInit);
};
pp$5.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, forInit) {
  var prec = this.type.binop;
  if (prec != null && (!forInit || this.type !== types$1._in)) {
    if (prec > minPrec) {
      var logical = this.type === types$1.logicalOR || this.type === types$1.logicalAND;
      var coalesce = this.type === types$1.coalesce;
      if (coalesce) {
        prec = types$1.logicalAND.binop;
      }
      var op = this.value;
      this.next();
      var startPos = this.start, startLoc = this.startLoc;
      var right = this.parseExprOp(this.parseMaybeUnary(null, false, false, forInit), startPos, startLoc, prec, forInit);
      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical || coalesce);
      if (logical && this.type === types$1.coalesce || coalesce && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) {
        this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses");
      }
      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, forInit);
    }
  }
  return left;
};
pp$5.buildBinary = function(startPos, startLoc, left, right, op, logical) {
  if (right.type === "PrivateIdentifier") {
    this.raise(right.start, "Private identifier can only be left side of binary expression");
  }
  var node = this.startNodeAt(startPos, startLoc);
  node.left = left;
  node.operator = op;
  node.right = right;
  return this.finishNode(node, logical ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(refDestructuringErrors, sawUnary, incDec, forInit) {
  var startPos = this.start, startLoc = this.startLoc, expr;
  if (this.isContextual("await") && this.canAwait) {
    expr = this.parseAwait(forInit);
    sawUnary = true;
  } else if (this.type.prefix) {
    var node = this.startNode(), update = this.type === types$1.incDec;
    node.operator = this.value;
    node.prefix = true;
    this.next();
    node.argument = this.parseMaybeUnary(null, true, update, forInit);
    this.checkExpressionErrors(refDestructuringErrors, true);
    if (update) {
      this.checkLValSimple(node.argument);
    } else if (this.strict && node.operator === "delete" && isLocalVariableAccess(node.argument)) {
      this.raiseRecoverable(node.start, "Deleting local variable in strict mode");
    } else if (node.operator === "delete" && isPrivateFieldAccess(node.argument)) {
      this.raiseRecoverable(node.start, "Private fields can not be deleted");
    } else {
      sawUnary = true;
    }
    expr = this.finishNode(node, update ? "UpdateExpression" : "UnaryExpression");
  } else if (!sawUnary && this.type === types$1.privateId) {
    if ((forInit || this.privateNameStack.length === 0) && this.options.checkPrivateFields) {
      this.unexpected();
    }
    expr = this.parsePrivateIdent();
    if (this.type !== types$1._in) {
      this.unexpected();
    }
  } else {
    expr = this.parseExprSubscripts(refDestructuringErrors, forInit);
    if (this.checkExpressionErrors(refDestructuringErrors)) {
      return expr;
    }
    while (this.type.postfix && !this.canInsertSemicolon()) {
      var node$1 = this.startNodeAt(startPos, startLoc);
      node$1.operator = this.value;
      node$1.prefix = false;
      node$1.argument = expr;
      this.checkLValSimple(expr);
      this.next();
      expr = this.finishNode(node$1, "UpdateExpression");
    }
  }
  if (!incDec && this.eat(types$1.starstar)) {
    if (sawUnary) {
      this.unexpected(this.lastTokStart);
    } else {
      return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false, false, forInit), "**", false);
    }
  } else {
    return expr;
  }
};
function isLocalVariableAccess(node) {
  return node.type === "Identifier" || node.type === "ParenthesizedExpression" && isLocalVariableAccess(node.expression);
}
function isPrivateFieldAccess(node) {
  return node.type === "MemberExpression" && node.property.type === "PrivateIdentifier" || node.type === "ChainExpression" && isPrivateFieldAccess(node.expression) || node.type === "ParenthesizedExpression" && isPrivateFieldAccess(node.expression);
}
pp$5.parseExprSubscripts = function(refDestructuringErrors, forInit) {
  var startPos = this.start, startLoc = this.startLoc;
  var expr = this.parseExprAtom(refDestructuringErrors, forInit);
  if (expr.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")") {
    return expr;
  }
  var result = this.parseSubscripts(expr, startPos, startLoc, false, forInit);
  if (refDestructuringErrors && result.type === "MemberExpression") {
    if (refDestructuringErrors.parenthesizedAssign >= result.start) {
      refDestructuringErrors.parenthesizedAssign = -1;
    }
    if (refDestructuringErrors.parenthesizedBind >= result.start) {
      refDestructuringErrors.parenthesizedBind = -1;
    }
    if (refDestructuringErrors.trailingComma >= result.start) {
      refDestructuringErrors.trailingComma = -1;
    }
  }
  return result;
};
pp$5.parseSubscripts = function(base2, startPos, startLoc, noCalls, forInit) {
  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base2.type === "Identifier" && base2.name === "async" && this.lastTokEnd === base2.end && !this.canInsertSemicolon() && base2.end - base2.start === 5 && this.potentialArrowAt === base2.start;
  var optionalChained = false;
  while (true) {
    var element2 = this.parseSubscript(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit);
    if (element2.optional) {
      optionalChained = true;
    }
    if (element2 === base2 || element2.type === "ArrowFunctionExpression") {
      if (optionalChained) {
        var chainNode = this.startNodeAt(startPos, startLoc);
        chainNode.expression = element2;
        element2 = this.finishNode(chainNode, "ChainExpression");
      }
      return element2;
    }
    base2 = element2;
  }
};
pp$5.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(types$1.arrow);
};
pp$5.parseSubscriptAsyncArrow = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true, forInit);
};
pp$5.parseSubscript = function(base2, startPos, startLoc, noCalls, maybeAsyncArrow, optionalChained, forInit) {
  var optionalSupported = this.options.ecmaVersion >= 11;
  var optional2 = optionalSupported && this.eat(types$1.questionDot);
  if (noCalls && optional2) {
    this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  }
  var computed = this.eat(types$1.bracketL);
  if (computed || optional2 && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
    var node = this.startNodeAt(startPos, startLoc);
    node.object = base2;
    if (computed) {
      node.property = this.parseExpression();
      this.expect(types$1.bracketR);
    } else if (this.type === types$1.privateId && base2.type !== "Super") {
      node.property = this.parsePrivateIdent();
    } else {
      node.property = this.parseIdent(this.options.allowReserved !== "never");
    }
    node.computed = !!computed;
    if (optionalSupported) {
      node.optional = optional2;
    }
    base2 = this.finishNode(node, "MemberExpression");
  } else if (!noCalls && this.eat(types$1.parenL)) {
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
    this.yieldPos = 0;
    this.awaitPos = 0;
    this.awaitIdentPos = 0;
    var exprList = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);
    if (maybeAsyncArrow && !optional2 && this.shouldParseAsyncArrow()) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      if (this.awaitIdentPos > 0) {
        this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function");
      }
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      this.awaitIdentPos = oldAwaitIdentPos;
      return this.parseSubscriptAsyncArrow(startPos, startLoc, exprList, forInit);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;
    var node$1 = this.startNodeAt(startPos, startLoc);
    node$1.callee = base2;
    node$1.arguments = exprList;
    if (optionalSupported) {
      node$1.optional = optional2;
    }
    base2 = this.finishNode(node$1, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    if (optional2 || optionalChained) {
      this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    }
    var node$2 = this.startNodeAt(startPos, startLoc);
    node$2.tag = base2;
    node$2.quasi = this.parseTemplate({ isTagged: true });
    base2 = this.finishNode(node$2, "TaggedTemplateExpression");
  }
  return base2;
};
pp$5.parseExprAtom = function(refDestructuringErrors, forInit, forNew) {
  if (this.type === types$1.slash) {
    this.readRegexp();
  }
  var node, canBeArrow = this.potentialArrowAt === this.start;
  switch (this.type) {
    case types$1._super:
      if (!this.allowSuper) {
        this.raise(this.start, "'super' keyword outside a method");
      }
      node = this.startNode();
      this.next();
      if (this.type === types$1.parenL && !this.allowDirectSuper) {
        this.raise(node.start, "super() call outside constructor of a subclass");
      }
      if (this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL) {
        this.unexpected();
      }
      return this.finishNode(node, "Super");
    case types$1._this:
      node = this.startNode();
      this.next();
      return this.finishNode(node, "ThisExpression");
    case types$1.name:
      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;
      var id = this.parseIdent(false);
      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function)) {
        this.overrideContext(types.f_expr);
        return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true, forInit);
      }
      if (canBeArrow && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow)) {
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false, forInit);
        }
        if (this.options.ecmaVersion >= 8 && id.name === "async" && this.type === types$1.name && !containsEsc && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc)) {
          id = this.parseIdent(false);
          if (this.canInsertSemicolon() || !this.eat(types$1.arrow)) {
            this.unexpected();
          }
          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true, forInit);
        }
      }
      return id;
    case types$1.regexp:
      var value = this.value;
      node = this.parseLiteral(value.value);
      node.regex = { pattern: value.pattern, flags: value.flags };
      return node;
    case types$1.num:
    case types$1.string:
      return this.parseLiteral(this.value);
    case types$1._null:
    case types$1._true:
    case types$1._false:
      node = this.startNode();
      node.value = this.type === types$1._null ? null : this.type === types$1._true;
      node.raw = this.type.keyword;
      this.next();
      return this.finishNode(node, "Literal");
    case types$1.parenL:
      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow, forInit);
      if (refDestructuringErrors) {
        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {
          refDestructuringErrors.parenthesizedAssign = start;
        }
        if (refDestructuringErrors.parenthesizedBind < 0) {
          refDestructuringErrors.parenthesizedBind = start;
        }
      }
      return expr;
    case types$1.bracketL:
      node = this.startNode();
      this.next();
      node.elements = this.parseExprList(types$1.bracketR, true, true, refDestructuringErrors);
      return this.finishNode(node, "ArrayExpression");
    case types$1.braceL:
      this.overrideContext(types.b_expr);
      return this.parseObj(false, refDestructuringErrors);
    case types$1._function:
      node = this.startNode();
      this.next();
      return this.parseFunction(node, 0);
    case types$1._class:
      return this.parseClass(this.startNode(), false);
    case types$1._new:
      return this.parseNew();
    case types$1.backQuote:
      return this.parseTemplate();
    case types$1._import:
      if (this.options.ecmaVersion >= 11) {
        return this.parseExprImport(forNew);
      } else {
        return this.unexpected();
      }
    default:
      return this.parseExprAtomDefault();
  }
};
pp$5.parseExprAtomDefault = function() {
  this.unexpected();
};
pp$5.parseExprImport = function(forNew) {
  var node = this.startNode();
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword import");
  }
  this.next();
  if (this.type === types$1.parenL && !forNew) {
    return this.parseDynamicImport(node);
  } else if (this.type === types$1.dot) {
    var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
    meta.name = "import";
    node.meta = this.finishNode(meta, "Identifier");
    return this.parseImportMeta(node);
  } else {
    this.unexpected();
  }
};
pp$5.parseDynamicImport = function(node) {
  this.next();
  node.source = this.parseMaybeAssign();
  if (this.options.ecmaVersion >= 16) {
    if (!this.eat(types$1.parenR)) {
      this.expect(types$1.comma);
      if (!this.afterTrailingComma(types$1.parenR)) {
        node.options = this.parseMaybeAssign();
        if (!this.eat(types$1.parenR)) {
          this.expect(types$1.comma);
          if (!this.afterTrailingComma(types$1.parenR)) {
            this.unexpected();
          }
        }
      } else {
        node.options = null;
      }
    } else {
      node.options = null;
    }
  } else {
    if (!this.eat(types$1.parenR)) {
      var errorPos = this.start;
      if (this.eat(types$1.comma) && this.eat(types$1.parenR)) {
        this.raiseRecoverable(errorPos, "Trailing comma is not allowed in import()");
      } else {
        this.unexpected(errorPos);
      }
    }
  }
  return this.finishNode(node, "ImportExpression");
};
pp$5.parseImportMeta = function(node) {
  this.next();
  var containsEsc = this.containsEsc;
  node.property = this.parseIdent(true);
  if (node.property.name !== "meta") {
    this.raiseRecoverable(node.property.start, "The only valid meta property for import is 'import.meta'");
  }
  if (containsEsc) {
    this.raiseRecoverable(node.start, "'import.meta' must not contain escaped characters");
  }
  if (this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere) {
    this.raiseRecoverable(node.start, "Cannot use 'import.meta' outside a module");
  }
  return this.finishNode(node, "MetaProperty");
};
pp$5.parseLiteral = function(value) {
  var node = this.startNode();
  node.value = value;
  node.raw = this.input.slice(this.start, this.end);
  if (node.raw.charCodeAt(node.raw.length - 1) === 110) {
    node.bigint = node.value != null ? node.value.toString() : node.raw.slice(0, -1).replace(/_/g, "");
  }
  this.next();
  return this.finishNode(node, "Literal");
};
pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var val2 = this.parseExpression();
  this.expect(types$1.parenR);
  return val2;
};
pp$5.shouldParseArrow = function(exprList) {
  return !this.canInsertSemicolon();
};
pp$5.parseParenAndDistinguishExpression = function(canBeArrow, forInit) {
  var startPos = this.start, startLoc = this.startLoc, val2, allowTrailingComma = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var innerStartPos = this.start, innerStartLoc = this.startLoc;
    var exprList = [], first = true, lastIsComma = false;
    var refDestructuringErrors = new DestructuringErrors(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;
    this.yieldPos = 0;
    this.awaitPos = 0;
    while (this.type !== types$1.parenR) {
      first ? first = false : this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(types$1.parenR, true)) {
        lastIsComma = true;
        break;
      } else if (this.type === types$1.ellipsis) {
        spreadStart = this.start;
        exprList.push(this.parseParenItem(this.parseRestBinding()));
        if (this.type === types$1.comma) {
          this.raiseRecoverable(
            this.start,
            "Comma is not permitted after the rest element"
          );
        }
        break;
      } else {
        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));
      }
    }
    var innerEndPos = this.lastTokEnd, innerEndLoc = this.lastTokEndLoc;
    this.expect(types$1.parenR);
    if (canBeArrow && this.shouldParseArrow(exprList) && this.eat(types$1.arrow)) {
      this.checkPatternErrors(refDestructuringErrors, false);
      this.checkYieldAwaitInDefaultParams();
      this.yieldPos = oldYieldPos;
      this.awaitPos = oldAwaitPos;
      return this.parseParenArrowList(startPos, startLoc, exprList, forInit);
    }
    if (!exprList.length || lastIsComma) {
      this.unexpected(this.lastTokStart);
    }
    if (spreadStart) {
      this.unexpected(spreadStart);
    }
    this.checkExpressionErrors(refDestructuringErrors, true);
    this.yieldPos = oldYieldPos || this.yieldPos;
    this.awaitPos = oldAwaitPos || this.awaitPos;
    if (exprList.length > 1) {
      val2 = this.startNodeAt(innerStartPos, innerStartLoc);
      val2.expressions = exprList;
      this.finishNodeAt(val2, "SequenceExpression", innerEndPos, innerEndLoc);
    } else {
      val2 = exprList[0];
    }
  } else {
    val2 = this.parseParenExpression();
  }
  if (this.options.preserveParens) {
    var par = this.startNodeAt(startPos, startLoc);
    par.expression = val2;
    return this.finishNode(par, "ParenthesizedExpression");
  } else {
    return val2;
  }
};
pp$5.parseParenItem = function(item) {
  return item;
};
pp$5.parseParenArrowList = function(startPos, startLoc, exprList, forInit) {
  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, false, forInit);
};
var empty = [];
pp$5.parseNew = function() {
  if (this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  }
  var node = this.startNode();
  this.next();
  if (this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
    var meta = this.startNodeAt(node.start, node.loc && node.loc.start);
    meta.name = "new";
    node.meta = this.finishNode(meta, "Identifier");
    this.next();
    var containsEsc = this.containsEsc;
    node.property = this.parseIdent(true);
    if (node.property.name !== "target") {
      this.raiseRecoverable(node.property.start, "The only valid meta property for new is 'new.target'");
    }
    if (containsEsc) {
      this.raiseRecoverable(node.start, "'new.target' must not contain escaped characters");
    }
    if (!this.allowNewDotTarget) {
      this.raiseRecoverable(node.start, "'new.target' can only be used in functions and class static block");
    }
    return this.finishNode(node, "MetaProperty");
  }
  var startPos = this.start, startLoc = this.startLoc;
  node.callee = this.parseSubscripts(this.parseExprAtom(null, false, true), startPos, startLoc, true, false);
  if (this.eat(types$1.parenL)) {
    node.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, false);
  } else {
    node.arguments = empty;
  }
  return this.finishNode(node, "NewExpression");
};
pp$5.parseTemplateElement = function(ref2) {
  var isTagged = ref2.isTagged;
  var elem = this.startNode();
  if (this.type === types$1.invalidTemplate) {
    if (!isTagged) {
      this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal");
    }
    elem.value = {
      raw: this.value.replace(/\r\n?/g, "\n"),
      cooked: null
    };
  } else {
    elem.value = {
      raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, "\n"),
      cooked: this.value
    };
  }
  this.next();
  elem.tail = this.type === types$1.backQuote;
  return this.finishNode(elem, "TemplateElement");
};
pp$5.parseTemplate = function(ref2) {
  if (ref2 === void 0) ref2 = {};
  var isTagged = ref2.isTagged;
  if (isTagged === void 0) isTagged = false;
  var node = this.startNode();
  this.next();
  node.expressions = [];
  var curElt = this.parseTemplateElement({ isTagged });
  node.quasis = [curElt];
  while (!curElt.tail) {
    if (this.type === types$1.eof) {
      this.raise(this.pos, "Unterminated template literal");
    }
    this.expect(types$1.dollarBraceL);
    node.expressions.push(this.parseExpression());
    this.expect(types$1.braceR);
    node.quasis.push(curElt = this.parseTemplateElement({ isTagged }));
  }
  this.next();
  return this.finishNode(node, "TemplateLiteral");
};
pp$5.isAsyncProp = function(prop) {
  return !prop.computed && prop.key.type === "Identifier" && prop.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(isPattern, refDestructuringErrors) {
  var node = this.startNode(), first = true, propHash = {};
  node.properties = [];
  this.next();
  while (!this.eat(types$1.braceR)) {
    if (!first) {
      this.expect(types$1.comma);
      if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR)) {
        break;
      }
    } else {
      first = false;
    }
    var prop = this.parseProperty(isPattern, refDestructuringErrors);
    if (!isPattern) {
      this.checkPropClash(prop, propHash, refDestructuringErrors);
    }
    node.properties.push(prop);
  }
  return this.finishNode(node, isPattern ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(isPattern, refDestructuringErrors) {
  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis)) {
    if (isPattern) {
      prop.argument = this.parseIdent(false);
      if (this.type === types$1.comma) {
        this.raiseRecoverable(this.start, "Comma is not permitted after the rest element");
      }
      return this.finishNode(prop, "RestElement");
    }
    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);
    if (this.type === types$1.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {
      refDestructuringErrors.trailingComma = this.start;
    }
    return this.finishNode(prop, "SpreadElement");
  }
  if (this.options.ecmaVersion >= 6) {
    prop.method = false;
    prop.shorthand = false;
    if (isPattern || refDestructuringErrors) {
      startPos = this.start;
      startLoc = this.startLoc;
    }
    if (!isPattern) {
      isGenerator = this.eat(types$1.star);
    }
  }
  var containsEsc = this.containsEsc;
  this.parsePropertyName(prop);
  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {
    isAsync = true;
    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types$1.star);
    this.parsePropertyName(prop);
  } else {
    isAsync = false;
  }
  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);
  return this.finishNode(prop, "Property");
};
pp$5.parseGetterSetter = function(prop) {
  var kind = prop.key.name;
  this.parsePropertyName(prop);
  prop.value = this.parseMethod(false);
  prop.kind = kind;
  var paramCount = prop.kind === "get" ? 0 : 1;
  if (prop.value.params.length !== paramCount) {
    var start = prop.value.start;
    if (prop.kind === "get") {
      this.raiseRecoverable(start, "getter should have no params");
    } else {
      this.raiseRecoverable(start, "setter should have exactly one param");
    }
  } else {
    if (prop.kind === "set" && prop.value.params[0].type === "RestElement") {
      this.raiseRecoverable(prop.value.params[0].start, "Setter cannot use rest params");
    }
  }
};
pp$5.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {
  if ((isGenerator || isAsync) && this.type === types$1.colon) {
    this.unexpected();
  }
  if (this.eat(types$1.colon)) {
    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);
    prop.kind = "init";
  } else if (this.options.ecmaVersion >= 6 && this.type === types$1.parenL) {
    if (isPattern) {
      this.unexpected();
    }
    prop.method = true;
    prop.value = this.parseMethod(isGenerator, isAsync);
    prop.kind = "init";
  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === "Identifier" && (prop.key.name === "get" || prop.key.name === "set") && (this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq)) {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.parseGetterSetter(prop);
  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === "Identifier") {
    if (isGenerator || isAsync) {
      this.unexpected();
    }
    this.checkUnreserved(prop.key);
    if (prop.key.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = startPos;
    }
    if (isPattern) {
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else if (this.type === types$1.eq && refDestructuringErrors) {
      if (refDestructuringErrors.shorthandAssign < 0) {
        refDestructuringErrors.shorthandAssign = this.start;
      }
      prop.value = this.parseMaybeDefault(startPos, startLoc, this.copyNode(prop.key));
    } else {
      prop.value = this.copyNode(prop.key);
    }
    prop.kind = "init";
    prop.shorthand = true;
  } else {
    this.unexpected();
  }
};
pp$5.parsePropertyName = function(prop) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL)) {
      prop.computed = true;
      prop.key = this.parseMaybeAssign();
      this.expect(types$1.bracketR);
      return prop.key;
    } else {
      prop.computed = false;
    }
  }
  return prop.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(node) {
  node.id = null;
  if (this.options.ecmaVersion >= 6) {
    node.generator = node.expression = false;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = false;
  }
};
pp$5.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {
  var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.initFunction(node);
  if (this.options.ecmaVersion >= 6) {
    node.generator = isGenerator;
  }
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));
  this.expect(types$1.parenL);
  node.params = this.parseBindingList(types$1.parenR, false, this.options.ecmaVersion >= 8);
  this.checkYieldAwaitInDefaultParams();
  this.parseFunctionBody(node, false, true, false);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "FunctionExpression");
};
pp$5.parseArrowExpression = function(node, params, isAsync, forInit) {
  var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;
  this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);
  this.initFunction(node);
  if (this.options.ecmaVersion >= 8) {
    node.async = !!isAsync;
  }
  this.yieldPos = 0;
  this.awaitPos = 0;
  this.awaitIdentPos = 0;
  node.params = this.toAssignableList(params, true);
  this.parseFunctionBody(node, true, false, forInit);
  this.yieldPos = oldYieldPos;
  this.awaitPos = oldAwaitPos;
  this.awaitIdentPos = oldAwaitIdentPos;
  return this.finishNode(node, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(node, isArrowFunction, isMethod, forInit) {
  var isExpression = isArrowFunction && this.type !== types$1.braceL;
  var oldStrict = this.strict, useStrict = false;
  if (isExpression) {
    node.body = this.parseMaybeAssign(forInit);
    node.expression = true;
    this.checkParams(node, false);
  } else {
    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);
    if (!oldStrict || nonSimple) {
      useStrict = this.strictDirective(this.end);
      if (useStrict && nonSimple) {
        this.raiseRecoverable(node.start, "Illegal 'use strict' directive in function with non-simple parameter list");
      }
    }
    var oldLabels = this.labels;
    this.labels = [];
    if (useStrict) {
      this.strict = true;
    }
    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));
    if (this.strict && node.id) {
      this.checkLValSimple(node.id, BIND_OUTSIDE);
    }
    node.body = this.parseBlock(false, void 0, useStrict && !oldStrict);
    node.expression = false;
    this.adaptDirectivePrologue(node.body.body);
    this.labels = oldLabels;
  }
  this.exitScope();
};
pp$5.isSimpleParamList = function(params) {
  for (var i = 0, list = params; i < list.length; i += 1) {
    var param = list[i];
    if (param.type !== "Identifier") {
      return false;
    }
  }
  return true;
};
pp$5.checkParams = function(node, allowDuplicates) {
  var nameHash = /* @__PURE__ */ Object.create(null);
  for (var i = 0, list = node.params; i < list.length; i += 1) {
    var param = list[i];
    this.checkLValInnerPattern(param, BIND_VAR, allowDuplicates ? null : nameHash);
  }
};
pp$5.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {
  var elts = [], first = true;
  while (!this.eat(close)) {
    if (!first) {
      this.expect(types$1.comma);
      if (allowTrailingComma && this.afterTrailingComma(close)) {
        break;
      }
    } else {
      first = false;
    }
    var elt = void 0;
    if (allowEmpty && this.type === types$1.comma) {
      elt = null;
    } else if (this.type === types$1.ellipsis) {
      elt = this.parseSpread(refDestructuringErrors);
      if (refDestructuringErrors && this.type === types$1.comma && refDestructuringErrors.trailingComma < 0) {
        refDestructuringErrors.trailingComma = this.start;
      }
    } else {
      elt = this.parseMaybeAssign(false, refDestructuringErrors);
    }
    elts.push(elt);
  }
  return elts;
};
pp$5.checkUnreserved = function(ref2) {
  var start = ref2.start;
  var end = ref2.end;
  var name = ref2.name;
  if (this.inGenerator && name === "yield") {
    this.raiseRecoverable(start, "Cannot use 'yield' as identifier inside a generator");
  }
  if (this.inAsync && name === "await") {
    this.raiseRecoverable(start, "Cannot use 'await' as identifier inside an async function");
  }
  if (!(this.currentThisScope().flags & SCOPE_VAR) && name === "arguments") {
    this.raiseRecoverable(start, "Cannot use 'arguments' in class field initializer");
  }
  if (this.inClassStaticBlock && (name === "arguments" || name === "await")) {
    this.raise(start, "Cannot use " + name + " in class static initialization block");
  }
  if (this.keywords.test(name)) {
    this.raise(start, "Unexpected keyword '" + name + "'");
  }
  if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf("\\") !== -1) {
    return;
  }
  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;
  if (re.test(name)) {
    if (!this.inAsync && name === "await") {
      this.raiseRecoverable(start, "Cannot use keyword 'await' outside an async function");
    }
    this.raiseRecoverable(start, "The keyword '" + name + "' is reserved");
  }
};
pp$5.parseIdent = function(liberal) {
  var node = this.parseIdentNode();
  this.next(!!liberal);
  this.finishNode(node, "Identifier");
  if (!liberal) {
    this.checkUnreserved(node);
    if (node.name === "await" && !this.awaitIdentPos) {
      this.awaitIdentPos = node.start;
    }
  }
  return node;
};
pp$5.parseIdentNode = function() {
  var node = this.startNode();
  if (this.type === types$1.name) {
    node.name = this.value;
  } else if (this.type.keyword) {
    node.name = this.type.keyword;
    if ((node.name === "class" || node.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {
      this.context.pop();
    }
    this.type = types$1.name;
  } else {
    this.unexpected();
  }
  return node;
};
pp$5.parsePrivateIdent = function() {
  var node = this.startNode();
  if (this.type === types$1.privateId) {
    node.name = this.value;
  } else {
    this.unexpected();
  }
  this.next();
  this.finishNode(node, "PrivateIdentifier");
  if (this.options.checkPrivateFields) {
    if (this.privateNameStack.length === 0) {
      this.raise(node.start, "Private field '#" + node.name + "' must be declared in an enclosing class");
    } else {
      this.privateNameStack[this.privateNameStack.length - 1].used.push(node);
    }
  }
  return node;
};
pp$5.parseYield = function(forInit) {
  if (!this.yieldPos) {
    this.yieldPos = this.start;
  }
  var node = this.startNode();
  this.next();
  if (this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr) {
    node.delegate = false;
    node.argument = null;
  } else {
    node.delegate = this.eat(types$1.star);
    node.argument = this.parseMaybeAssign(forInit);
  }
  return this.finishNode(node, "YieldExpression");
};
pp$5.parseAwait = function(forInit) {
  if (!this.awaitPos) {
    this.awaitPos = this.start;
  }
  var node = this.startNode();
  this.next();
  node.argument = this.parseMaybeUnary(null, true, false, forInit);
  return this.finishNode(node, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(pos, message) {
  var loc = getLineInfo(this.input, pos);
  message += " (" + loc.line + ":" + loc.column + ")";
  if (this.sourceFile) {
    message += " in " + this.sourceFile;
  }
  var err2 = new SyntaxError(message);
  err2.pos = pos;
  err2.loc = loc;
  err2.raisedAt = this.pos;
  throw err2;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
  if (this.options.locations) {
    return new Position(this.curLine, this.pos - this.lineStart);
  }
};
var pp$3 = Parser.prototype;
var Scope = function Scope2(flags) {
  this.flags = flags;
  this.var = [];
  this.lexical = [];
  this.functions = [];
};
pp$3.enterScope = function(flags) {
  this.scopeStack.push(new Scope(flags));
};
pp$3.exitScope = function() {
  this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(scope) {
  return scope.flags & SCOPE_FUNCTION || !this.inModule && scope.flags & SCOPE_TOP;
};
pp$3.declareName = function(name, bindingType, pos) {
  var redeclared = false;
  if (bindingType === BIND_LEXICAL) {
    var scope = this.currentScope();
    redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;
    scope.lexical.push(name);
    if (this.inModule && scope.flags & SCOPE_TOP) {
      delete this.undefinedExports[name];
    }
  } else if (bindingType === BIND_SIMPLE_CATCH) {
    var scope$1 = this.currentScope();
    scope$1.lexical.push(name);
  } else if (bindingType === BIND_FUNCTION) {
    var scope$2 = this.currentScope();
    if (this.treatFunctionsAsVar) {
      redeclared = scope$2.lexical.indexOf(name) > -1;
    } else {
      redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1;
    }
    scope$2.functions.push(name);
  } else {
    for (var i = this.scopeStack.length - 1; i >= 0; --i) {
      var scope$3 = this.scopeStack[i];
      if (scope$3.lexical.indexOf(name) > -1 && !(scope$3.flags & SCOPE_SIMPLE_CATCH && scope$3.lexical[0] === name) || !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {
        redeclared = true;
        break;
      }
      scope$3.var.push(name);
      if (this.inModule && scope$3.flags & SCOPE_TOP) {
        delete this.undefinedExports[name];
      }
      if (scope$3.flags & SCOPE_VAR) {
        break;
      }
    }
  }
  if (redeclared) {
    this.raiseRecoverable(pos, "Identifier '" + name + "' has already been declared");
  }
};
pp$3.checkLocalExport = function(id) {
  if (this.scopeStack[0].lexical.indexOf(id.name) === -1 && this.scopeStack[0].var.indexOf(id.name) === -1) {
    this.undefinedExports[id.name] = id;
  }
};
pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK)) {
      return scope;
    }
  }
};
pp$3.currentThisScope = function() {
  for (var i = this.scopeStack.length - 1; ; i--) {
    var scope = this.scopeStack[i];
    if (scope.flags & (SCOPE_VAR | SCOPE_CLASS_FIELD_INIT | SCOPE_CLASS_STATIC_BLOCK) && !(scope.flags & SCOPE_ARROW)) {
      return scope;
    }
  }
};
var Node = function Node2(parser, pos, loc) {
  this.type = "";
  this.start = pos;
  this.end = 0;
  if (parser.options.locations) {
    this.loc = new SourceLocation(parser, loc);
  }
  if (parser.options.directSourceFile) {
    this.sourceFile = parser.options.directSourceFile;
  }
  if (parser.options.ranges) {
    this.range = [pos, 0];
  }
};
var pp$2 = Parser.prototype;
pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(pos, loc) {
  return new Node(this, pos, loc);
};
function finishNodeAt(node, type3, pos, loc) {
  node.type = type3;
  node.end = pos;
  if (this.options.locations) {
    node.loc.end = loc;
  }
  if (this.options.ranges) {
    node.range[1] = pos;
  }
  return node;
}
pp$2.finishNode = function(node, type3) {
  return finishNodeAt.call(this, node, type3, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(node, type3, pos, loc) {
  return finishNodeAt.call(this, node, type3, pos, loc);
};
pp$2.copyNode = function(node) {
  var newNode = new Node(this, node.start, this.startLoc);
  for (var prop in node) {
    newNode[prop] = node[prop];
  }
  return newNode;
};
var scriptValuesAddedInUnicode = "Gara Garay Gukh Gurung_Khema Hrkt Katakana_Or_Hiragana Kawi Kirat_Rai Krai Nag_Mundari Nagm Ol_Onal Onao Sunu Sunuwar Todhri Todr Tulu_Tigalari Tutg Unknown Zzzz";
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS";
var ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic";
var ecma11BinaryProperties = ecma10BinaryProperties;
var ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict";
var ecma13BinaryProperties = ecma12BinaryProperties;
var ecma14BinaryProperties = ecma13BinaryProperties;
var unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
};
var ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji";
var unicodeBinaryPropertiesOfStrings = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: ecma14BinaryPropertiesOfStrings
};
var unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu";
var ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb";
var ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd";
var ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho";
var ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi";
var ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith";
var ecma14ScriptValues = ecma13ScriptValues + " " + scriptValuesAddedInUnicode;
var unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
};
var data = {};
function buildUnicodeData(ecmaVersion) {
  var d2 = data[ecmaVersion] = {
    binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + " " + unicodeGeneralCategoryValues),
    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[ecmaVersion]),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[ecmaVersion])
    }
  };
  d2.nonBinary.Script_Extensions = d2.nonBinary.Script;
  d2.nonBinary.gc = d2.nonBinary.General_Category;
  d2.nonBinary.sc = d2.nonBinary.Script;
  d2.nonBinary.scx = d2.nonBinary.Script_Extensions;
}
for (i = 0, list = [9, 10, 11, 12, 13, 14]; i < list.length; i += 1) {
  ecmaVersion = list[i];
  buildUnicodeData(ecmaVersion);
}
var ecmaVersion;
var i;
var list;
var pp$1 = Parser.prototype;
var BranchID = function BranchID2(parent, base2) {
  this.parent = parent;
  this.base = base2 || this;
};
BranchID.prototype.separatedFrom = function separatedFrom(alt) {
  for (var self2 = this; self2; self2 = self2.parent) {
    for (var other = alt; other; other = other.parent) {
      if (self2.base === other.base && self2 !== other) {
        return true;
      }
    }
  }
  return false;
};
BranchID.prototype.sibling = function sibling() {
  return new BranchID(this.parent, this.base);
};
var RegExpValidationState = function RegExpValidationState2(parser) {
  this.parser = parser;
  this.validFlags = "gim" + (parser.options.ecmaVersion >= 6 ? "uy" : "") + (parser.options.ecmaVersion >= 9 ? "s" : "") + (parser.options.ecmaVersion >= 13 ? "d" : "") + (parser.options.ecmaVersion >= 15 ? "v" : "");
  this.unicodeProperties = data[parser.options.ecmaVersion >= 14 ? 14 : parser.options.ecmaVersion];
  this.source = "";
  this.flags = "";
  this.start = 0;
  this.switchU = false;
  this.switchV = false;
  this.switchN = false;
  this.pos = 0;
  this.lastIntValue = 0;
  this.lastStringValue = "";
  this.lastAssertionIsQuantifiable = false;
  this.numCapturingParens = 0;
  this.maxBackReference = 0;
  this.groupNames = /* @__PURE__ */ Object.create(null);
  this.backReferenceNames = [];
  this.branchID = null;
};
RegExpValidationState.prototype.reset = function reset(start, pattern, flags) {
  var unicodeSets = flags.indexOf("v") !== -1;
  var unicode = flags.indexOf("u") !== -1;
  this.start = start | 0;
  this.source = pattern + "";
  this.flags = flags;
  if (unicodeSets && this.parser.options.ecmaVersion >= 15) {
    this.switchU = true;
    this.switchV = true;
    this.switchN = true;
  } else {
    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;
    this.switchV = false;
    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;
  }
};
RegExpValidationState.prototype.raise = function raise(message) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + message);
};
RegExpValidationState.prototype.at = function at2(i, forceU) {
  if (forceU === void 0) forceU = false;
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return -1;
  }
  var c4 = s.charCodeAt(i);
  if (!(forceU || this.switchU) || c4 <= 55295 || c4 >= 57344 || i + 1 >= l) {
    return c4;
  }
  var next = s.charCodeAt(i + 1);
  return next >= 56320 && next <= 57343 ? (c4 << 10) + next - 56613888 : c4;
};
RegExpValidationState.prototype.nextIndex = function nextIndex(i, forceU) {
  if (forceU === void 0) forceU = false;
  var s = this.source;
  var l = s.length;
  if (i >= l) {
    return l;
  }
  var c4 = s.charCodeAt(i), next;
  if (!(forceU || this.switchU) || c4 <= 55295 || c4 >= 57344 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 56320 || next > 57343) {
    return i + 1;
  }
  return i + 2;
};
RegExpValidationState.prototype.current = function current(forceU) {
  if (forceU === void 0) forceU = false;
  return this.at(this.pos, forceU);
};
RegExpValidationState.prototype.lookahead = function lookahead(forceU) {
  if (forceU === void 0) forceU = false;
  return this.at(this.nextIndex(this.pos, forceU), forceU);
};
RegExpValidationState.prototype.advance = function advance(forceU) {
  if (forceU === void 0) forceU = false;
  this.pos = this.nextIndex(this.pos, forceU);
};
RegExpValidationState.prototype.eat = function eat(ch, forceU) {
  if (forceU === void 0) forceU = false;
  if (this.current(forceU) === ch) {
    this.advance(forceU);
    return true;
  }
  return false;
};
RegExpValidationState.prototype.eatChars = function eatChars(chs, forceU) {
  if (forceU === void 0) forceU = false;
  var pos = this.pos;
  for (var i = 0, list = chs; i < list.length; i += 1) {
    var ch = list[i];
    var current2 = this.at(pos, forceU);
    if (current2 === -1 || current2 !== ch) {
      return false;
    }
    pos = this.nextIndex(pos, forceU);
  }
  this.pos = pos;
  return true;
};
pp$1.validateRegExpFlags = function(state) {
  var validFlags = state.validFlags;
  var flags = state.flags;
  var u = false;
  var v = false;
  for (var i = 0; i < flags.length; i++) {
    var flag = flags.charAt(i);
    if (validFlags.indexOf(flag) === -1) {
      this.raise(state.start, "Invalid regular expression flag");
    }
    if (flags.indexOf(flag, i + 1) > -1) {
      this.raise(state.start, "Duplicate regular expression flag");
    }
    if (flag === "u") {
      u = true;
    }
    if (flag === "v") {
      v = true;
    }
  }
  if (this.options.ecmaVersion >= 15 && u && v) {
    this.raise(state.start, "Invalid regular expression flag");
  }
};
function hasProp(obj) {
  for (var _23 in obj) {
    return true;
  }
  return false;
}
pp$1.validateRegExpPattern = function(state) {
  this.regexp_pattern(state);
  if (!state.switchN && this.options.ecmaVersion >= 9 && hasProp(state.groupNames)) {
    state.switchN = true;
    this.regexp_pattern(state);
  }
};
pp$1.regexp_pattern = function(state) {
  state.pos = 0;
  state.lastIntValue = 0;
  state.lastStringValue = "";
  state.lastAssertionIsQuantifiable = false;
  state.numCapturingParens = 0;
  state.maxBackReference = 0;
  state.groupNames = /* @__PURE__ */ Object.create(null);
  state.backReferenceNames.length = 0;
  state.branchID = null;
  this.regexp_disjunction(state);
  if (state.pos !== state.source.length) {
    if (state.eat(
      41
      /* ) */
    )) {
      state.raise("Unmatched ')'");
    }
    if (state.eat(
      93
      /* ] */
    ) || state.eat(
      125
      /* } */
    )) {
      state.raise("Lone quantifier brackets");
    }
  }
  if (state.maxBackReference > state.numCapturingParens) {
    state.raise("Invalid escape");
  }
  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {
    var name = list[i];
    if (!state.groupNames[name]) {
      state.raise("Invalid named capture referenced");
    }
  }
};
pp$1.regexp_disjunction = function(state) {
  var trackDisjunction = this.options.ecmaVersion >= 16;
  if (trackDisjunction) {
    state.branchID = new BranchID(state.branchID, null);
  }
  this.regexp_alternative(state);
  while (state.eat(
    124
    /* | */
  )) {
    if (trackDisjunction) {
      state.branchID = state.branchID.sibling();
    }
    this.regexp_alternative(state);
  }
  if (trackDisjunction) {
    state.branchID = state.branchID.parent;
  }
  if (this.regexp_eatQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  if (state.eat(
    123
    /* { */
  )) {
    state.raise("Lone quantifier brackets");
  }
};
pp$1.regexp_alternative = function(state) {
  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {
  }
};
pp$1.regexp_eatTerm = function(state) {
  if (this.regexp_eatAssertion(state)) {
    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {
      if (state.switchU) {
        state.raise("Invalid quantifier");
      }
    }
    return true;
  }
  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {
    this.regexp_eatQuantifier(state);
    return true;
  }
  return false;
};
pp$1.regexp_eatAssertion = function(state) {
  var start = state.pos;
  state.lastAssertionIsQuantifiable = false;
  if (state.eat(
    94
    /* ^ */
  ) || state.eat(
    36
    /* $ */
  )) {
    return true;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    if (state.eat(
      66
      /* B */
    ) || state.eat(
      98
      /* b */
    )) {
      return true;
    }
    state.pos = start;
  }
  if (state.eat(
    40
    /* ( */
  ) && state.eat(
    63
    /* ? */
  )) {
    var lookbehind = false;
    if (this.options.ecmaVersion >= 9) {
      lookbehind = state.eat(
        60
        /* < */
      );
    }
    if (state.eat(
      61
      /* = */
    ) || state.eat(
      33
      /* ! */
    )) {
      this.regexp_disjunction(state);
      if (!state.eat(
        41
        /* ) */
      )) {
        state.raise("Unterminated group");
      }
      state.lastAssertionIsQuantifiable = !lookbehind;
      return true;
    }
  }
  state.pos = start;
  return false;
};
pp$1.regexp_eatQuantifier = function(state, noError) {
  if (noError === void 0) noError = false;
  if (this.regexp_eatQuantifierPrefix(state, noError)) {
    state.eat(
      63
      /* ? */
    );
    return true;
  }
  return false;
};
pp$1.regexp_eatQuantifierPrefix = function(state, noError) {
  return state.eat(
    42
    /* * */
  ) || state.eat(
    43
    /* + */
  ) || state.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(state, noError);
};
pp$1.regexp_eatBracedQuantifier = function(state, noError) {
  var start = state.pos;
  if (state.eat(
    123
    /* { */
  )) {
    var min = 0, max = -1;
    if (this.regexp_eatDecimalDigits(state)) {
      min = state.lastIntValue;
      if (state.eat(
        44
        /* , */
      ) && this.regexp_eatDecimalDigits(state)) {
        max = state.lastIntValue;
      }
      if (state.eat(
        125
        /* } */
      )) {
        if (max !== -1 && max < min && !noError) {
          state.raise("numbers out of order in {} quantifier");
        }
        return true;
      }
    }
    if (state.switchU && !noError) {
      state.raise("Incomplete quantifier");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatAtom = function(state) {
  return this.regexp_eatPatternCharacters(state) || state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatUncapturingGroup = function(state) {
  var start = state.pos;
  if (state.eat(
    40
    /* ( */
  )) {
    if (state.eat(
      63
      /* ? */
    )) {
      if (this.options.ecmaVersion >= 16) {
        var addModifiers = this.regexp_eatModifiers(state);
        var hasHyphen = state.eat(
          45
          /* - */
        );
        if (addModifiers || hasHyphen) {
          for (var i = 0; i < addModifiers.length; i++) {
            var modifier = addModifiers.charAt(i);
            if (addModifiers.indexOf(modifier, i + 1) > -1) {
              state.raise("Duplicate regular expression modifiers");
            }
          }
          if (hasHyphen) {
            var removeModifiers = this.regexp_eatModifiers(state);
            if (!addModifiers && !removeModifiers && state.current() === 58) {
              state.raise("Invalid regular expression modifiers");
            }
            for (var i$1 = 0; i$1 < removeModifiers.length; i$1++) {
              var modifier$1 = removeModifiers.charAt(i$1);
              if (removeModifiers.indexOf(modifier$1, i$1 + 1) > -1 || addModifiers.indexOf(modifier$1) > -1) {
                state.raise("Duplicate regular expression modifiers");
              }
            }
          }
        }
      }
      if (state.eat(
        58
        /* : */
      )) {
        this.regexp_disjunction(state);
        if (state.eat(
          41
          /* ) */
        )) {
          return true;
        }
        state.raise("Unterminated group");
      }
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatCapturingGroup = function(state) {
  if (state.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9) {
      this.regexp_groupSpecifier(state);
    } else if (state.current() === 63) {
      state.raise("Invalid group");
    }
    this.regexp_disjunction(state);
    if (state.eat(
      41
      /* ) */
    )) {
      state.numCapturingParens += 1;
      return true;
    }
    state.raise("Unterminated group");
  }
  return false;
};
pp$1.regexp_eatModifiers = function(state) {
  var modifiers = "";
  var ch = 0;
  while ((ch = state.current()) !== -1 && isRegularExpressionModifier(ch)) {
    modifiers += codePointToString(ch);
    state.advance();
  }
  return modifiers;
};
function isRegularExpressionModifier(ch) {
  return ch === 105 || ch === 109 || ch === 115;
}
pp$1.regexp_eatExtendedAtom = function(state) {
  return state.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(state) {
  if (this.regexp_eatBracedQuantifier(state, true)) {
    state.raise("Nothing to repeat");
  }
  return false;
};
pp$1.regexp_eatSyntaxCharacter = function(state) {
  var ch = state.current();
  if (isSyntaxCharacter(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isSyntaxCharacter(ch) {
  return ch === 36 || ch >= 40 && ch <= 43 || ch === 46 || ch === 63 || ch >= 91 && ch <= 94 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatPatternCharacters = function(state) {
  var start = state.pos;
  var ch = 0;
  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {
    state.advance();
  }
  return state.pos !== start;
};
pp$1.regexp_eatExtendedPatternCharacter = function(state) {
  var ch = state.current();
  if (ch !== -1 && ch !== 36 && !(ch >= 40 && ch <= 43) && ch !== 46 && ch !== 63 && ch !== 91 && ch !== 94 && ch !== 124) {
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_groupSpecifier = function(state) {
  if (state.eat(
    63
    /* ? */
  )) {
    if (!this.regexp_eatGroupName(state)) {
      state.raise("Invalid group");
    }
    var trackDisjunction = this.options.ecmaVersion >= 16;
    var known = state.groupNames[state.lastStringValue];
    if (known) {
      if (trackDisjunction) {
        for (var i = 0, list = known; i < list.length; i += 1) {
          var altID = list[i];
          if (!altID.separatedFrom(state.branchID)) {
            state.raise("Duplicate capture group name");
          }
        }
      } else {
        state.raise("Duplicate capture group name");
      }
    }
    if (trackDisjunction) {
      (known || (state.groupNames[state.lastStringValue] = [])).push(state.branchID);
    } else {
      state.groupNames[state.lastStringValue] = true;
    }
  }
};
pp$1.regexp_eatGroupName = function(state) {
  state.lastStringValue = "";
  if (state.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(
      62
      /* > */
    )) {
      return true;
    }
    state.raise("Invalid capture group name");
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierName = function(state) {
  state.lastStringValue = "";
  if (this.regexp_eatRegExpIdentifierStart(state)) {
    state.lastStringValue += codePointToString(state.lastIntValue);
    while (this.regexp_eatRegExpIdentifierPart(state)) {
      state.lastStringValue += codePointToString(state.lastIntValue);
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatRegExpIdentifierStart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierStart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierStart(ch) {
  return isIdentifierStart(ch, true) || ch === 36 || ch === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(state) {
  var start = state.pos;
  var forceU = this.options.ecmaVersion >= 11;
  var ch = state.current(forceU);
  state.advance(forceU);
  if (ch === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(state, forceU)) {
    ch = state.lastIntValue;
  }
  if (isRegExpIdentifierPart(ch)) {
    state.lastIntValue = ch;
    return true;
  }
  state.pos = start;
  return false;
};
function isRegExpIdentifierPart(ch) {
  return isIdentifierChar(ch, true) || ch === 36 || ch === 95 || ch === 8204 || ch === 8205;
}
pp$1.regexp_eatAtomEscape = function(state) {
  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {
    return true;
  }
  if (state.switchU) {
    if (state.current() === 99) {
      state.raise("Invalid unicode escape");
    }
    state.raise("Invalid escape");
  }
  return false;
};
pp$1.regexp_eatBackReference = function(state) {
  var start = state.pos;
  if (this.regexp_eatDecimalEscape(state)) {
    var n3 = state.lastIntValue;
    if (state.switchU) {
      if (n3 > state.maxBackReference) {
        state.maxBackReference = n3;
      }
      return true;
    }
    if (n3 <= state.numCapturingParens) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatKGroupName = function(state) {
  if (state.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(state)) {
      state.backReferenceNames.push(state.lastStringValue);
      return true;
    }
    state.raise("Invalid named reference");
  }
  return false;
};
pp$1.regexp_eatCharacterEscape = function(state) {
  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state, false) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);
};
pp$1.regexp_eatCControlLetter = function(state) {
  var start = state.pos;
  if (state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatZero = function(state) {
  if (state.current() === 48 && !isDecimalDigit(state.lookahead())) {
    state.lastIntValue = 0;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlEscape = function(state) {
  var ch = state.current();
  if (ch === 116) {
    state.lastIntValue = 9;
    state.advance();
    return true;
  }
  if (ch === 110) {
    state.lastIntValue = 10;
    state.advance();
    return true;
  }
  if (ch === 118) {
    state.lastIntValue = 11;
    state.advance();
    return true;
  }
  if (ch === 102) {
    state.lastIntValue = 12;
    state.advance();
    return true;
  }
  if (ch === 114) {
    state.lastIntValue = 13;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatControlLetter = function(state) {
  var ch = state.current();
  if (isControlLetter(ch)) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
function isControlLetter(ch) {
  return ch >= 65 && ch <= 90 || ch >= 97 && ch <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(state, forceU) {
  if (forceU === void 0) forceU = false;
  var start = state.pos;
  var switchU = forceU || state.switchU;
  if (state.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 4)) {
      var lead = state.lastIntValue;
      if (switchU && lead >= 55296 && lead <= 56319) {
        var leadSurrogateEnd = state.pos;
        if (state.eat(
          92
          /* \ */
        ) && state.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(state, 4)) {
          var trail = state.lastIntValue;
          if (trail >= 56320 && trail <= 57343) {
            state.lastIntValue = (lead - 55296) * 1024 + (trail - 56320) + 65536;
            return true;
          }
        }
        state.pos = leadSurrogateEnd;
        state.lastIntValue = lead;
      }
      return true;
    }
    if (switchU && state.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(state) && state.eat(
      125
      /* } */
    ) && isValidUnicode(state.lastIntValue)) {
      return true;
    }
    if (switchU) {
      state.raise("Invalid unicode escape");
    }
    state.pos = start;
  }
  return false;
};
function isValidUnicode(ch) {
  return ch >= 0 && ch <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(state) {
  if (state.switchU) {
    if (this.regexp_eatSyntaxCharacter(state)) {
      return true;
    }
    if (state.eat(
      47
      /* / */
    )) {
      state.lastIntValue = 47;
      return true;
    }
    return false;
  }
  var ch = state.current();
  if (ch !== 99 && (!state.switchN || ch !== 107)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatDecimalEscape = function(state) {
  state.lastIntValue = 0;
  var ch = state.current();
  if (ch >= 49 && ch <= 57) {
    do {
      state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
      state.advance();
    } while ((ch = state.current()) >= 48 && ch <= 57);
    return true;
  }
  return false;
};
var CharSetNone = 0;
var CharSetOk = 1;
var CharSetString = 2;
pp$1.regexp_eatCharacterClassEscape = function(state) {
  var ch = state.current();
  if (isCharacterClassEscape(ch)) {
    state.lastIntValue = -1;
    state.advance();
    return CharSetOk;
  }
  var negate = false;
  if (state.switchU && this.options.ecmaVersion >= 9 && ((negate = ch === 80) || ch === 112)) {
    state.lastIntValue = -1;
    state.advance();
    var result;
    if (state.eat(
      123
      /* { */
    ) && (result = this.regexp_eatUnicodePropertyValueExpression(state)) && state.eat(
      125
      /* } */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Invalid property name");
      }
      return result;
    }
    state.raise("Invalid property name");
  }
  return CharSetNone;
};
function isCharacterClassEscape(ch) {
  return ch === 100 || ch === 68 || ch === 115 || ch === 83 || ch === 119 || ch === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(state) {
  var start = state.pos;
  if (this.regexp_eatUnicodePropertyName(state) && state.eat(
    61
    /* = */
  )) {
    var name = state.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(state)) {
      var value = state.lastStringValue;
      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);
      return CharSetOk;
    }
  }
  state.pos = start;
  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {
    var nameOrValue = state.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);
  }
  return CharSetNone;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {
  if (!hasOwn(state.unicodeProperties.nonBinary, name)) {
    state.raise("Invalid property name");
  }
  if (!state.unicodeProperties.nonBinary[name].test(value)) {
    state.raise("Invalid property value");
  }
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {
  if (state.unicodeProperties.binary.test(nameOrValue)) {
    return CharSetOk;
  }
  if (state.switchV && state.unicodeProperties.binaryOfStrings.test(nameOrValue)) {
    return CharSetString;
  }
  state.raise("Invalid property name");
};
pp$1.regexp_eatUnicodePropertyName = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyNameCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(ch) {
  return isControlLetter(ch) || ch === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(state) {
  var ch = 0;
  state.lastStringValue = "";
  while (isUnicodePropertyValueCharacter(ch = state.current())) {
    state.lastStringValue += codePointToString(ch);
    state.advance();
  }
  return state.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(ch) {
  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {
  return this.regexp_eatUnicodePropertyValue(state);
};
pp$1.regexp_eatCharacterClass = function(state) {
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (!state.eat(
      93
      /* ] */
    )) {
      state.raise("Unterminated character class");
    }
    if (negate && result === CharSetString) {
      state.raise("Negated character class may contain strings");
    }
    return true;
  }
  return false;
};
pp$1.regexp_classContents = function(state) {
  if (state.current() === 93) {
    return CharSetOk;
  }
  if (state.switchV) {
    return this.regexp_classSetExpression(state);
  }
  this.regexp_nonEmptyClassRanges(state);
  return CharSetOk;
};
pp$1.regexp_nonEmptyClassRanges = function(state) {
  while (this.regexp_eatClassAtom(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(state)) {
      var right = state.lastIntValue;
      if (state.switchU && (left === -1 || right === -1)) {
        state.raise("Invalid character class");
      }
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
    }
  }
};
pp$1.regexp_eatClassAtom = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(state)) {
      return true;
    }
    if (state.switchU) {
      var ch$1 = state.current();
      if (ch$1 === 99 || isOctalDigit(ch$1)) {
        state.raise("Invalid class escape");
      }
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  var ch = state.current();
  if (ch !== 93) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatClassEscape = function(state) {
  var start = state.pos;
  if (state.eat(
    98
    /* b */
  )) {
    state.lastIntValue = 8;
    return true;
  }
  if (state.switchU && state.eat(
    45
    /* - */
  )) {
    state.lastIntValue = 45;
    return true;
  }
  if (!state.switchU && state.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(state)) {
      return true;
    }
    state.pos = start;
  }
  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);
};
pp$1.regexp_classSetExpression = function(state) {
  var result = CharSetOk, subResult;
  if (this.regexp_eatClassSetRange(state)) ;
  else if (subResult = this.regexp_eatClassSetOperand(state)) {
    if (subResult === CharSetString) {
      result = CharSetString;
    }
    var start = state.pos;
    while (state.eatChars(
      [38, 38]
      /* && */
    )) {
      if (state.current() !== 38 && (subResult = this.regexp_eatClassSetOperand(state))) {
        if (subResult !== CharSetString) {
          result = CharSetOk;
        }
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) {
      return result;
    }
    while (state.eatChars(
      [45, 45]
      /* -- */
    )) {
      if (this.regexp_eatClassSetOperand(state)) {
        continue;
      }
      state.raise("Invalid character in character class");
    }
    if (start !== state.pos) {
      return result;
    }
  } else {
    state.raise("Invalid character in character class");
  }
  for (; ; ) {
    if (this.regexp_eatClassSetRange(state)) {
      continue;
    }
    subResult = this.regexp_eatClassSetOperand(state);
    if (!subResult) {
      return result;
    }
    if (subResult === CharSetString) {
      result = CharSetString;
    }
  }
};
pp$1.regexp_eatClassSetRange = function(state) {
  var start = state.pos;
  if (this.regexp_eatClassSetCharacter(state)) {
    var left = state.lastIntValue;
    if (state.eat(
      45
      /* - */
    ) && this.regexp_eatClassSetCharacter(state)) {
      var right = state.lastIntValue;
      if (left !== -1 && right !== -1 && left > right) {
        state.raise("Range out of order in character class");
      }
      return true;
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatClassSetOperand = function(state) {
  if (this.regexp_eatClassSetCharacter(state)) {
    return CharSetOk;
  }
  return this.regexp_eatClassStringDisjunction(state) || this.regexp_eatNestedClass(state);
};
pp$1.regexp_eatNestedClass = function(state) {
  var start = state.pos;
  if (state.eat(
    91
    /* [ */
  )) {
    var negate = state.eat(
      94
      /* ^ */
    );
    var result = this.regexp_classContents(state);
    if (state.eat(
      93
      /* ] */
    )) {
      if (negate && result === CharSetString) {
        state.raise("Negated character class may contain strings");
      }
      return result;
    }
    state.pos = start;
  }
  if (state.eat(
    92
    /* \ */
  )) {
    var result$1 = this.regexp_eatCharacterClassEscape(state);
    if (result$1) {
      return result$1;
    }
    state.pos = start;
  }
  return null;
};
pp$1.regexp_eatClassStringDisjunction = function(state) {
  var start = state.pos;
  if (state.eatChars(
    [92, 113]
    /* \q */
  )) {
    if (state.eat(
      123
      /* { */
    )) {
      var result = this.regexp_classStringDisjunctionContents(state);
      if (state.eat(
        125
        /* } */
      )) {
        return result;
      }
    } else {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return null;
};
pp$1.regexp_classStringDisjunctionContents = function(state) {
  var result = this.regexp_classString(state);
  while (state.eat(
    124
    /* | */
  )) {
    if (this.regexp_classString(state) === CharSetString) {
      result = CharSetString;
    }
  }
  return result;
};
pp$1.regexp_classString = function(state) {
  var count = 0;
  while (this.regexp_eatClassSetCharacter(state)) {
    count++;
  }
  return count === 1 ? CharSetOk : CharSetString;
};
pp$1.regexp_eatClassSetCharacter = function(state) {
  var start = state.pos;
  if (state.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatCharacterEscape(state) || this.regexp_eatClassSetReservedPunctuator(state)) {
      return true;
    }
    if (state.eat(
      98
      /* b */
    )) {
      state.lastIntValue = 8;
      return true;
    }
    state.pos = start;
    return false;
  }
  var ch = state.current();
  if (ch < 0 || ch === state.lookahead() && isClassSetReservedDoublePunctuatorCharacter(ch)) {
    return false;
  }
  if (isClassSetSyntaxCharacter(ch)) {
    return false;
  }
  state.advance();
  state.lastIntValue = ch;
  return true;
};
function isClassSetReservedDoublePunctuatorCharacter(ch) {
  return ch === 33 || ch >= 35 && ch <= 38 || ch >= 42 && ch <= 44 || ch === 46 || ch >= 58 && ch <= 64 || ch === 94 || ch === 96 || ch === 126;
}
function isClassSetSyntaxCharacter(ch) {
  return ch === 40 || ch === 41 || ch === 45 || ch === 47 || ch >= 91 && ch <= 93 || ch >= 123 && ch <= 125;
}
pp$1.regexp_eatClassSetReservedPunctuator = function(state) {
  var ch = state.current();
  if (isClassSetReservedPunctuator(ch)) {
    state.lastIntValue = ch;
    state.advance();
    return true;
  }
  return false;
};
function isClassSetReservedPunctuator(ch) {
  return ch === 33 || ch === 35 || ch === 37 || ch === 38 || ch === 44 || ch === 45 || ch >= 58 && ch <= 62 || ch === 64 || ch === 96 || ch === 126;
}
pp$1.regexp_eatClassControlLetter = function(state) {
  var ch = state.current();
  if (isDecimalDigit(ch) || ch === 95) {
    state.lastIntValue = ch % 32;
    state.advance();
    return true;
  }
  return false;
};
pp$1.regexp_eatHexEscapeSequence = function(state) {
  var start = state.pos;
  if (state.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(state, 2)) {
      return true;
    }
    if (state.switchU) {
      state.raise("Invalid escape");
    }
    state.pos = start;
  }
  return false;
};
pp$1.regexp_eatDecimalDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isDecimalDigit(ch = state.current())) {
    state.lastIntValue = 10 * state.lastIntValue + (ch - 48);
    state.advance();
  }
  return state.pos !== start;
};
function isDecimalDigit(ch) {
  return ch >= 48 && ch <= 57;
}
pp$1.regexp_eatHexDigits = function(state) {
  var start = state.pos;
  var ch = 0;
  state.lastIntValue = 0;
  while (isHexDigit(ch = state.current())) {
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return state.pos !== start;
};
function isHexDigit(ch) {
  return ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102;
}
function hexToInt(ch) {
  if (ch >= 65 && ch <= 70) {
    return 10 + (ch - 65);
  }
  if (ch >= 97 && ch <= 102) {
    return 10 + (ch - 97);
  }
  return ch - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(state) {
  if (this.regexp_eatOctalDigit(state)) {
    var n1 = state.lastIntValue;
    if (this.regexp_eatOctalDigit(state)) {
      var n22 = state.lastIntValue;
      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {
        state.lastIntValue = n1 * 64 + n22 * 8 + state.lastIntValue;
      } else {
        state.lastIntValue = n1 * 8 + n22;
      }
    } else {
      state.lastIntValue = n1;
    }
    return true;
  }
  return false;
};
pp$1.regexp_eatOctalDigit = function(state) {
  var ch = state.current();
  if (isOctalDigit(ch)) {
    state.lastIntValue = ch - 48;
    state.advance();
    return true;
  }
  state.lastIntValue = 0;
  return false;
};
function isOctalDigit(ch) {
  return ch >= 48 && ch <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(state, length) {
  var start = state.pos;
  state.lastIntValue = 0;
  for (var i = 0; i < length; ++i) {
    var ch = state.current();
    if (!isHexDigit(ch)) {
      state.pos = start;
      return false;
    }
    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);
    state.advance();
  }
  return true;
};
var Token = function Token2(p2) {
  this.type = p2.type;
  this.value = p2.value;
  this.start = p2.start;
  this.end = p2.end;
  if (p2.options.locations) {
    this.loc = new SourceLocation(p2, p2.startLoc, p2.endLoc);
  }
  if (p2.options.ranges) {
    this.range = [p2.start, p2.end];
  }
};
var pp = Parser.prototype;
pp.next = function(ignoreEscapeSequenceInKeyword) {
  if (!ignoreEscapeSequenceInKeyword && this.type.keyword && this.containsEsc) {
    this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword);
  }
  if (this.options.onToken) {
    this.options.onToken(new Token(this));
  }
  this.lastTokEnd = this.end;
  this.lastTokStart = this.start;
  this.lastTokEndLoc = this.endLoc;
  this.lastTokStartLoc = this.startLoc;
  this.nextToken();
};
pp.getToken = function() {
  this.next();
  return new Token(this);
};
if (typeof Symbol !== "undefined") {
  pp[Symbol.iterator] = function() {
    var this$1$1 = this;
    return {
      next: function() {
        var token = this$1$1.getToken();
        return {
          done: token.type === types$1.eof,
          value: token
        };
      }
    };
  };
}
pp.nextToken = function() {
  var curContext = this.curContext();
  if (!curContext || !curContext.preserveSpace) {
    this.skipSpace();
  }
  this.start = this.pos;
  if (this.options.locations) {
    this.startLoc = this.curPosition();
  }
  if (this.pos >= this.input.length) {
    return this.finishToken(types$1.eof);
  }
  if (curContext.override) {
    return curContext.override(this);
  } else {
    this.readToken(this.fullCharCodeAtPos());
  }
};
pp.readToken = function(code) {
  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92) {
    return this.readWord();
  }
  return this.getTokenFromCode(code);
};
pp.fullCharCodeAtPos = function() {
  var code = this.input.charCodeAt(this.pos);
  if (code <= 55295 || code >= 56320) {
    return code;
  }
  var next = this.input.charCodeAt(this.pos + 1);
  return next <= 56319 || next >= 57344 ? code : (code << 10) + next - 56613888;
};
pp.skipBlockComment = function() {
  var startLoc = this.options.onComment && this.curPosition();
  var start = this.pos, end = this.input.indexOf("*/", this.pos += 2);
  if (end === -1) {
    this.raise(this.pos - 2, "Unterminated comment");
  }
  this.pos = end + 2;
  if (this.options.locations) {
    for (var nextBreak = void 0, pos = start; (nextBreak = nextLineBreak(this.input, pos, this.pos)) > -1; ) {
      ++this.curLine;
      pos = this.lineStart = nextBreak;
    }
  }
  if (this.options.onComment) {
    this.options.onComment(
      true,
      this.input.slice(start + 2, end),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipLineComment = function(startSkip) {
  var start = this.pos;
  var startLoc = this.options.onComment && this.curPosition();
  var ch = this.input.charCodeAt(this.pos += startSkip);
  while (this.pos < this.input.length && !isNewLine(ch)) {
    ch = this.input.charCodeAt(++this.pos);
  }
  if (this.options.onComment) {
    this.options.onComment(
      false,
      this.input.slice(start + startSkip, this.pos),
      start,
      this.pos,
      startLoc,
      this.curPosition()
    );
  }
};
pp.skipSpace = function() {
  loop: while (this.pos < this.input.length) {
    var ch = this.input.charCodeAt(this.pos);
    switch (ch) {
      case 32:
      case 160:
        ++this.pos;
        break;
      case 13:
        if (this.input.charCodeAt(this.pos + 1) === 10) {
          ++this.pos;
        }
      case 10:
      case 8232:
      case 8233:
        ++this.pos;
        if (this.options.locations) {
          ++this.curLine;
          this.lineStart = this.pos;
        }
        break;
      case 47:
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42:
            this.skipBlockComment();
            break;
          case 47:
            this.skipLineComment(2);
            break;
          default:
            break loop;
        }
        break;
      default:
        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {
          ++this.pos;
        } else {
          break loop;
        }
    }
  }
};
pp.finishToken = function(type3, val2) {
  this.end = this.pos;
  if (this.options.locations) {
    this.endLoc = this.curPosition();
  }
  var prevType = this.type;
  this.type = type3;
  this.value = val2;
  this.updateContext(prevType);
};
pp.readToken_dot = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next >= 48 && next <= 57) {
    return this.readNumber(true);
  }
  var next2 = this.input.charCodeAt(this.pos + 2);
  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {
    this.pos += 3;
    return this.finishToken(types$1.ellipsis);
  } else {
    ++this.pos;
    return this.finishToken(types$1.dot);
  }
};
pp.readToken_slash = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (this.exprAllowed) {
    ++this.pos;
    return this.readRegexp();
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  var tokentype = code === 42 ? types$1.star : types$1.modulo;
  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {
    ++size;
    tokentype = types$1.starstar;
    next = this.input.charCodeAt(this.pos + 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, size + 1);
  }
  return this.finishOp(tokentype, size);
};
pp.readToken_pipe_amp = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (this.options.ecmaVersion >= 12) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 === 61) {
        return this.finishOp(types$1.assign, 3);
      }
    }
    return this.finishOp(code === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(code === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === code) {
    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {
      this.skipLineComment(3);
      this.skipSpace();
      return this.nextToken();
    }
    return this.finishOp(types$1.incDec, 2);
  }
  if (next === 61) {
    return this.finishOp(types$1.assign, 2);
  }
  return this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  var size = 1;
  if (next === code) {
    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;
    if (this.input.charCodeAt(this.pos + size) === 61) {
      return this.finishOp(types$1.assign, size + 1);
    }
    return this.finishOp(types$1.bitShift, size);
  }
  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {
    this.skipLineComment(4);
    this.skipSpace();
    return this.nextToken();
  }
  if (next === 61) {
    size = 2;
  }
  return this.finishOp(types$1.relational, size);
};
pp.readToken_eq_excl = function(code) {
  var next = this.input.charCodeAt(this.pos + 1);
  if (next === 61) {
    return this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);
  }
  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {
    this.pos += 2;
    return this.finishToken(types$1.arrow);
  }
  return this.finishOp(code === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
  var ecmaVersion = this.options.ecmaVersion;
  if (ecmaVersion >= 11) {
    var next = this.input.charCodeAt(this.pos + 1);
    if (next === 46) {
      var next2 = this.input.charCodeAt(this.pos + 2);
      if (next2 < 48 || next2 > 57) {
        return this.finishOp(types$1.questionDot, 2);
      }
    }
    if (next === 63) {
      if (ecmaVersion >= 12) {
        var next2$1 = this.input.charCodeAt(this.pos + 2);
        if (next2$1 === 61) {
          return this.finishOp(types$1.assign, 3);
        }
      }
      return this.finishOp(types$1.coalesce, 2);
    }
  }
  return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
  var ecmaVersion = this.options.ecmaVersion;
  var code = 35;
  if (ecmaVersion >= 13) {
    ++this.pos;
    code = this.fullCharCodeAtPos();
    if (isIdentifierStart(code, true) || code === 92) {
      return this.finishToken(types$1.privateId, this.readWord1());
    }
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.getTokenFromCode = function(code) {
  switch (code) {
    case 46:
      return this.readToken_dot();
    case 40:
      ++this.pos;
      return this.finishToken(types$1.parenL);
    case 41:
      ++this.pos;
      return this.finishToken(types$1.parenR);
    case 59:
      ++this.pos;
      return this.finishToken(types$1.semi);
    case 44:
      ++this.pos;
      return this.finishToken(types$1.comma);
    case 91:
      ++this.pos;
      return this.finishToken(types$1.bracketL);
    case 93:
      ++this.pos;
      return this.finishToken(types$1.bracketR);
    case 123:
      ++this.pos;
      return this.finishToken(types$1.braceL);
    case 125:
      ++this.pos;
      return this.finishToken(types$1.braceR);
    case 58:
      ++this.pos;
      return this.finishToken(types$1.colon);
    case 96:
      if (this.options.ecmaVersion < 6) {
        break;
      }
      ++this.pos;
      return this.finishToken(types$1.backQuote);
    case 48:
      var next = this.input.charCodeAt(this.pos + 1);
      if (next === 120 || next === 88) {
        return this.readRadixNumber(16);
      }
      if (this.options.ecmaVersion >= 6) {
        if (next === 111 || next === 79) {
          return this.readRadixNumber(8);
        }
        if (next === 98 || next === 66) {
          return this.readRadixNumber(2);
        }
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(false);
    case 34:
    case 39:
      return this.readString(code);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(code);
    case 124:
    case 38:
      return this.readToken_pipe_amp(code);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(code);
    case 60:
    case 62:
      return this.readToken_lt_gt(code);
    case 61:
    case 33:
      return this.readToken_eq_excl(code);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(types$1.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(code) + "'");
};
pp.finishOp = function(type3, size) {
  var str = this.input.slice(this.pos, this.pos + size);
  this.pos += size;
  return this.finishToken(type3, str);
};
pp.readRegexp = function() {
  var escaped, inClass, start = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(start, "Unterminated regular expression");
    }
    var ch = this.input.charAt(this.pos);
    if (lineBreak.test(ch)) {
      this.raise(start, "Unterminated regular expression");
    }
    if (!escaped) {
      if (ch === "[") {
        inClass = true;
      } else if (ch === "]" && inClass) {
        inClass = false;
      } else if (ch === "/" && !inClass) {
        break;
      }
      escaped = ch === "\\";
    } else {
      escaped = false;
    }
    ++this.pos;
  }
  var pattern = this.input.slice(start, this.pos);
  ++this.pos;
  var flagsStart = this.pos;
  var flags = this.readWord1();
  if (this.containsEsc) {
    this.unexpected(flagsStart);
  }
  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  state.reset(start, pattern, flags);
  this.validateRegExpFlags(state);
  this.validateRegExpPattern(state);
  var value = null;
  try {
    value = new RegExp(pattern, flags);
  } catch (e2) {
  }
  return this.finishToken(types$1.regexp, { pattern, flags, value });
};
pp.readInt = function(radix, len, maybeLegacyOctalNumericLiteral) {
  var allowSeparators = this.options.ecmaVersion >= 12 && len === void 0;
  var isLegacyOctalNumericLiteral = maybeLegacyOctalNumericLiteral && this.input.charCodeAt(this.pos) === 48;
  var start = this.pos, total = 0, lastCode = 0;
  for (var i = 0, e2 = len == null ? Infinity : len; i < e2; ++i, ++this.pos) {
    var code = this.input.charCodeAt(this.pos), val2 = void 0;
    if (allowSeparators && code === 95) {
      if (isLegacyOctalNumericLiteral) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals");
      }
      if (lastCode === 95) {
        this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore");
      }
      if (i === 0) {
        this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits");
      }
      lastCode = code;
      continue;
    }
    if (code >= 97) {
      val2 = code - 97 + 10;
    } else if (code >= 65) {
      val2 = code - 65 + 10;
    } else if (code >= 48 && code <= 57) {
      val2 = code - 48;
    } else {
      val2 = Infinity;
    }
    if (val2 >= radix) {
      break;
    }
    lastCode = code;
    total = total * radix + val2;
  }
  if (allowSeparators && lastCode === 95) {
    this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits");
  }
  if (this.pos === start || len != null && this.pos - start !== len) {
    return null;
  }
  return total;
};
function stringToNumber(str, isLegacyOctalNumericLiteral) {
  if (isLegacyOctalNumericLiteral) {
    return parseInt(str, 8);
  }
  return parseFloat(str.replace(/_/g, ""));
}
function stringToBigInt(str) {
  if (typeof BigInt !== "function") {
    return null;
  }
  return BigInt(str.replace(/_/g, ""));
}
pp.readRadixNumber = function(radix) {
  var start = this.pos;
  this.pos += 2;
  var val2 = this.readInt(radix);
  if (val2 == null) {
    this.raise(this.start + 2, "Expected number in radix " + radix);
  }
  if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {
    val2 = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
  } else if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  return this.finishToken(types$1.num, val2);
};
pp.readNumber = function(startsWithDot) {
  var start = this.pos;
  if (!startsWithDot && this.readInt(10, void 0, true) === null) {
    this.raise(start, "Invalid number");
  }
  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;
  if (octal && this.strict) {
    this.raise(start, "Invalid number");
  }
  var next = this.input.charCodeAt(this.pos);
  if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {
    var val$1 = stringToBigInt(this.input.slice(start, this.pos));
    ++this.pos;
    if (isIdentifierStart(this.fullCharCodeAtPos())) {
      this.raise(this.pos, "Identifier directly after number");
    }
    return this.finishToken(types$1.num, val$1);
  }
  if (octal && /[89]/.test(this.input.slice(start, this.pos))) {
    octal = false;
  }
  if (next === 46 && !octal) {
    ++this.pos;
    this.readInt(10);
    next = this.input.charCodeAt(this.pos);
  }
  if ((next === 69 || next === 101) && !octal) {
    next = this.input.charCodeAt(++this.pos);
    if (next === 43 || next === 45) {
      ++this.pos;
    }
    if (this.readInt(10) === null) {
      this.raise(start, "Invalid number");
    }
  }
  if (isIdentifierStart(this.fullCharCodeAtPos())) {
    this.raise(this.pos, "Identifier directly after number");
  }
  var val2 = stringToNumber(this.input.slice(start, this.pos), octal);
  return this.finishToken(types$1.num, val2);
};
pp.readCodePoint = function() {
  var ch = this.input.charCodeAt(this.pos), code;
  if (ch === 123) {
    if (this.options.ecmaVersion < 6) {
      this.unexpected();
    }
    var codePos = ++this.pos;
    code = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos);
    ++this.pos;
    if (code > 1114111) {
      this.invalidStringToken(codePos, "Code point out of bounds");
    }
  } else {
    code = this.readHexChar(4);
  }
  return code;
};
pp.readString = function(quote) {
  var out = "", chunkStart = ++this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated string constant");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === quote) {
      break;
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(false);
      chunkStart = this.pos;
    } else if (ch === 8232 || ch === 8233) {
      if (this.options.ecmaVersion < 10) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
      if (this.options.locations) {
        this.curLine++;
        this.lineStart = this.pos;
      }
    } else {
      if (isNewLine(ch)) {
        this.raise(this.start, "Unterminated string constant");
      }
      ++this.pos;
    }
  }
  out += this.input.slice(chunkStart, this.pos++);
  return this.finishToken(types$1.string, out);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
  this.inTemplateElement = true;
  try {
    this.readTmplToken();
  } catch (err2) {
    if (err2 === INVALID_TEMPLATE_ESCAPE_ERROR) {
      this.readInvalidTemplateToken();
    } else {
      throw err2;
    }
  }
  this.inTemplateElement = false;
};
pp.invalidStringToken = function(position, message) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  } else {
    this.raise(position, message);
  }
};
pp.readTmplToken = function() {
  var out = "", chunkStart = this.pos;
  for (; ; ) {
    if (this.pos >= this.input.length) {
      this.raise(this.start, "Unterminated template");
    }
    var ch = this.input.charCodeAt(this.pos);
    if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) {
      if (this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate)) {
        if (ch === 36) {
          this.pos += 2;
          return this.finishToken(types$1.dollarBraceL);
        } else {
          ++this.pos;
          return this.finishToken(types$1.backQuote);
        }
      }
      out += this.input.slice(chunkStart, this.pos);
      return this.finishToken(types$1.template, out);
    }
    if (ch === 92) {
      out += this.input.slice(chunkStart, this.pos);
      out += this.readEscapedChar(true);
      chunkStart = this.pos;
    } else if (isNewLine(ch)) {
      out += this.input.slice(chunkStart, this.pos);
      ++this.pos;
      switch (ch) {
        case 13:
          if (this.input.charCodeAt(this.pos) === 10) {
            ++this.pos;
          }
        case 10:
          out += "\n";
          break;
        default:
          out += String.fromCharCode(ch);
          break;
      }
      if (this.options.locations) {
        ++this.curLine;
        this.lineStart = this.pos;
      }
      chunkStart = this.pos;
    } else {
      ++this.pos;
    }
  }
};
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++) {
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{") {
          break;
        }
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
      case "\r":
        if (this.input[this.pos + 1] === "\n") {
          ++this.pos;
        }
      case "\n":
      case "\u2028":
      case "\u2029":
        ++this.curLine;
        this.lineStart = this.pos + 1;
        break;
    }
  }
  this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(inTemplate) {
  var ch = this.input.charCodeAt(++this.pos);
  ++this.pos;
  switch (ch) {
    case 110:
      return "\n";
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return codePointToString(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      if (this.input.charCodeAt(this.pos) === 10) {
        ++this.pos;
      }
    case 10:
      if (this.options.locations) {
        this.lineStart = this.pos;
        ++this.curLine;
      }
      return "";
    case 56:
    case 57:
      if (this.strict) {
        this.invalidStringToken(
          this.pos - 1,
          "Invalid escape sequence"
        );
      }
      if (inTemplate) {
        var codePos = this.pos - 1;
        this.invalidStringToken(
          codePos,
          "Invalid escape sequence in template string"
        );
      }
    default:
      if (ch >= 48 && ch <= 55) {
        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];
        var octal = parseInt(octalStr, 8);
        if (octal > 255) {
          octalStr = octalStr.slice(0, -1);
          octal = parseInt(octalStr, 8);
        }
        this.pos += octalStr.length - 1;
        ch = this.input.charCodeAt(this.pos);
        if ((octalStr !== "0" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {
          this.invalidStringToken(
            this.pos - 1 - octalStr.length,
            inTemplate ? "Octal literal in template string" : "Octal literal in strict mode"
          );
        }
        return String.fromCharCode(octal);
      }
      if (isNewLine(ch)) {
        if (this.options.locations) {
          this.lineStart = this.pos;
          ++this.curLine;
        }
        return "";
      }
      return String.fromCharCode(ch);
  }
};
pp.readHexChar = function(len) {
  var codePos = this.pos;
  var n3 = this.readInt(16, len);
  if (n3 === null) {
    this.invalidStringToken(codePos, "Bad character escape sequence");
  }
  return n3;
};
pp.readWord1 = function() {
  this.containsEsc = false;
  var word = "", first = true, chunkStart = this.pos;
  var astral = this.options.ecmaVersion >= 6;
  while (this.pos < this.input.length) {
    var ch = this.fullCharCodeAtPos();
    if (isIdentifierChar(ch, astral)) {
      this.pos += ch <= 65535 ? 1 : 2;
    } else if (ch === 92) {
      this.containsEsc = true;
      word += this.input.slice(chunkStart, this.pos);
      var escStart = this.pos;
      if (this.input.charCodeAt(++this.pos) !== 117) {
        this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX");
      }
      ++this.pos;
      var esc2 = this.readCodePoint();
      if (!(first ? isIdentifierStart : isIdentifierChar)(esc2, astral)) {
        this.invalidStringToken(escStart, "Invalid Unicode escape");
      }
      word += codePointToString(esc2);
      chunkStart = this.pos;
    } else {
      break;
    }
    first = false;
  }
  return word + this.input.slice(chunkStart, this.pos);
};
pp.readWord = function() {
  var word = this.readWord1();
  var type3 = types$1.name;
  if (this.keywords.test(word)) {
    type3 = keywords[word];
  }
  return this.finishToken(type3, word);
};
var version2 = "8.15.0";
Parser.acorn = {
  Parser,
  version: version2,
  defaultOptions,
  Position,
  SourceLocation,
  getLineInfo,
  Node,
  TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext,
  tokContexts: types,
  isIdentifierChar,
  isIdentifierStart,
  Token,
  isNewLine,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace
};
function parse7(input, options2) {
  return Parser.parse(input, options2);
}

// node_modules/acorn-walk/dist/walk.mjs
function simple(node, visitors, baseVisitor, state, override) {
  if (!baseVisitor) {
    baseVisitor = base;
  }
  (function c4(node2, st, override2) {
    var type3 = override2 || node2.type;
    baseVisitor[type3](node2, st, c4);
    if (visitors[type3]) {
      visitors[type3](node2, st);
    }
  })(node, state, override);
}
function ancestor(node, visitors, baseVisitor, state, override) {
  var ancestors = [];
  if (!baseVisitor) {
    baseVisitor = base;
  }
  (function c4(node2, st, override2) {
    var type3 = override2 || node2.type;
    var isNew = node2 !== ancestors[ancestors.length - 1];
    if (isNew) {
      ancestors.push(node2);
    }
    baseVisitor[type3](node2, st, c4);
    if (visitors[type3]) {
      visitors[type3](node2, st || ancestors, ancestors);
    }
    if (isNew) {
      ancestors.pop();
    }
  })(node, state, override);
}
function skipThrough(node, st, c4) {
  c4(node, st);
}
function ignore(_node, _st, _c2) {
}
var base = {};
base.Program = base.BlockStatement = base.StaticBlock = function(node, st, c4) {
  for (var i = 0, list = node.body; i < list.length; i += 1) {
    var stmt = list[i];
    c4(stmt, st, "Statement");
  }
};
base.Statement = skipThrough;
base.EmptyStatement = ignore;
base.ExpressionStatement = base.ParenthesizedExpression = base.ChainExpression = function(node, st, c4) {
  return c4(node.expression, st, "Expression");
};
base.IfStatement = function(node, st, c4) {
  c4(node.test, st, "Expression");
  c4(node.consequent, st, "Statement");
  if (node.alternate) {
    c4(node.alternate, st, "Statement");
  }
};
base.LabeledStatement = function(node, st, c4) {
  return c4(node.body, st, "Statement");
};
base.BreakStatement = base.ContinueStatement = ignore;
base.WithStatement = function(node, st, c4) {
  c4(node.object, st, "Expression");
  c4(node.body, st, "Statement");
};
base.SwitchStatement = function(node, st, c4) {
  c4(node.discriminant, st, "Expression");
  for (var i = 0, list = node.cases; i < list.length; i += 1) {
    var cs = list[i];
    c4(cs, st);
  }
};
base.SwitchCase = function(node, st, c4) {
  if (node.test) {
    c4(node.test, st, "Expression");
  }
  for (var i = 0, list = node.consequent; i < list.length; i += 1) {
    var cons = list[i];
    c4(cons, st, "Statement");
  }
};
base.ReturnStatement = base.YieldExpression = base.AwaitExpression = function(node, st, c4) {
  if (node.argument) {
    c4(node.argument, st, "Expression");
  }
};
base.ThrowStatement = base.SpreadElement = function(node, st, c4) {
  return c4(node.argument, st, "Expression");
};
base.TryStatement = function(node, st, c4) {
  c4(node.block, st, "Statement");
  if (node.handler) {
    c4(node.handler, st);
  }
  if (node.finalizer) {
    c4(node.finalizer, st, "Statement");
  }
};
base.CatchClause = function(node, st, c4) {
  if (node.param) {
    c4(node.param, st, "Pattern");
  }
  c4(node.body, st, "Statement");
};
base.WhileStatement = base.DoWhileStatement = function(node, st, c4) {
  c4(node.test, st, "Expression");
  c4(node.body, st, "Statement");
};
base.ForStatement = function(node, st, c4) {
  if (node.init) {
    c4(node.init, st, "ForInit");
  }
  if (node.test) {
    c4(node.test, st, "Expression");
  }
  if (node.update) {
    c4(node.update, st, "Expression");
  }
  c4(node.body, st, "Statement");
};
base.ForInStatement = base.ForOfStatement = function(node, st, c4) {
  c4(node.left, st, "ForInit");
  c4(node.right, st, "Expression");
  c4(node.body, st, "Statement");
};
base.ForInit = function(node, st, c4) {
  if (node.type === "VariableDeclaration") {
    c4(node, st);
  } else {
    c4(node, st, "Expression");
  }
};
base.DebuggerStatement = ignore;
base.FunctionDeclaration = function(node, st, c4) {
  return c4(node, st, "Function");
};
base.VariableDeclaration = function(node, st, c4) {
  for (var i = 0, list = node.declarations; i < list.length; i += 1) {
    var decl = list[i];
    c4(decl, st);
  }
};
base.VariableDeclarator = function(node, st, c4) {
  c4(node.id, st, "Pattern");
  if (node.init) {
    c4(node.init, st, "Expression");
  }
};
base.Function = function(node, st, c4) {
  if (node.id) {
    c4(node.id, st, "Pattern");
  }
  for (var i = 0, list = node.params; i < list.length; i += 1) {
    var param = list[i];
    c4(param, st, "Pattern");
  }
  c4(node.body, st, node.expression ? "Expression" : "Statement");
};
base.Pattern = function(node, st, c4) {
  if (node.type === "Identifier") {
    c4(node, st, "VariablePattern");
  } else if (node.type === "MemberExpression") {
    c4(node, st, "MemberPattern");
  } else {
    c4(node, st);
  }
};
base.VariablePattern = ignore;
base.MemberPattern = skipThrough;
base.RestElement = function(node, st, c4) {
  return c4(node.argument, st, "Pattern");
};
base.ArrayPattern = function(node, st, c4) {
  for (var i = 0, list = node.elements; i < list.length; i += 1) {
    var elt = list[i];
    if (elt) {
      c4(elt, st, "Pattern");
    }
  }
};
base.ObjectPattern = function(node, st, c4) {
  for (var i = 0, list = node.properties; i < list.length; i += 1) {
    var prop = list[i];
    if (prop.type === "Property") {
      if (prop.computed) {
        c4(prop.key, st, "Expression");
      }
      c4(prop.value, st, "Pattern");
    } else if (prop.type === "RestElement") {
      c4(prop.argument, st, "Pattern");
    }
  }
};
base.Expression = skipThrough;
base.ThisExpression = base.Super = base.MetaProperty = ignore;
base.ArrayExpression = function(node, st, c4) {
  for (var i = 0, list = node.elements; i < list.length; i += 1) {
    var elt = list[i];
    if (elt) {
      c4(elt, st, "Expression");
    }
  }
};
base.ObjectExpression = function(node, st, c4) {
  for (var i = 0, list = node.properties; i < list.length; i += 1) {
    var prop = list[i];
    c4(prop, st);
  }
};
base.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;
base.SequenceExpression = function(node, st, c4) {
  for (var i = 0, list = node.expressions; i < list.length; i += 1) {
    var expr = list[i];
    c4(expr, st, "Expression");
  }
};
base.TemplateLiteral = function(node, st, c4) {
  for (var i = 0, list = node.quasis; i < list.length; i += 1) {
    var quasi = list[i];
    c4(quasi, st);
  }
  for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1) {
    var expr = list$1[i$1];
    c4(expr, st, "Expression");
  }
};
base.TemplateElement = ignore;
base.UnaryExpression = base.UpdateExpression = function(node, st, c4) {
  c4(node.argument, st, "Expression");
};
base.BinaryExpression = base.LogicalExpression = function(node, st, c4) {
  c4(node.left, st, "Expression");
  c4(node.right, st, "Expression");
};
base.AssignmentExpression = base.AssignmentPattern = function(node, st, c4) {
  c4(node.left, st, "Pattern");
  c4(node.right, st, "Expression");
};
base.ConditionalExpression = function(node, st, c4) {
  c4(node.test, st, "Expression");
  c4(node.consequent, st, "Expression");
  c4(node.alternate, st, "Expression");
};
base.NewExpression = base.CallExpression = function(node, st, c4) {
  c4(node.callee, st, "Expression");
  if (node.arguments) {
    for (var i = 0, list = node.arguments; i < list.length; i += 1) {
      var arg = list[i];
      c4(arg, st, "Expression");
    }
  }
};
base.MemberExpression = function(node, st, c4) {
  c4(node.object, st, "Expression");
  if (node.computed) {
    c4(node.property, st, "Expression");
  }
};
base.ExportNamedDeclaration = base.ExportDefaultDeclaration = function(node, st, c4) {
  if (node.declaration) {
    c4(node.declaration, st, node.type === "ExportNamedDeclaration" || node.declaration.id ? "Statement" : "Expression");
  }
  if (node.source) {
    c4(node.source, st, "Expression");
  }
};
base.ExportAllDeclaration = function(node, st, c4) {
  if (node.exported) {
    c4(node.exported, st);
  }
  c4(node.source, st, "Expression");
};
base.ImportDeclaration = function(node, st, c4) {
  for (var i = 0, list = node.specifiers; i < list.length; i += 1) {
    var spec = list[i];
    c4(spec, st);
  }
  c4(node.source, st, "Expression");
};
base.ImportExpression = function(node, st, c4) {
  c4(node.source, st, "Expression");
};
base.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.PrivateIdentifier = base.Literal = ignore;
base.TaggedTemplateExpression = function(node, st, c4) {
  c4(node.tag, st, "Expression");
  c4(node.quasi, st, "Expression");
};
base.ClassDeclaration = base.ClassExpression = function(node, st, c4) {
  return c4(node, st, "Class");
};
base.Class = function(node, st, c4) {
  if (node.id) {
    c4(node.id, st, "Pattern");
  }
  if (node.superClass) {
    c4(node.superClass, st, "Expression");
  }
  c4(node.body, st);
};
base.ClassBody = function(node, st, c4) {
  for (var i = 0, list = node.body; i < list.length; i += 1) {
    var elt = list[i];
    c4(elt, st);
  }
};
base.MethodDefinition = base.PropertyDefinition = base.Property = function(node, st, c4) {
  if (node.computed) {
    c4(node.key, st, "Expression");
  }
  if (node.value) {
    c4(node.value, st, "Expression");
  }
};

// node_modules/p5/dist/core/friendly_errors/sketch_verifier.js
var ignoreFunction = [
  "setup",
  "draw",
  "preload",
  "deviceMoved",
  "deviceTurned",
  "deviceShaken",
  "doubleClicked",
  "mousePressed",
  "mouseReleased",
  "mouseMoved",
  "mouseDragged",
  "mouseClicked",
  "mouseWheel",
  "touchStarted",
  "touchMoved",
  "touchEnded",
  "keyPressed",
  "keyReleased",
  "keyTyped",
  "windowResized"
  // 'name',
  // 'parent',
  // 'toString',
  // 'print',
  // 'stop',
  // 'onended'
];
var verifierUtils = {
  /**
    * Fetches the contents of a script element in the user's sketch.
    *
    * @private
    * @method fetchScript
    * @param {HTMLScriptElement} script
    * @returns {Promise<string>}
  */
  fetchScript: async function(script) {
    if (script.src) {
      try {
        const contents = await fetch(script.src).then((res) => res.text());
        return contents;
      } catch (error42) {
        console.error("Error fetching script:", error42);
        return "";
      }
    } else {
      return script.textContent;
    }
  },
  /**
   * Extracts the user-defined variables and functions from the user code with
   * the help of Espree parser.
   *
   * @private
   * @method extractUserDefinedVariablesAndFuncs
   * @param {String} code - The code to extract variables and functions from.
   * @returns {Object} An object containing the user's defined variables and functions.
   * @returns {Array<{name: string, line: number}>} [userDefinitions.variables] Array of user-defined variable names and their line numbers.
   * @returns {Array<{name: string, line: number}>} [userDefinitions.functions] Array of user-defined function names and their line numbers.
   */
  extractUserDefinedVariablesAndFuncs: function(code) {
    const userDefinitions = {
      variables: [],
      functions: []
    };
    const lineOffset = -1;
    try {
      const ast = parse7(code, {
        ecmaVersion: 2021,
        sourceType: "module",
        locations: true
        // This helps us get the line number.
      });
      simple(ast, {
        VariableDeclarator(node) {
          if (node.id.type === "Identifier") {
            const category = node.init && ["ArrowFunctionExpression", "FunctionExpression"].includes(node.init.type) ? "functions" : "variables";
            userDefinitions[category].push({
              name: node.id.name,
              line: node.loc.start.line + lineOffset
            });
          }
        },
        FunctionDeclaration(node) {
          if (node.id && node.id.type === "Identifier") {
            userDefinitions.functions.push({
              name: node.id.name,
              line: node.loc.start.line + lineOffset
            });
          }
        },
        // We consider class declarations to be a special form of variable
        // declaration.
        ClassDeclaration(node) {
          if (node.id && node.id.type === "Identifier") {
            userDefinitions.variables.push({
              name: node.id.name,
              line: node.loc.start.line + lineOffset
            });
          }
        }
      });
    } catch (error42) {
      console.error("Error parsing code:", error42);
    }
    return userDefinitions;
  },
  /**
   * Checks user-defined variables and functions for conflicts with p5.js
   * constants and global functions.
   *
   * This function performs two main checks:
   * 1. Verifies if any user definition conflicts with p5.js constants.
   * 2. Checks if any user definition conflicts with global functions from
   * p5.js renderer classes.
   *
   * If a conflict is found, it reports a friendly error message and halts
   * further checking.
   *
   * @private
   * @param {Object} userDefinitions - An object containing user-defined variables and functions.
   * @param {Array<{name: string, line: number}>} userDefinitions.variables - Array of user-defined variable names and their line numbers.
   * @param {Array<{name: string, line: number}>} userDefinitions.functions - Array of user-defined function names and their line numbers.
   * @returns {boolean} - Returns true if a conflict is found, false otherwise.
   */
  checkForConstsAndFuncs: function(userDefinitions, p53) {
    const allDefinitions = [
      ...userDefinitions.variables,
      ...userDefinitions.functions
    ];
    function generateFriendlyError(errorType, name, line) {
      const url2 = `https://p5js.org/reference/p5/${name}`;
      const message = `${errorType} "${name}" on line ${line} is being redeclared and conflicts with a p5.js ${errorType.toLowerCase()}. p5.js reference: ${url2}`;
      return message;
    }
    for (let { name, line } of allDefinitions) {
      const libDefinition = constants[name];
      if (libDefinition !== void 0) {
        const message = generateFriendlyError("Constant", name, line);
        console.log(message);
        return true;
      }
    }
    const globalFunctions = new Set(
      Object.getOwnPropertyNames(p53.prototype).filter((key) => !key.startsWith("_") && key !== "constructor")
    );
    for (let { name, line } of allDefinitions) {
      if (!ignoreFunction.includes(name) && globalFunctions.has(name)) {
        const message = generateFriendlyError("Function", name, line);
        console.log(message);
        return true;
      }
    }
    return false;
  },
  /**
   * Extracts the user's code from the script fetched. Note that this method
   * assumes that the user's code is always the last script element in the
   * sketch.
   *
   * @private
   * @method getUserCode
   * @returns {Promise<string>} The user's code as a string.
   */
  getUserCode: async function() {
    const scripts = document.querySelectorAll("script");
    const userCodeScript = scripts[scripts.length - 1];
    const userCode = await verifierUtils.fetchScript(userCodeScript);
    return userCode;
  },
  /**
   * @private
   */
  runFES: async function(p53) {
    const userCode = await verifierUtils.getUserCode();
    const userDefinedVariablesAndFuncs = verifierUtils.extractUserDefinedVariablesAndFuncs(userCode);
    verifierUtils.checkForConstsAndFuncs(userDefinedVariablesAndFuncs, p53);
  }
};
function sketchVerifier(p53, _fn, lifecycles) {
  lifecycles.presetup = async function() {
    if (!p53.disableFriendlyErrors && !p53.disableSketchChecker) {
      verifierUtils.runFES(p53);
    }
  };
}
if (typeof p5 !== "undefined") {
  sketchVerifier(p5, p5.prototype);
}

// node_modules/p5/dist/core/friendly_errors/file_errors.js
function fileErrors(p53, fn2) {
  const fileLoadErrorCases = (num, filePath) => {
    const suggestion = translator("fes.fileLoadError.suggestion", {
      filePath,
      url: "https://github.com/processing/p5.js/wiki/Local-server"
    });
    switch (num) {
      case 0:
        return {
          message: translator("fes.fileLoadError.image", {
            suggestion
          }),
          method: "loadImage"
        };
      case 1:
        return {
          message: translator("fes.fileLoadError.xml", {
            suggestion
          }),
          method: "loadXML"
        };
      case 2:
        return {
          message: translator("fes.fileLoadError.table", {
            suggestion
          }),
          method: "loadTable"
        };
      case 3:
        return {
          message: translator("fes.fileLoadError.strings", {
            suggestion
          }),
          method: "loadStrings"
        };
      case 4:
        return {
          message: translator("fes.fileLoadError.font", {
            suggestion
          }),
          method: "loadFont"
        };
      case 5:
        return {
          message: translator("fes.fileLoadError.json", {
            suggestion
          }),
          method: "loadJSON"
        };
      case 6:
        return {
          message: translator("fes.fileLoadError.bytes", {
            suggestion
          }),
          method: "loadBytes"
        };
      case 7:
        return {
          message: translator("fes.fileLoadError.large"),
          method: "loadX"
        };
      case 8:
        return {
          message: translator("fes.fileLoadError.gif"),
          method: "loadImage"
        };
    }
  };
  p53._friendlyFileLoadError = function(errorType, filePath) {
    const { message, method } = fileLoadErrorCases(errorType, filePath);
    p53._friendlyError(message, method, 3);
  };
}
if (typeof p5 !== "undefined") {
  fileErrors(p5, p5.prototype);
}

// node_modules/p5/dist/core/friendly_errors/index.js
function friendlyErrors(p53) {
  p53.registerAddon(fesCore);
  p53.registerAddon(stacktrace);
  p53.registerAddon(validateParams);
  p53.registerAddon(sketchVerifier);
  p53.registerAddon(fileErrors);
}

// node_modules/p5/dist/data/local_storage.js
function storage(p53, fn2) {
  fn2.storeItem = function(key, value) {
    if (typeof key !== "string") {
      console.log(
        `The argument that you passed to storeItem() - ${key} is not a string.`
      );
    }
    if (key.endsWith("p5TypeID")) {
      console.log(
        `The argument that you passed to storeItem() - ${key} must not end with 'p5TypeID'.`
      );
    }
    if (typeof value === "undefined") {
      console.log("You cannot store undefined variables using storeItem().");
    }
    let type3 = typeof value;
    switch (type3) {
      case "number":
      case "boolean":
        value = value.toString();
        break;
      case "object":
        if (value instanceof p53.Color) {
          type3 = "p5.Color";
          value = value.toString();
        } else if (value instanceof p53.Vector) {
          type3 = "p5.Vector";
          const coord = [value.x, value.y, value.z];
          value = coord;
        }
        value = JSON.stringify(value);
        break;
    }
    localStorage.setItem(key, value);
    const typeKey = `${key}p5TypeID`;
    localStorage.setItem(typeKey, type3);
  };
  fn2.getItem = function(key) {
    let value = localStorage.getItem(key);
    const type3 = localStorage.getItem(`${key}p5TypeID`);
    if (typeof type3 === "undefined") {
      console.log(
        `Unable to determine type of item stored under ${key}in local storage. Did you save the item with something other than setItem()?`
      );
    } else if (value !== null) {
      switch (type3) {
        case "number":
          value = parseFloat(value);
          break;
        case "boolean":
          value = value === "true";
          break;
        case "object":
          value = JSON.parse(value);
          break;
        case "p5.Color":
          value = this.color(JSON.parse(value));
          break;
        case "p5.Vector":
          value = JSON.parse(value);
          value = this.createVector(...value);
          break;
      }
    }
    return value;
  };
  fn2.clearStorage = function() {
    const keys = Object.keys(localStorage);
    keys.forEach((key) => {
      if (key.endsWith("p5TypeID")) {
        this.removeItem(key.replace("p5TypeID", ""));
      }
    });
  };
  fn2.removeItem = function(key) {
    if (typeof key !== "string") {
      console.log(
        `The argument that you passed to removeItem() - ${key} is not a string.`
      );
    }
    localStorage.removeItem(key);
    localStorage.removeItem(`${key}p5TypeID`);
  };
}
if (typeof p5 !== "undefined") {
  storage(p5, p5.prototype);
}

// node_modules/p5/dist/data/index.js
function data2(p53) {
  p53.registerAddon(storage);
}

// node_modules/p5/dist/dom/dom.js
function dom(p53, fn2) {
  fn2.select = function(e2, p2) {
    const container = this._getContainer(p2);
    const res = container.querySelector(e2);
    if (res) {
      return this._wrapElement(res);
    } else {
      return null;
    }
  };
  fn2.selectAll = function(e2, p2) {
    const arr2 = [];
    const container = this._getContainer(p2);
    const res = container.querySelectorAll(e2);
    if (res) {
      for (let j2 = 0; j2 < res.length; j2++) {
        const obj = this._wrapElement(res[j2]);
        arr2.push(obj);
      }
    }
    return arr2;
  };
  fn2._getContainer = function(p2) {
    let container = document;
    if (typeof p2 === "string") {
      container = document.querySelector(p2) || document;
    } else if (p2 instanceof Element) {
      container = p2.elt;
    } else if (p2 instanceof HTMLElement) {
      container = p2;
    }
    return container;
  };
  fn2._wrapElement = function(elt) {
    const children = Array.prototype.slice.call(elt.children);
    if (elt.tagName === "INPUT" && elt.type === "checkbox") {
      let converted = new Element(elt, this);
      converted.checked = function(...args) {
        if (args.length === 0) {
          return this.elt.checked;
        } else if (args[0]) {
          this.elt.checked = true;
        } else {
          this.elt.checked = false;
        }
        return this;
      };
      return converted;
    } else if (elt.tagName === "VIDEO" || elt.tagName === "AUDIO") {
      return new MediaElement(elt, this);
    } else if (elt.tagName === "SELECT") {
      return this.createSelect(new Element(elt, this));
    } else if (children.length > 0 && children.every(function(c4) {
      return c4.tagName === "INPUT" || c4.tagName === "LABEL";
    }) && (elt.tagName === "DIV" || elt.tagName === "SPAN")) {
      return this.createRadio(new Element(elt, this));
    } else {
      return new Element(elt, this);
    }
  };
  fn2.createElement = function(tag, content) {
    const elt = document.createElement(tag);
    if (typeof content !== "undefined") {
      elt.innerHTML = content;
    }
    return addElement(elt, this);
  };
  fn2.removeElements = function(e2) {
    const isNotCanvasElement = (el) => !(el.elt instanceof HTMLCanvasElement);
    const removeableElements = this._elements.filter(isNotCanvasElement);
    removeableElements.map((el) => el.remove());
  };
  function addElement(elt, pInst, media2) {
    const node = pInst._userNode ? pInst._userNode : document.body;
    node.appendChild(elt);
    const c4 = media2 ? new MediaElement(elt, pInst) : new Element(elt, pInst);
    pInst._elements.push(c4);
    return c4;
  }
  fn2.createDiv = function(html = "") {
    let elt = document.createElement("div");
    elt.innerHTML = html;
    return addElement(elt, this);
  };
  fn2.createP = function(html = "") {
    let elt = document.createElement("p");
    elt.innerHTML = html;
    return addElement(elt, this);
  };
  fn2.createSpan = function(html = "") {
    let elt = document.createElement("span");
    elt.innerHTML = html;
    return addElement(elt, this);
  };
  fn2.createImg = function() {
    const elt = document.createElement("img");
    const args = arguments;
    let self2;
    if (args.length > 1 && typeof args[1] === "string") {
      elt.alt = args[1];
    }
    if (args.length > 2 && typeof args[2] === "string") {
      elt.crossOrigin = args[2];
    }
    elt.src = args[0];
    self2 = addElement(elt, this);
    elt.addEventListener("load", function() {
      self2.width = elt.offsetWidth || elt.width;
      self2.height = elt.offsetHeight || elt.height;
      const last2 = args[args.length - 1];
      if (typeof last2 === "function") last2(self2);
    });
    return self2;
  };
  fn2.createA = function(href, html, target) {
    const elt = document.createElement("a");
    elt.href = href;
    elt.innerHTML = html;
    if (target) elt.target = target;
    return addElement(elt, this);
  };
  fn2.createSlider = function(min, max, value, step) {
    const elt = document.createElement("input");
    elt.type = "range";
    elt.min = min;
    elt.max = max;
    if (step === 0) {
      elt.step = 1e-18;
    } else if (step) {
      elt.step = step;
    }
    if (typeof value === "number") elt.value = value;
    return addElement(elt, this);
  };
  fn2.createButton = function(label, value) {
    const elt = document.createElement("button");
    elt.innerHTML = label;
    if (value) elt.value = value;
    return addElement(elt, this);
  };
  fn2.createCheckbox = function(...args) {
    const elt = document.createElement("div");
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    const label = document.createElement("label");
    label.appendChild(checkbox);
    elt.appendChild(label);
    const self2 = addElement(elt, this);
    self2.checked = function(...args2) {
      const cb = self2.elt.firstElementChild.getElementsByTagName("input")[0];
      if (cb) {
        if (args2.length === 0) {
          return cb.checked;
        } else if (args2[0]) {
          cb.checked = true;
        } else {
          cb.checked = false;
        }
      }
      return self2;
    };
    this.value = function(val2) {
      self2.value = val2;
      return this;
    };
    if (args[0]) {
      self2.value(args[0]);
      const span = document.createElement("span");
      span.innerHTML = args[0];
      label.appendChild(span);
    }
    if (args[1]) {
      checkbox.checked = true;
    }
    return self2;
  };
  fn2.createSelect = function(...args) {
    let self2;
    let arg = args[0];
    if (arg instanceof Element && arg.elt instanceof HTMLSelectElement) {
      self2 = arg;
      this.elt = arg.elt;
    } else if (arg instanceof HTMLSelectElement) {
      self2 = addElement(arg, this);
      this.elt = arg;
    } else {
      const elt = document.createElement("select");
      if (arg && typeof arg === "boolean") {
        elt.setAttribute("multiple", "true");
      }
      self2 = addElement(elt, this);
      this.elt = elt;
    }
    self2.option = function(name, value) {
      let index;
      if (name === void 0) {
        return;
      }
      for (let i = 0; i < this.elt.length; i += 1) {
        if (this.elt[i].textContent === name) {
          index = i;
          break;
        }
      }
      if (index !== void 0) {
        if (value === false) {
          this.elt.remove(index);
        } else {
          this.elt[index].value = value;
        }
      } else {
        const opt = document.createElement("option");
        opt.textContent = name;
        opt.value = value === void 0 ? name : value;
        this.elt.appendChild(opt);
        this._pInst._elements.push(opt);
      }
    };
    self2.selected = function(value) {
      if (value !== void 0) {
        for (let i = 0; i < this.elt.length; i += 1) {
          if (this.elt[i].value.toString() === value.toString()) {
            this.elt.selectedIndex = i;
          }
        }
        return this;
      } else {
        if (this.elt.getAttribute("multiple")) {
          let arr2 = [];
          for (const selectedOption of this.elt.selectedOptions) {
            arr2.push(selectedOption.value);
          }
          return arr2;
        } else {
          return this.elt.value;
        }
      }
    };
    self2.disable = function(value) {
      if (typeof value === "string") {
        for (let i = 0; i < this.elt.length; i++) {
          if (this.elt[i].value.toString() === value) {
            this.elt[i].disabled = true;
            this.elt[i].selected = false;
          }
        }
      } else {
        this.elt.disabled = true;
      }
      return this;
    };
    self2.enable = function(value) {
      if (typeof value === "string") {
        for (let i = 0; i < this.elt.length; i++) {
          if (this.elt[i].value.toString() === value) {
            this.elt[i].disabled = false;
            this.elt[i].selected = false;
          }
        }
      } else {
        this.elt.disabled = false;
        for (let i = 0; i < this.elt.length; i++) {
          this.elt[i].disabled = false;
          this.elt[i].selected = false;
        }
      }
      return this;
    };
    return self2;
  };
  let counter = 0;
  fn2.createRadio = function(...args) {
    let self2;
    let radioElement;
    let name;
    const arg0 = args[0];
    if (arg0 instanceof Element && (arg0.elt instanceof HTMLDivElement || arg0.elt instanceof HTMLSpanElement)) {
      self2 = arg0;
      this.elt = arg0.elt;
    } else if (
      // If existing radio Element is provided as argument 0
      arg0 instanceof HTMLDivElement || arg0 instanceof HTMLSpanElement
    ) {
      self2 = addElement(arg0, this);
      this.elt = arg0;
      radioElement = arg0;
      if (typeof args[1] === "string") name = args[1];
    } else {
      if (typeof arg0 === "string") name = arg0;
      radioElement = document.createElement("div");
      self2 = addElement(radioElement, this);
      this.elt = radioElement;
    }
    self2._name = name || `radioOption_${counter++}`;
    const isRadioInput = (el) => el instanceof HTMLInputElement && el.type === "radio";
    const isLabelElement = (el) => el instanceof HTMLLabelElement;
    const isSpanElement = (el) => el instanceof HTMLSpanElement;
    self2._getOptionsArray = function() {
      return Array.from(this.elt.children).filter(
        (el) => isRadioInput(el) || isLabelElement(el) && isRadioInput(el.firstElementChild)
      ).map((el) => isRadioInput(el) ? el : el.firstElementChild);
    };
    self2.option = function(value, label) {
      let optionEl;
      for (const option of self2._getOptionsArray()) {
        if (option.value === value) {
          optionEl = option;
          break;
        }
      }
      if (optionEl === void 0) {
        optionEl = document.createElement("input");
        optionEl.setAttribute("type", "radio");
        optionEl.setAttribute("value", value);
      }
      optionEl.setAttribute("name", self2._name);
      let labelElement;
      if (!isLabelElement(optionEl.parentElement)) {
        labelElement = document.createElement("label");
        labelElement.insertAdjacentElement("afterbegin", optionEl);
      } else {
        labelElement = optionEl.parentElement;
      }
      let spanElement;
      if (!isSpanElement(labelElement.lastElementChild)) {
        spanElement = document.createElement("span");
        optionEl.insertAdjacentElement("afterend", spanElement);
      } else {
        spanElement = labelElement.lastElementChild;
      }
      spanElement.innerHTML = label === void 0 ? value : label;
      this.elt.appendChild(labelElement);
      return optionEl;
    };
    self2.remove = function(value) {
      for (const optionEl of self2._getOptionsArray()) {
        if (optionEl.value === value) {
          if (isLabelElement(optionEl.parentElement)) {
            optionEl.parentElement.remove();
          } else {
            optionEl.remove();
          }
          return;
        }
      }
    };
    self2.value = function() {
      let result = "";
      for (const option of self2._getOptionsArray()) {
        if (option.checked) {
          result = option.value;
          break;
        }
      }
      return result;
    };
    self2.selected = function(value) {
      let result = null;
      if (value === void 0) {
        for (const option of self2._getOptionsArray()) {
          if (option.checked) {
            result = option;
            break;
          }
        }
      } else {
        self2._getOptionsArray().forEach((option) => {
          option.checked = false;
          option.removeAttribute("checked");
        });
        for (const option of self2._getOptionsArray()) {
          if (option.value === value) {
            option.setAttribute("checked", true);
            option.checked = true;
            result = option;
          }
        }
      }
      return result;
    };
    self2.disable = function(shouldDisable = true) {
      for (const radioInput of self2._getOptionsArray()) {
        radioInput.setAttribute("disabled", shouldDisable);
      }
    };
    return self2;
  };
  fn2.createColorPicker = function(value) {
    const elt = document.createElement("input");
    let self2;
    elt.type = "color";
    if (value) {
      if (value instanceof p53.Color) {
        elt.value = value.toString("#rrggbb");
      } else {
        this.push();
        this.colorMode("rgb");
        elt.value = this.color(value).toString("#rrggbb");
        this.pop();
      }
    } else {
      elt.value = "#000000";
    }
    self2 = addElement(elt, this);
    const inst = this;
    self2.color = function() {
      inst.push();
      if (value) {
        if (value.mode) {
          inst.colorMode(value.mode, ...(value == null ? void 0 : value.maxes) ? value.maxes[value.mode] || [] : []);
        }
      }
      const c4 = inst.color(this.elt.value);
      inst.pop();
      return c4;
    };
    return self2;
  };
  fn2.createInput = function(value = "", type3 = "text") {
    let elt = document.createElement("input");
    elt.setAttribute("value", value);
    elt.setAttribute("type", type3);
    return addElement(elt, this);
  };
  fn2.createFileInput = function(callback, multiple = false) {
    const handleFileSelect = function(event) {
      for (const file3 of event.target.files) {
        File2._load(file3, callback);
      }
    };
    if (!(window.File && window.FileReader && window.FileList && window.Blob)) {
      console.log(
        "The File APIs are not fully supported in this browser. Cannot create element."
      );
      return;
    }
    const fileInput = document.createElement("input");
    fileInput.setAttribute("type", "file");
    if (multiple) fileInput.setAttribute("multiple", true);
    fileInput.addEventListener("change", handleFileSelect, false);
    return addElement(fileInput, this);
  };
}
if (typeof p5 !== "undefined") {
  dom(p5, p5.prototype);
}

// node_modules/p5/dist/dom/index.js
function dom2(p53) {
  p53.registerAddon(dom);
  p53.registerAddon(element);
  p53.registerAddon(media);
  p53.registerAddon(file);
}

// node_modules/p5/dist/events/acceleration.js
function acceleration(p53, fn2) {
  fn2.deviceOrientation = window.innerWidth / window.innerHeight > 1 ? "landscape" : "portrait";
  fn2.accelerationX = 0;
  fn2.accelerationY = 0;
  fn2.accelerationZ = 0;
  fn2.pAccelerationX = 0;
  fn2.pAccelerationY = 0;
  fn2.pAccelerationZ = 0;
  fn2._updatePAccelerations = function() {
    this.pAccelerationX = this.accelerationX;
    this.pAccelerationY = this.accelerationY;
    this.pAccelerationZ = this.accelerationZ;
  };
  fn2.rotationX = 0;
  fn2.rotationY = 0;
  fn2.rotationZ = 0;
  fn2.pRotationX = 0;
  fn2.pRotationY = 0;
  fn2.pRotationZ = 0;
  let startAngleX = 0;
  let startAngleY = 0;
  let startAngleZ = 0;
  let rotateDirectionX = "clockwise";
  let rotateDirectionY = "clockwise";
  let rotateDirectionZ = "clockwise";
  fn2.pRotateDirectionX = void 0;
  fn2.pRotateDirectionY = void 0;
  fn2.pRotateDirectionZ = void 0;
  fn2._updatePRotations = function() {
    this.pRotationX = this.rotationX;
    this.pRotationY = this.rotationY;
    this.pRotationZ = this.rotationZ;
  };
  fn2.turnAxis = void 0;
  let move_threshold = 0.5;
  let shake_threshold = 30;
  fn2.setMoveThreshold = function(val2) {
    move_threshold = val2;
  };
  fn2.setShakeThreshold = function(val2) {
    shake_threshold = val2;
  };
  fn2._ondeviceorientation = function(e2) {
    this._updatePRotations();
    this.rotationX = this._fromDegrees(e2.beta);
    this.rotationY = this._fromDegrees(e2.gamma);
    this.rotationZ = this._fromDegrees(e2.alpha);
    this._handleMotion();
  };
  fn2._ondevicemotion = function(e2) {
    this._updatePAccelerations();
    this.accelerationX = e2.acceleration.x * 2;
    this.accelerationY = e2.acceleration.y * 2;
    this.accelerationZ = e2.acceleration.z * 2;
    this._handleMotion();
  };
  fn2._handleMotion = function() {
    if (window.orientation === 90 || window.orientation === -90) {
      this.deviceOrientation = "landscape";
    } else if (window.orientation === 0) {
      this.deviceOrientation = "portrait";
    } else if (window.orientation === void 0) {
      this.deviceOrientation = "undefined";
    }
    const context = this._isGlobal ? window : this;
    if (typeof context.deviceMoved === "function") {
      if (Math.abs(this.accelerationX - this.pAccelerationX) > move_threshold || Math.abs(this.accelerationY - this.pAccelerationY) > move_threshold || Math.abs(this.accelerationZ - this.pAccelerationZ) > move_threshold) {
        context.deviceMoved();
      }
    }
    if (typeof context.deviceTurned === "function") {
      const wRX = this._toDegrees(this.rotationX) + 180;
      const wPRX = this._toDegrees(this.pRotationX) + 180;
      let wSAX = startAngleX + 180;
      if (wRX - wPRX > 0 && wRX - wPRX < 270 || wRX - wPRX < -270) {
        rotateDirectionX = "clockwise";
      } else if (wRX - wPRX < 0 || wRX - wPRX > 270) {
        rotateDirectionX = "counter-clockwise";
      }
      if (rotateDirectionX !== this.pRotateDirectionX) {
        wSAX = wRX;
      }
      if (Math.abs(wRX - wSAX) > 90 && Math.abs(wRX - wSAX) < 270) {
        wSAX = wRX;
        this.turnAxis = "X";
        context.deviceTurned();
      }
      this.pRotateDirectionX = rotateDirectionX;
      startAngleX = wSAX - 180;
      const wRY = this._toDegrees(this.rotationY) + 180;
      const wPRY = this._toDegrees(this.pRotationY) + 180;
      let wSAY = startAngleY + 180;
      if (wRY - wPRY > 0 && wRY - wPRY < 270 || wRY - wPRY < -270) {
        rotateDirectionY = "clockwise";
      } else if (wRY - wPRY < 0 || wRY - this.pRotationY > 270) {
        rotateDirectionY = "counter-clockwise";
      }
      if (rotateDirectionY !== this.pRotateDirectionY) {
        wSAY = wRY;
      }
      if (Math.abs(wRY - wSAY) > 90 && Math.abs(wRY - wSAY) < 270) {
        wSAY = wRY;
        this.turnAxis = "Y";
        context.deviceTurned();
      }
      this.pRotateDirectionY = rotateDirectionY;
      startAngleY = wSAY - 180;
      const rotZ = this._toDegrees(this.rotationZ);
      const pRotZ = this._toDegrees(this.pRotationZ);
      if (rotZ - pRotZ > 0 && rotZ - pRotZ < 270 || rotZ - pRotZ < -270) {
        rotateDirectionZ = "clockwise";
      } else if (rotZ - pRotZ < 0 || rotZ - pRotZ > 270) {
        rotateDirectionZ = "counter-clockwise";
      }
      if (rotateDirectionZ !== this.pRotateDirectionZ) {
        startAngleZ = rotZ;
      }
      if (Math.abs(rotZ - startAngleZ) > 90 && Math.abs(rotZ - startAngleZ) < 270) {
        startAngleZ = rotZ;
        this.turnAxis = "Z";
        context.deviceTurned();
      }
      this.pRotateDirectionZ = rotateDirectionZ;
      this.turnAxis = void 0;
    }
    if (typeof context.deviceShaken === "function") {
      let accelerationChangeX;
      let accelerationChangeY;
      if (this.pAccelerationX !== null) {
        accelerationChangeX = Math.abs(this.accelerationX - this.pAccelerationX);
        accelerationChangeY = Math.abs(this.accelerationY - this.pAccelerationY);
      }
      if (accelerationChangeX + accelerationChangeY > shake_threshold) {
        context.deviceShaken();
      }
    }
  };
}
if (typeof p5 !== "undefined") {
  acceleration(p5, p5.prototype);
}

// node_modules/p5/dist/events/keyboard.js
function isCode(input) {
  const leftRightKeys = [
    "Alt",
    "Shift",
    "Control",
    "Meta"
  ];
  if (leftRightKeys.includes(input)) {
    return false;
  }
  if (typeof input !== "string") {
    return false;
  }
  return input.length > 1;
}
function keyboard(p53, fn2) {
  fn2.keyIsPressed = false;
  fn2.key = "";
  fn2.code = "";
  fn2.keyCode = 0;
  fn2._onkeydown = function(e2) {
    if (this._downKeys[e2.code]) {
      return;
    }
    this.keyIsPressed = true;
    this.keyCode = e2.which;
    this.key = e2.key;
    this.code = e2.code;
    this._downKeyCodes[e2.code] = true;
    this._downKeys[e2.key] = true;
    const context = this._isGlobal ? window : this;
    if (typeof context.keyPressed === "function" && !e2.charCode) {
      const executeDefault = context.keyPressed(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
  };
  fn2._onkeyup = function(e2) {
    const context = this._isGlobal ? window : this;
    if (typeof context.keyReleased === "function") {
      const executeDefault = context.keyReleased(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
    delete this._downKeyCodes[e2.code];
    delete this._downKeys[e2.key];
    if (!this._areDownKeys()) {
      this.keyIsPressed = false;
      this.key = "";
      this.code = "";
    } else {
      const lastPressedCode = Object.keys(this._downKeyCodes).pop();
      this.code = lastPressedCode;
      const lastPressedKey = Object.keys(this._downKeys).pop();
      this.key = lastPressedKey;
    }
  };
  fn2._onkeypress = function(e2) {
    if (e2.which === this._lastKeyCodeTyped && e2.repeat) {
      return;
    }
    this._lastKeyCodeTyped = e2.which;
    this.key = e2.key || String.fromCharCode(e2.which) || e2.which;
    const context = this._isGlobal ? window : this;
    if (typeof context.keyTyped === "function") {
      const executeDefault = context.keyTyped(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
  };
  fn2._onblur = function(e2) {
    this._downKeys = {};
  };
  fn2.keyIsDown = function(input) {
    if (isCode(input)) {
      return this._downKeyCodes[input] || this._downKeys[input] || false;
    } else {
      return this._downKeys[input] || this._downKeyCodes[input] || false;
    }
  };
  fn2._areDownKeys = function() {
    for (const key in this._downKeys) {
      if (this._downKeys.hasOwnProperty(key) && this._downKeys[key] === true) {
        return true;
      }
    }
    return false;
  };
}
if (typeof p5 !== "undefined") {
  keyboard(p5, p5.prototype);
}

// node_modules/p5/dist/events/pointer.js
function pointer(p53, fn2) {
  fn2.movedX = 0;
  fn2.movedY = 0;
  fn2._hasMouseInteracted = false;
  fn2.mouseX = 0;
  fn2.mouseY = 0;
  fn2.pmouseX = 0;
  fn2.pmouseY = 0;
  fn2.winMouseX = 0;
  fn2.winMouseY = 0;
  fn2.pwinMouseX = 0;
  fn2.pwinMouseY = 0;
  fn2.mouseButton = {
    left: false,
    right: false,
    center: false
  };
  fn2.touches = [];
  fn2._activePointers = /* @__PURE__ */ new Map();
  fn2.mouseIsPressed = false;
  fn2._updatePointerCoords = function(e2) {
    if (this._curElement !== null) {
      const canvas2 = this._curElement.elt;
      const sx = canvas2.scrollWidth / this.width || 1;
      const sy = canvas2.scrollHeight / this.height || 1;
      if (e2.pointerType == "touch") {
        const touches = [];
        for (const touch of this._activePointers.values()) {
          touches.push(getTouchInfo(canvas2, sx, sy, touch));
        }
        this.touches = touches;
      }
      const mousePos = getMouseInfo(canvas2, sx, sy, e2);
      this.movedX = e2.movementX || 0;
      this.movedY = e2.movementY || 0;
      this.mouseX = mousePos.x;
      this.mouseY = mousePos.y;
      this.winMouseX = mousePos.winX;
      this.winMouseY = mousePos.winY;
      if (!this._hasMouseInteracted) {
        this._updateMouseCoords();
        this._hasMouseInteracted = true;
      }
    }
  };
  fn2._updateMouseCoords = function() {
    this.pmouseX = this.mouseX;
    this.pmouseY = this.mouseY;
    this.pwinMouseX = this.winMouseX;
    this.pwinMouseY = this.winMouseY;
    this._pmouseWheelDeltaY = this._mouseWheelDeltaY;
  };
  function getMouseInfo(canvas2, sx, sy, evt) {
    const rect = canvas2.getBoundingClientRect();
    return {
      x: (evt.clientX - rect.left) / sx,
      y: (evt.clientY - rect.top) / sy,
      winX: evt.clientX,
      winY: evt.clientY
    };
  }
  function getTouchInfo(canvas2, sx, sy, touch) {
    const rect = canvas2.getBoundingClientRect();
    return {
      x: (touch.clientX - rect.left) / sx,
      y: (touch.clientY - rect.top) / sy,
      winX: touch.clientX,
      winY: touch.clientY,
      id: touch.pointerId
    };
  }
  fn2._setMouseButton = function(e2) {
    this.mouseButton.left = Array.from(this._activePointers.values()).some(
      (touch) => (touch.buttons & 1) !== 0
    );
    this.mouseButton.center = Array.from(this._activePointers.values()).some(
      (touch) => (touch.buttons & 4) !== 0
    );
    this.mouseButton.right = Array.from(this._activePointers.values()).some(
      (touch) => (touch.buttons & 2) !== 0
    );
  };
  fn2._onpointermove = function(e2) {
    const context = this._isGlobal ? window : this;
    let executeDefault;
    this._updatePointerCoords(e2);
    this._activePointers.set(e2.pointerId, e2);
    this._setMouseButton(e2);
    if (!this.mouseIsPressed && typeof context.mouseMoved === "function") {
      executeDefault = context.mouseMoved(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    } else if (this.mouseIsPressed && typeof context.mouseDragged === "function") {
      executeDefault = context.mouseDragged(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
  };
  fn2._onpointerdown = function(e2) {
    const context = this._isGlobal ? window : this;
    let executeDefault;
    this.mouseIsPressed = true;
    this._activePointers.set(e2.pointerId, e2);
    this._setMouseButton(e2);
    this._updatePointerCoords(e2);
    if (typeof context.mousePressed === "function") {
      executeDefault = context.mousePressed(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
  };
  fn2._onpointerup = function(e2) {
    const context = this._isGlobal ? window : this;
    let executeDefault;
    this.mouseIsPressed = false;
    this._activePointers.delete(e2.pointerId);
    this._setMouseButton(e2);
    this._updatePointerCoords(e2);
    if (typeof context.mouseReleased === "function") {
      executeDefault = context.mouseReleased(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
  };
  fn2._ondragend = fn2._onpointerup;
  fn2._ondragover = fn2._onpointermove;
  fn2._onclick = function(e2) {
    const context = this._isGlobal ? window : this;
    if (typeof context.mouseClicked === "function") {
      const executeDefault = context.mouseClicked(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
  };
  fn2._ondblclick = function(e2) {
    const context = this._isGlobal ? window : this;
    if (typeof context.doubleClicked === "function") {
      const executeDefault = context.doubleClicked(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
  };
  fn2._mouseWheelDeltaY = 0;
  fn2._pmouseWheelDeltaY = 0;
  fn2._onwheel = function(e2) {
    const context = this._isGlobal ? window : this;
    this._mouseWheelDeltaY = e2.deltaY;
    if (typeof context.mouseWheel === "function") {
      e2.delta = e2.deltaY;
      const executeDefault = context.mouseWheel(e2);
      if (executeDefault === false) {
        e2.preventDefault();
      }
    }
  };
  fn2.requestPointerLock = function() {
    const canvas2 = this._curElement.elt;
    canvas2.requestPointerLock = canvas2.requestPointerLock || canvas2.mozRequestPointerLock;
    if (!canvas2.requestPointerLock) {
      console.log("requestPointerLock is not implemented in this browser");
      return false;
    }
    canvas2.requestPointerLock();
    return true;
  };
  fn2.exitPointerLock = function() {
    document.exitPointerLock();
  };
}
if (typeof p5 !== "undefined") {
  pointer(p5, p5.prototype);
}

// node_modules/p5/dist/events/index.js
function events(p53) {
  p53.registerAddon(acceleration);
  p53.registerAddon(keyboard);
  p53.registerAddon(pointer);
}

// node_modules/p5/dist/image/index.js
var import_omggif5 = __toESM(require_omggif());
var import_file_saver8 = __toESM(require_FileSaver());
var import_libtess6 = __toESM(require_libtess_min());
function image3(p53) {
  p53.registerAddon(image2);
  p53.registerAddon(loadingDisplaying);
  p53.registerAddon(image);
  p53.registerAddon(pixels);
  p53.registerAddon(shader);
  p53.registerAddon(texture);
}

// node_modules/p5/dist/io/p5.Table.js
var Table = class {
  constructor(rows) {
    this.columns = [];
    this.rows = [];
  }
  toString(separator = ",") {
    let rows = this.rows.map((row) => row.arr);
    if (!this.columns.some((column) => column === null)) {
      rows = [this.columns, ...rows];
    }
    return stringify(rows, {
      separator
    });
  }
  /**
   *  Use <a href="/reference/p5.Table/addRow/">addRow()</a> to add a new row of data to a <a href="#/p5.Table">p5.Table</a> object. By default,
   *  an empty row is created. Typically, you would store a reference to
   *  the new row in a TableRow object (see newRow in the example above),
   *  and then set individual values using <a href="#/p5/set">set()</a>.
   *
   *  If a <a href="#/p5.TableRow">p5.TableRow</a> object is included as a parameter, then that row is
   *  duplicated and added to the table.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param   {p5.TableRow} [row] row to be added to the table
   *  @return  {p5.TableRow} the row that was added
   *
   * @example
   * <div>
   * <code>
   * // Given the CSV file "mammals.csv"
   * // in the project's "assets" folder:
   * //
   * // id,species,name
   * // 0,Capra hircus,Goat
   * // 1,Panthera pardus,Leopard
   * // 2,Equus zebra,Zebra
   *
   * let table;
   *
   * async function setup() {
   *   // Create a 300x300 canvas
   *   createCanvas(300, 300);
   *
   *   // Load the CSV file from the assets folder with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Add a new row for "Wolf"
   *   let newRow = table.addRow();
   *   newRow.setString('id', table.getRowCount() - 1);
   *   newRow.setString('species', 'Canis Lupus');
   *     newRow.setString('name', 'Wolf');
   *
   *   // Set text properties
   *   fill(0);       // Text color: black
   *    textSize(12);  // Adjust text size as needed
   *
   *   // Display the table data on the canvas
   *   // Each cell is positioned based on its row and column
   *   for (let r = 0; r < table.getRowCount(); r++) {
   *     for (let c = 0; c < table.getColumnCount(); c++) {
   *       let x = c * 50 + 10;  // Horizontal spacing for each column
   *       let y = r * 30 + 20;  // Vertical spacing for each row
   *       text(table.getString(r, c), x * c, y);
   *     }
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  addRow(row) {
    const r = row || new p5.TableRow();
    if (typeof r.arr === "undefined" || typeof r.obj === "undefined") {
      throw new Error(`invalid TableRow: ${r}`);
    }
    r.table = this;
    this.rows.push(r);
    return r;
  }
  /**
   * Removes a row from the table object.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param   {Integer} id ID number of the row to remove
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas and set a white background
   *   createCanvas(200, 200);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *    table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Remove the first row from the table
   *   table.removeRow(0);
   *
   *   // Set text properties for drawing on the canvas
   *   fill(0);      // Set text color to black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Display the table values on the canvas:
   *   // Each row's cell values are joined into a single string and drawn on a new line.
   *   let y = 20; // Starting vertical position
   *   for (let r = 0; r < table.getRowCount(); r++) {
   *     let rowText = "";
   *     for (let c = 0; c < table.getColumnCount(); c++) {
   *       rowText += table.getString(r, c) + " ";
   *     }
   *     text(rowText, 18, y * 3);
   *     y += 20;
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  removeRow(id) {
    this.rows[id].table = null;
    const chunk = this.rows.splice(id + 1, this.rows.length);
    this.rows.pop();
    this.rows = this.rows.concat(chunk);
  }
  /**
   * Returns a reference to the specified <a href="#/p5.TableRow">p5.TableRow</a>. The reference
   * can then be used to get and set values of the selected row.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param  {Integer}   rowID ID number of the row to get
   * @return {p5.TableRow} <a href="#/p5.TableRow">p5.TableRow</a> object
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas
   *   createCanvas(200, 200);
   *   background(255); // Set background to white
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Get the row at index 1 (second row)
   *   let row = table.getRow(1);
   *
   *   // Set text properties for drawing on the canvas
   *   fill(0);      // Set text color to black
   *   textSize(12); // Set the text size
   *
   *   // Loop over each column in the row and display its value on the canvas
   *   for (let c = 0; c < table.getColumnCount(); c++) {
   *     text(row.getString(c), 10, 20 + c * 50 + 20);
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  getRow(r) {
    return this.rows[r];
  }
  /**
   *  Gets all rows from the table. Returns an array of <a href="#/p5.TableRow">p5.TableRow</a>s.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @return {p5.TableRow[]}   Array of <a href="#/p5.TableRow">p5.TableRow</a>s
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas and set a white background
   *   createCanvas(200, 200);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   let rows = table.getRows();
   *
   *   // Warning: rows is an array of objects.
   *   // Set the 'name' of each row to 'Unicorn'
   *   for (let r = 0; r < rows.length; r++) {
   *     rows[r].set('name', 'Unicorn');
   *   }
   *
   *   // Set text properties
   *   fill(0);      // Set text color to black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Display the modified table values on the canvas
   *   // We'll join each row's values with a space and display each row on a new line.
   *   let y = 20; // Starting y position
   *   for (let r = 0; r < table.getRowCount(); r++) {
   *     let rowText = "";
   *     for (let c = 0; c < table.getColumnCount(); c++) {
   *       rowText += table.getString(r, c) + " ";
   *     }
   *     text(rowText, 10, y * 2);
   *     y += 20; // Move to next line
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  getRows() {
    return this.rows;
  }
  /**
   *  Finds the first row in the Table that contains the value
   *  provided, and returns a reference to that row. Even if
   *  multiple rows are possible matches, only the first matching
   *  row is returned. The column to search may be specified by
   *  either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {String} value  The value to match
   *  @param  {Integer|String} column ID number or title of the
   *                                 column to search
   *  @return {p5.TableRow}
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 100x100 canvas
   *   createCanvas(100, 100);
   *   background(255); // Set background to white
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *    // Find the row with the animal named "Zebra"
   *   let row = table.findRow('Zebra', 'name');
   *
   *   // Get the species from the found row
   *   let species = row.getString('species');
   *
   *   // Set text properties and display the species on the canvas
   *   fill(0);      // Set text color to black
   *   textSize(12); // Adjust text size as needed
   *   text(species, 10, 30);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  findRow(value, column) {
    if (typeof column === "string") {
      for (let i = 0; i < this.rows.length; i++) {
        if (this.rows[i].obj[this.columns.indexOf(column)] === value) {
          return this.rows[i];
        }
      }
    } else {
      for (let j2 = 0; j2 < this.rows.length; j2++) {
        if (this.rows[j2].arr[column] === value) {
          return this.rows[j2];
        }
      }
    }
    return null;
  }
  /**
   *  Finds the rows in the Table that contain the value
   *  provided, and returns references to those rows. Returns an
   *  Array, so for must be used to iterate through all the rows,
   *  as shown in the example above. The column to search may be
   *  specified by either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {String} value  The value to match
   *  @param  {Integer|String} column ID number or title of the
   *                                 column to search
   *  @return {p5.TableRow[]}        An Array of TableRow objects
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas
   *   createCanvas(200, 200);
   *   background(255); // Set background to white
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Add another goat entry
   *   let newRow = table.addRow();
   *   newRow.setString('id', table.getRowCount() - 1);
   *   newRow.setString('species', 'Scape Goat');
   *   newRow.setString('name', 'Goat');
   *
   *   // Find rows where the name is "Goat"
   *   let rows = table.findRows('Goat', 'name');
   *
   *   // Set text properties
   *   fill(0);      // Set text color to black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Display the result on the canvas
   *   text(rows.length + ' Goats found', 10, 30);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  findRows(value, column) {
    const ret = [];
    if (typeof column === "string") {
      for (let i = 0; i < this.rows.length; i++) {
        if (this.rows[i].obj[this.columns.indexOf(column)] === value) {
          ret.push(this.rows[i]);
        }
      }
    } else {
      for (let j2 = 0; j2 < this.rows.length; j2++) {
        if (this.rows[j2].arr[column] === value) {
          ret.push(this.rows[j2]);
        }
      }
    }
    return ret;
  }
  /**
   * Finds the first row in the Table that matches the regular
   * expression provided, and returns a reference to that row.
   * Even if multiple rows are possible matches, only the first
   * matching row is returned. The column to search may be
   * specified by either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param  {String|RegExp} regexp The regular expression to match
   * @param  {String|Integer} column The column ID (number) or
   *                                  title (string)
   * @return {p5.TableRow}        TableRow object
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas
   *   createCanvas(200, 200);
   *   background(255); // Set background to white
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Search using the specified regex on column index 1 (species)
   *   let mammal = table.matchRow(new RegExp('ant'), 1);
   *   let species = mammal.getString(1);  // "Panthera pardus"
   *
   *   // Set text properties for drawing on the canvas
   *   fill(0);       // Text color: black
   *   textSize(12);  // Adjust text size as needed
   *
   *   // Display the species on the canvas
   *   text(species, 10, 30);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  matchRow(regexp, column) {
    if (typeof column === "number") {
      for (let j2 = 0; j2 < this.rows.length; j2++) {
        if (this.rows[j2].arr[column].match(regexp)) {
          return this.rows[j2];
        }
      }
    } else {
      for (let i = 0; i < this.rows.length; i++) {
        if (this.rows[i].obj[this.columns.indexOf(column)].match(regexp)) {
          return this.rows[i];
        }
      }
    }
    return null;
  }
  /**
   * Finds the rows in the Table that match the regular expression provided,
   * and returns references to those rows. Returns an array, so for must be
   * used to iterate through all the rows, as shown in the example. The
   * column to search may be specified by either its ID or title.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param  {String} regexp The regular expression to match
   * @param  {String|Integer} [column] The column ID (number) or
   *                                  title (string)
   * @return {p5.TableRow[]}          An Array of TableRow objects
   * @example
   * <div>
   * <code>
   * let table;
   *
   * function setup() {
   *   // Create a 200x200 canvas and set a white background
   *   createCanvas(200, 200);
   *   background(255);
   *
   *   // Create a new p5.Table and add columns
   *   table = new p5.Table();
   *   table.addColumn('name');
   *   table.addColumn('type');
   *
   *   // Add rows to the table
   *    let newRow = table.addRow();
   *   newRow.setString('name', 'Lion');
   *    newRow.setString('type', 'Mammal');
   *
   *   newRow = table.addRow();
   *   newRow.setString('name', 'Snake');
   *   newRow.setString('type', 'Reptile');
   *
   *    newRow = table.addRow();
   *   newRow.setString('name', 'Mosquito');
   *   newRow.setString('type', 'Insect');
   *
   *   newRow = table.addRow();
   *   newRow.setString('name', 'Lizard');
   *   newRow.setString('type', 'Reptile');
   *
   *   // Search for rows where the "type" starts with "R"
   *   let rows = table.matchRows('R.*', 'type');
   *
   *   // Set text properties for drawing on the canvas
   *   fill(0);       // Text color: black
   *   textSize(12);  // Text size
   *
   *   // Display each matching row on the canvas
   *   let y = 20;
   *   for (let i = 0; i < rows.length; i++) {
   *     let output = rows[i].getString('name') + ': ' + rows[i].getString('type');
   *     text(output, 10, y);
   *     y += 20;
   *   }
   * }
   * </code>
   * </div>
   */
  matchRows(regexp, column) {
    const ret = [];
    if (typeof column === "number") {
      for (let j2 = 0; j2 < this.rows.length; j2++) {
        if (this.rows[j2].arr[column].match(regexp)) {
          ret.push(this.rows[j2]);
        }
      }
    } else {
      for (let i = 0; i < this.rows.length; i++) {
        if (this.rows[i].obj[this.columns.indexOf(column)].match(regexp)) {
          ret.push(this.rows[i]);
        }
      }
    }
    return ret;
  }
  /**
   *  Retrieves all values in the specified column, and returns them
   *  as an array. The column may be specified by either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {String|Number} column String or Number of the column to return
   *  @return {Array}       Array of column values
   *
   * @example
   * <div class="norender">
   * <code>
   * // Given the CSV file "mammals.csv"
   * // in the project's "assets" folder:
   * //
   * // id,species,name
   * // 0,Capra hircus,Goat
   * // 1,Panthera pardus,Leopard
   * // 2,Equus zebra,Zebra
   *
   * let table;
   **
   * async function setup() {
   *   // The table is comma separated value "csv"
   *   // and has a header specifying the columns labels.
   *   table = await loadTable('assets/mammals.csv', 'csv', 'header');
   *
   *   //getColumn returns an array that can be printed directly
   *   print(table.getColumn('species'));
   *   //outputs ["Capra hircus", "Panthera pardus", "Equus zebra"]
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  getColumn(value) {
    const ret = [];
    if (typeof value === "string") {
      for (let i = 0; i < this.rows.length; i++) {
        ret.push(this.rows[i].obj[this.columns.indexOf(value)]);
      }
    } else {
      for (let j2 = 0; j2 < this.rows.length; j2++) {
        ret.push(this.rows[j2].arr[value]);
      }
    }
    return ret;
  }
  /**
   *  Removes all rows from a Table. While all rows are removed,
   *  columns and column titles are maintained.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *
   * @example
   * <div>
   * <code>
   * // Given the CSV file "mammals.csv"
   * // in the project's "assets" folder:
   * //
   * // id,species,name
   * // 0,Capra hircus,Goat
   * // 1,Panthera pardus,Leopard
   * // 2,Equus zebra,Zebra
   *
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas
   *   createCanvas(200, 200);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
  *
   *   // Clear all rows from the table
   *   table.clearRows();
   *
   *   // Set text properties
   *   fill(0);       // Text color: black
   *   textSize(12);  // Adjust text size as needed
   *
   *   // Display the number of rows and columns on the canvas
   *   text(table.getRowCount() + ' total rows in table', 10, 30);
   *   text(table.getColumnCount() + ' total columns in table', 10, 60);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  clearRows() {
    delete this.rows;
    this.rows = [];
  }
  /**
   *  Use <a href="/reference/p5.Table/addColumn/">addColumn()</a> to add a new column to a <a href="#/p5.Table">Table</a> object.
   *  Typically, you will want to specify a title, so the column
   *  may be easily referenced later by name. (If no title is
   *  specified, the new column's title will be null.)
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param {String} [title] title of the given column
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   createCanvas(300, 300);
   *   table = await loadTable('/assets/mammals.csv', ',', 'header');
   *
   *   table.addColumn('carnivore');
   *   table.set(0, 'carnivore', 'no');
   *   table.set(1, 'carnivore', 'yes');
   *   table.set(2, 'carnivore', 'no');
   *
   *   fill(0);      // Set text color to black
   *   textSize(11); // Adjust text size as needed
   *
   *   for (let r = 0; r < table.getRowCount(); r++) {
   *     for (let c = 0; c < table.getColumnCount(); c++) {
   *       // Keep column spacing consistent (e.g. 80 pixels apart).
   *       let x = c * 80 + 10;
   *       let y = r * 30 + 20;
   *       // Use x directly, rather than multiplying by c again
   *       text(table.getString(r, c), x, y);
   *     }
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  addColumn(title) {
    const t = title || null;
    this.columns.push(t);
  }
  /**
   *  Returns the total number of columns in a Table.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @return {Integer} Number of columns in this table
   * @example
   * <div>
   * <code>
   * // given the cvs file "blobs.csv" in /assets directory
   * // ID, Name, Flavor, Shape, Color
   * // Blob1, Blobby, Sweet, Blob, Pink
   * // Blob2, Saddy, Savory, Blob, Blue
   *
   * let table;
   *
   * async function setup() {
   *   table = await loadTable('assets/blobs.csv');
   *
   *   createCanvas(200, 100);
   *   textAlign(CENTER);
   *   background(255);
   * }
   *
   * function draw() {
   *   let numOfColumn = table.getColumnCount();
   *   text('There are ' + numOfColumn + ' columns in the table.', 100, 50);
   * }
   * </code>
   * </div>
   */
  getColumnCount() {
    return this.columns.length;
  }
  /**
   *  Returns the total number of rows in a Table.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @return {Integer} Number of rows in this table
   * @example
   * <div>
   * <code>
   * // given the cvs file "blobs.csv" in /assets directory
   * //
   * // ID, Name, Flavor, Shape, Color
   * // Blob1, Blobby, Sweet, Blob, Pink
   * // Blob2, Saddy, Savory, Blob, Blue
   *
   * let table;
   *
   * async function setup() {
   *   table = await loadTable('assets/blobs.csv');
   *
   *   createCanvas(200, 100);
   *   textAlign(CENTER);
   *   background(255);
   * }
   *
   * function draw() {
   *   text('There are ' + table.getRowCount() + ' rows in the table.', 100, 50);
   * }
   * </code>
   * </div>
   */
  getRowCount() {
    return this.rows.length;
  }
  /**
   *  Removes any of the specified characters (or "tokens").
   *
   *  If no column is specified, then the values in all columns and
   *  rows are processed. A specific column may be referenced by
   *  either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {String} chars  String listing characters to be removed
   *  @param  {String|Integer} [column] Column ID (number)
   *                                   or name (string)
   *
   * @example
   * <div class="norender"><code>
   * function setup() {
   *   let table = new p5.Table();
   *
   *   table.addColumn('name');
   *   table.addColumn('type');
   *
   *   let newRow = table.addRow();
   *   newRow.setString('name', '   $Lion  ,');
   *   newRow.setString('type', ',,,Mammal');
   *
   *   newRow = table.addRow();
   *   newRow.setString('name', '$Snake  ');
   *   newRow.setString('type', ',,,Reptile');
   *
   *   table.removeTokens(',$ ');
   *   print(table.getArray());
   * }
   *
   * // prints:
   * //  0  "Lion"   "Mamal"
   * //  1  "Snake"  "Reptile"
   * </code></div>
   */
  removeTokens(chars, column) {
    const escape2 = (s) => s.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
    const charArray = [];
    for (let i = 0; i < chars.length; i++) {
      charArray.push(escape2(chars.charAt(i)));
    }
    const regex = new RegExp(charArray.join("|"), "g");
    if (typeof column === "undefined") {
      for (let c4 = 0; c4 < this.columns.length; c4++) {
        for (let d2 = 0; d2 < this.rows.length; d2++) {
          let s = this.rows[d2].arr[c4];
          s = s.replace(regex, "");
          this.rows[d2].arr[c4] = s;
          this.rows[d2].obj[this.columns[c4]] = s;
        }
      }
    } else if (typeof column === "string") {
      for (let j2 = 0; j2 < this.rows.length; j2++) {
        let val2 = this.rows[j2].obj[column];
        val2 = val2.replace(regex, "");
        this.rows[j2].obj[column] = val2;
        const pos = this.columns.indexOf(column);
        this.rows[j2].arr[pos] = val2;
      }
    } else {
      for (let k = 0; k < this.rows.length; k++) {
        let str = this.rows[k].arr[column];
        str = str.replace(regex, "");
        this.rows[k].arr[column] = str;
        this.rows[k].obj[this.columns[column]] = str;
      }
    }
  }
  /**
   *  Trims leading and trailing whitespace, such as spaces and tabs,
   *  from String table values. If no column is specified, then the
   *  values in all columns and rows are trimmed. A specific column
   *  may be referenced by either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {String|Integer} [column] Column ID (number)
   *                                   or name (string)
   * @example
   * <div class="norender"><code>
   * function setup() {
   *   let table = new p5.Table();
   *
   *   table.addColumn('name');
   *   table.addColumn('type');
   *
   *   let newRow = table.addRow();
   *   newRow.setString('name', '   Lion  ,');
   *   newRow.setString('type', ' Mammal  ');
   *
   *   newRow = table.addRow();
   *   newRow.setString('name', '  Snake  ');
   *   newRow.setString('type', '  Reptile  ');
   *
   *   table.trim();
   *   print(table.getArray());
   * }
   *
   * // prints:
   * //  0  "Lion"   "Mamal"
   * //  1  "Snake"  "Reptile"
   * </code></div>
   */
  trim(column) {
    const regex = new RegExp(" ", "g");
    if (typeof column === "undefined") {
      for (let c4 = 0; c4 < this.columns.length; c4++) {
        for (let d2 = 0; d2 < this.rows.length; d2++) {
          let s = this.rows[d2].arr[c4];
          s = s.replace(regex, "");
          this.rows[d2].arr[c4] = s;
          this.rows[d2].obj[this.columns[c4]] = s;
        }
      }
    } else if (typeof column === "string") {
      for (let j2 = 0; j2 < this.rows.length; j2++) {
        let val2 = this.rows[j2].obj[column];
        val2 = val2.replace(regex, "");
        this.rows[j2].obj[column] = val2;
        const pos = this.columns.indexOf(column);
        this.rows[j2].arr[pos] = val2;
      }
    } else {
      for (let k = 0; k < this.rows.length; k++) {
        let str = this.rows[k].arr[column];
        str = str.replace(regex, "");
        this.rows[k].arr[column] = str;
        this.rows[k].obj[this.columns[column]] = str;
      }
    }
  }
  /**
   *  Use <a href="/reference/p5.Table/removeColumn/">removeColumn()</a> to remove an existing column from a Table
   *  object. The column to be removed may be identified by either
   *  its title (a String) or its index value (an int).
   *  removeColumn(0) would remove the first column, removeColumn(1)
   *  would remove the second column, and so on.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {String|Integer} column columnName (string) or ID (number)
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 100x100 canvas
   *   createCanvas(100, 100);
   *   background(255); // Set background to white
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *    // Remove the "id" column
   *    table.removeColumn('id');
   *
   *   // Get the remaining column count
   *   let colCount = table.getColumnCount();
   *
   *   // Set text properties
   *   fill(0);      // Text color: black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Display the column count on the canvas
   *   text(colCount, 40, 50);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  removeColumn(c4) {
    let cString;
    let cNumber;
    if (typeof c4 === "string") {
      cString = c4;
      cNumber = this.columns.indexOf(c4);
    } else {
      cNumber = c4;
      cString = this.columns[c4];
    }
    const chunk = this.columns.splice(cNumber + 1, this.columns.length);
    this.columns.pop();
    this.columns = this.columns.concat(chunk);
    for (let i = 0; i < this.rows.length; i++) {
      const tempR = this.rows[i].arr;
      const chip = tempR.splice(cNumber + 1, tempR.length);
      tempR.pop();
      this.rows[i].arr = tempR.concat(chip);
      delete this.rows[i].obj[cString];
    }
  }
  /**
   * Stores a value in the Table's specified row and column.
   * The row is specified by its ID, while the column may be specified
   * by either its ID or title.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param {Integer} row row ID
   * @param {String|Integer} column column ID (Number)
   *                               or title (String)
   * @param {String|Number} value  value to assign
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas and set a white background
   *   createCanvas(200, 200);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Update the first row: change species to "Canis Lupus" and name to "Wolf"
   *   table.set(0, 'species', 'Canis Lupus');
   *   table.set(0, 'name', 'Wolf');
   *
   *   // Set text properties for drawing on the canvas
   *   fill(0);      // Text color: black
   *    textSize(12); // Adjust text size as needed
   *
   *   // Display the table values on the canvas:
   *   // Each row's values are concatenated into a single string and displayed on a new line.
   *   let y = 20; // Starting vertical position
   *   for (let r = 0; r < table.getRowCount(); r++) {
   *     let rowText = "";
   *     for (let c = 0; c < table.getColumnCount(); c++) {
   *       rowText += table.getString(r, c) + " ";
   *     }
   *     text(rowText, 10, y * 2.5);
   *     y += 20;
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  set(row, column, value) {
    this.rows[row].set(column, value);
  }
  /**
   * Stores a Float value in the Table's specified row and column.
   * The row is specified by its ID, while the column may be specified
   * by either its ID or title.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param {Integer} row row ID
   * @param {String|Integer} column column ID (Number)
   *                               or title (String)
   * @param {Number} value  value to assign
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 100x100 canvas and set a white background
   *   createCanvas(100, 100);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Set the value in row 1, column "id" to the number 1
   *   table.setNum(1, 'id', 1);
   *
   *   // Get the first column as an array and join its values into a string for display.
   *   let col0 = table.getColumn(0);  // Expected output: ["0", 1, "2"]
   *   let output = col0.join(", ");
   *
   *   // Set text properties and display the output on the canvas
   *   fill(0);      // Text color: black
   *   textSize(12); // Adjust text size as needed
   *   text(output, 30, 50);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  setNum(row, column, value) {
    this.rows[row].setNum(column, value);
  }
  /**
   * Stores a String value in the Table's specified row and column.
   * The row is specified by its ID, while the column may be specified
   * by either its ID or title.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param {Integer} row row ID
   * @param {String|Integer} column column ID (Number)
   *                               or title (String)
   * @param {String} value  value to assign
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas and set a white background
   *   createCanvas(200, 200);
   *   background(255);
   *
   *   // Load the CSV file from the assets folder with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Add a new row with the new animal data
   *   let newRow = table.addRow();
   *   newRow.setString('id', table.getRowCount() - 1);
   *   newRow.setString('species', 'Canis Lupus');
   *   newRow.setString('name', 'Wolf');
   *
   *   // Convert the table to a 2D array
   *   let tableArray = table.getArray();
   *
   *   // Set text properties
   *   fill(0);       // Set text color to black
   *   textSize(12);  // Adjust text size as needed
   *
   *   // Display each row of the table on the canvas
   *   let y = 20;  // Starting y position
   *   for (let i = 0; i < tableArray.length; i++) {
   *     // Join the values of each row with a comma separator
   *     let rowText = tableArray[i].join(', ');
   *     text(rowText, 15, y * 2);
   *     y += 20;  // Increment y position for the next row
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  setString(row, column, value) {
    this.rows[row].setString(column, value);
  }
  /**
   * Retrieves a value from the Table's specified row and column.
   * The row is specified by its ID, while the column may be specified by
   * either its ID or title.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param {Integer} row row ID
   * @param  {String|Integer} column columnName (string) or
   *                                   ID (number)
   * @return {String|Number}
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 100x100 canvas
   *   createCanvas(100, 100);
   *   background(255); // Set background to white
   *
   *   // Load the CSV file from the assets folder with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Set text properties for drawing on the canvas
   *   fill(0);      // Text color: black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Get the values from the table
   *   let value1 = table.get(0, 1);       // Using column index (1) => "Capra hircus"
   *   let value2 = table.get(0, 'species'); // Using column name => "Capra hircus"
   *
   *   // Display the values on the canvas
   *   text(value1, 10, 30);
   *   text(value2, 10, 60);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  get(row, column) {
    if (typeof column === "string") {
      return this.rows[row].get(this.columns.indexOf(column));
    } else {
      return this.rows[row].get(column);
    }
  }
  /**
   * Retrieves a Float value from the Table's specified row and column.
   * The row is specified by its ID, while the column may be specified by
   * either its ID or title.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param {Integer} row row ID
   * @param  {String|Integer} column columnName (string) or
   *                                   ID (number)
   * @return {Number}
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 100x100 canvas
   *   createCanvas(100, 100);
   *   background(255); // Set background to white
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Compute the result: id at row 1, column 0 plus 100 (i.e. 1 + 100 = 101)
   *   let result = table.getNum(1, 0) + 100;
   *
   *   // Set text properties and display the result on the canvas
   *   fill(0);      // Set text color to black
   *   textSize(12); // Adjust text size as needed
   *   text(result, 10, 30);  // Display the result at position (10, 30)
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  getNum(row, column) {
    return this.rows[row].getNum(column);
  }
  /**
   * Retrieves a String value from the Table's specified row and column.
   * The row is specified by its ID, while the column may be specified by
   * either its ID or title.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param {Integer} row row ID
   * @param  {String|Integer} column columnName (string) or
   *                                   ID (number)
   * @return {String}
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas
   *   createCanvas(200, 200);
   *   background(255); // Set background to white
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Set text properties
   *   fill(0);      // Text color: black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Display each table cell value on the canvas one below the other.
   *   // We use a variable 'y' to increment the vertical position.
   *   let y = 20;
   *   text(table.getString(0, 0), 10, y); // 0
   *   y += 20;
   *   text(table.getString(0, 1), 10, y); // Capra hircus
   *   y += 20;
   *   text(table.getString(0, 2), 10, y); // Goat
   *   y += 20;
   *   text(table.getString(1, 0), 10, y); // 1
   *   y += 20;
   *   text(table.getString(1, 1), 10, y); // Panthera pardus
   *   y += 20;
   *   text(table.getString(1, 2), 10, y); // Leopard
   *   y += 20;
   *   text(table.getString(2, 0), 10, y); // 2
   *   y += 20;
   *   text(table.getString(2, 1), 10, y); // Equus zebra
   *   y += 20;
   *   text(table.getString(2, 2), 10, y); // Zebra
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  getString(row, column) {
    return this.rows[row].getString(column);
  }
  /**
   * Retrieves all table data and returns as an object. If a column name is
   * passed in, each row object will be stored with that attribute as its
   * title.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @param {String} [headerColumn] Name of the column which should be used to
   *                              title each row object (optional)
   * @return {Object}
   *
   * @example
   * <div class="norender">
   * <code>
   * // Given the CSV file "mammals.csv"
   * // in the project's "assets" folder:
   * //
   * // id,species,name
   * // 0,Capra hircus,Goat
   * // 1,Panthera pardus,Leopard
   * // 2,Equus zebra,Zebra
   *
   * let table;
   *
   * async function setup() {
   *   // The table is comma separated value "csv"
   *   // and has a header specifying the columns labels.
   *   table = await loadTable('assets/mammals.csv', 'csv', 'header');
   *
   *   let tableObject = table.getObject();
   *
   *   print(tableObject);
   *   //outputs an object
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  getObject(headerColumn) {
    const tableObject = {};
    let obj, cPos, index;
    for (let i = 0; i < this.rows.length; i++) {
      obj = this.rows[i].obj;
      if (typeof headerColumn === "string") {
        cPos = this.columns.indexOf(headerColumn);
        if (cPos >= 0) {
          index = obj[headerColumn];
          tableObject[index] = obj;
        } else {
          throw new Error(`This table has no column named "${headerColumn}"`);
        }
      } else {
        tableObject[i] = this.rows[i].obj;
      }
    }
    return tableObject;
  }
  /**
   * Retrieves all table data and returns it as a multidimensional array.
   *
   * @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   * @return {Array}
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas and set a white background
   *   createCanvas(200, 200);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Get the CSV data as a 2D array
   *   let tableArray = table.getArray();
   *
   *   // Set text properties
   *   fill(0);      // Set text color to black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Display each row of the CSV on the canvas
   *   // Each row is displayed on a separate line
   *   for (let i = 0; i < tableArray.length; i++) {
   *     let rowText = tableArray[i].join(", ");
   *     text(rowText, 10, 20 + i * 50 + 30);
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  getArray() {
    const tableArray = [];
    for (let i = 0; i < this.rows.length; i++) {
      tableArray.push(this.rows[i].arr);
    }
    return tableArray;
  }
};
function table(p53, fn2) {
  p53.Table = Table;
}
if (typeof p5 !== "undefined") {
  table(p5, p5.prototype);
}

// node_modules/p5/dist/io/p5.TableRow.js
var TableRow = class {
  constructor(row = []) {
    let arr2 = row;
    this.arr = arr2;
    this.obj = Object.fromEntries(arr2.entries());
    this.table = null;
  }
  /**
   *  Stores a value in the TableRow's specified column.
   *  The column may be specified by either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param {String|Integer} column Column ID (Number)
   *                                or Title (String)
   *  @param {String|Number} value  The value to be stored
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas and set a white background
   *   createCanvas(200, 200);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Set every row's "name" to "Unicorn"
   *    let rows = table.getRows();
   *   for (let r = 0; r < rows.length; r++) {
   *     rows[r].set('name', 'Unicorn');
   *   }
   *
   *   // Convert the table to an array
   *   let tableArray = table.getArray();
   *
   *   // Set text properties
   *   fill(0);      // Set text color to black
   *   textSize(12); // Set text size
   *
   *   // Display each row of the table on the canvas
   *   let y = 20; // Starting y position
   *   for (let i = 0; i < tableArray.length; i++) {
   *     let rowText = tableArray[i].join(', ');
   *     text(rowText, 10, y * 2.5);
   *     y += 20; // Increment y position for the next row
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  set(column, value) {
    if (typeof column === "string") {
      const cPos = this.table.columns.indexOf(column);
      if (cPos >= 0) {
        this.obj[column] = value;
        this.arr[cPos] = value;
      } else {
        throw new Error(`This table has no column named "${column}"`);
      }
    } else {
      if (column < this.table.columns.length) {
        this.arr[column] = value;
        const cTitle = this.table.columns[column];
        this.obj[cTitle] = value;
      } else {
        throw new Error(`Column #${column} is out of the range of this table`);
      }
    }
  }
  /**
   *  Stores a Float value in the TableRow's specified column.
   *  The column may be specified by either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param {String|Integer} column Column ID (Number)
   *                                or Title (String)
   *  @param {Number|String} value  The value to be stored
   *                                as a Float
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x200 canvas and set a white background
   *   createCanvas(200, 200);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Update each row's "id" to (row index + 10)
   *   let rows = table.getRows();
   *   for (let r = 0; r < rows.length; r++) {
   *     rows[r].setNum('id', r + 10);
   *   }
   *
   *   // Convert the table to a 2D array for display
   *   let tableArray = table.getArray();
   *
   *   // Set text properties
   *   fill(0);      // Text color: black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Display each row of the table on the canvas
   *   let y = 20;   // Starting y position
   *   for (let i = 0; i < tableArray.length; i++) {
   *     // Join each row's values with a comma separator
   *     let rowText = tableArray[i].join(', ');
   *     text(rowText, 10, y * 2.5);
   *     y += 20;  // Increment y for the next row
   *   }
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  setNum(column, value) {
    const floatVal = parseFloat(value);
    this.set(column, floatVal);
  }
  /**
   *  Stores a String value in the TableRow's specified column.
   *  The column may be specified by either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param {String|Integer} column Column ID (Number)
   *                                or Title (String)
   *  @param {String|Number|Boolean|Object} value  The value to be stored
   *                                as a String
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 300x200 canvas and set a white background
   *   createCanvas(300, 200);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Update each row's "name" field
   *   let rows = table.getRows();
   *   for (let r = 0; r < rows.length; r++) {
   *     let name = rows[r].getString('name');
   *     rows[r].setString('name', 'A ' + name + ' named George');
   *   }
   *
   *   // Convert the table to a 2D array for display
   *   let tableArray = table.getArray();
   *
   *   // Set text properties
   *   fill(0);      // Text color: black
   *   textSize(12); // Adjust text size as needed
   *
   *   // Display each row of the table on the canvas
   *   let y = 20;   // Starting y position
   *   for (let i = 0; i < tableArray.length; i++) {
   *     let rowText = tableArray[i].join(', ');
   *     text(rowText, 10, y * 2.5);
   *     y += 20;    // Increment y for the next row
   *   }
   *
   *   // describe('no image displayed');
   * }
   * </code>
   */
  setString(column, value) {
    const stringVal = value.toString();
    this.set(column, stringVal);
  }
  /**
   *  Retrieves a value from the TableRow's specified column.
   *  The column may be specified by either its ID or title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {String|Integer} column columnName (string) or
   *                                   ID (number)
   *  @return {String|Number}
   *
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 200x100 canvas and set a white background
   *   createCanvas(200, 100);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *    table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   // Extract the names from each row and store them in an array
   *   let names = [];
   *   let rows = table.getRows();
   *   for (let r = 0; r < rows.length; r++) {
   *     names.push(rows[r].get('name'));
   *   }
   *
   *   // Set text properties and display the names on the canvas
   *   fill(0);      // Set text color to black
   *   textSize(12); // Set text size
   *
   *   // Join names into a single string separated by commas
   *   let namesText = names.join(', ');
   *   text(namesText, 35, 50);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  get(column) {
    if (typeof column === "string") {
      return this.obj[this.table.columns.indexOf(column)];
    } else {
      return this.arr[column];
    }
  }
  /**
   *  Retrieves a Float value from the TableRow's specified
   *  column. The column may be specified by either its ID or
   *  title.
   *
   *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)
   *  @param  {String|Integer} column columnName (string) or
   *                                   ID (number)
   *  @return {Number}  Float Floating point number
   * @example
   * <div>
   * <code>
   * let table;
   *
   * async function setup() {
   *   // Create a 300x100 canvas and set a white background
   *   createCanvas(300, 100);
   *   background(255);
   *
   *   // Load the CSV file with a header row
   *   table = await loadTable('assets/mammals.csv', ',', 'header');
   *
   *   let rows = table.getRows();
   *   let minId = Infinity;
   *   let maxId = -Infinity;
   *
   *   for (let r = 0; r < rows.length; r++) {
   *     let id = rows[r].getNum('id');
   *     minId = min(minId, id);
   *     maxId = max(maxId, id);
   *    }
   *
   *   let result = 'minimum id = ' + minId + ', maximum id = ' + maxId;
   *
   *   // Set text properties and display the result on the canvas
   *   fill(0);      // Set text color to black
   *   textSize(12); // Set text size
   *   text(result, 10, 50);
   *
   *   describe('no image displayed');
   * }
   * </code>
   * </div>
   */
  getNum(column) {
    let ret;
    if (typeof column === "string") {
      ret = parseFloat(this.obj[this.table.columns.indexOf(column)]);
    } else {
      ret = parseFloat(this.arr[column]);
    }
    if (ret.toString() === "NaN") {
      throw `Error: ${this.obj[column]} is NaN (Not a Number)`;
    }
    return ret;
  }
  /**
     *  Retrieves an String value from the TableRow's specified
     *  column. The column may be specified by either its ID or
     *  title.
     *
     *  @deprecated p5.Table will be removed in a future version of p5.js to make way for a new, friendlier version :)

     *  @param  {String|Integer} column columnName (string) or
     *                                   ID (number)
     *  @return {String}  String
     * @example
     * <div>
     * <code>
     * let table;
     *
     * async function setup() {
     *   // Create a 200x100 canvas and set a white background
     *   createCanvas(200, 100);
     *   background(255);
     *
     *   // Load the CSV file with a header row
     *   table = await loadTable('assets/mammals.csv', ',', 'header');
     *
     *   let rows = table.getRows();
     *   let longest = '';
     *   for (let r = 0; r < rows.length; r++) {
     *      let species = rows[r].getString('species');
     *      if (longest.length < species.length) {
     *       longest = species;
     *     }
     *   }
     *
     *   let result = 'longest: ' + longest;
     *
     *   // Set text properties and display the result on the canvas
     *   fill(0);      // Set text color to black
     *   textSize(12); // Set text size
     *   text(result, 30, 50);
     *
     *   describe('no image displayed');
     * }
     * </code>
     * </div>
     */
  getString(column) {
    if (typeof column === "string") {
      return this.obj[this.table.columns.indexOf(column)].toString();
    } else {
      return this.arr[column].toString();
    }
  }
};
function tableRow(p53, fn2) {
  p53.TableRow = TableRow;
}
if (typeof p5 !== "undefined") {
  tableRow(p5, p5.prototype);
}

// node_modules/p5/dist/io/index.js
var import_file_saver9 = __toESM(require_FileSaver());
var import_omggif6 = __toESM(require_omggif());
var import_libtess7 = __toESM(require_libtess_min());
function io(p53) {
  p53.registerAddon(files);
  p53.registerAddon(table);
  p53.registerAddon(tableRow);
  p53.registerAddon(xml);
}

// node_modules/p5/dist/math/calculation.js
function calculation(p53, fn2) {
  fn2.abs = Math.abs;
  fn2.ceil = Math.ceil;
  fn2.constrain = function(n3, low, high) {
    return Math.max(Math.min(n3, high), low);
  };
  fn2.dist = function(...args) {
    if (args.length === 4) {
      return Math.hypot(args[2] - args[0], args[3] - args[1]);
    } else if (args.length === 6) {
      return Math.hypot(
        args[3] - args[0],
        args[4] - args[1],
        args[5] - args[2]
      );
    }
  };
  fn2.exp = Math.exp;
  fn2.floor = Math.floor;
  fn2.lerp = function(start, stop, amt) {
    return amt * (stop - start) + start;
  };
  fn2.log = Math.log;
  fn2.mag = function(x, y) {
    return Math.hypot(x, y);
  };
  fn2.map = function(n3, start1, stop1, start2, stop2, withinBounds) {
    const newval = (n3 - start1) / (stop1 - start1) * (stop2 - start2) + start2;
    if (!withinBounds) {
      return newval;
    }
    if (start2 < stop2) {
      return this.constrain(newval, start2, stop2);
    } else {
      return this.constrain(newval, stop2, start2);
    }
  };
  fn2.max = function(...args) {
    const findMax = (arr2) => {
      let max = -Infinity;
      for (let x of arr2) {
        max = Math.max(max, x);
      }
      return max;
    };
    if (args[0] instanceof Array) {
      return findMax(args[0]);
    } else {
      return findMax(args);
    }
  };
  fn2.min = function(...args) {
    const findMin = (arr2) => {
      let min = Infinity;
      for (let x of arr2) {
        min = Math.min(min, x);
      }
      return min;
    };
    if (args[0] instanceof Array) {
      return findMin(args[0]);
    } else {
      return findMin(args);
    }
  };
  fn2.norm = function(n3, start, stop) {
    return this.map(n3, start, stop, 0, 1);
  };
  fn2.pow = Math.pow;
  fn2.round = function(n3, decimals) {
    if (!decimals) {
      return Math.round(n3);
    }
    const multiplier = Math.pow(10, decimals);
    return Math.round(n3 * multiplier) / multiplier;
  };
  fn2.sq = (n3) => n3 * n3;
  fn2.sqrt = Math.sqrt;
  fn2.fract = function(toConvert) {
    let sign = 0;
    let num = Number(toConvert);
    if (isNaN(num) || Math.abs(num) === Infinity) {
      return num;
    } else if (num < 0) {
      num = -num;
      sign = 1;
    }
    if (String(num).includes(".") && !String(num).includes("e")) {
      let toFract = String(num);
      toFract = Number("0" + toFract.slice(toFract.indexOf(".")));
      return Math.abs(sign - toFract);
    } else if (num < 1) {
      return Math.abs(sign - num);
    } else {
      return 0;
    }
  };
}
if (typeof p5 !== "undefined") {
  calculation(p5, p5.prototype);
}

// node_modules/p5/dist/math/noise.js
function noise(p53, fn2) {
  const PERLIN_YWRAPB = 4;
  const PERLIN_YWRAP = 1 << PERLIN_YWRAPB;
  const PERLIN_ZWRAPB = 8;
  const PERLIN_ZWRAP = 1 << PERLIN_ZWRAPB;
  const PERLIN_SIZE = 4095;
  let perlin_octaves = 4;
  let perlin_amp_falloff = 0.5;
  const scaled_cosine = (i) => 0.5 * (1 - Math.cos(i * Math.PI));
  let perlin;
  fn2.noise = function(x, y = 0, z = 0) {
    if (perlin == null) {
      perlin = new Array(PERLIN_SIZE + 1);
      for (let i = 0; i < PERLIN_SIZE + 1; i++) {
        perlin[i] = Math.random();
      }
    }
    if (x < 0) {
      x = -x;
    }
    if (y < 0) {
      y = -y;
    }
    if (z < 0) {
      z = -z;
    }
    let xi = Math.floor(x), yi = Math.floor(y), zi = Math.floor(z);
    let xf = x - xi;
    let yf = y - yi;
    let zf = z - zi;
    let rxf, ryf;
    let r = 0;
    let ampl = 0.5;
    let n1, n22, n3;
    for (let o = 0; o < perlin_octaves; o++) {
      let of = xi + (yi << PERLIN_YWRAPB) + (zi << PERLIN_ZWRAPB);
      rxf = scaled_cosine(xf);
      ryf = scaled_cosine(yf);
      n1 = perlin[of & PERLIN_SIZE];
      n1 += rxf * (perlin[of + 1 & PERLIN_SIZE] - n1);
      n22 = perlin[of + PERLIN_YWRAP & PERLIN_SIZE];
      n22 += rxf * (perlin[of + PERLIN_YWRAP + 1 & PERLIN_SIZE] - n22);
      n1 += ryf * (n22 - n1);
      of += PERLIN_ZWRAP;
      n22 = perlin[of & PERLIN_SIZE];
      n22 += rxf * (perlin[of + 1 & PERLIN_SIZE] - n22);
      n3 = perlin[of + PERLIN_YWRAP & PERLIN_SIZE];
      n3 += rxf * (perlin[of + PERLIN_YWRAP + 1 & PERLIN_SIZE] - n3);
      n22 += ryf * (n3 - n22);
      n1 += scaled_cosine(zf) * (n22 - n1);
      r += n1 * ampl;
      ampl *= perlin_amp_falloff;
      xi <<= 1;
      xf *= 2;
      yi <<= 1;
      yf *= 2;
      zi <<= 1;
      zf *= 2;
      if (xf >= 1) {
        xi++;
        xf--;
      }
      if (yf >= 1) {
        yi++;
        yf--;
      }
      if (zf >= 1) {
        zi++;
        zf--;
      }
    }
    return r;
  };
  fn2.noiseDetail = function(lod, falloff) {
    if (lod > 0) {
      perlin_octaves = lod;
    }
    if (falloff > 0) {
      perlin_amp_falloff = falloff;
    }
  };
  fn2.noiseSeed = function(seed) {
    const lcg = /* @__PURE__ */ (() => {
      const m3 = 4294967296;
      const a2 = 1664525;
      const c4 = 1013904223;
      let seed2, z;
      return {
        setSeed(val2) {
          z = seed2 = (val2 == null ? Math.random() * m3 : val2) >>> 0;
        },
        getSeed() {
          return seed2;
        },
        rand() {
          z = (a2 * z + c4) % m3;
          return z / m3;
        }
      };
    })();
    lcg.setSeed(seed);
    perlin = new Array(PERLIN_SIZE + 1);
    for (let i = 0; i < PERLIN_SIZE + 1; i++) {
      perlin[i] = lcg.rand();
    }
  };
}
if (typeof p5 !== "undefined") {
  noise(p5, p5.prototype);
}

// node_modules/p5/dist/math/random.js
function random(p53, fn2) {
  const randomStateProp = "_lcg_random_state";
  const m3 = 4294967296;
  const a2 = 1664525;
  const c4 = 1013904223;
  let y2 = 0;
  fn2._lcg = function(stateProperty) {
    this[stateProperty] = (a2 * this[stateProperty] + c4) % m3;
    return this[stateProperty] / m3;
  };
  fn2._lcgSetSeed = function(stateProperty, val2) {
    this[stateProperty] = (val2 == null ? Math.random() * m3 : val2) >>> 0;
  };
  fn2.randomSeed = function(seed) {
    this._lcgSetSeed(randomStateProp, seed);
    this._gaussian_previous = false;
  };
  fn2.random = function(min, max) {
    let rand;
    if (this[randomStateProp] != null) {
      rand = this._lcg(randomStateProp);
    } else {
      rand = Math.random();
    }
    if (typeof min === "undefined") {
      return rand;
    } else if (typeof max === "undefined") {
      if (min instanceof Array) {
        return min[Math.floor(rand * min.length)];
      } else {
        return rand * min;
      }
    } else {
      if (min > max) {
        const tmp = min;
        min = max;
        max = tmp;
      }
      return rand * (max - min) + min;
    }
  };
  fn2.randomGaussian = function(mean, sd = 1) {
    let y1, x1, x2, w;
    if (this._gaussian_previous) {
      y1 = y2;
      this._gaussian_previous = false;
    } else {
      do {
        x1 = this.random(2) - 1;
        x2 = this.random(2) - 1;
        w = x1 * x1 + x2 * x2;
      } while (w >= 1);
      w = Math.sqrt(-2 * Math.log(w) / w);
      y1 = x1 * w;
      y2 = x2 * w;
      this._gaussian_previous = true;
    }
    const m4 = mean || 0;
    return y1 * sd + m4;
  };
}
if (typeof p5 !== "undefined") {
  random(p5, p5.prototype);
}

// node_modules/p5/dist/math/math.js
function math(p53, fn2) {
  fn2.createVector = function(x, y, z) {
    if (this instanceof p53) {
      return new p53.Vector(
        this._fromRadians.bind(this),
        this._toRadians.bind(this),
        ...arguments
      );
    } else {
      return new p53.Vector(x, y, z);
    }
  };
  fn2.createMatrix = function(...args) {
    return new p53.Matrix(...args);
  };
}
if (typeof p5 !== "undefined") {
  math(p5, p5.prototype);
}

// node_modules/p5/dist/math/index.js
function math2(p53) {
  p53.registerAddon(calculation);
  p53.registerAddon(noise);
  p53.registerAddon(random);
  p53.registerAddon(trigonometry);
  p53.registerAddon(math);
  p53.registerAddon(vector);
}

// node_modules/p5/dist/utilities/conversion.js
function conversion(p53, fn2) {
  fn2.float = function(str) {
    if (str instanceof Array) {
      return str.map(parseFloat);
    }
    return parseFloat(str);
  };
  fn2.int = function(n3, radix = 10) {
    if (n3 === Infinity || n3 === "Infinity") {
      return Infinity;
    } else if (n3 === -Infinity || n3 === "-Infinity") {
      return -Infinity;
    } else if (typeof n3 === "string") {
      return parseInt(n3, radix);
    } else if (typeof n3 === "number") {
      return n3 | 0;
    } else if (typeof n3 === "boolean") {
      return n3 ? 1 : 0;
    } else if (n3 instanceof Array) {
      return n3.map((n4) => fn2.int(n4, radix));
    }
  };
  fn2.str = function(n3) {
    if (n3 instanceof Array) {
      return n3.map(fn2.str);
    } else {
      return String(n3);
    }
  };
  fn2.boolean = function(n3) {
    if (typeof n3 === "number") {
      return n3 !== 0;
    } else if (typeof n3 === "string") {
      return n3.toLowerCase() === "true";
    } else if (typeof n3 === "boolean") {
      return n3;
    } else if (n3 instanceof Array) {
      return n3.map(fn2.boolean);
    }
  };
  fn2.byte = function(n3) {
    const nn = fn2.int(n3, 10);
    if (typeof nn === "number") {
      return (nn + 128) % 256 - 128;
    } else if (nn instanceof Array) {
      return nn.map(fn2.byte);
    }
  };
  fn2.char = function(n3) {
    if (typeof n3 === "number" && !isNaN(n3)) {
      return String.fromCharCode(n3);
    } else if (n3 instanceof Array) {
      return n3.map(fn2.char);
    } else if (typeof n3 === "string") {
      return fn2.char(parseInt(n3, 10));
    }
  };
  fn2.unchar = function(n3) {
    if (typeof n3 === "string" && n3.length === 1) {
      return n3.charCodeAt(0);
    } else if (n3 instanceof Array) {
      return n3.map(fn2.unchar);
    }
  };
  fn2.hex = function(n3, digits) {
    digits = digits === void 0 || digits === null ? digits = 8 : digits;
    if (n3 instanceof Array) {
      return n3.map((n4) => fn2.hex(n4, digits));
    } else if (n3 === Infinity || n3 === -Infinity) {
      const c4 = n3 === Infinity ? "F" : "0";
      return c4.repeat(digits);
    } else if (typeof n3 === "number") {
      if (n3 < 0) {
        n3 = 4294967295 + n3 + 1;
      }
      let hex = Number(n3).toString(16).toUpperCase();
      while (hex.length < digits) {
        hex = `0${hex}`;
      }
      if (hex.length >= digits) {
        hex = hex.substring(hex.length - digits, hex.length);
      }
      return hex;
    }
  };
  fn2.unhex = function(n3) {
    if (n3 instanceof Array) {
      return n3.map(fn2.unhex);
    } else {
      return parseInt(`0x${n3}`, 16);
    }
  };
}
if (typeof p5 !== "undefined") {
  conversion(p5, p5.prototype);
}

// node_modules/p5/dist/utilities/utility_functions.js
function utilityFunctions(p53, fn2) {
  fn2.nf = function(nums, left, right) {
    if (nums instanceof Array) {
      return nums.map((x) => doNf(x, left, right));
    } else {
      const typeOfFirst = Object.prototype.toString.call(nums);
      if (typeOfFirst === "[object Arguments]") {
        if (nums.length === 3) {
          return this.nf(nums[0], nums[1], nums[2]);
        } else if (nums.length === 2) {
          return this.nf(nums[0], nums[1]);
        } else {
          return this.nf(nums[0]);
        }
      } else {
        return doNf(nums, left, right);
      }
    }
  };
  function doNf(num, left, right) {
    let isNegative = num < 0;
    num = Math.abs(num);
    let [leftPart, rightPart] = num.toString().split(".");
    if (typeof right === "undefined") {
      leftPart = leftPart.padStart(left, "0");
      let result = rightPart ? leftPart + "." + rightPart : leftPart;
      return isNegative ? "-" + result : result;
    } else {
      let roundedOff = num.toFixed(right);
      [leftPart, rightPart] = roundedOff.toString().split(".");
      leftPart = leftPart.padStart(left, "0");
      let result = typeof rightPart === "undefined" ? leftPart : leftPart + "." + rightPart;
      return isNegative ? "-" + result : result;
    }
  }
  fn2.nfc = function(num, right) {
    if (num instanceof Array) {
      return num.map((x) => doNfc(x, right));
    } else {
      return doNfc(num, right);
    }
  };
  function doNfc(num, right) {
    num = num.toString();
    const dec = num.indexOf(".");
    let rem = dec !== -1 ? num.substring(dec) : "";
    let n3 = dec !== -1 ? num.substring(0, dec) : num;
    n3 = n3.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    if (right === 0) {
      rem = "";
    } else if (typeof right !== "undefined") {
      if (right > rem.length) {
        rem += dec === -1 ? "." : "";
        const len = right - rem.length + 1;
        for (let i = 0; i < len; i++) {
          rem += "0";
        }
      } else {
        rem = rem.substring(0, right + 1);
      }
    }
    return n3 + rem;
  }
  fn2.nfp = function(...args) {
    const nfRes = fn2.nf.apply(this, args);
    if (nfRes instanceof Array) {
      return nfRes.map(addNfp);
    } else {
      return addNfp(nfRes);
    }
  };
  function addNfp(num) {
    return parseFloat(num) > 0 ? `+${num.toString()}` : num.toString();
  }
  fn2.nfs = function(...args) {
    const nfRes = fn2.nf.apply(this, args);
    if (nfRes instanceof Array) {
      return nfRes.map(addNfs);
    } else {
      return addNfs(nfRes);
    }
  };
  function addNfs(num) {
    return parseFloat(num) >= 0 ? ` ${num.toString()}` : num.toString();
  }
  fn2.splitTokens = function(value, delims) {
    let d2;
    if (typeof delims !== "undefined") {
      let str = delims;
      const sqc = /\]/g.exec(str);
      let sqo = /\[/g.exec(str);
      if (sqo && sqc) {
        str = str.slice(0, sqc.index) + str.slice(sqc.index + 1);
        sqo = /\[/g.exec(str);
        str = str.slice(0, sqo.index) + str.slice(sqo.index + 1);
        d2 = new RegExp(`[\\[${str}\\]]`, "g");
      } else if (sqc) {
        str = str.slice(0, sqc.index) + str.slice(sqc.index + 1);
        d2 = new RegExp(`[${str}\\]]`, "g");
      } else if (sqo) {
        str = str.slice(0, sqo.index) + str.slice(sqo.index + 1);
        d2 = new RegExp(`[${str}\\[]`, "g");
      } else {
        d2 = new RegExp(`[${str}]`, "g");
      }
    } else {
      d2 = /\s/g;
    }
    return value.split(d2).filter((n3) => n3);
  };
  fn2.shuffle = function(arr2, bool) {
    const isView = ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(arr2);
    arr2 = bool || isView ? arr2 : arr2.slice();
    let rnd, tmp, idx = arr2.length;
    while (idx > 1) {
      rnd = this.random(0, 1) * idx | 0;
      tmp = arr2[--idx];
      arr2[idx] = arr2[rnd];
      arr2[rnd] = tmp;
    }
    return arr2;
  };
}
if (typeof p5 !== "undefined") {
  utilityFunctions(p5, p5.prototype);
}

// node_modules/p5/dist/utilities/time_date.js
function timeDate(p53, fn2) {
  fn2.day = function() {
    return (/* @__PURE__ */ new Date()).getDate();
  };
  fn2.hour = function() {
    return (/* @__PURE__ */ new Date()).getHours();
  };
  fn2.minute = function() {
    return (/* @__PURE__ */ new Date()).getMinutes();
  };
  fn2.millis = function() {
    if (this._millisStart === -1) {
      return 0;
    } else {
      return window.performance.now() - this._millisStart;
    }
  };
  fn2.month = function() {
    return (/* @__PURE__ */ new Date()).getMonth() + 1;
  };
  fn2.second = function() {
    return (/* @__PURE__ */ new Date()).getSeconds();
  };
  fn2.year = function() {
    return (/* @__PURE__ */ new Date()).getFullYear();
  };
}
if (typeof p5 !== "undefined") {
  timeDate(p5, p5.prototype);
}

// node_modules/p5/dist/utilities/index.js
function utilities(p53) {
  p53.registerAddon(conversion);
  p53.registerAddon(utilityFunctions);
  p53.registerAddon(timeDate);
}

// node_modules/p5/dist/webgl/interaction.js
function interaction(p53, fn2) {
  fn2.orbitControl = function(sensitivityX, sensitivityY, sensitivityZ, options2) {
    this._assert3d("orbitControl");
    const cam = this._renderer.states.curCamera;
    if (typeof sensitivityX === "undefined") {
      sensitivityX = 1;
    }
    if (typeof sensitivityY === "undefined") {
      sensitivityY = sensitivityX;
    }
    if (typeof sensitivityZ === "undefined") {
      sensitivityZ = 1;
    }
    if (typeof options2 !== "object") {
      options2 = {};
    }
    if (this.contextMenuDisabled !== true) {
      this.canvas.oncontextmenu = () => false;
      this.contextMenuDisabled = true;
    }
    if (this.wheelDefaultDisabled !== true) {
      this.canvas.onwheel = () => false;
      this.wheelDefaultDisabled = true;
    }
    const { disableTouchActions = true } = options2;
    if (this.touchActionsDisabled !== true && disableTouchActions) {
      this.canvas.style["touch-action"] = "none";
      this.touchActionsDisabled = true;
    }
    const { freeRotation = false } = options2;
    const movedTouches = [];
    this.touches.forEach((curTouch) => {
      this._renderer.prevTouches.forEach((prevTouch) => {
        if (curTouch.id === prevTouch.id) {
          const movedTouch = {
            x: curTouch.x,
            y: curTouch.y,
            px: prevTouch.x,
            py: prevTouch.y
          };
          movedTouches.push(movedTouch);
        }
      });
    });
    this._renderer.prevTouches = this.touches;
    let deltaRadius = 0;
    let deltaTheta = 0;
    let deltaPhi = 0;
    let moveDeltaX = 0;
    let moveDeltaY = 0;
    const damping = 0.85;
    const rotateAccelerationFactor = 0.6;
    const moveAccelerationFactor = 0.15;
    const mouseZoomScaleFactor = 0.01;
    const touchZoomScaleFactor = 4e-4;
    const scaleFactor = this.height < this.width ? this.height : this.width;
    let pointersInCanvas = false;
    if (movedTouches.length > 0) {
      pointersInCanvas = movedTouches[0].x > 0 && movedTouches[0].x < this.width && movedTouches[0].y > 0 && movedTouches[0].y < this.height;
      if (movedTouches.length === 1) {
        const t = movedTouches[0];
        deltaTheta = -sensitivityX * (t.x - t.px) / scaleFactor;
        deltaPhi = sensitivityY * (t.y - t.py) / scaleFactor;
      } else {
        const t0 = movedTouches[0];
        const t1 = movedTouches[1];
        const distWithTouches = Math.hypot(t0.x - t1.x, t0.y - t1.y);
        const prevDistWithTouches = Math.hypot(t0.px - t1.px, t0.py - t1.py);
        const changeDist = distWithTouches - prevDistWithTouches;
        deltaRadius = -changeDist * sensitivityZ * touchZoomScaleFactor;
        moveDeltaX = 0.5 * (t0.x + t1.x) - 0.5 * (t0.px + t1.px);
        moveDeltaY = 0.5 * (t0.y + t1.y) - 0.5 * (t0.py + t1.py);
      }
      if (this.touches.length > 0) {
        if (pointersInCanvas) {
          this._renderer.executeRotateAndMove = true;
          this._renderer.executeZoom = true;
        }
      } else {
        this._renderer.executeRotateAndMove = false;
        this._renderer.executeZoom = false;
      }
    } else {
      pointersInCanvas = this.mouseX > 0 && this.mouseX < this.width && (this.mouseY > 0 && this.mouseY < this.height);
      if (this._mouseWheelDeltaY !== 0) {
        deltaRadius = Math.sign(this._mouseWheelDeltaY) * sensitivityZ;
        deltaRadius *= mouseZoomScaleFactor;
        this._mouseWheelDeltaY = 0;
        if (pointersInCanvas) this._renderer.executeZoom = true;
      } else {
        this._renderer.executeZoom = false;
      }
      if (this.mouseIsPressed) {
        if (this.mouseButton.left) {
          deltaTheta = -sensitivityX * this.movedX / scaleFactor;
          deltaPhi = sensitivityY * this.movedY / scaleFactor;
        } else if (this.mouseButton.right) {
          moveDeltaX = this.movedX;
          moveDeltaY = this.movedY * cam.yScale;
        }
        if (pointersInCanvas) this._renderer.executeRotateAndMove = true;
      } else {
        this._renderer.executeRotateAndMove = false;
      }
    }
    if (deltaRadius !== 0 && this._renderer.executeZoom) {
      this._renderer.zoomVelocity += deltaRadius;
    }
    if (Math.abs(this._renderer.zoomVelocity) > 1e-3) {
      if (freeRotation) {
        cam._orbitFree(
          0,
          0,
          this._renderer.zoomVelocity
        );
      } else {
        cam._orbit(
          0,
          0,
          this._renderer.zoomVelocity
        );
      }
      if (cam.projMatrix.mat4[15] !== 0) {
        cam.projMatrix.mat4[0] *= Math.pow(
          10,
          -this._renderer.zoomVelocity
        );
        cam.projMatrix.mat4[5] *= Math.pow(
          10,
          -this._renderer.zoomVelocity
        );
        this._renderer.states.setValue("uPMatrix", this._renderer.states.uPMatrix.clone());
        this._renderer.states.uPMatrix.mat4[0] = cam.projMatrix.mat4[0];
        this._renderer.states.uPMatrix.mat4[5] = cam.projMatrix.mat4[5];
      }
      this._renderer.zoomVelocity *= damping;
    } else {
      this._renderer.zoomVelocity = 0;
    }
    if ((deltaTheta !== 0 || deltaPhi !== 0) && this._renderer.executeRotateAndMove) {
      this._renderer.rotateVelocity.add(
        deltaTheta * rotateAccelerationFactor,
        deltaPhi * rotateAccelerationFactor
      );
    }
    if (this._renderer.rotateVelocity.magSq() > 1e-6) {
      if (freeRotation) {
        cam._orbitFree(
          -this._renderer.rotateVelocity.x,
          this._renderer.rotateVelocity.y,
          0
        );
      } else {
        cam._orbit(
          this._renderer.rotateVelocity.x,
          this._renderer.rotateVelocity.y,
          0
        );
      }
      this._renderer.rotateVelocity.mult(damping);
    } else {
      this._renderer.rotateVelocity.set(0, 0);
    }
    if ((moveDeltaX !== 0 || moveDeltaY !== 0) && this._renderer.executeRotateAndMove) {
      const ndcX = moveDeltaX * 2 / this.width;
      const ndcY = -moveDeltaY * 2 / this.height;
      this._renderer.moveVelocity.add(
        ndcX * moveAccelerationFactor,
        ndcY * moveAccelerationFactor
      );
    }
    if (this._renderer.moveVelocity.magSq() > 1e-6) {
      const local = cam._getLocalAxes();
      const diffX = cam.eyeX - cam.centerX;
      const diffY = cam.eyeY - cam.centerY;
      const diffZ = cam.eyeZ - cam.centerZ;
      const viewZ = Math.sqrt(diffX * diffX + diffY * diffY + diffZ * diffZ);
      let cv = new Vector(cam.centerX, cam.centerY, cam.centerZ);
      cv = cam.cameraMatrix.multiplyPoint(cv);
      cv = this._renderer.states.uPMatrix.multiplyAndNormalizePoint(cv);
      cv.x -= this._renderer.moveVelocity.x;
      cv.y -= this._renderer.moveVelocity.y;
      let dx, dy;
      const uP = this._renderer.states.uPMatrix.mat4;
      if (uP[15] === 0) {
        dx = (uP[8] + cv.x) / uP[0] * viewZ;
        dy = (uP[9] + cv.y) / uP[5] * viewZ;
      } else {
        dx = (cv.x - uP[12]) / uP[0];
        dy = (cv.y - uP[13]) / uP[5];
      }
      cam.setPosition(
        cam.eyeX + dx * local.x[0] + dy * local.y[0],
        cam.eyeY + dx * local.x[1] + dy * local.y[1],
        cam.eyeZ + dx * local.x[2] + dy * local.y[2]
      );
      this._renderer.moveVelocity.mult(damping);
    } else {
      this._renderer.moveVelocity.set(0, 0);
    }
    return this;
  };
  fn2.debugMode = function(...args) {
    this._assert3d("debugMode");
    for (let i = p53.lifecycleHooks.postdraw.length - 1; i >= 0; i--) {
      if (p53.lifecycleHooks.postdraw[i].toString() === this._grid().toString() || p53.lifecycleHooks.postdraw[i].toString() === this._axesIcon().toString()) {
        p53.lifecycleHooks.postdraw.splice(i, 1);
      }
    }
    if (args[0] === GRID) {
      p53.lifecycleHooks.postdraw.push(
        this._grid(args[1], args[2], args[3], args[4], args[5])
      );
    } else if (args[0] === AXES) {
      p53.lifecycleHooks.postdraw.push(
        this._axesIcon(args[1], args[2], args[3], args[4])
      );
    } else {
      p53.lifecycleHooks.postdraw.push(
        this._grid(args[0], args[1], args[2], args[3], args[4])
      );
      p53.lifecycleHooks.postdraw.push(
        this._axesIcon(args[5], args[6], args[7], args[8])
      );
    }
  };
  fn2.noDebugMode = function() {
    this._assert3d("noDebugMode");
    for (let i = p53.lifecycleHooks.postdraw.length - 1; i >= 0; i--) {
      if (p53.lifecycleHooks.postdraw[i].toString() === this._grid().toString() || p53.lifecycleHooks.postdraw[i].toString() === this._axesIcon().toString()) {
        p53.lifecycleHooks.postdraw.splice(i, 1);
      }
    }
  };
  fn2._grid = function(size, numDivs, xOff, yOff, zOff) {
    if (typeof size === "undefined") {
      size = this.width / 2;
    }
    if (typeof numDivs === "undefined") {
      numDivs = Math.round(size / 30) < 4 ? 4 : Math.round(size / 30);
    }
    if (typeof xOff === "undefined") {
      xOff = 0;
    }
    if (typeof yOff === "undefined") {
      yOff = 0;
    }
    if (typeof zOff === "undefined") {
      zOff = 0;
    }
    const spacing = size / numDivs;
    const halfSize = size / 2;
    return function() {
      this.push();
      this.stroke(
        this._renderer.states.curStrokeColor[0] * 255,
        this._renderer.states.curStrokeColor[1] * 255,
        this._renderer.states.curStrokeColor[2] * 255
      );
      this._renderer.states.setValue("uModelMatrix", this._renderer.states.uModelMatrix.clone());
      this._renderer.states.uModelMatrix.reset();
      for (let q = 0; q <= numDivs; q++) {
        this.beginShape(this.LINES);
        this.vertex(-halfSize + xOff, yOff, q * spacing - halfSize + zOff);
        this.vertex(+halfSize + xOff, yOff, q * spacing - halfSize + zOff);
        this.endShape();
      }
      for (let i = 0; i <= numDivs; i++) {
        this.beginShape(this.LINES);
        this.vertex(i * spacing - halfSize + xOff, yOff, -halfSize + zOff);
        this.vertex(i * spacing - halfSize + xOff, yOff, +halfSize + zOff);
        this.endShape();
      }
      this.pop();
    };
  };
  fn2._axesIcon = function(size, xOff, yOff, zOff) {
    if (typeof size === "undefined") {
      size = this.width / 20 > 40 ? this.width / 20 : 40;
    }
    if (typeof xOff === "undefined") {
      xOff = -this.width / 4;
    }
    if (typeof yOff === "undefined") {
      yOff = xOff;
    }
    if (typeof zOff === "undefined") {
      zOff = xOff;
    }
    return () => {
      this.push();
      this._renderer.states.setValue("uModelMatrix", this._renderer.states.uModelMatrix.clone());
      this._renderer.states.uModelMatrix.reset();
      this.strokeWeight(2);
      this.stroke(255, 0, 0);
      this.beginShape(this.LINES);
      this.vertex(xOff, yOff, zOff);
      this.vertex(xOff + size, yOff, zOff);
      this.endShape();
      this.stroke(0, 255, 0);
      this.beginShape(this.LINES);
      this.vertex(xOff, yOff, zOff);
      this.vertex(xOff, yOff + size, zOff);
      this.endShape();
      this.stroke(0, 0, 255);
      this.beginShape(this.LINES);
      this.vertex(xOff, yOff, zOff);
      this.vertex(xOff, yOff, zOff + size);
      this.endShape();
      this.pop();
    };
  };
}
if (typeof p5 !== "undefined") {
  interaction(p5, p5.prototype);
}

// node_modules/p5/dist/webgl/loading.js
var import_file_saver10 = __toESM(require_FileSaver());
var import_omggif7 = __toESM(require_omggif());
var import_libtess8 = __toESM(require_libtess_min());
async function fileExists(url2) {
  try {
    const response = await fetch(url2, { method: "HEAD" });
    return response.ok;
  } catch (error42) {
    return false;
  }
}
function loading2(p53, fn2) {
  fn2.loadModel = async function(path2, fileType, normalize, successCallback, failureCallback) {
    let flipU = false;
    let flipV = false;
    if (typeof fileType === "object") {
      normalize = fileType.normalize || false;
      successCallback = fileType.successCallback;
      failureCallback = fileType.failureCallback;
      fileType = fileType.fileType || fileType;
      flipU = fileType.flipU || false;
      flipV = fileType.flipV || false;
    } else {
      if (typeof arguments[arguments.length - 1] === "function") {
        if (typeof arguments[arguments.length - 2] === "function") {
          successCallback = arguments[arguments.length - 2];
          failureCallback = arguments[arguments.length - 1];
        } else {
          successCallback = arguments[arguments.length - 1];
        }
      }
      if (typeof fileType === "string") {
        if (typeof normalize !== "boolean") normalize = false;
      } else if (typeof fileType === "boolean") {
        normalize = fileType;
        fileType = path2.slice(-4);
      } else {
        fileType = path2.slice(-4);
        normalize = false;
      }
    }
    if (fileType.toLowerCase() !== ".obj" && fileType.toLowerCase() !== ".stl") {
      fileType = ".obj";
    }
    const model = new Geometry(void 0, void 0, void 0, this._renderer);
    model.gid = `${path2}|${normalize}`;
    async function getMaterials(lines) {
      const parsedMaterialPromises = [];
      for (let line of lines) {
        const mtllibMatch = line.match(/^mtllib (.+)/);
        if (mtllibMatch) {
          let mtlPath = "";
          const mtlFilename = mtllibMatch[1];
          const objPathParts = path2.split("/");
          if (objPathParts.length > 1) {
            objPathParts.pop();
            const objFolderPath = objPathParts.join("/");
            mtlPath = objFolderPath + "/" + mtlFilename;
          } else {
            mtlPath = mtlFilename;
          }
          parsedMaterialPromises.push(
            fileExists(mtlPath).then((exists) => {
              if (exists) {
                return parseMtl(mtlPath);
              } else {
                console.warn(`MTL file not found or error in parsing; proceeding without materials: ${mtlPath}`);
                return {};
              }
            }).catch((error42) => {
              console.warn(`Error loading MTL file: ${mtlPath}`, error42);
              return {};
            })
          );
        }
      }
      try {
        const parsedMaterials = await Promise.all(parsedMaterialPromises);
        const materials = Object.assign({}, ...parsedMaterials);
        return materials;
      } catch (error42) {
        return {};
      }
    }
    try {
      if (fileType.match(/\.stl$/i)) {
        const { data: data3 } = await request(path2, "arrayBuffer");
        parseSTL(model, data3);
        if (normalize) {
          model.normalize();
        }
        if (flipU) {
          model.flipU();
        }
        if (flipV) {
          model.flipV();
        }
        model._makeTriangleEdges();
        if (successCallback) {
          return successCallback(model);
        } else {
          return model;
        }
      } else if (fileType.match(/\.obj$/i)) {
        const { data: data3 } = await request(path2, "text");
        const lines = data3.split("\n");
        const parsedMaterials = await getMaterials(lines);
        parseObj(model, lines, parsedMaterials);
        if (normalize) {
          model.normalize();
        }
        if (flipU) {
          model.flipU();
        }
        if (flipV) {
          model.flipV();
        }
        model._makeTriangleEdges();
        if (successCallback) {
          return successCallback(model);
        } else {
          return model;
        }
      }
    } catch (err2) {
      p53._friendlyFileLoadError(3, path2);
      if (failureCallback) {
        return failureCallback(err2);
      } else {
        throw err2;
      }
    }
  };
  async function parseMtl(mtlPath) {
    let currentMaterial = null;
    let materials = {};
    const { data: data3 } = await request(mtlPath, "text");
    const lines = data3.split("\n");
    for (let line = 0; line < lines.length; ++line) {
      const tokens = lines[line].trim().split(/\s+/);
      if (tokens[0] === "newmtl") {
        const materialName = tokens[1];
        currentMaterial = materialName;
        materials[currentMaterial] = {};
      } else if (tokens[0] === "Kd") {
        materials[currentMaterial].diffuseColor = [
          parseFloat(tokens[1]),
          parseFloat(tokens[2]),
          parseFloat(tokens[3])
        ];
      } else if (tokens[0] === "Ka") {
        materials[currentMaterial].ambientColor = [
          parseFloat(tokens[1]),
          parseFloat(tokens[2]),
          parseFloat(tokens[3])
        ];
      } else if (tokens[0] === "Ks") {
        materials[currentMaterial].specularColor = [
          parseFloat(tokens[1]),
          parseFloat(tokens[2]),
          parseFloat(tokens[3])
        ];
      } else if (tokens[0] === "map_Kd") {
        materials[currentMaterial].texturePath = tokens[1];
      }
    }
    return materials;
  }
  function parseObj(model, lines, materials = {}) {
    const loadedVerts = {
      v: [],
      vt: [],
      vn: []
    };
    const usedVerts = {};
    let currentMaterial = null;
    let hasColoredVertices = false;
    let hasColorlessVertices = false;
    for (let line = 0; line < lines.length; ++line) {
      const tokens = lines[line].trim().split(/\b\s+/);
      if (tokens.length > 0) {
        if (tokens[0] === "usemtl") {
          currentMaterial = tokens[1];
        } else if (tokens[0] === "v" || tokens[0] === "vn") {
          const vertex2 = new Vector(
            parseFloat(tokens[1]),
            parseFloat(tokens[2]),
            parseFloat(tokens[3])
          );
          loadedVerts[tokens[0]].push(vertex2);
        } else if (tokens[0] === "vt") {
          const texVertex = [parseFloat(tokens[1]), 1 - parseFloat(tokens[2])];
          loadedVerts[tokens[0]].push(texVertex);
        } else if (tokens[0] === "f") {
          for (let tri = 3; tri < tokens.length; ++tri) {
            const face = [];
            const vertexTokens = [1, tri - 1, tri];
            for (let tokenInd = 0; tokenInd < vertexTokens.length; ++tokenInd) {
              const vertString = tokens[vertexTokens[tokenInd]];
              let vertParts = vertString.split("/");
              for (let i = 0; i < vertParts.length; i++) {
                vertParts[i] = parseInt(vertParts[i]) - 1;
              }
              if (!usedVerts[vertString]) {
                usedVerts[vertString] = {};
              }
              if (usedVerts[vertString][currentMaterial] === void 0) {
                const vertIndex = model.vertices.length;
                model.vertices.push(loadedVerts.v[vertParts[0]].copy());
                model.uvs.push(loadedVerts.vt[vertParts[1]] ? loadedVerts.vt[vertParts[1]].slice() : [0, 0]);
                model.vertexNormals.push(loadedVerts.vn[vertParts[2]] ? loadedVerts.vn[vertParts[2]].copy() : new Vector());
                usedVerts[vertString][currentMaterial] = vertIndex;
                face.push(vertIndex);
                if (currentMaterial && materials[currentMaterial] && materials[currentMaterial].diffuseColor) {
                  hasColoredVertices = true;
                  const materialDiffuseColor = materials[currentMaterial].diffuseColor;
                  model.vertexColors.push(materialDiffuseColor[0]);
                  model.vertexColors.push(materialDiffuseColor[1]);
                  model.vertexColors.push(materialDiffuseColor[2]);
                  model.vertexColors.push(1);
                } else {
                  hasColorlessVertices = true;
                }
              } else {
                face.push(usedVerts[vertString][currentMaterial]);
              }
            }
            if (face[0] !== face[1] && face[0] !== face[2] && face[1] !== face[2]) {
              model.faces.push(face);
            }
          }
        }
      }
    }
    if (model.vertexNormals.length === 0) {
      model.computeNormals();
    }
    if (hasColoredVertices === hasColorlessVertices) {
      throw new Error("Model coloring is inconsistent. Either all vertices should have colors or none should.");
    }
    return model;
  }
  function parseSTL(model, buffer) {
    if (isBinary(buffer)) {
      parseBinarySTL(model, buffer);
    } else {
      const reader = new DataView(buffer);
      if (!("TextDecoder" in window)) {
        console.warn(
          "Sorry, ASCII STL loading only works in browsers that support TextDecoder (https://caniuse.com/#feat=textencoder)"
        );
        return model;
      }
      const decoder = new TextDecoder("utf-8");
      const lines = decoder.decode(reader);
      const lineArray = lines.split("\n");
      parseASCIISTL(model, lineArray);
    }
    return model;
  }
  function isBinary(data3) {
    const reader = new DataView(data3);
    const solid = [115, 111, 108, 105, 100];
    for (let off = 0; off < 5; off++) {
      if (matchDataViewAt(solid, reader, off)) return false;
    }
    return true;
  }
  function matchDataViewAt(query, reader, offset2) {
    for (let i = 0, il = query.length; i < il; i++) {
      if (query[i] !== reader.getUint8(offset2 + i, false)) return false;
    }
    return true;
  }
  function parseBinarySTL(model, buffer) {
    const reader = new DataView(buffer);
    const faces = reader.getUint32(80, true);
    let r, g2, b3, hasColors = false, colors;
    let defaultR, defaultG, defaultB;
    for (let index = 0; index < 80 - 10; index++) {
      if (reader.getUint32(index, false) === 1129270351 && reader.getUint8(index + 4) === 82 && reader.getUint8(index + 5) === 61) {
        hasColors = true;
        colors = [];
        defaultR = reader.getUint8(index + 6) / 255;
        defaultG = reader.getUint8(index + 7) / 255;
        defaultB = reader.getUint8(index + 8) / 255;
      }
    }
    const dataOffset = 84;
    const faceLength = 12 * 4 + 2;
    for (let face = 0; face < faces; face++) {
      const start = dataOffset + face * faceLength;
      const normalX = reader.getFloat32(start, true);
      const normalY = reader.getFloat32(start + 4, true);
      const normalZ = reader.getFloat32(start + 8, true);
      if (hasColors) {
        const packedColor = reader.getUint16(start + 48, true);
        if ((packedColor & 32768) === 0) {
          r = (packedColor & 31) / 31;
          g2 = (packedColor >> 5 & 31) / 31;
          b3 = (packedColor >> 10 & 31) / 31;
        } else {
          r = defaultR;
          g2 = defaultG;
          b3 = defaultB;
        }
      }
      const newNormal = new Vector(normalX, normalY, normalZ);
      for (let i = 1; i <= 3; i++) {
        const vertexstart = start + i * 12;
        const newVertex = new Vector(
          reader.getFloat32(vertexstart, true),
          reader.getFloat32(vertexstart + 4, true),
          reader.getFloat32(vertexstart + 8, true)
        );
        model.vertices.push(newVertex);
        model.vertexNormals.push(newNormal);
        if (hasColors) {
          colors.push(r, g2, b3);
        }
      }
      model.faces.push([3 * face, 3 * face + 1, 3 * face + 2]);
      model.uvs.push([0, 0], [0, 0], [0, 0]);
    }
    return model;
  }
  function parseASCIISTL(model, lines) {
    let state = "";
    let curVertexIndex = [];
    let newNormal, newVertex;
    for (let iterator = 0; iterator < lines.length; ++iterator) {
      const line = lines[iterator].trim();
      const parts = line.split(" ");
      for (let partsiterator = 0; partsiterator < parts.length; ++partsiterator) {
        if (parts[partsiterator] === "") {
          parts.splice(partsiterator, 1);
        }
      }
      if (parts.length === 0) {
        continue;
      }
      switch (state) {
        case "":
          if (parts[0] !== "solid") {
            console.error(line);
            console.error(`Invalid state "${parts[0]}", should be "solid"`);
            return;
          } else {
            state = "solid";
          }
          break;
        case "solid":
          if (parts[0] !== "facet" || parts[1] !== "normal") {
            console.error(line);
            console.error(
              `Invalid state "${parts[0]}", should be "facet normal"`
            );
            return;
          } else {
            newNormal = new Vector(
              parseFloat(parts[2]),
              parseFloat(parts[3]),
              parseFloat(parts[4])
            );
            model.vertexNormals.push(newNormal, newNormal, newNormal);
            state = "facet normal";
          }
          break;
        case "facet normal":
          if (parts[0] !== "outer" || parts[1] !== "loop") {
            console.error(line);
            console.error(`Invalid state "${parts[0]}", should be "outer loop"`);
            return;
          } else {
            state = "vertex";
          }
          break;
        case "vertex":
          if (parts[0] === "vertex") {
            newVertex = new Vector(
              parseFloat(parts[1]),
              parseFloat(parts[2]),
              parseFloat(parts[3])
            );
            model.vertices.push(newVertex);
            model.uvs.push([0, 0]);
            curVertexIndex.push(model.vertices.indexOf(newVertex));
          } else if (parts[0] === "endloop") {
            model.faces.push(curVertexIndex);
            curVertexIndex = [];
            state = "endloop";
          } else {
            console.error(line);
            console.error(
              `Invalid state "${parts[0]}", should be "vertex" or "endloop"`
            );
            return;
          }
          break;
        case "endloop":
          if (parts[0] !== "endfacet") {
            console.error(line);
            console.error(`Invalid state "${parts[0]}", should be "endfacet"`);
            return;
          } else {
            state = "endfacet";
          }
          break;
        case "endfacet":
          if (parts[0] === "endsolid") ;
          else if (parts[0] === "facet" && parts[1] === "normal") {
            newNormal = new Vector(
              parseFloat(parts[2]),
              parseFloat(parts[3]),
              parseFloat(parts[4])
            );
            model.vertexNormals.push(newNormal, newNormal, newNormal);
            state = "facet normal";
          } else {
            console.error(line);
            console.error(
              `Invalid state "${parts[0]}", should be "endsolid" or "facet normal"`
            );
            return;
          }
          break;
        default:
          console.error(`Invalid state "${state}"`);
          break;
      }
    }
    return model;
  }
  fn2.model = function(model, count = 1) {
    this._assert3d("model");
    this._renderer.model(model, count);
  };
  let modelCounter = 0;
  fn2.createModel = function(modelString, fileType = " ", options2) {
    let normalize = false;
    let successCallback;
    let failureCallback;
    let flipU = false;
    let flipV = false;
    if (options2 && typeof options2 === "object") {
      normalize = options2.normalize || false;
      successCallback = options2.successCallback;
      failureCallback = options2.failureCallback;
      flipU = options2.flipU || false;
      flipV = options2.flipV || false;
    } else if (typeof options2 === "boolean") {
      normalize = options2;
      successCallback = arguments[3];
      failureCallback = arguments[4];
    } else {
      successCallback = typeof arguments[2] === "function" ? arguments[2] : void 0;
      failureCallback = arguments[3];
    }
    const model = new p53.Geometry();
    model.gid = `${fileType}|${normalize}|${modelCounter++}`;
    if (fileType.match(/\.stl$/i)) {
      try {
        let uint8array = new TextEncoder().encode(modelString);
        let arrayBuffer = uint8array.buffer;
        parseSTL(model, arrayBuffer);
      } catch (error42) {
        if (failureCallback) {
          failureCallback(error42);
        } else {
          p53._friendlyError("Error during parsing: " + error42.message);
        }
        return;
      }
    } else if (fileType.match(/\.obj$/i)) {
      try {
        const lines = modelString.split("\n");
        parseObj(model, lines);
      } catch (error42) {
        if (failureCallback) {
          failureCallback(error42);
        } else {
          p53._friendlyError("Error during parsing: " + error42.message);
        }
        return;
      }
    } else {
      p53._friendlyFileLoadError(3, modelString);
      if (failureCallback) {
        failureCallback();
      } else {
        p53._friendlyError(
          "Sorry, the file type is invalid. Only OBJ and STL files are supported."
        );
      }
    }
    if (normalize) {
      model.normalize();
    }
    if (flipU) {
      model.flipU();
    }
    if (flipV) {
      model.flipV();
    }
    model._makeTriangleEdges();
    if (typeof successCallback === "function") {
      successCallback(model);
    }
    return model;
  };
}
if (typeof p5 !== "undefined") {
  loading2(p5, p5.prototype);
}

// node_modules/p5/dist/type/textCore.js
var import_file_saver11 = __toESM(require_FileSaver());
var textCoreConstants = {
  IDEOGRAPHIC: "ideographic",
  RIGHT_TO_LEFT: "rtl",
  LEFT_TO_RIGHT: "ltr",
  _CTX_MIDDLE: "middle",
  _TEXT_BOUNDS: "_textBoundsSingle",
  _FONT_BOUNDS: "_fontBoundsSingle",
  HANGING: "hanging",
  START: "start",
  END: "end"
};
function textCore(p53, fn2) {
  const LeadingScale = 1.275;
  const DefaultFill = "#000000";
  const LinebreakRe = /\r?\n/g;
  const CommaDelimRe = /,\s+/;
  const QuotedRe = /^".*"$/;
  const TabsRe = /\t/g;
  const FontVariationSettings = "fontVariationSettings";
  const VariableAxes = ["wght", "wdth", "ital", "slnt", "opsz"];
  const VariableAxesRe = new RegExp(`(?:${VariableAxes.join("|")})`);
  const textFunctions = [
    "text",
    "textAlign",
    "textAscent",
    "textDescent",
    "textLeading",
    "textMode",
    "textFont",
    "textSize",
    "textStyle",
    "textWidth",
    "textWrap",
    "textBounds",
    "textDirection",
    "textProperty",
    "textProperties",
    "fontBounds",
    "fontWidth",
    "fontAscent",
    "fontDescent",
    "textWeight"
  ];
  textFunctions.forEach((func) => {
    fn2[func] = function(...args) {
      if (!(func in Renderer.prototype)) {
        throw Error(`Renderer2D.prototype.${func} is not defined.`);
      }
      return this._renderer[func](...args);
    };
    p53.Graphics.prototype[func] = function(...args) {
      return this._renderer[func](...args);
    };
  });
  const RendererTextProps = {
    textAlign: { default: fn2.LEFT, type: "Context2d" },
    textBaseline: { default: fn2.BASELINE, type: "Context2d" },
    textFont: { default: { family: "sans-serif" } },
    textLeading: { default: 15 },
    textSize: { default: 12 },
    textWrap: { default: fn2.WORD },
    fontStretch: { default: fn2.NORMAL, isShorthand: true },
    // font-stretch: { default:  normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded }
    fontWeight: { default: fn2.NORMAL, isShorthand: true },
    // font-stretch: { default:  normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded }
    lineHeight: { default: fn2.NORMAL, isShorthand: true },
    // line-height: { default:  normal | number | length | percentage }
    fontVariant: { default: fn2.NORMAL, isShorthand: true },
    // font-variant: { default:  normal | small-caps }
    fontStyle: { default: fn2.NORMAL, isShorthand: true },
    // font-style: { default:  normal | italic | oblique } [was 'textStyle' in v1]
    direction: { default: "inherit" }
    // direction: { default: inherit | ltr | rtl }
  };
  const ContextTextProps = ["font", "direction", "fontKerning", "fontStretch", "fontVariantCaps", "letterSpacing", "textAlign", "textBaseline", "textRendering", "wordSpacing"];
  const ShorthandFontProps = Object.keys(RendererTextProps).filter((p2) => RendererTextProps[p2].isShorthand);
  const FontStretchKeys = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"];
  let contextQueue, cachedDiv;
  Renderer.prototype.text = function(str, x, y, width, height) {
    let setBaseline = this.textDrawingContext().textBaseline;
    ({ x, y, width, height } = this._handleRectMode(x, y, width, height));
    let lines = this._processLines(str, width, height);
    lines = this._positionLines(x, y, width, height, lines);
    lines.forEach((line) => this._renderText(line.text, line.x, line.y));
    this.textDrawingContext().textBaseline = setBaseline;
  };
  Renderer.prototype.textBounds = function(str, x, y, width, height) {
    return this._computeBounds(textCoreConstants._TEXT_BOUNDS, str, x, y, width, height).bounds;
  };
  Renderer.prototype.fontBounds = function(str, x, y, width, height) {
    return this._computeBounds(textCoreConstants._FONT_BOUNDS, str, x, y, width, height).bounds;
  };
  Renderer.prototype.textWidth = function(theText) {
    let lines = this._processLines(theText);
    return Math.max(...lines.map((l) => this._textWidthSingle(l)));
  };
  Renderer.prototype.fontWidth = function(theText) {
    let lines = this._processLines(theText);
    return Math.max(...lines.map((l) => this._fontWidthSingle(l)));
  };
  Renderer.prototype.textAscent = function(txt = "") {
    if (!txt.length) return this.fontAscent();
    return this.textDrawingContext().measureText(txt).actualBoundingBoxAscent;
  };
  Renderer.prototype.fontAscent = function() {
    return this.textDrawingContext().measureText("_").fontBoundingBoxAscent;
  };
  Renderer.prototype.textDescent = function(txt = "") {
    if (!txt.length) return this.fontDescent();
    return this.textDrawingContext().measureText(txt).actualBoundingBoxDescent;
  };
  Renderer.prototype.fontDescent = function() {
    return this.textDrawingContext().measureText("_").fontBoundingBoxDescent;
  };
  Renderer.prototype.textAlign = function(h, v) {
    if (typeof h !== "undefined") {
      this.states.setValue("textAlign", h);
      if (typeof v !== "undefined") {
        if (v === fn2.CENTER) {
          v = textCoreConstants._CTX_MIDDLE;
        }
        this.states.setValue("textBaseline", v);
      }
      return this._applyTextProperties();
    }
    return {
      horizontal: this.states.textAlign,
      vertical: this.states.textBaseline
    };
  };
  Renderer.prototype._currentTextFont = function() {
    return this.states.textFont.font || this.states.textFont.family;
  };
  Renderer.prototype.textFont = function(font2, size, options2) {
    var _a2;
    if (arguments.length === 0) {
      return this._currentTextFont();
    }
    let family = font2;
    if (font2 instanceof p53.Font) {
      family = font2.face.family;
    } else if (font2.data instanceof Uint8Array) {
      family = font2.name.fontFamily;
      if ((_a2 = font2.name) == null ? void 0 : _a2.fontSubfamily) {
        family += "-" + font2.name.fontSubfamily;
      }
    } else if (typeof font2 === "string") {
      if (typeof size === "undefined" && /[.0-9]+(%|em|p[xt])/.test(family)) {
        ({ family, size } = this._directSetFontString(family));
      }
    }
    if (typeof family !== "string") throw Error("null font in textFont()");
    if (arguments.length === 2 && typeof size === "object") {
      options2 = size;
      size = void 0;
    }
    this.states.setValue("textFont", { font: font2, family, size });
    if (typeof size !== "undefined") {
      this._setTextSize(size);
    }
    if (typeof options2 === "object") {
      this.textProperties(options2);
    }
    return this._applyTextProperties();
  };
  Renderer.prototype._directSetFontString = function(font2, debug = 0) {
    if (debug) console.log('_directSetFontString"' + font2 + '"');
    let defaults2 = ShorthandFontProps.reduce((props, p2) => {
      props[p2] = RendererTextProps[p2].default;
      return props;
    }, {});
    let el = this._cachedDiv(defaults2);
    el.style.font = font2;
    let style = getComputedStyle(el);
    ShorthandFontProps.forEach((prop) => {
      this.states[prop] = style[prop];
      if (debug) console.log("  this.states." + prop + '="' + style[prop] + '"');
    });
    return { family: style.fontFamily, size: style.fontSize };
  };
  Renderer.prototype.textLeading = function(leading) {
    if (typeof leading === "number") {
      this.states.setValue("leadingSet", true);
      this.states.setValue("textLeading", leading);
      return this._applyTextProperties();
    }
    return this.states.textLeading;
  };
  Renderer.prototype.textWeight = function(weight) {
    if (typeof weight === "number") {
      this.states.setValue("fontWeight", weight);
      this._applyTextProperties();
      if (!p53.prototype._isSafari()) {
        this._setCanvasStyleProperty("font-variation-settings", `"wght" ${weight}`);
      }
      return;
    }
    return this.states.fontWeight;
  };
  Renderer.prototype.textSize = function(size) {
    if (typeof size !== "undefined") {
      this._setTextSize(size);
      return this._applyTextProperties();
    }
    return this.states.textSize;
  };
  Renderer.prototype.textStyle = function(style) {
    if (typeof style !== "undefined") {
      this.states.setValue("fontStyle", style);
      return this._applyTextProperties();
    }
    return this.states.fontStyle;
  };
  Renderer.prototype.textWrap = function(wrapStyle) {
    if (wrapStyle === fn2.WORD || wrapStyle === fn2.CHAR) {
      this.states.setValue("textWrap", wrapStyle);
      return this._pInst;
    }
    return this.states.textWrap;
  };
  Renderer.prototype.textDirection = function(direction) {
    if (typeof direction !== "undefined") {
      this.states.setValue("direction", direction);
      return this._applyTextProperties();
    }
    return this.states.direction;
  };
  Renderer.prototype.textProperty = function(prop, value, opts) {
    let modified = false, debug = (opts == null ? void 0 : opts.debug) || false;
    if (typeof value === "undefined") {
      let props = this.textProperties();
      if (prop in props) return props[prop];
      throw Error('Unknown text option "' + prop + '"');
    }
    if (prop in this.states && this.states[prop] !== value) {
      this.states[prop] = value;
      modified = true;
      if (debug) {
        console.log("this.states." + prop + '="' + options[prop] + '"');
      }
    } else if (prop in this.textDrawingContext()) {
      this._setContextProperty(prop, value, debug);
      modified = true;
    } else if (prop in this.textCanvas().style) {
      this._setCanvasStyleProperty(prop, value, debug);
      modified = true;
    } else {
      console.warn('Ignoring unknown text option: "' + prop + '"\n');
    }
    return modified ? this._applyTextProperties() : this._pInst;
  };
  Renderer.prototype.textProperties = function(properties) {
    if (typeof properties !== "undefined") {
      Object.keys(properties).forEach((opt) => {
        this.textProperty(opt, properties[opt]);
      });
      return this._pInst;
    }
    let context = this.textDrawingContext();
    properties = ContextTextProps.reduce((props, p2) => {
      props[p2] = context[p2];
      return props;
    }, {});
    Object.keys(RendererTextProps).forEach((p2) => {
      var _a2;
      if (((_a2 = RendererTextProps[p2]) == null ? void 0 : _a2.type) === "Context2d") {
        properties[p2] = context[p2];
      } else {
        if (p2 === "textFont") {
          let current2 = this._currentTextFont();
          if (typeof current2 === "object" && "_pInst" in current2) {
            current2 = Object.assign({}, current2);
            delete current2._pInst;
          }
          properties[p2] = current2;
        } else {
          properties[p2] = this.states[p2];
        }
      }
    });
    return properties;
  };
  Renderer.prototype.textMode = function() {
  };
  Renderer.prototype._currentTextFont = function() {
    return this.states.textFont.font || this.states.textFont.family;
  };
  Renderer.prototype._computeBounds = function(type3, str, x, y, width, height, opts) {
    let context = this.textDrawingContext();
    let setBaseline = context.textBaseline;
    let { textLeading, textAlign } = this.states;
    ({ width, height } = this._rectModeAdjust(x, y, width, height));
    let lines = this._processLines(str, width, height);
    let boxes = lines.map((line, i) => this[type3].bind(this)(line, x, y + i * textLeading));
    if (lines.length > 1) {
      boxes.forEach((bb) => bb.x += p53.Renderer2D.prototype._xAlignOffset.call(this, textAlign, width));
    }
    if (typeof height !== "undefined") {
      p53.Renderer2D.prototype._yAlignOffset.call(this, boxes, height);
    }
    let bounds = boxes[0];
    if (lines.length > 1) {
      bounds = this._aggregateBounds(boxes);
      if (!(opts == null ? void 0 : opts.ignoreRectMode)) {
        this._rectModeAlign(bounds, width || 0, height || 0);
      }
    }
    context.textBaseline = setBaseline;
    return { bounds, lines };
  };
  Renderer.prototype._rectModeAdjust = function(x, y, width, height) {
    if (typeof width !== "undefined") {
      switch (this.states.rectMode) {
        case fn2.CENTER:
          break;
        case fn2.CORNERS:
          width -= x;
          height -= y;
          break;
        case fn2.RADIUS:
          width *= 2;
          height *= 2;
          break;
      }
    }
    return { x, y, width, height };
  };
  Renderer.prototype._setCanvasStyleProperty = function(opt, val2, debug) {
    let value = val2.toString();
    if (debug) console.log("canvas.style." + opt + '="' + value + '"');
    if (opt === FontVariationSettings) {
      this._handleFontVariationSettings(value);
    }
    this.textCanvas().style[opt] = value;
    if (this.textCanvas().style[opt] !== value) ;
  };
  Renderer.prototype._handleFontVariationSettings = function(value, debug = false) {
    if (typeof value === "object") {
      value = Object.keys(value).map((k) => k + " " + value[k]).join(", ");
    }
    let values = value.split(CommaDelimRe);
    values.forEach((v) => {
      v = v.replace(/["']/g, "");
      let matches = VariableAxesRe.exec(v);
      if (matches && matches.length) {
        let axis = matches[0];
        let val2 = parseFloat(parseFloat(v.replace(axis, "").trim()).toFixed(3));
        switch (axis) {
          case "wght":
            if (debug) console.log("setting font-weight=" + val2);
            if (this.states.fontWeight !== val2) this.textWeight(val2);
            return val2;
          case "wdth":
            break;
          case "ital":
            if (debug) console.log("setting font-style=" + (val2 ? "italic" : "normal"));
            break;
          case "slnt":
            if (debug) console.log("setting font-style=" + (val2 ? "oblique" : "normal"));
            break;
          case "opsz":
            if (debug) console.log("setting font-optical-size=" + val2);
            break;
        }
      }
    });
  };
  Renderer.prototype._setContextProperty = function(prop, val2, debug = false) {
    if (this.textDrawingContext()[prop] === val2) {
      return this._pInst;
    }
    (contextQueue ?? (contextQueue = [])).push([prop, val2]);
    if (debug) console.log("queued context2d." + prop + '="' + val2 + '"');
  };
  Renderer.prototype._handleRectMode = function(x, y, width, height) {
    let rectMode = this.states.rectMode;
    if (typeof width !== "undefined") {
      switch (rectMode) {
        case fn2.RADIUS:
          width *= 2;
          x -= width / 2;
          if (typeof height !== "undefined") {
            height *= 2;
            y -= height / 2;
          }
          break;
        case fn2.CENTER:
          x -= width / 2;
          if (typeof height !== "undefined") {
            y -= height / 2;
          }
          break;
        case fn2.CORNERS:
          width -= x;
          if (typeof height !== "undefined") {
            height -= y;
          }
          break;
      }
    }
    return { x, y, width, height };
  };
  Renderer.prototype._fontSizePx = function(theSize, { family } = this.states.textFont) {
    const isNumString = (num) => !isNaN(num) && num.trim() !== "";
    if (isNumString(theSize)) {
      return parseFloat(theSize);
    }
    let ele = this._cachedDiv({ fontSize: theSize });
    ele.style.fontSize = theSize;
    ele.style.fontFamily = family;
    let fontSizeStr = getComputedStyle(ele).fontSize;
    let fontSize = parseFloat(fontSizeStr);
    if (typeof fontSize !== "number") {
      throw Error("textSize: invalid font-size");
    }
    return fontSize;
  };
  Renderer.prototype._cachedDiv = function(props) {
    if (typeof cachedDiv === "undefined") {
      let ele = document.createElement("div");
      ele.ariaHidden = "true";
      ele.style.display = "none";
      Object.entries(props).forEach(([prop, val2]) => {
        ele.style[prop] = val2;
      });
      this.textCanvas().appendChild(ele);
      cachedDiv = ele;
    }
    return cachedDiv;
  };
  Renderer.prototype._aggregateBounds = function(bboxes) {
    let minX = Math.min(...bboxes.map((b3) => b3.x));
    let minY = Math.min(...bboxes.map((b3) => b3.y));
    let maxY = Math.max(...bboxes.map((b3) => b3.y + b3.h));
    let maxX = Math.max(...bboxes.map((b3) => b3.x + b3.w));
    return { x: minX, y: minY, w: maxX - minX, h: maxY - minY };
  };
  Renderer.prototype._processLines = function(str, width, height) {
    if (typeof width !== "undefined") {
      let drawingContext = this.textDrawingContext();
      if (drawingContext.textBaseline === fn2.BASELINE) {
        this.drawingContext.textBaseline = fn2.TOP;
      }
    }
    let lines = this._splitOnBreaks(str.toString());
    let hasLineBreaks = lines.length > 1;
    let hasWidth = typeof width !== "undefined";
    let exceedsWidth = hasWidth && lines.some((l) => this._textWidthSingle(l) > width);
    let { textLeading: leading, textWrap } = this.states;
    if (hasLineBreaks || exceedsWidth) {
      if (hasWidth) lines = this._lineate(textWrap, lines, width);
    }
    if (hasWidth && typeof height !== "undefined") {
      if (typeof leading === "undefined") {
        throw Error("leading is required if height is specified");
      }
      for (let i = 0; i < lines.length; i++) {
        let lh = leading * (i + 1);
        if (lh > height) {
          lines = lines.slice(0, i);
          break;
        }
      }
    }
    return lines;
  };
  Renderer.prototype._xAlignOffset = function(textAlign, width) {
    switch (textAlign) {
      case fn2.LEFT:
        return 0;
      case fn2.CENTER:
        return width / 2;
      case fn2.RIGHT:
        return width;
      case textCoreConstants.START:
        return 0;
      case textCoreConstants.END:
        throw new Error("textBounds: END not yet supported for textAlign");
      default:
        return 0;
    }
  };
  Renderer.prototype._rectModeAlign = function(bb, width, height) {
    if (typeof width !== "undefined") {
      switch (this.states.rectMode) {
        case fn2.CENTER:
          bb.x -= (width - bb.w) / 2;
          bb.y -= (height - bb.h) / 2;
          break;
        case fn2.CORNERS:
          bb.w += bb.x;
          bb.h += bb.y;
          break;
        case fn2.RADIUS:
          bb.x -= (width - bb.w) / 2;
          bb.y -= (height - bb.h) / 2;
          bb.w /= 2;
          bb.h /= 2;
          break;
      }
      return bb;
    }
  };
  Renderer.prototype._rectModeAlignRevert = function(bb, width, height) {
    if (typeof width !== "undefined") {
      switch (this.states.rectMode) {
        case fn2.CENTER:
          bb.x += (width - bb.w) / 2;
          bb.y += (height - bb.h) / 2;
          break;
        case fn2.CORNERS:
          bb.w -= bb.x;
          bb.h -= bb.y;
          break;
        case fn2.RADIUS:
          bb.x += (width - bb.w) / 2;
          bb.y += (height - bb.h) / 2;
          bb.w *= 2;
          bb.h *= 2;
          break;
      }
      return bb;
    }
  };
  Renderer.prototype._textWidthSingle = function(s) {
    let metrics = this.textDrawingContext().measureText(s);
    let abl = metrics.actualBoundingBoxLeft;
    let abr = metrics.actualBoundingBoxRight;
    return abr + abl;
  };
  Renderer.prototype._fontWidthSingle = function(s) {
    return this.textDrawingContext().measureText(s).width;
  };
  Renderer.prototype._textBoundsSingle = function(s, x = 0, y = 0) {
    let metrics = this.textDrawingContext().measureText(s);
    let asc = metrics.actualBoundingBoxAscent;
    let desc = metrics.actualBoundingBoxDescent;
    let abl = metrics.actualBoundingBoxLeft;
    let abr = metrics.actualBoundingBoxRight;
    return { x: x - abl, y: y - asc, w: abr + abl, h: asc + desc };
  };
  Renderer.prototype._fontBoundsSingle = function(s, x = 0, y = 0) {
    let metrics = this.textDrawingContext().measureText(s);
    let asc = metrics.fontBoundingBoxAscent;
    let desc = metrics.fontBoundingBoxDescent;
    x -= this._xAlignOffset(this.states.textAlign, metrics.width);
    return { x, y: y - asc, w: metrics.width, h: asc + desc };
  };
  Renderer.prototype._setTextSize = function(theSize) {
    if (typeof theSize === "string") {
      theSize = this._fontSizePx(theSize);
    }
    if (typeof theSize === "number") {
      if (this.states.textSize !== theSize) {
        this.states.setValue("textSize", theSize);
        if (!this.states.leadingSet) {
          this.states.setValue("textLeading", this.states.textSize * LeadingScale);
        }
        return true;
      }
    } else {
      console.warn("textSize: invalid size: " + theSize);
    }
    return false;
  };
  Renderer.prototype._lineate = function(textWrap, lines, maxWidth = Infinity, opts = {}) {
    let splitter = opts.splitChar ?? (textWrap === fn2.WORD ? " " : "");
    let line, testLine, testWidth, words, newLines = [];
    for (let lidx = 0; lidx < lines.length; lidx++) {
      line = "";
      words = lines[lidx].split(splitter);
      for (let widx = 0; widx < words.length; widx++) {
        testLine = `${line + words[widx]}` + splitter;
        testWidth = this._textWidthSingle(testLine);
        if (line.length > 0 && testWidth > maxWidth) {
          newLines.push(line.trim());
          line = `${words[widx]}` + splitter;
        } else {
          line = testLine;
        }
      }
      newLines.push(line.trim());
    }
    return newLines;
  };
  Renderer.prototype._splitOnBreaks = function(s) {
    if (!s || s.length === 0) return [""];
    return s.replace(TabsRe, "  ").split(LinebreakRe);
  };
  Renderer.prototype._parseFontFamily = function(familyStr) {
    let parts = familyStr.split(CommaDelimRe);
    let family = parts.map((part) => {
      part = part.trim();
      if (part.indexOf(" ") > -1 && !QuotedRe.test(part)) {
        part = `"${part}"`;
      }
      return part;
    }).join(", ");
    return family;
  };
  Renderer.prototype._applyFontString = function() {
    let { textFont, textSize, lineHeight, fontStyle, fontWeight, fontVariant } = this.states;
    let drawingContext = this.textDrawingContext();
    let family = this._parseFontFamily(textFont.family);
    let style = fontStyle !== fn2.NORMAL ? `${fontStyle} ` : "";
    let weight = fontWeight !== fn2.NORMAL ? `${fontWeight} ` : "";
    let variant = fontVariant !== fn2.NORMAL ? `${fontVariant} ` : "";
    let fsize = `${textSize}px` + (lineHeight !== fn2.NORMAL ? `/${lineHeight} ` : " ");
    let fontString = `${style}${variant}${weight}${fsize}${family}`.trim();
    drawingContext.font = fontString;
    if (drawingContext.font !== fontString) {
      let expected = fontString;
      let actual = drawingContext.font;
      if (expected !== actual) {
        return false;
      }
    }
    return true;
  };
  Renderer.prototype._applyTextProperties = function(debug = false) {
    this._applyFontString();
    let context = this.textDrawingContext();
    context.direction = this.states.direction;
    context.textAlign = this.states.textAlign;
    context.textBaseline = this.states.textBaseline;
    let stretch = this.states.fontStretch;
    if (FontStretchKeys.includes(stretch) && context.fontStretch !== stretch) {
      context.fontStretch = stretch;
    }
    while (contextQueue == null ? void 0 : contextQueue.length) {
      let [prop, val2] = contextQueue.shift();
      if (debug) console.log('apply context property "' + prop + '" = "' + val2 + '"');
      context[prop] = val2;
      if (context[prop] !== val2) {
        console.warn(`Unable to set '${prop}' property on context2d. It may not be supported.`);
        console.log('Expected "' + val2 + '" but got: "' + context[prop] + '"');
      }
    }
    return this._pInst;
  };
  if (p53.Renderer2D) {
    p53.Renderer2D.prototype.textCanvas = function() {
      return this.canvas;
    };
    p53.Renderer2D.prototype.textDrawingContext = function() {
      return this.drawingContext;
    };
    p53.Renderer2D.prototype._renderText = function(text2, x, y, maxY, minY) {
      let states = this.states;
      let context = this.textDrawingContext();
      if (y < minY || y >= maxY) {
        return;
      }
      this.push();
      if (states.strokeColor && states.strokeSet) {
        context.strokeText(text2, x, y);
      }
      if (!this._clipping && states.fillColor) {
        if (!states.fillSet) {
          this._setFill(DefaultFill);
        }
        context.fillText(text2, x, y);
      }
      this.pop();
    };
    p53.Renderer2D.prototype._positionLines = function(x, y, width, height, lines) {
      let { textLeading, textAlign } = this.states;
      let adjustedX, lineData = new Array(lines.length);
      let adjustedW = typeof width === "undefined" ? 0 : width;
      let adjustedH = typeof height === "undefined" ? 0 : height;
      for (let i = 0; i < lines.length; i++) {
        switch (textAlign) {
          case textCoreConstants.START:
            throw new Error("textBounds: START not yet supported for textAlign");
          case fn2.LEFT:
            adjustedX = x;
            break;
          case fn2.CENTER:
            adjustedX = x + adjustedW / 2;
            break;
          case fn2.RIGHT:
            adjustedX = x + adjustedW;
            break;
          case textCoreConstants.END:
            throw new Error("textBounds: END not yet supported for textAlign");
        }
        lineData[i] = { text: lines[i], x: adjustedX, y: y + i * textLeading };
      }
      return this._yAlignOffset(lineData, adjustedH);
    };
    p53.Renderer2D.prototype._yAlignOffset = function(dataArr, height) {
      if (typeof height === "undefined") {
        throw Error("_yAlignOffset: height is required");
      }
      let { textLeading, textBaseline } = this.states;
      let yOff = 0, numLines = dataArr.length;
      let ydiff = height - textLeading * (numLines - 1);
      switch (textBaseline) {
        case fn2.TOP:
          break;
        case fn2.BASELINE:
          break;
        case textCoreConstants._CTX_MIDDLE:
          yOff = ydiff / 2;
          break;
        case fn2.BOTTOM:
          yOff = ydiff;
          break;
        case textCoreConstants.IDEOGRAPHIC:
          console.warn("textBounds: IDEOGRAPHIC not yet supported for textBaseline");
          break;
        case textCoreConstants.HANGING:
          console.warn("textBounds: HANGING not yet supported for textBaseline");
          break;
      }
      dataArr.forEach((ele) => ele.y += yOff);
      return dataArr;
    };
  }
  if (p53.RendererGL) {
    p53.RendererGL.prototype.textCanvas = function() {
      if (!this._textCanvas) {
        this._textCanvas = document.createElement("canvas");
        this._textCanvas.width = 1;
        this._textCanvas.height = 1;
        this._textCanvas.style.display = "none";
        this.canvas.parentElement.insertBefore(this._textCanvas, this.canvas);
      }
      return this._textCanvas;
    };
    p53.RendererGL.prototype.textDrawingContext = function() {
      if (!this._textDrawingContext) {
        const textCanvas = this.textCanvas();
        this._textDrawingContext = textCanvas.getContext("2d");
      }
      return this._textDrawingContext;
    };
    const oldRemove = p53.RendererGL.prototype.remove;
    p53.RendererGL.prototype.remove = function() {
      if (this._textCanvas) {
        this._textCanvas.parentElement.removeChild(this._textCanvas);
      }
      oldRemove.call(this);
    };
    p53.RendererGL.prototype._positionLines = function(x, y, width, height, lines) {
      let { textLeading, textAlign } = this.states;
      const widths = lines.map((line) => this._fontWidthSingle(line));
      let adjustedX, lineData = new Array(lines.length);
      let adjustedW = typeof width === "undefined" ? Math.max(0, ...widths) : width;
      let adjustedH = typeof height === "undefined" ? 0 : height;
      for (let i = 0; i < lines.length; i++) {
        switch (textAlign) {
          case textCoreConstants.START:
            throw new Error("textBounds: START not yet supported for textAlign");
          case fn2.LEFT:
            adjustedX = x;
            break;
          case fn2.CENTER:
            adjustedX = x + (adjustedW - widths[i]) / 2 - adjustedW / 2 + (width || 0) / 2;
            break;
          case fn2.RIGHT:
            adjustedX = x + adjustedW - widths[i] - adjustedW + (width || 0);
            break;
          case textCoreConstants.END:
            throw new Error("textBounds: END not yet supported for textAlign");
        }
        lineData[i] = { text: lines[i], x: adjustedX, y: y + i * textLeading };
      }
      return this._yAlignOffset(lineData, adjustedH);
    };
    p53.RendererGL.prototype._yAlignOffset = function(dataArr, height) {
      var _a2;
      if (typeof height === "undefined") {
        throw Error("_yAlignOffset: height is required");
      }
      let { textLeading, textBaseline, textSize, textFont } = this.states;
      let yOff = 0, numLines = dataArr.length;
      let totalHeight = textSize * numLines + (textLeading - textSize) * (numLines - 1);
      switch (textBaseline) {
        case fn2.TOP:
          yOff = textSize;
          break;
        case fn2.BASELINE:
          break;
        case textCoreConstants._CTX_MIDDLE:
          yOff = -totalHeight / 2 + textSize + (height || 0) / 2;
          break;
        case fn2.BOTTOM:
          yOff = -(totalHeight - textSize) + (height || 0);
          break;
        default:
          console.warn(`${textBaseline} is not supported in WebGL mode.`);
          break;
      }
      yOff += ((_a2 = this.states.textFont.font) == null ? void 0 : _a2._verticalAlign(textSize)) || 0;
      dataArr.forEach((ele) => ele.y += yOff);
      return dataArr;
    };
  }
}
if (typeof p5 !== "undefined") {
  textCore(p5, p5.prototype);
}

// node_modules/p5/dist/type/p5.Font.js
var import_unicode_range = __toESM(require_lib());

// node_modules/p5/dist/type/unicodeRanges.js
var unicodeRanges = [
  {
    category: "control character",
    hexrange: ["0000", "001f"]
  },
  {
    category: "basic latin",
    hexrange: ["0000", "007f"]
  },
  {
    category: "latin-1 supplement",
    hexrange: ["0080", "00ff"]
  },
  {
    category: "latin extended-a",
    hexrange: ["0100", "017f"]
  },
  {
    category: "latin extended-b",
    hexrange: ["0180", "024f"]
  },
  {
    category: "ipa extensions",
    hexrange: ["0250", "02af"]
  },
  {
    category: "spacing modifier letters",
    hexrange: ["02b0", "02ff"]
  },
  {
    category: "combining diacritical marks",
    hexrange: ["0300", "036f"]
  },
  {
    category: "greek and coptic",
    hexrange: ["0370", "03ff"]
  },
  {
    category: "cyrillic",
    hexrange: ["0400", "04ff"]
  },
  {
    category: "cyrillic supplement",
    hexrange: ["0500", "052f"]
  },
  {
    category: "armenian",
    hexrange: ["0530", "058f"]
  },
  {
    category: "hebrew",
    hexrange: ["0590", "05ff"]
  },
  {
    category: "arabic",
    hexrange: ["0600", "06ff"]
  },
  {
    category: "syriac",
    hexrange: ["0700", "074f"]
  },
  {
    category: "arabic supplement",
    hexrange: ["0750", "077f"]
  },
  {
    category: "thaana",
    hexrange: ["0780", "07bf"]
  },
  {
    category: "nko",
    hexrange: ["07c0", "07ff"]
  },
  {
    category: "samaritan",
    hexrange: ["0800", "083f"]
  },
  {
    category: "mandaic",
    hexrange: ["0840", "085f"]
  },
  {
    category: "syriac supplement",
    hexrange: ["0860", "086f"]
  },
  {
    category: "arabic extended-b",
    hexrange: ["0870", "089f"]
  },
  {
    category: "arabic extended-a",
    hexrange: ["08a0", "08ff"]
  },
  {
    category: "devanagari",
    hexrange: ["0900", "097f"]
  },
  {
    category: "bengali",
    hexrange: ["0980", "09ff"]
  },
  {
    category: "gurmukhi",
    hexrange: ["0a00", "0a7f"]
  },
  {
    category: "gujarati",
    hexrange: ["0a80", "0aff"]
  },
  {
    category: "oriya",
    hexrange: ["0b00", "0b7f"]
  },
  {
    category: "tamil",
    hexrange: ["0b80", "0bff"]
  },
  {
    category: "telugu",
    hexrange: ["0c00", "0c7f"]
  },
  {
    category: "kannada",
    hexrange: ["0c80", "0cff"]
  },
  {
    category: "malayalam",
    hexrange: ["0d00", "0d7f"]
  },
  {
    category: "sinhala",
    hexrange: ["0d80", "0dff"]
  },
  {
    category: "thai",
    hexrange: ["0e00", "0e7f"]
  },
  {
    category: "lao",
    hexrange: ["0e80", "0eff"]
  },
  {
    category: "tibetan",
    hexrange: ["0f00", "0fff"]
  },
  {
    category: "myanmar",
    hexrange: ["1000", "109f"]
  },
  {
    category: "georgian",
    hexrange: ["10a0", "10ff"]
  },
  {
    category: "hangul jamo",
    hexrange: ["1100", "11ff"]
  },
  {
    category: "ethiopic",
    hexrange: ["1200", "137f"]
  },
  {
    category: "ethiopic supplement",
    hexrange: ["1380", "139f"]
  },
  {
    category: "cherokee",
    hexrange: ["13a0", "13ff"]
  },
  {
    category: "unified canadian aboriginal syllabics",
    hexrange: ["1400", "167f"]
  },
  {
    category: "ogham",
    hexrange: ["1680", "169f"]
  },
  {
    category: "runic",
    hexrange: ["16a0", "16ff"]
  },
  {
    category: "tagalog",
    hexrange: ["1700", "171f"]
  },
  {
    category: "hanunoo",
    hexrange: ["1720", "173f"]
  },
  {
    category: "buhid",
    hexrange: ["1740", "175f"]
  },
  {
    category: "tagbanwa",
    hexrange: ["1760", "177f"]
  },
  {
    category: "khmer",
    hexrange: ["1780", "17ff"]
  },
  {
    category: "mongolian",
    hexrange: ["1800", "18af"]
  },
  {
    category: "unified canadian aboriginal syllabics extended",
    hexrange: ["18b0", "18ff"]
  },
  {
    category: "limbu",
    hexrange: ["1900", "194f"]
  },
  {
    category: "tai le",
    hexrange: ["1950", "197f"]
  },
  {
    category: "new tai lue",
    hexrange: ["1980", "19df"]
  },
  {
    category: "khmer symbols",
    hexrange: ["19e0", "19ff"]
  },
  {
    category: "buginese",
    hexrange: ["1a00", "1a1f"]
  },
  {
    category: "tai tham",
    hexrange: ["1a20", "1aaf"]
  },
  {
    category: "combining diacritical marks extended",
    hexrange: ["1ab0", "1aff"]
  },
  {
    category: "balinese",
    hexrange: ["1b00", "1b7f"]
  },
  {
    category: "sundanese",
    hexrange: ["1b80", "1bbf"]
  },
  {
    category: "batak",
    hexrange: ["1bc0", "1bff"]
  },
  {
    category: "lepcha",
    hexrange: ["1c00", "1c4f"]
  },
  {
    category: "ol chiki",
    hexrange: ["1c50", "1c7f"]
  },
  {
    category: "cyrillic extended-c",
    hexrange: ["1c80", "1c8f"]
  },
  {
    category: "georgian extended",
    hexrange: ["1c90", "1cbf"]
  },
  {
    category: "sundanese supplement",
    hexrange: ["1cc0", "1ccf"]
  },
  {
    category: "vedic extensions",
    hexrange: ["1cd0", "1cff"]
  },
  {
    category: "phonetic extensions",
    hexrange: ["1d00", "1d7f"]
  },
  {
    category: "phonetic extensions supplement",
    hexrange: ["1d80", "1dbf"]
  },
  {
    category: "combining diacritical marks supplement",
    hexrange: ["1dc0", "1dff"]
  },
  {
    category: "latin extended additional",
    hexrange: ["1e00", "1eff"]
  },
  {
    category: "greek extended",
    hexrange: ["1f00", "1fff"]
  },
  {
    category: "general punctuation",
    hexrange: ["2000", "206f"]
  },
  {
    category: "superscripts and subscripts",
    hexrange: ["2070", "209f"]
  },
  {
    category: "currency symbols",
    hexrange: ["20a0", "20cf"]
  },
  {
    category: "combining diacritical marks for symbols",
    hexrange: ["20d0", "20ff"]
  },
  {
    category: "letterlike symbols",
    hexrange: ["2100", "214f"]
  },
  {
    category: "number forms",
    hexrange: ["2150", "218f"]
  },
  {
    category: "arrows",
    hexrange: ["2190", "21ff"]
  },
  {
    category: "mathematical operators",
    hexrange: ["2200", "22ff"]
  },
  {
    category: "miscellaneous technical",
    hexrange: ["2300", "23ff"]
  },
  {
    category: "control pictures",
    hexrange: ["2400", "243f"]
  },
  {
    category: "optical character recognition",
    hexrange: ["2440", "245f"]
  },
  {
    category: "enclosed alphanumerics",
    hexrange: ["2460", "24ff"]
  },
  {
    category: "box drawing",
    hexrange: ["2500", "257f"]
  },
  {
    category: "block elements",
    hexrange: ["2580", "259f"]
  },
  {
    category: "geometric shapes",
    hexrange: ["25a0", "25ff"]
  },
  {
    category: "miscellaneous symbols",
    hexrange: ["2600", "26ff"]
  },
  {
    category: "dingbats",
    hexrange: ["2700", "27bf"]
  },
  {
    category: "miscellaneous mathematical symbols-a",
    hexrange: ["27c0", "27ef"]
  },
  {
    category: "supplemental arrows-a",
    hexrange: ["27f0", "27ff"]
  },
  {
    category: "braille patterns",
    hexrange: ["2800", "28ff"]
  },
  {
    category: "supplemental arrows-b",
    hexrange: ["2900", "297f"]
  },
  {
    category: "miscellaneous mathematical symbols-b",
    hexrange: ["2980", "29ff"]
  },
  {
    category: "supplemental mathematical operators",
    hexrange: ["2a00", "2aff"]
  },
  {
    category: "miscellaneous symbols and arrows",
    hexrange: ["2b00", "2bff"]
  },
  {
    category: "glagolitic",
    hexrange: ["2c00", "2c5f"]
  },
  {
    category: "latin extended-c",
    hexrange: ["2c60", "2c7f"]
  },
  {
    category: "coptic",
    hexrange: ["2c80", "2cff"]
  },
  {
    category: "georgian supplement",
    hexrange: ["2d00", "2d2f"]
  },
  {
    category: "tifinagh",
    hexrange: ["2d30", "2d7f"]
  },
  {
    category: "ethiopic extended",
    hexrange: ["2d80", "2ddf"]
  },
  {
    category: "cyrillic extended-a",
    hexrange: ["2de0", "2dff"]
  },
  {
    category: "supplemental punctuation",
    hexrange: ["2e00", "2e7f"]
  },
  {
    category: "cjk radicals supplement",
    hexrange: ["2e80", "2eff"]
  },
  {
    category: "kangxi radicals",
    hexrange: ["2f00", "2fdf"]
  },
  {
    category: "ideographic description characters",
    hexrange: ["2ff0", "2fff"]
  },
  {
    category: "cjk symbols and punctuation",
    hexrange: ["3000", "303f"]
  },
  {
    category: "hiragana",
    hexrange: ["3040", "309f"]
  },
  {
    category: "katakana",
    hexrange: ["30a0", "30ff"]
  },
  {
    category: "bopomofo",
    hexrange: ["3100", "312f"]
  },
  {
    category: "hangul compatibility jamo",
    hexrange: ["3130", "318f"]
  },
  {
    category: "kanbun",
    hexrange: ["3190", "319f"]
  },
  {
    category: "bopomofo extended",
    hexrange: ["31a0", "31bf"]
  },
  {
    category: "cjk strokes",
    hexrange: ["31c0", "31ef"]
  },
  {
    category: "katakana phonetic extensions",
    hexrange: ["31f0", "31ff"]
  },
  {
    category: "enclosed cjk letters and months",
    hexrange: ["3200", "32ff"]
  },
  {
    category: "cjk compatibility",
    hexrange: ["3300", "33ff"]
  },
  {
    category: "cjk unified ideographs extension a",
    hexrange: ["3400", "4dbf"]
  },
  {
    category: "yijing hexagram symbols",
    hexrange: ["4dc0", "4dff"]
  },
  {
    category: "cjk unified ideographs",
    hexrange: ["4e00", "9fff"]
  },
  {
    category: "yi syllables",
    hexrange: ["a000", "a48f"]
  },
  {
    category: "yi radicals",
    hexrange: ["a490", "a4cf"]
  },
  {
    category: "lisu",
    hexrange: ["a4d0", "a4ff"]
  },
  {
    category: "vai",
    hexrange: ["a500", "a63f"]
  },
  {
    category: "cyrillic extended-b",
    hexrange: ["a640", "a69f"]
  },
  {
    category: "bamum",
    hexrange: ["a6a0", "a6ff"]
  },
  {
    category: "modifier tone letters",
    hexrange: ["a700", "a71f"]
  },
  {
    category: "latin extended-d",
    hexrange: ["a720", "a7ff"]
  },
  {
    category: "syloti nagri",
    hexrange: ["a800", "a82f"]
  },
  {
    category: "common indic number forms",
    hexrange: ["a830", "a83f"]
  },
  {
    category: "phags-pa",
    hexrange: ["a840", "a87f"]
  },
  {
    category: "saurashtra",
    hexrange: ["a880", "a8df"]
  },
  {
    category: "devanagari extended",
    hexrange: ["a8e0", "a8ff"]
  },
  {
    category: "kayah li",
    hexrange: ["a900", "a92f"]
  },
  {
    category: "rejang",
    hexrange: ["a930", "a95f"]
  },
  {
    category: "hangul jamo extended-a",
    hexrange: ["a960", "a97f"]
  },
  {
    category: "javanese",
    hexrange: ["a980", "a9df"]
  },
  {
    category: "myanmar extended-b",
    hexrange: ["a9e0", "a9ff"]
  },
  {
    category: "cham",
    hexrange: ["aa00", "aa5f"]
  },
  {
    category: "myanmar extended-a",
    hexrange: ["aa60", "aa7f"]
  },
  {
    category: "tai viet",
    hexrange: ["aa80", "aadf"]
  },
  {
    category: "meetei mayek extensions",
    hexrange: ["aae0", "aaff"]
  },
  {
    category: "ethiopic extended-a",
    hexrange: ["ab00", "ab2f"]
  },
  {
    category: "latin extended-e",
    hexrange: ["ab30", "ab6f"]
  },
  {
    category: "cherokee supplement",
    hexrange: ["ab70", "abbf"]
  },
  {
    category: "meetei mayek",
    hexrange: ["abc0", "abff"]
  },
  {
    category: "hangul syllables",
    hexrange: ["ac00", "d7af"]
  },
  {
    category: "hangul jamo extended-b",
    hexrange: ["d7b0", "d7ff"]
  },
  {
    category: "high surrogates",
    hexrange: ["d800", "db7f"]
  },
  {
    category: "high private use surrogates",
    hexrange: ["db80", "dbff"]
  },
  {
    category: "low surrogates",
    hexrange: ["dc00", "dfff"]
  },
  {
    category: "private use area",
    hexrange: ["e000", "f8ff"]
  },
  {
    category: "cjk compatibility ideographs",
    hexrange: ["f900", "faff"]
  },
  {
    category: "alphabetic presentation forms",
    hexrange: ["fb00", "fb4f"]
  },
  {
    category: "arabic presentation forms-a",
    hexrange: ["fb50", "fdff"]
  },
  {
    category: "variation selectors",
    hexrange: ["fe00", "fe0f"]
  },
  {
    category: "vertical forms",
    hexrange: ["fe10", "fe1f"]
  },
  {
    category: "combining half marks",
    hexrange: ["fe20", "fe2f"]
  },
  {
    category: "cjk compatibility forms",
    hexrange: ["fe30", "fe4f"]
  },
  {
    category: "small form variants",
    hexrange: ["fe50", "fe6f"]
  },
  {
    category: "arabic presentation forms-b",
    hexrange: ["fe70", "feff"]
  },
  {
    category: "halfwidth and fullwidth forms",
    hexrange: ["ff00", "ffef"]
  },
  {
    category: "specials",
    hexrange: ["fff0", "ffff"]
  },
  {
    category: "linear b syllabary",
    hexrange: ["10000", "1007f"]
  },
  {
    category: "linear b ideograms",
    hexrange: ["10080", "100ff"]
  },
  {
    category: "aegean numbers",
    hexrange: ["10100", "1013f"]
  },
  {
    category: "ancient greek numbers",
    hexrange: ["10140", "1018f"]
  },
  {
    category: "ancient symbols",
    hexrange: ["10190", "101cf"]
  },
  {
    category: "phaistos disc",
    hexrange: ["101d0", "101ff"]
  },
  {
    category: "lycian",
    hexrange: ["10280", "1029f"]
  },
  {
    category: "carian",
    hexrange: ["102a0", "102df"]
  },
  {
    category: "coptic epact numbers",
    hexrange: ["102e0", "102ff"]
  },
  {
    category: "old italic",
    hexrange: ["10300", "1032f"]
  },
  {
    category: "gothic",
    hexrange: ["10330", "1034f"]
  },
  {
    category: "old permic",
    hexrange: ["10350", "1037f"]
  },
  {
    category: "ugaritic",
    hexrange: ["10380", "1039f"]
  },
  {
    category: "old persian",
    hexrange: ["103a0", "103df"]
  },
  {
    category: "deseret",
    hexrange: ["10400", "1044f"]
  },
  {
    category: "shavian",
    hexrange: ["10450", "1047f"]
  },
  {
    category: "osmanya",
    hexrange: ["10480", "104af"]
  },
  {
    category: "osage",
    hexrange: ["104b0", "104ff"]
  },
  {
    category: "elbasan",
    hexrange: ["10500", "1052f"]
  },
  {
    category: "caucasian albanian",
    hexrange: ["10530", "1056f"]
  },
  {
    category: "vithkuqi",
    hexrange: ["10570", "105bf"]
  },
  {
    category: "linear a",
    hexrange: ["10600", "1077f"]
  },
  {
    category: "latin extended-f",
    hexrange: ["10780", "107bf"]
  },
  {
    category: "cypriot syllabary",
    hexrange: ["10800", "1083f"]
  },
  {
    category: "imperial aramaic",
    hexrange: ["10840", "1085f"]
  },
  {
    category: "palmyrene",
    hexrange: ["10860", "1087f"]
  },
  {
    category: "nabataean",
    hexrange: ["10880", "108af"]
  },
  {
    category: "hatran",
    hexrange: ["108e0", "108ff"]
  },
  {
    category: "phoenician",
    hexrange: ["10900", "1091f"]
  },
  {
    category: "lydian",
    hexrange: ["10920", "1093f"]
  },
  {
    category: "meroitic hieroglyphs",
    hexrange: ["10980", "1099f"]
  },
  {
    category: "meroitic cursive",
    hexrange: ["109a0", "109ff"]
  },
  {
    category: "kharoshthi",
    hexrange: ["10a00", "10a5f"]
  },
  {
    category: "old south arabian",
    hexrange: ["10a60", "10a7f"]
  },
  {
    category: "old north arabian",
    hexrange: ["10a80", "10a9f"]
  },
  {
    category: "manichaean",
    hexrange: ["10ac0", "10aff"]
  },
  {
    category: "avestan",
    hexrange: ["10b00", "10b3f"]
  },
  {
    category: "inscriptional parthian",
    hexrange: ["10b40", "10b5f"]
  },
  {
    category: "inscriptional pahlavi",
    hexrange: ["10b60", "10b7f"]
  },
  {
    category: "psalter pahlavi",
    hexrange: ["10b80", "10baf"]
  },
  {
    category: "old turkic",
    hexrange: ["10c00", "10c4f"]
  },
  {
    category: "old hungarian",
    hexrange: ["10c80", "10cff"]
  },
  {
    category: "hanifi rohingya",
    hexrange: ["10d00", "10d3f"]
  },
  {
    category: "rumi numeral symbols",
    hexrange: ["10e60", "10e7f"]
  },
  {
    category: "yezidi",
    hexrange: ["10e80", "10ebf"]
  },
  {
    category: "arabic extended-c",
    hexrange: ["10ec0", "10eff"]
  },
  {
    category: "old sogdian",
    hexrange: ["10f00", "10f2f"]
  },
  {
    category: "sogdian",
    hexrange: ["10f30", "10f6f"]
  },
  {
    category: "old uyghur",
    hexrange: ["10f70", "10faf"]
  },
  {
    category: "chorasmian",
    hexrange: ["10fb0", "10fdf"]
  },
  {
    category: "elymaic",
    hexrange: ["10fe0", "10fff"]
  },
  {
    category: "brahmi",
    hexrange: ["11000", "1107f"]
  },
  {
    category: "kaithi",
    hexrange: ["11080", "110cf"]
  },
  {
    category: "sora sompeng",
    hexrange: ["110d0", "110ff"]
  },
  {
    category: "chakma",
    hexrange: ["11100", "1114f"]
  },
  {
    category: "mahajani",
    hexrange: ["11150", "1117f"]
  },
  {
    category: "sharada",
    hexrange: ["11180", "111df"]
  },
  {
    category: "sinhala archaic numbers",
    hexrange: ["111e0", "111ff"]
  },
  {
    category: "khojki",
    hexrange: ["11200", "1124f"]
  },
  {
    category: "multani",
    hexrange: ["11280", "112af"]
  },
  {
    category: "khudawadi",
    hexrange: ["112b0", "112ff"]
  },
  {
    category: "grantha",
    hexrange: ["11300", "1137f"]
  },
  {
    category: "newa",
    hexrange: ["11400", "1147f"]
  },
  {
    category: "tirhuta",
    hexrange: ["11480", "114df"]
  },
  {
    category: "siddham",
    hexrange: ["11580", "115ff"]
  },
  {
    category: "modi",
    hexrange: ["11600", "1165f"]
  },
  {
    category: "mongolian supplement",
    hexrange: ["11660", "1167f"]
  },
  {
    category: "takri",
    hexrange: ["11680", "116cf"]
  },
  {
    category: "ahom",
    hexrange: ["11700", "1174f"]
  },
  {
    category: "dogra",
    hexrange: ["11800", "1184f"]
  },
  {
    category: "warang citi",
    hexrange: ["118a0", "118ff"]
  },
  {
    category: "dives akuru",
    hexrange: ["11900", "1195f"]
  },
  {
    category: "nandinagari",
    hexrange: ["119a0", "119ff"]
  },
  {
    category: "zanabazar square",
    hexrange: ["11a00", "11a4f"]
  },
  {
    category: "soyombo",
    hexrange: ["11a50", "11aaf"]
  },
  {
    category: "unified canadian aboriginal syllabics extended-a",
    hexrange: ["11ab0", "11abf"]
  },
  {
    category: "pau cin hau",
    hexrange: ["11ac0", "11aff"]
  },
  {
    category: "devanagari extended-a",
    hexrange: ["11b00", "11b5f"]
  },
  {
    category: "bhaiksuki",
    hexrange: ["11c00", "11c6f"]
  },
  {
    category: "marchen",
    hexrange: ["11c70", "11cbf"]
  },
  {
    category: "masaram gondi",
    hexrange: ["11d00", "11d5f"]
  },
  {
    category: "gunjala gondi",
    hexrange: ["11d60", "11daf"]
  },
  {
    category: "makasar",
    hexrange: ["11ee0", "11eff"]
  },
  {
    category: "kawi",
    hexrange: ["11f00", "11f5f"]
  },
  {
    category: "lisu supplement",
    hexrange: ["11fb0", "11fbf"]
  },
  {
    category: "tamil supplement",
    hexrange: ["11fc0", "11fff"]
  },
  {
    category: "cuneiform",
    hexrange: ["12000", "123ff"]
  },
  {
    category: "cuneiform numbers and punctuation",
    hexrange: ["12400", "1247f"]
  },
  {
    category: "early dynastic cuneiform",
    hexrange: ["12480", "1254f"]
  },
  {
    category: "cypro-minoan",
    hexrange: ["12f90", "12fff"]
  },
  {
    category: "egyptian hieroglyphs",
    hexrange: ["13000", "1342f"]
  },
  {
    category: "egyptian hieroglyph format controls",
    hexrange: ["13430", "1345f"]
  },
  {
    category: "anatolian hieroglyphs",
    hexrange: ["14400", "1467f"]
  },
  {
    category: "bamum supplement",
    hexrange: ["16800", "16a3f"]
  },
  {
    category: "mro",
    hexrange: ["16a40", "16a6f"]
  },
  {
    category: "tangsa",
    hexrange: ["16a70", "16acf"]
  },
  {
    category: "bassa vah",
    hexrange: ["16ad0", "16aff"]
  },
  {
    category: "pahawh hmong",
    hexrange: ["16b00", "16b8f"]
  },
  {
    category: "medefaidrin",
    hexrange: ["16e40", "16e9f"]
  },
  {
    category: "miao",
    hexrange: ["16f00", "16f9f"]
  },
  {
    category: "ideographic symbols and punctuation",
    hexrange: ["16fe0", "16fff"]
  },
  {
    category: "tangut",
    hexrange: ["17000", "187ff"]
  },
  {
    category: "tangut components",
    hexrange: ["18800", "18aff"]
  },
  {
    category: "khitan small script",
    hexrange: ["18b00", "18cff"]
  },
  {
    category: "tangut supplement",
    hexrange: ["18d00", "18d7f"]
  },
  {
    category: "kana extended-b",
    hexrange: ["1aff0", "1afff"]
  },
  {
    category: "kana supplement",
    hexrange: ["1b000", "1b0ff"]
  },
  {
    category: "kana extended-a",
    hexrange: ["1b100", "1b12f"]
  },
  {
    category: "small kana extension",
    hexrange: ["1b130", "1b16f"]
  },
  {
    category: "nushu",
    hexrange: ["1b170", "1b2ff"]
  },
  {
    category: "duployan",
    hexrange: ["1bc00", "1bc9f"]
  },
  {
    category: "shorthand format controls",
    hexrange: ["1bca0", "1bcaf"]
  },
  {
    category: "znamenny musical notation",
    hexrange: ["1cf00", "1cfcf"]
  },
  {
    category: "byzantine musical symbols",
    hexrange: ["1d000", "1d0ff"]
  },
  {
    category: "musical symbols",
    hexrange: ["1d100", "1d1ff"]
  },
  {
    category: "ancient greek musical notation",
    hexrange: ["1d200", "1d24f"]
  },
  {
    category: "kaktovik numerals",
    hexrange: ["1d2c0", "1d2df"]
  },
  {
    category: "mayan numerals",
    hexrange: ["1d2e0", "1d2ff"]
  },
  {
    category: "tai xuan jing symbols",
    hexrange: ["1d300", "1d35f"]
  },
  {
    category: "counting rod numerals",
    hexrange: ["1d360", "1d37f"]
  },
  {
    category: "mathematical alphanumeric symbols",
    hexrange: ["1d400", "1d7ff"]
  },
  {
    category: "sutton signwriting",
    hexrange: ["1d800", "1daaf"]
  },
  {
    category: "latin extended-g",
    hexrange: ["1df00", "1dfff"]
  },
  {
    category: "glagolitic supplement",
    hexrange: ["1e000", "1e02f"]
  },
  {
    category: "cyrillic extended-d",
    hexrange: ["1e030", "1e08f"]
  },
  {
    category: "nyiakeng puachue hmong",
    hexrange: ["1e100", "1e14f"]
  },
  {
    category: "toto",
    hexrange: ["1e290", "1e2bf"]
  },
  {
    category: "wancho",
    hexrange: ["1e2c0", "1e2ff"]
  },
  {
    category: "nag mundari",
    hexrange: ["1e4d0", "1e4ff"]
  },
  {
    category: "ethiopic extended-b",
    hexrange: ["1e7e0", "1e7ff"]
  },
  {
    category: "mende kikakui",
    hexrange: ["1e800", "1e8df"]
  },
  {
    category: "adlam",
    hexrange: ["1e900", "1e95f"]
  },
  {
    category: "indic siyaq numbers",
    hexrange: ["1ec70", "1ecbf"]
  },
  {
    category: "ottoman siyaq numbers",
    hexrange: ["1ed00", "1ed4f"]
  },
  {
    category: "arabic mathematical alphabetic symbols",
    hexrange: ["1ee00", "1eeff"]
  },
  {
    category: "mahjong tiles",
    hexrange: ["1f000", "1f02f"]
  },
  {
    category: "domino tiles",
    hexrange: ["1f030", "1f09f"]
  },
  {
    category: "playing cards",
    hexrange: ["1f0a0", "1f0ff"]
  },
  {
    category: "enclosed alphanumeric supplement",
    hexrange: ["1f100", "1f1ff"]
  },
  {
    category: "enclosed ideographic supplement",
    hexrange: ["1f200", "1f2ff"]
  },
  {
    category: "miscellaneous symbols and pictographs",
    hexrange: ["1f300", "1f5ff"]
  },
  {
    category: "emoticons (emoji)",
    hexrange: ["1f600", "1f64f"]
  },
  {
    category: "ornamental dingbats",
    hexrange: ["1f650", "1f67f"]
  },
  {
    category: "transport and map symbols",
    hexrange: ["1f680", "1f6ff"]
  },
  {
    category: "alchemical symbols",
    hexrange: ["1f700", "1f77f"]
  },
  {
    category: "geometric shapes extended",
    hexrange: ["1f780", "1f7ff"]
  },
  {
    category: "supplemental arrows-c",
    hexrange: ["1f800", "1f8ff"]
  },
  {
    category: "supplemental symbols and pictographs",
    hexrange: ["1f900", "1f9ff"]
  },
  {
    category: "chess symbols",
    hexrange: ["1fa00", "1fa6f"]
  },
  {
    category: "symbols and pictographs extended-a",
    hexrange: ["1fa70", "1faff"]
  },
  {
    category: "symbols for legacy computing",
    hexrange: ["1fb00", "1fbff"]
  },
  {
    category: "cjk unified ideographs extension b",
    hexrange: ["20000", "2a6df"]
  },
  {
    category: "cjk unified ideographs extension c",
    hexrange: ["2a700", "2b73f"]
  },
  {
    category: "cjk unified ideographs extension d",
    hexrange: ["2b740", "2b81f"]
  },
  {
    category: "cjk unified ideographs extension e",
    hexrange: ["2b820", "2ceaf"]
  },
  {
    category: "cjk unified ideographs extension f",
    hexrange: ["2ceb0", "2ebef"]
  },
  {
    category: "cjk unified ideographs extension i",
    hexrange: ["2ebf0", "2ee5f"]
  },
  {
    category: "cjk compatibility ideographs supplement",
    hexrange: ["2f800", "2fa1f"]
  },
  {
    category: "cjk unified ideographs extension g",
    hexrange: ["30000", "3134f"]
  },
  {
    category: "cjk unified ideographs extension h",
    hexrange: ["31350", "323af"]
  },
  {
    category: "tags",
    hexrange: ["e0000", "e007f"]
  },
  {
    category: "variation selectors supplement",
    hexrange: ["e0100", "e01ef"]
  },
  {
    category: "supplementary private use area-a",
    hexrange: ["f0000", "fffff"]
  },
  {
    category: "supplementary private use area-b",
    hexrange: ["100000", "10ffff"]
  }
];

// node_modules/pako/dist/pako.esm.mjs
var Z_FIXED$1 = 4;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN$1 = 2;
function zero$1(buf) {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0])
);
var extra_dbits = (
  /* extra bits for each distance code */
  new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13])
);
var extra_blbits = (
  /* extra bits for each bit length code */
  new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7])
);
var bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var DIST_CODE_LEN = 512;
var static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
var static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
var _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
var _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
var base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
var base_dist = new Array(D_CODES$1);
zero$1(base_dist);
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
var d_code = (dist) => {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
var put_short = (s, w) => {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
};
var send_bits = (s, value, length) => {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
};
var send_code = (s, c4, tree) => {
  send_bits(
    s,
    tree[c4 * 2],
    tree[c4 * 2 + 1]
    /*.Len*/
  );
};
var bi_reverse = (code, len) => {
  let res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
};
var bi_flush = (s) => {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
};
var gen_bitlen = (s, desc) => {
  const tree = desc.dyn_tree;
  const max_code = desc.max_code;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const extra = desc.stat_desc.extra_bits;
  const base2 = desc.stat_desc.extra_base;
  const max_length = desc.stat_desc.max_length;
  let h;
  let n3, m3;
  let bits;
  let xbits;
  let f;
  let overflow = 0;
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {
    n3 = s.heap[h];
    bits = tree[tree[n3 * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n3 * 2 + 1] = bits;
    if (n3 > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n3 >= base2) {
      xbits = extra[n3 - base2];
    }
    f = tree[n3 * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n3 * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n3 = s.bl_count[bits];
    while (n3 !== 0) {
      m3 = s.heap[--h];
      if (m3 > max_code) {
        continue;
      }
      if (tree[m3 * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m3 * 2 + 1]) * tree[m3 * 2];
        tree[m3 * 2 + 1] = bits;
      }
      n3--;
    }
  }
};
var gen_codes = (tree, max_code, bl_count) => {
  const next_code = new Array(MAX_BITS$1 + 1);
  let code = 0;
  let bits;
  let n3;
  for (bits = 1; bits <= MAX_BITS$1; bits++) {
    code = code + bl_count[bits - 1] << 1;
    next_code[bits] = code;
  }
  for (n3 = 0; n3 <= max_code; n3++) {
    let len = tree[n3 * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n3 * 2] = bi_reverse(next_code[len]++, len);
  }
};
var tr_static_init = () => {
  let n3;
  let bits;
  let length;
  let code;
  let dist;
  const bl_count = new Array(MAX_BITS$1 + 1);
  length = 0;
  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {
    base_length[code] = length;
    for (n3 = 0; n3 < 1 << extra_lbits[code]; n3++) {
      _length_code[length++] = code;
    }
  }
  _length_code[length - 1] = code;
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n3 = 0; n3 < 1 << extra_dbits[code]; n3++) {
      _dist_code[dist++] = code;
    }
  }
  dist >>= 7;
  for (; code < D_CODES$1; code++) {
    base_dist[code] = dist << 7;
    for (n3 = 0; n3 < 1 << extra_dbits[code] - 7; n3++) {
      _dist_code[256 + dist++] = code;
    }
  }
  for (bits = 0; bits <= MAX_BITS$1; bits++) {
    bl_count[bits] = 0;
  }
  n3 = 0;
  while (n3 <= 143) {
    static_ltree[n3 * 2 + 1] = 8;
    n3++;
    bl_count[8]++;
  }
  while (n3 <= 255) {
    static_ltree[n3 * 2 + 1] = 9;
    n3++;
    bl_count[9]++;
  }
  while (n3 <= 279) {
    static_ltree[n3 * 2 + 1] = 7;
    n3++;
    bl_count[7]++;
  }
  while (n3 <= 287) {
    static_ltree[n3 * 2 + 1] = 8;
    n3++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);
  for (n3 = 0; n3 < D_CODES$1; n3++) {
    static_dtree[n3 * 2 + 1] = 5;
    static_dtree[n3 * 2] = bi_reverse(n3, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);
};
var init_block = (s) => {
  let n3;
  for (n3 = 0; n3 < L_CODES$1; n3++) {
    s.dyn_ltree[n3 * 2] = 0;
  }
  for (n3 = 0; n3 < D_CODES$1; n3++) {
    s.dyn_dtree[n3 * 2] = 0;
  }
  for (n3 = 0; n3 < BL_CODES$1; n3++) {
    s.bl_tree[n3 * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.sym_next = s.matches = 0;
};
var bi_windup = (s) => {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
};
var smaller = (tree, n3, m3, depth) => {
  const _n2 = n3 * 2;
  const _m2 = m3 * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n3] <= depth[m3];
};
var pqdownheap = (s, tree, k) => {
  const v = s.heap[k];
  let j2 = k << 1;
  while (j2 <= s.heap_len) {
    if (j2 < s.heap_len && smaller(tree, s.heap[j2 + 1], s.heap[j2], s.depth)) {
      j2++;
    }
    if (smaller(tree, v, s.heap[j2], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j2];
    k = j2;
    j2 <<= 1;
  }
  s.heap[k] = v;
};
var compress_block = (s, ltree, dtree) => {
  let dist;
  let lc;
  let sx = 0;
  let code;
  let extra;
  if (s.sym_next !== 0) {
    do {
      dist = s.pending_buf[s.sym_buf + sx++] & 255;
      dist += (s.pending_buf[s.sym_buf + sx++] & 255) << 8;
      lc = s.pending_buf[s.sym_buf + sx++];
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code = _length_code[lc];
        send_code(s, code + LITERALS$1 + 1, ltree);
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
        }
        dist--;
        code = d_code(dist);
        send_code(s, code, dtree);
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
        }
      }
    } while (sx < s.sym_next);
  }
  send_code(s, END_BLOCK, ltree);
};
var build_tree = (s, desc) => {
  const tree = desc.dyn_tree;
  const stree = desc.stat_desc.static_tree;
  const has_stree = desc.stat_desc.has_stree;
  const elems = desc.stat_desc.elems;
  let n3, m3;
  let max_code = -1;
  let node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE$1;
  for (n3 = 0; n3 < elems; n3++) {
    if (tree[n3 * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n3;
      s.depth[n3] = 0;
    } else {
      tree[n3 * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n3 = s.heap_len >> 1; n3 >= 1; n3--) {
    pqdownheap(s, tree, n3);
  }
  node = elems;
  do {
    n3 = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m3 = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n3;
    s.heap[--s.heap_max] = m3;
    tree[node * 2] = tree[n3 * 2] + tree[m3 * 2];
    s.depth[node] = (s.depth[n3] >= s.depth[m3] ? s.depth[n3] : s.depth[m3]) + 1;
    tree[n3 * 2 + 1] = tree[m3 * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
};
var scan_tree = (s, tree, max_code) => {
  let n3;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n3 = 0; n3 <= max_code; n3++) {
    curlen = nextlen;
    nextlen = tree[(n3 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var send_tree = (s, tree, max_code) => {
  let n3;
  let prevlen = -1;
  let curlen;
  let nextlen = tree[0 * 2 + 1];
  let count = 0;
  let max_count = 7;
  let min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n3 = 0; n3 <= max_code; n3++) {
    curlen = nextlen;
    nextlen = tree[(n3 + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
};
var build_bl_tree = (s) => {
  let max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
};
var send_all_trees = (s, lcodes, dcodes, blcodes) => {
  let rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
};
var detect_data_type = (s) => {
  let block_mask = 4093624447;
  let n3;
  for (n3 = 0; n3 <= 31; n3++, block_mask >>>= 1) {
    if (block_mask & 1 && s.dyn_ltree[n3 * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n3 = 32; n3 < LITERALS$1; n3++) {
    if (s.dyn_ltree[n3 * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
};
var static_init_done = false;
var _tr_init$1 = (s) => {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
};
var _tr_stored_block$1 = (s, buf, stored_len, last2) => {
  send_bits(s, (STORED_BLOCK << 1) + (last2 ? 1 : 0), 3);
  bi_windup(s);
  put_short(s, stored_len);
  put_short(s, ~stored_len);
  if (stored_len) {
    s.pending_buf.set(s.window.subarray(buf, buf + stored_len), s.pending);
  }
  s.pending += stored_len;
};
var _tr_align$1 = (s) => {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
};
var _tr_flush_block$1 = (s, buf, stored_len, last2) => {
  let opt_lenb, static_lenb;
  let max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN$1) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block$1(s, buf, stored_len, last2);
  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last2 ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last2 ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last2) {
    bi_windup(s);
  }
};
var _tr_tally$1 = (s, dist, lc) => {
  s.pending_buf[s.sym_buf + s.sym_next++] = dist;
  s.pending_buf[s.sym_buf + s.sym_next++] = dist >> 8;
  s.pending_buf[s.sym_buf + s.sym_next++] = lc;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.sym_next === s.sym_end;
};
var _tr_init_1 = _tr_init$1;
var _tr_stored_block_1 = _tr_stored_block$1;
var _tr_flush_block_1 = _tr_flush_block$1;
var _tr_tally_1 = _tr_tally$1;
var _tr_align_1 = _tr_align$1;
var trees = {
  _tr_init: _tr_init_1,
  _tr_stored_block: _tr_stored_block_1,
  _tr_flush_block: _tr_flush_block_1,
  _tr_tally: _tr_tally_1,
  _tr_align: _tr_align_1
};
var adler32 = (adler, buf, len, pos) => {
  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n3 = 0;
  while (len !== 0) {
    n3 = len > 2e3 ? 2e3 : len;
    len -= n3;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n3);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
};
var adler32_1 = adler32;
var makeTable = () => {
  let c4, table2 = [];
  for (var n3 = 0; n3 < 256; n3++) {
    c4 = n3;
    for (var k = 0; k < 8; k++) {
      c4 = c4 & 1 ? 3988292384 ^ c4 >>> 1 : c4 >>> 1;
    }
    table2[n3] = c4;
  }
  return table2;
};
var crcTable = new Uint32Array(makeTable());
var crc32 = (crc, buf, len, pos) => {
  const t = crcTable;
  const end = pos + len;
  crc ^= -1;
  for (let i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
};
var crc32_1 = crc32;
var messages = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
var constants$2 = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,
  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  Z_MEM_ERROR: -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,
  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,
  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,
  /* The deflate compression method */
  Z_DEFLATED: 8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};
var { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$2,
  Z_PARTIAL_FLUSH,
  Z_FULL_FLUSH: Z_FULL_FLUSH$1,
  Z_FINISH: Z_FINISH$3,
  Z_BLOCK: Z_BLOCK$1,
  Z_OK: Z_OK$3,
  Z_STREAM_END: Z_STREAM_END$3,
  Z_STREAM_ERROR: Z_STREAM_ERROR$2,
  Z_DATA_ERROR: Z_DATA_ERROR$2,
  Z_BUF_ERROR: Z_BUF_ERROR$1,
  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,
  Z_FILTERED,
  Z_HUFFMAN_ONLY,
  Z_RLE,
  Z_FIXED,
  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,
  Z_UNKNOWN,
  Z_DEFLATED: Z_DEFLATED$2
} = constants$2;
var MAX_MEM_LEVEL = 9;
var MAX_WBITS$1 = 15;
var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var GZIP_STATE = 57;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
var err = (strm, errorCode) => {
  strm.msg = messages[errorCode];
  return errorCode;
};
var rank = (f) => {
  return f * 2 - (f > 4 ? 9 : 0);
};
var zero = (buf) => {
  let len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
};
var slide_hash = (s) => {
  let n3, m3;
  let p2;
  let wsize = s.w_size;
  n3 = s.hash_size;
  p2 = n3;
  do {
    m3 = s.head[--p2];
    s.head[p2] = m3 >= wsize ? m3 - wsize : 0;
  } while (--n3);
  n3 = wsize;
  p2 = n3;
  do {
    m3 = s.prev[--p2];
    s.prev[p2] = m3 >= wsize ? m3 - wsize : 0;
  } while (--n3);
};
var HASH_ZLIB = (s, prev, data3) => (prev << s.hash_shift ^ data3) & s.hash_mask;
var HASH = HASH_ZLIB;
var flush_pending = (strm) => {
  const s = strm.state;
  let len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
};
var flush_block_only = (s, last2) => {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last2);
  s.block_start = s.strstart;
  flush_pending(s.strm);
};
var put_byte = (s, b3) => {
  s.pending_buf[s.pending++] = b3;
};
var putShortMSB = (s, b3) => {
  s.pending_buf[s.pending++] = b3 >>> 8 & 255;
  s.pending_buf[s.pending++] = b3 & 255;
};
var read_buf = (strm, buf, start, size) => {
  let len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32_1(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32_1(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
};
var longest_match = (s, cur_match) => {
  let chain_length = s.max_chain_length;
  let scan = s.strstart;
  let match;
  let len;
  let best_len = s.prev_length;
  let nice_match = s.nice_match;
  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  const _win = s.window;
  const wmask = s.w_mask;
  const prev = s.prev;
  const strend = s.strstart + MAX_MATCH;
  let scan_end1 = _win[scan + best_len - 1];
  let scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
};
var fill_window = (s) => {
  const _w_size = s.w_size;
  let n3, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      s.window.set(s.window.subarray(_w_size, _w_size + _w_size - more), 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      if (s.insert > s.strstart) {
        s.insert = s.strstart;
      }
      slide_hash(s);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n3 = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n3;
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);
      while (s.insert) {
        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
};
var deflate_stored = (s, flush) => {
  let min_block = s.pending_buf_size - 5 > s.w_size ? s.w_size : s.pending_buf_size - 5;
  let len, left, have, last2 = 0;
  let used = s.strm.avail_in;
  do {
    len = 65535;
    have = s.bi_valid + 42 >> 3;
    if (s.strm.avail_out < have) {
      break;
    }
    have = s.strm.avail_out - have;
    left = s.strstart - s.block_start;
    if (len > left + s.strm.avail_in) {
      len = left + s.strm.avail_in;
    }
    if (len > have) {
      len = have;
    }
    if (len < min_block && (len === 0 && flush !== Z_FINISH$3 || flush === Z_NO_FLUSH$2 || len !== left + s.strm.avail_in)) {
      break;
    }
    last2 = flush === Z_FINISH$3 && len === left + s.strm.avail_in ? 1 : 0;
    _tr_stored_block(s, 0, 0, last2);
    s.pending_buf[s.pending - 4] = len;
    s.pending_buf[s.pending - 3] = len >> 8;
    s.pending_buf[s.pending - 2] = ~len;
    s.pending_buf[s.pending - 1] = ~len >> 8;
    flush_pending(s.strm);
    if (left) {
      if (left > len) {
        left = len;
      }
      s.strm.output.set(s.window.subarray(s.block_start, s.block_start + left), s.strm.next_out);
      s.strm.next_out += left;
      s.strm.avail_out -= left;
      s.strm.total_out += left;
      s.block_start += left;
      len -= left;
    }
    if (len) {
      read_buf(s.strm, s.strm.output, s.strm.next_out, len);
      s.strm.next_out += len;
      s.strm.avail_out -= len;
      s.strm.total_out += len;
    }
  } while (last2 === 0);
  used -= s.strm.avail_in;
  if (used) {
    if (used >= s.w_size) {
      s.matches = 2;
      s.window.set(s.strm.input.subarray(s.strm.next_in - s.w_size, s.strm.next_in), 0);
      s.strstart = s.w_size;
      s.insert = s.strstart;
    } else {
      if (s.window_size - s.strstart <= used) {
        s.strstart -= s.w_size;
        s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
        if (s.matches < 2) {
          s.matches++;
        }
        if (s.insert > s.strstart) {
          s.insert = s.strstart;
        }
      }
      s.window.set(s.strm.input.subarray(s.strm.next_in - used, s.strm.next_in), s.strstart);
      s.strstart += used;
      s.insert += used > s.w_size - s.insert ? s.w_size - s.insert : used;
    }
    s.block_start = s.strstart;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  if (last2) {
    return BS_FINISH_DONE;
  }
  if (flush !== Z_NO_FLUSH$2 && flush !== Z_FINISH$3 && s.strm.avail_in === 0 && s.strstart === s.block_start) {
    return BS_BLOCK_DONE;
  }
  have = s.window_size - s.strstart;
  if (s.strm.avail_in > have && s.block_start >= s.w_size) {
    s.block_start -= s.w_size;
    s.strstart -= s.w_size;
    s.window.set(s.window.subarray(s.w_size, s.w_size + s.strstart), 0);
    if (s.matches < 2) {
      s.matches++;
    }
    have += s.w_size;
    if (s.insert > s.strstart) {
      s.insert = s.strstart;
    }
  }
  if (have > s.strm.avail_in) {
    have = s.strm.avail_in;
  }
  if (have) {
    read_buf(s.strm, s.window, s.strstart, have);
    s.strstart += have;
    s.insert += have > s.w_size - s.insert ? s.w_size - s.insert : have;
  }
  if (s.high_water < s.strstart) {
    s.high_water = s.strstart;
  }
  have = s.bi_valid + 42 >> 3;
  have = s.pending_buf_size - have > 65535 ? 65535 : s.pending_buf_size - have;
  min_block = have > s.w_size ? s.w_size : have;
  left = s.strstart - s.block_start;
  if (left >= min_block || (left || flush === Z_FINISH$3) && flush !== Z_NO_FLUSH$2 && s.strm.avail_in === 0 && left <= have) {
    len = left > have ? have : left;
    last2 = flush === Z_FINISH$3 && s.strm.avail_in === 0 && len === left ? 1 : 0;
    _tr_stored_block(s, s.block_start, len, last2);
    s.block_start += len;
    flush_pending(s.strm);
  }
  return last2 ? BS_FINISH_STARTED : BS_NEED_MORE;
};
var deflate_fast = (s, flush) => {
  let hash_head;
  let bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_slow = (s, flush) => {
  let hash_head;
  let bflush;
  let max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH) {
      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_rle = (s, flush) => {
  let bflush;
  let prev;
  let scan, strend;
  const _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
var deflate_huff = (s, flush) => {
  let bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH$2) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH$3) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.sym_next) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
};
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),
  /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),
  /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),
  /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),
  /* 3 */
  new Config(4, 4, 16, 16, deflate_slow),
  /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),
  /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),
  /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),
  /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),
  /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)
  /* 9 max compression */
];
var lm_init = (s) => {
  s.window_size = 2 * s.w_size;
  zero(s.head);
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
};
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED$2;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);
  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);
  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = new Uint16Array(MAX_BITS + 1);
  this.heap = new Uint16Array(2 * L_CODES + 1);
  zero(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = new Uint16Array(2 * L_CODES + 1);
  zero(this.depth);
  this.sym_buf = 0;
  this.lit_bufsize = 0;
  this.sym_next = 0;
  this.sym_end = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
var deflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const s = strm.state;
  if (!s || s.strm !== strm || s.status !== INIT_STATE && //#ifdef GZIP
  s.status !== GZIP_STATE && //#endif
  s.status !== EXTRA_STATE && s.status !== NAME_STATE && s.status !== COMMENT_STATE && s.status !== HCRC_STATE && s.status !== BUSY_STATE && s.status !== FINISH_STATE) {
    return 1;
  }
  return 0;
};
var deflateResetKeep = (strm) => {
  if (deflateStateCheck(strm)) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  const s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = //#ifdef GZIP
  s.wrap === 2 ? GZIP_STATE : (
    //#endif
    s.wrap ? INIT_STATE : BUSY_STATE
  );
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = -2;
  _tr_init(s);
  return Z_OK$3;
};
var deflateReset = (strm) => {
  const ret = deflateResetKeep(strm);
  if (ret === Z_OK$3) {
    lm_init(strm.state);
  }
  return ret;
};
var deflateSetHeader = (strm, head) => {
  if (deflateStateCheck(strm) || strm.state.wrap !== 2) {
    return Z_STREAM_ERROR$2;
  }
  strm.state.gzhead = head;
  return Z_OK$3;
};
var deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {
  if (!strm) {
    return Z_STREAM_ERROR$2;
  }
  let wrap = 1;
  if (level === Z_DEFAULT_COMPRESSION$1) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED || windowBits === 8 && wrap !== 1) {
    return err(strm, Z_STREAM_ERROR$2);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  const s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.status = INIT_STATE;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new Uint8Array(s.w_size * 2);
  s.head = new Uint16Array(s.hash_size);
  s.prev = new Uint16Array(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = new Uint8Array(s.pending_buf_size);
  s.sym_buf = s.lit_bufsize;
  s.sym_end = (s.lit_bufsize - 1) * 3;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
};
var deflateInit = (strm, level) => {
  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);
};
var deflate$2 = (strm, flush) => {
  if (deflateStateCheck(strm) || flush > Z_BLOCK$1 || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  if (!strm.output || strm.avail_in !== 0 && !strm.input || s.status === FINISH_STATE && flush !== Z_FINISH$3) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);
  }
  const old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR$1);
  }
  if (s.status === INIT_STATE && s.wrap === 0) {
    s.status = BUSY_STATE;
  }
  if (s.status === INIT_STATE) {
    let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;
    let level_flags = -1;
    if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
      level_flags = 0;
    } else if (s.level < 6) {
      level_flags = 1;
    } else if (s.level === 6) {
      level_flags = 2;
    } else {
      level_flags = 3;
    }
    header |= level_flags << 6;
    if (s.strstart !== 0) {
      header |= PRESET_DICT;
    }
    header += 31 - header % 31;
    putShortMSB(s, header);
    if (s.strstart !== 0) {
      putShortMSB(s, strm.adler >>> 16);
      putShortMSB(s, strm.adler & 65535);
    }
    strm.adler = 1;
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (s.status === GZIP_STATE) {
    strm.adler = 0;
    put_byte(s, 31);
    put_byte(s, 139);
    put_byte(s, 8);
    if (!s.gzhead) {
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, 0);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, OS_CODE);
      s.status = BUSY_STATE;
      flush_pending(strm);
      if (s.pending !== 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    } else {
      put_byte(
        s,
        (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
      );
      put_byte(s, s.gzhead.time & 255);
      put_byte(s, s.gzhead.time >> 8 & 255);
      put_byte(s, s.gzhead.time >> 16 & 255);
      put_byte(s, s.gzhead.time >> 24 & 255);
      put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
      put_byte(s, s.gzhead.os & 255);
      if (s.gzhead.extra && s.gzhead.extra.length) {
        put_byte(s, s.gzhead.extra.length & 255);
        put_byte(s, s.gzhead.extra.length >> 8 & 255);
      }
      if (s.gzhead.hcrc) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);
      }
      s.gzindex = 0;
      s.status = EXTRA_STATE;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      let beg = s.pending;
      let left = (s.gzhead.extra.length & 65535) - s.gzindex;
      while (s.pending + left > s.pending_buf_size) {
        let copy2 = s.pending_buf_size - s.pending;
        s.pending_buf.set(s.gzhead.extra.subarray(s.gzindex, s.gzindex + copy2), s.pending);
        s.pending = s.pending_buf_size;
        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
        }
        s.gzindex += copy2;
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
        beg = 0;
        left -= copy2;
      }
      let gzhead_extra = new Uint8Array(s.gzhead.extra);
      s.pending_buf.set(gzhead_extra.subarray(s.gzindex, s.gzindex + left), s.pending);
      s.pending += left;
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = NAME_STATE;
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      let beg = s.pending;
      let val2;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.name.length) {
          val2 = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val2 = 0;
        }
        put_byte(s, val2);
      } while (val2 !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      s.gzindex = 0;
    }
    s.status = COMMENT_STATE;
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      let beg = s.pending;
      let val2;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          if (s.pending !== 0) {
            s.last_flush = -1;
            return Z_OK$3;
          }
          beg = 0;
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val2 = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val2 = 0;
        }
        put_byte(s, val2);
      } while (val2 !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
    }
    s.status = HCRC_STATE;
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
        if (s.pending !== 0) {
          s.last_flush = -1;
          return Z_OK$3;
        }
      }
      put_byte(s, strm.adler & 255);
      put_byte(s, strm.adler >> 8 & 255);
      strm.adler = 0;
    }
    s.status = BUSY_STATE;
    flush_pending(strm);
    if (s.pending !== 0) {
      s.last_flush = -1;
      return Z_OK$3;
    }
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {
    let bstate = s.level === 0 ? deflate_stored(s, flush) : s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK$3;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK$1) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH$1) {
          zero(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK$3;
      }
    }
  }
  if (flush !== Z_FINISH$3) {
    return Z_OK$3;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END$3;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;
};
var deflateEnd = (strm) => {
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const status = strm.state.status;
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;
};
var deflateSetDictionary = (strm, dictionary) => {
  let dictLength = dictionary.length;
  if (deflateStateCheck(strm)) {
    return Z_STREAM_ERROR$2;
  }
  const s = strm.state;
  const wrap = s.wrap;
  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR$2;
  }
  if (wrap === 1) {
    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      zero(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    let tmpDict = new Uint8Array(s.w_size);
    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  const avail = strm.avail_in;
  const next = strm.next_in;
  const input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    let str = s.strstart;
    let n3 = s.lookahead - (MIN_MATCH - 1);
    do {
      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n3);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK$3;
};
var deflateInit_1 = deflateInit;
var deflateInit2_1 = deflateInit2;
var deflateReset_1 = deflateReset;
var deflateResetKeep_1 = deflateResetKeep;
var deflateSetHeader_1 = deflateSetHeader;
var deflate_2$1 = deflate$2;
var deflateEnd_1 = deflateEnd;
var deflateSetDictionary_1 = deflateSetDictionary;
var deflateInfo = "pako deflate (from Nodeca project)";
var deflate_1$2 = {
  deflateInit: deflateInit_1,
  deflateInit2: deflateInit2_1,
  deflateReset: deflateReset_1,
  deflateResetKeep: deflateResetKeep_1,
  deflateSetHeader: deflateSetHeader_1,
  deflate: deflate_2$1,
  deflateEnd: deflateEnd_1,
  deflateSetDictionary: deflateSetDictionary_1,
  deflateInfo
};
var _has = (obj, key) => {
  return Object.prototype.hasOwnProperty.call(obj, key);
};
var assign = function(obj) {
  const sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    const source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (const p2 in source) {
      if (_has(source, p2)) {
        obj[p2] = source[p2];
      }
    }
  }
  return obj;
};
var flattenChunks = (chunks) => {
  let len = 0;
  for (let i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }
  const result = new Uint8Array(len);
  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {
    let chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }
  return result;
};
var common = {
  assign,
  flattenChunks
};
var STR_APPLY_UIA_OK = true;
try {
  String.fromCharCode.apply(null, new Uint8Array(1));
} catch (__) {
  STR_APPLY_UIA_OK = false;
}
var _utf8len = new Uint8Array(256);
for (let q = 0; q < 256; q++) {
  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
}
_utf8len[254] = _utf8len[254] = 1;
var string2buf = (str) => {
  if (typeof TextEncoder === "function" && TextEncoder.prototype.encode) {
    return new TextEncoder().encode(str);
  }
  let buf, c4, c24, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c4 = str.charCodeAt(m_pos);
    if ((c4 & 64512) === 55296 && m_pos + 1 < str_len) {
      c24 = str.charCodeAt(m_pos + 1);
      if ((c24 & 64512) === 56320) {
        c4 = 65536 + (c4 - 55296 << 10) + (c24 - 56320);
        m_pos++;
      }
    }
    buf_len += c4 < 128 ? 1 : c4 < 2048 ? 2 : c4 < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c4 = str.charCodeAt(m_pos);
    if ((c4 & 64512) === 55296 && m_pos + 1 < str_len) {
      c24 = str.charCodeAt(m_pos + 1);
      if ((c24 & 64512) === 56320) {
        c4 = 65536 + (c4 - 55296 << 10) + (c24 - 56320);
        m_pos++;
      }
    }
    if (c4 < 128) {
      buf[i++] = c4;
    } else if (c4 < 2048) {
      buf[i++] = 192 | c4 >>> 6;
      buf[i++] = 128 | c4 & 63;
    } else if (c4 < 65536) {
      buf[i++] = 224 | c4 >>> 12;
      buf[i++] = 128 | c4 >>> 6 & 63;
      buf[i++] = 128 | c4 & 63;
    } else {
      buf[i++] = 240 | c4 >>> 18;
      buf[i++] = 128 | c4 >>> 12 & 63;
      buf[i++] = 128 | c4 >>> 6 & 63;
      buf[i++] = 128 | c4 & 63;
    }
  }
  return buf;
};
var buf2binstring = (buf, len) => {
  if (len < 65534) {
    if (buf.subarray && STR_APPLY_UIA_OK) {
      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));
    }
  }
  let result = "";
  for (let i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
};
var buf2string = (buf, max) => {
  const len = max || buf.length;
  if (typeof TextDecoder === "function" && TextDecoder.prototype.decode) {
    return new TextDecoder().decode(buf.subarray(0, max));
  }
  let i, out;
  const utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    let c4 = buf[i++];
    if (c4 < 128) {
      utf16buf[out++] = c4;
      continue;
    }
    let c_len = _utf8len[c4];
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c4 &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c4 = c4 << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c4 < 65536) {
      utf16buf[out++] = c4;
    } else {
      c4 -= 65536;
      utf16buf[out++] = 55296 | c4 >> 10 & 1023;
      utf16buf[out++] = 56320 | c4 & 1023;
    }
  }
  return buf2binstring(utf16buf, out);
};
var utf8border = (buf, max) => {
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  let pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + _utf8len[buf[pos]] > max ? pos : max;
};
var strings2 = {
  string2buf,
  buf2string,
  utf8border
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
var zstream = ZStream;
var toString$1 = Object.prototype.toString;
var {
  Z_NO_FLUSH: Z_NO_FLUSH$1,
  Z_SYNC_FLUSH,
  Z_FULL_FLUSH,
  Z_FINISH: Z_FINISH$2,
  Z_OK: Z_OK$2,
  Z_STREAM_END: Z_STREAM_END$2,
  Z_DEFAULT_COMPRESSION,
  Z_DEFAULT_STRATEGY,
  Z_DEFLATED: Z_DEFLATED$1
} = constants$2;
function Deflate$1(options2) {
  this.options = common.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED$1,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY
  }, options2 || {});
  let opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = deflate_1$2.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK$2) {
    throw new Error(messages[status]);
  }
  if (opt.header) {
    deflate_1$2.deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    let dict;
    if (typeof opt.dictionary === "string") {
      dict = strings2.string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }
    status = deflate_1$2.deflateSetDictionary(this.strm, dict);
    if (status !== Z_OK$2) {
      throw new Error(messages[status]);
    }
    this._dict_set = true;
  }
}
Deflate$1.prototype.push = function(data3, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  let status, _flush_mode;
  if (this.ended) {
    return false;
  }
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;
  if (typeof data3 === "string") {
    strm.input = strings2.string2buf(data3);
  } else if (toString$1.call(data3) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data3);
  } else {
    strm.input = data3;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    status = deflate_1$2.deflate(strm, _flush_mode);
    if (status === Z_STREAM_END$2) {
      if (strm.next_out > 0) {
        this.onData(strm.output.subarray(0, strm.next_out));
      }
      status = deflate_1$2.deflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return status === Z_OK$2;
    }
    if (strm.avail_out === 0) {
      this.onData(strm.output);
      continue;
    }
    if (_flush_mode > 0 && strm.next_out > 0) {
      this.onData(strm.output.subarray(0, strm.next_out));
      strm.avail_out = 0;
      continue;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Deflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Deflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK$2) {
    this.result = common.flattenChunks(this.chunks);
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options2) {
  const deflator = new Deflate$1(options2);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || messages[deflator.err];
  }
  return deflator.result;
}
function deflateRaw$1(input, options2) {
  options2 = options2 || {};
  options2.raw = true;
  return deflate$1(input, options2);
}
function gzip$1(input, options2) {
  options2 = options2 || {};
  options2.gzip = true;
  return deflate$1(input, options2);
}
var Deflate_1$1 = Deflate$1;
var deflate_2 = deflate$1;
var deflateRaw_1$1 = deflateRaw$1;
var gzip_1$1 = gzip$1;
var constants$1 = constants$2;
var deflate_1$1 = {
  Deflate: Deflate_1$1,
  deflate: deflate_2,
  deflateRaw: deflateRaw_1$1,
  gzip: gzip_1$1,
  constants: constants$1
};
var BAD$1 = 16209;
var TYPE$1 = 16191;
var inffast = function inflate_fast(strm, start) {
  let _in;
  let last2;
  let _out;
  let beg;
  let end;
  let dmax;
  let wsize;
  let whave;
  let wnext;
  let s_window;
  let hold;
  let bits;
  let lcode;
  let dcode;
  let lmask;
  let dmask;
  let here;
  let op;
  let len;
  let dist;
  let from;
  let from_source;
  let input, output2;
  const state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last2 = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output2 = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output2[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD$1;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD$1;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output2;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output2[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output2;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output2[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output2;
                      }
                    }
                    while (len > 2) {
                      output2[_out++] = from_source[from++];
                      output2[_out++] = from_source[from++];
                      output2[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output2[_out++] = from_source[from++];
                      if (len > 1) {
                        output2[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output2[_out++] = output2[from++];
                      output2[_out++] = output2[from++];
                      output2[_out++] = output2[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output2[_out++] = output2[from++];
                      if (len > 1) {
                        output2[_out++] = output2[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD$1;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE$1;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break top;
          }
          break;
        }
    } while (_in < last2 && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};
var MAXBITS = 15;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var lbase = new Uint16Array([
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
]);
var lext = new Uint8Array([
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
]);
var dbase = new Uint16Array([
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
]);
var dext = new Uint8Array([
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
]);
var inflate_table = (type3, lens, lens_index, codes, table2, table_index, work, opts) => {
  const bits = opts.bits;
  let len = 0;
  let sym = 0;
  let min = 0, max = 0;
  let root = 0;
  let curr = 0;
  let drop = 0;
  let left = 0;
  let used = 0;
  let huff = 0;
  let incr;
  let fill;
  let low;
  let mask;
  let next;
  let base2 = null;
  let match;
  const count = new Uint16Array(MAXBITS + 1);
  const offs = new Uint16Array(MAXBITS + 1);
  let extra = null;
  let here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {
    table2[table_index++] = 1 << 24 | 64 << 16 | 0;
    table2[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }
  if (root < min) {
    root = min;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type3 === CODES$1 || max !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type3 === CODES$1) {
    base2 = extra = work;
    match = 20;
  } else if (type3 === LENS$1) {
    base2 = lbase;
    extra = lext;
    match = 257;
  } else {
    base2 = dbase;
    extra = dext;
    match = 0;
  }
  huff = 0;
  sym = 0;
  len = min;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type3 === LENS$1 && used > ENOUGH_LENS$1 || type3 === DISTS$1 && used > ENOUGH_DISTS$1) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] + 1 < match) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] >= match) {
      here_op = extra[work[sym] - match];
      here_val = base2[work[sym] - match];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    do {
      fill -= incr;
      table2[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type3 === LENS$1 && used > ENOUGH_LENS$1 || type3 === DISTS$1 && used > ENOUGH_DISTS$1) {
        return 1;
      }
      low = huff & mask;
      table2[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table2[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
};
var inftrees = inflate_table;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var {
  Z_FINISH: Z_FINISH$1,
  Z_BLOCK,
  Z_TREES,
  Z_OK: Z_OK$1,
  Z_STREAM_END: Z_STREAM_END$1,
  Z_NEED_DICT: Z_NEED_DICT$1,
  Z_STREAM_ERROR: Z_STREAM_ERROR$1,
  Z_DATA_ERROR: Z_DATA_ERROR$1,
  Z_MEM_ERROR: Z_MEM_ERROR$1,
  Z_BUF_ERROR,
  Z_DEFLATED
} = constants$2;
var HEAD = 16180;
var FLAGS = 16181;
var TIME = 16182;
var OS = 16183;
var EXLEN = 16184;
var EXTRA = 16185;
var NAME = 16186;
var COMMENT = 16187;
var HCRC = 16188;
var DICTID = 16189;
var DICT = 16190;
var TYPE = 16191;
var TYPEDO = 16192;
var STORED = 16193;
var COPY_ = 16194;
var COPY = 16195;
var TABLE = 16196;
var LENLENS = 16197;
var CODELENS = 16198;
var LEN_ = 16199;
var LEN = 16200;
var LENEXT = 16201;
var DIST = 16202;
var DISTEXT = 16203;
var MATCH = 16204;
var LIT = 16205;
var CHECK = 16206;
var LENGTH = 16207;
var DONE = 16208;
var BAD = 16209;
var MEM = 16210;
var SYNC = 16211;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var MAX_WBITS = 15;
var DEF_WBITS = MAX_WBITS;
var zswap32 = (q) => {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
};
function InflateState() {
  this.strm = null;
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = new Uint16Array(320);
  this.work = new Uint16Array(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
var inflateStateCheck = (strm) => {
  if (!strm) {
    return 1;
  }
  const state = strm.state;
  if (!state || state.strm !== strm || state.mode < HEAD || state.mode > SYNC) {
    return 1;
  }
  return 0;
};
var inflateResetKeep = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.flags = -1;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);
  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
};
var inflateReset = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
};
var inflateReset2 = (strm, windowBits) => {
  let wrap;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 5;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
};
var inflateInit2 = (strm, windowBits) => {
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  const state = new InflateState();
  strm.state = state;
  state.strm = strm;
  state.window = null;
  state.mode = HEAD;
  const ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
};
var inflateInit = (strm) => {
  return inflateInit2(strm, DEF_WBITS);
};
var virgin = true;
var lenfix;
var distfix;
var fixedtables = (state) => {
  if (virgin) {
    lenfix = new Int32Array(512);
    distfix = new Int32Array(32);
    let sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
};
var updatewindow = (strm, src, end, copy2) => {
  let dist;
  const state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new Uint8Array(state.wsize);
  }
  if (copy2 >= state.wsize) {
    state.window.set(src.subarray(end - state.wsize, end), 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy2) {
      dist = copy2;
    }
    state.window.set(src.subarray(end - copy2, end - copy2 + dist), state.wnext);
    copy2 -= dist;
    if (copy2) {
      state.window.set(src.subarray(end - copy2, end), 0);
      state.wnext = copy2;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
};
var inflate$2 = (strm, flush) => {
  let state;
  let input, output2;
  let next;
  let put;
  let have, left;
  let hold;
  let bits;
  let _in, _out;
  let copy2;
  let from;
  let from_source;
  let here = 0;
  let here_bits, here_op, here_val;
  let last_bits, last_op, last_val;
  let len;
  let ret;
  const hbuf = new Uint8Array(4);
  let opts;
  let n3;
  const order = (
    /* permutation of code lengths */
    new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  );
  if (inflateStateCheck(strm) || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output2 = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            if (state.wbits === 0) {
              state.wbits = 15;
            }
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          }
          if (len > 15 || len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD;
            break;
          }
          state.dmax = 1 << state.wbits;
          state.flags = 0;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED) {
            strm.msg = "unknown compression method";
            state.mode = BAD;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32_1(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512 && state.wrap & 4) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32_1(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512 && state.wrap & 4) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32_1(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy2 = state.length;
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Uint8Array(state.head.extra_len);
                }
                state.head.extra.set(
                  input.subarray(
                    next,
                    // extra field is limited to 65536 bytes
                    // - no need for additional size check
                    next + copy2
                  ),
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512 && state.wrap & 4) {
                state.check = crc32_1(state.check, input, copy2, next);
              }
              have -= copy2;
              next += copy2;
              state.length -= copy2;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len = input[next + copy2++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy2 < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy2 = 0;
            do {
              len = input[next + copy2++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy2 < have);
            if (state.flags & 512 && state.wrap & 4) {
              state.check = crc32_1(state.check, input, copy2, next);
            }
            have -= copy2;
            next += copy2;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE;
        case TYPE:
          if (flush === Z_BLOCK || flush === Z_TREES) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy2 = state.length;
          if (copy2) {
            if (copy2 > have) {
              copy2 = have;
            }
            if (copy2 > left) {
              copy2 = left;
            }
            if (copy2 === 0) {
              break inf_leave;
            }
            output2.set(input.subarray(next, next + copy2), put);
            have -= copy2;
            next += copy2;
            left -= copy2;
            put += copy2;
            state.length -= copy2;
            break;
          }
          state.mode = TYPE;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n3 = here_bits + 2;
                while (bits < n3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD;
                  break;
                }
                len = state.lens[state.have - 1];
                copy2 = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n3 = here_bits + 3;
                while (bits < n3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy2 = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n3 = here_bits + 7;
                while (bits < n3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy2 = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy2 > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD;
                break;
              }
              while (copy2--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inffast(strm, _out);
            put = strm.next_out;
            output2 = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n3 = state.extra;
            while (bits < n3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n3 = state.extra;
            while (bits < n3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy2 = _out - left;
          if (state.offset > copy2) {
            copy2 = state.offset - copy2;
            if (copy2 > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
            }
            if (copy2 > state.wnext) {
              copy2 -= state.wnext;
              from = state.wsize - copy2;
            } else {
              from = state.wnext - copy2;
            }
            if (copy2 > state.length) {
              copy2 = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output2;
            from = put - state.offset;
            copy2 = state.length;
          }
          if (copy2 > left) {
            copy2 = left;
          }
          left -= copy2;
          state.length -= copy2;
          do {
            output2[put++] = from_source[from++];
          } while (--copy2);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output2[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (state.wrap & 4 && _out) {
              strm.adler = state.check = /*UPDATE_CHECK(state.check, put - _out, _out);*/
              state.flags ? crc32_1(state.check, output2, _out, put - _out) : adler32_1(state.check, output2, _out, put - _out);
            }
            _out = left;
            if (state.wrap & 4 && (state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (state.wrap & 4 && hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR$1;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap & 4 && _out) {
    strm.adler = state.check = /*UPDATE_CHECK(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32_1(state.check, output2, _out, strm.next_out - _out) : adler32_1(state.check, output2, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR;
  }
  return ret;
};
var inflateEnd = (strm) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  let state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
};
var inflateGetHeader = (strm, head) => {
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  const state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
};
var inflateSetDictionary = (strm, dictionary) => {
  const dictLength = dictionary.length;
  let state;
  let dictid;
  let ret;
  if (inflateStateCheck(strm)) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32_1(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR$1;
  }
  state.havedict = 1;
  return Z_OK$1;
};
var inflateReset_1 = inflateReset;
var inflateReset2_1 = inflateReset2;
var inflateResetKeep_1 = inflateResetKeep;
var inflateInit_1 = inflateInit;
var inflateInit2_1 = inflateInit2;
var inflate_2$1 = inflate$2;
var inflateEnd_1 = inflateEnd;
var inflateGetHeader_1 = inflateGetHeader;
var inflateSetDictionary_1 = inflateSetDictionary;
var inflateInfo = "pako inflate (from Nodeca project)";
var inflate_1$2 = {
  inflateReset: inflateReset_1,
  inflateReset2: inflateReset2_1,
  inflateResetKeep: inflateResetKeep_1,
  inflateInit: inflateInit_1,
  inflateInit2: inflateInit2_1,
  inflate: inflate_2$1,
  inflateEnd: inflateEnd_1,
  inflateGetHeader: inflateGetHeader_1,
  inflateSetDictionary: inflateSetDictionary_1,
  inflateInfo
};
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var gzheader = GZheader;
var toString2 = Object.prototype.toString;
var {
  Z_NO_FLUSH,
  Z_FINISH,
  Z_OK,
  Z_STREAM_END,
  Z_NEED_DICT,
  Z_STREAM_ERROR,
  Z_DATA_ERROR,
  Z_MEM_ERROR
} = constants$2;
function Inflate$1(options2) {
  this.options = common.assign({
    chunkSize: 1024 * 64,
    windowBits: 15,
    to: ""
  }, options2 || {});
  const opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options2 && options2.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new zstream();
  this.strm.avail_out = 0;
  let status = inflate_1$2.inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(messages[status]);
  }
  this.header = new gzheader();
  inflate_1$2.inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = strings2.string2buf(opt.dictionary);
    } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(messages[status]);
      }
    }
  }
}
Inflate$1.prototype.push = function(data3, flush_mode) {
  const strm = this.strm;
  const chunkSize = this.options.chunkSize;
  const dictionary = this.options.dictionary;
  let status, _flush_mode, last_avail_out;
  if (this.ended) return false;
  if (flush_mode === ~~flush_mode) _flush_mode = flush_mode;
  else _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (toString2.call(data3) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data3);
  } else {
    strm.input = data3;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  for (; ; ) {
    if (strm.avail_out === 0) {
      strm.output = new Uint8Array(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate_1$2.inflate(strm, _flush_mode);
    if (status === Z_NEED_DICT && dictionary) {
      status = inflate_1$2.inflateSetDictionary(strm, dictionary);
      if (status === Z_OK) {
        status = inflate_1$2.inflate(strm, _flush_mode);
      } else if (status === Z_DATA_ERROR) {
        status = Z_NEED_DICT;
      }
    }
    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data3[strm.next_in] !== 0) {
      inflate_1$2.inflateReset(strm);
      status = inflate_1$2.inflate(strm, _flush_mode);
    }
    switch (status) {
      case Z_STREAM_ERROR:
      case Z_DATA_ERROR:
      case Z_NEED_DICT:
      case Z_MEM_ERROR:
        this.onEnd(status);
        this.ended = true;
        return false;
    }
    last_avail_out = strm.avail_out;
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END) {
        if (this.options.to === "string") {
          let next_out_utf8 = strings2.utf8border(strm.output, strm.next_out);
          let tail = strm.next_out - next_out_utf8;
          let utf8str = strings2.buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);
          this.onData(utf8str);
        } else {
          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));
        }
      }
    }
    if (status === Z_OK && last_avail_out === 0) continue;
    if (status === Z_STREAM_END) {
      status = inflate_1$2.inflateEnd(this.strm);
      this.onEnd(status);
      this.ended = true;
      return true;
    }
    if (strm.avail_in === 0) break;
  }
  return true;
};
Inflate$1.prototype.onData = function(chunk) {
  this.chunks.push(chunk);
};
Inflate$1.prototype.onEnd = function(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = common.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function inflate$1(input, options2) {
  const inflator = new Inflate$1(options2);
  inflator.push(input);
  if (inflator.err) throw inflator.msg || messages[inflator.err];
  return inflator.result;
}
function inflateRaw$1(input, options2) {
  options2 = options2 || {};
  options2.raw = true;
  return inflate$1(input, options2);
}
var Inflate_1$1 = Inflate$1;
var inflate_2 = inflate$1;
var inflateRaw_1$1 = inflateRaw$1;
var ungzip$1 = inflate$1;
var constants2 = constants$2;
var inflate_1$1 = {
  Inflate: Inflate_1$1,
  inflate: inflate_2,
  inflateRaw: inflateRaw_1$1,
  ungzip: ungzip$1,
  constants: constants2
};
var { Deflate, deflate, deflateRaw, gzip } = deflate_1$1;
var { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;
var inflate_1 = inflate;

// node_modules/p5/dist/type/lib/Typr.js
var pako = { inflate: inflate_1 };
var Typr = {};
Typr["parse"] = function(buff) {
  var bin = Typr["B"];
  var readFont = function(data4, idx, offset3, tmap2) {
    var T2 = Typr["T"];
    var prsr = {
      "cmap": T2.cmap,
      "head": T2.head,
      "hhea": T2.hhea,
      "maxp": T2.maxp,
      "hmtx": T2.hmtx,
      "name": T2.name,
      "OS/2": T2.OS2,
      "post": T2.post,
      "loca": T2.loca,
      "kern": T2.kern,
      "glyf": T2.glyf,
      "CFF ": T2.CFF,
      /*
      "GPOS",
      "GSUB",
      "GDEF",*/
      "GSUB": T2.GSUB,
      "CBLC": T2.CBLC,
      "CBDT": T2.CBDT,
      "SVG ": T2.SVG,
      "COLR": T2.colr,
      "CPAL": T2.cpal,
      "sbix": T2.sbix,
      "fvar": T2.fvar,
      "gvar": T2.gvar,
      "avar": T2.avar,
      "HVAR": T2.HVAR
      //"VORG",
    };
    var obj2 = { "_data": data4, "_index": idx, "_offset": offset3 };
    for (var t in prsr) {
      var tab = Typr["findTable"](data4, t, offset3);
      if (tab) {
        var off = tab[0], tobj = tmap2[off];
        if (tobj == null) tobj = prsr[t].parseTab(data4, off, tab[1], obj2);
        obj2[t] = tmap2[off] = tobj;
      }
    }
    return obj2;
  };
  function woffToOtf(data4) {
    var numTables = bin.readUshort(data4, 12);
    var totalSize = bin.readUint(data4, 16);
    var otf = new Uint8Array(totalSize), toff = 12 + numTables * 16;
    bin.writeASCII(otf, 0, "OTTO");
    bin.writeUshort(otf, 4, numTables);
    var off = 44;
    for (var i2 = 0; i2 < numTables; i2++) {
      var tag2 = bin.readASCII(data4, off, 4);
      var tof = bin.readUint(data4, off + 4);
      var cLe = bin.readUint(data4, off + 8);
      var oLe = bin.readUint(data4, off + 12);
      off += 20;
      var tab = data4.slice(tof, tof + cLe);
      if (cLe != oLe) tab = pako["inflate"](tab);
      var to2 = 12 + i2 * 16;
      bin.writeASCII(otf, to2, tag2);
      bin.writeUint(otf, to2 + 8, toff);
      bin.writeUint(otf, to2 + 12, oLe);
      otf.set(tab, toff);
      toff += oLe;
    }
    return otf;
  }
  var data3 = new Uint8Array(buff);
  let compressedData;
  if (data3[0] == 119) {
    compressedData = data3;
    data3 = woffToOtf(data3);
  }
  var tmap = {};
  var tag = bin.readASCII(data3, 0, 4);
  if (tag == "ttcf") {
    var offset2 = 4;
    bin.readUshort(data3, offset2);
    offset2 += 2;
    bin.readUshort(data3, offset2);
    offset2 += 2;
    var numF = bin.readUint(data3, offset2);
    offset2 += 4;
    var fnts = [];
    for (var i = 0; i < numF; i++) {
      var foff = bin.readUint(data3, offset2);
      offset2 += 4;
      fnts.push(readFont(data3, i, foff, tmap));
    }
    return fnts;
  }
  var fnt = readFont(data3, 0, 0, tmap);
  fnt._compressedData = compressedData;
  var fvar = fnt["fvar"];
  if (fvar) {
    var out = [fnt];
    for (var i = 0; i < fvar[1].length; i++) {
      var fv = fvar[1][i];
      var obj = {};
      out.push(obj);
      for (var p2 in fnt) obj[p2] = fnt[p2];
      obj["_index"] = i;
      var name = obj["name"] = JSON.parse(JSON.stringify(obj["name"]));
      name["fontSubfamily"] = fv[0];
      if (fv[3] == null) fv[3] = (name["fontFamily"] + "-" + name["fontSubfamily"])["replaceAll"](" ", "");
      name["postScriptName"] = fv[3];
    }
    return out;
  }
  return [fnt];
};
Typr["findTable"] = function(data3, tab, foff) {
  var bin = Typr["B"];
  var numTables = bin.readUshort(data3, foff + 4);
  var offset2 = foff + 12;
  for (var i = 0; i < numTables; i++) {
    var tag = bin.readASCII(data3, offset2, 4);
    bin.readUint(data3, offset2 + 4);
    var toffset = bin.readUint(data3, offset2 + 8);
    var length = bin.readUint(data3, offset2 + 12);
    if (tag == tab) return [toffset, length];
    offset2 += 16;
  }
  return null;
};
Typr["T"] = {};
Typr["B"] = {
  readFixed: function(data3, o) {
    return (data3[o] << 8 | data3[o + 1]) + (data3[o + 2] << 8 | data3[o + 3]) / (256 * 256 + 4);
  },
  readF2dot14: function(data3, o) {
    var num = Typr["B"].readShort(data3, o);
    return num / 16384;
  },
  readInt: function(buff, p2) {
    var a2 = Typr["B"].t.uint8;
    a2[0] = buff[p2 + 3];
    a2[1] = buff[p2 + 2];
    a2[2] = buff[p2 + 1];
    a2[3] = buff[p2];
    return Typr["B"].t.int32[0];
  },
  readInt8: function(buff, p2) {
    var a2 = Typr["B"].t.uint8;
    a2[0] = buff[p2];
    return Typr["B"].t.int8[0];
  },
  readShort: function(buff, p2) {
    var a2 = Typr["B"].t.uint16;
    a2[0] = buff[p2] << 8 | buff[p2 + 1];
    return Typr["B"].t.int16[0];
  },
  readUshort: function(buff, p2) {
    return buff[p2] << 8 | buff[p2 + 1];
  },
  writeUshort: function(buff, p2, n3) {
    buff[p2] = n3 >> 8 & 255;
    buff[p2 + 1] = n3 & 255;
  },
  readUshorts: function(buff, p2, len) {
    var arr2 = [];
    for (var i = 0; i < len; i++) {
      var v = Typr["B"].readUshort(buff, p2 + i * 2);
      arr2.push(v);
    }
    return arr2;
  },
  readUint: function(buff, p2) {
    var a2 = Typr["B"].t.uint8;
    a2[3] = buff[p2];
    a2[2] = buff[p2 + 1];
    a2[1] = buff[p2 + 2];
    a2[0] = buff[p2 + 3];
    return Typr["B"].t.uint32[0];
  },
  writeUint: function(buff, p2, n3) {
    buff[p2] = n3 >> 24 & 255;
    buff[p2 + 1] = n3 >> 16 & 255;
    buff[p2 + 2] = n3 >> 8 & 255;
    buff[p2 + 3] = n3 >> 0 & 255;
  },
  readUint64: function(buff, p2) {
    return Typr["B"].readUint(buff, p2) * (4294967295 + 1) + Typr["B"].readUint(buff, p2 + 4);
  },
  readASCII: function(buff, p2, l) {
    var s = "";
    for (var i = 0; i < l; i++) s += String.fromCharCode(buff[p2 + i]);
    return s;
  },
  writeASCII: function(buff, p2, s) {
    for (var i = 0; i < s.length; i++)
      buff[p2 + i] = s.charCodeAt(i);
  },
  readUnicode: function(buff, p2, l) {
    var s = "";
    for (var i = 0; i < l; i++) {
      var c4 = buff[p2++] << 8 | buff[p2++];
      s += String.fromCharCode(c4);
    }
    return s;
  },
  _tdec: window["TextDecoder"] ? new window["TextDecoder"]() : null,
  readUTF8: function(buff, p2, l) {
    var tdec = Typr["B"]._tdec;
    if (tdec && p2 == 0 && l == buff.length) return tdec["decode"](buff);
    return Typr["B"].readASCII(buff, p2, l);
  },
  readBytes: function(buff, p2, l) {
    var arr2 = [];
    for (var i = 0; i < l; i++) arr2.push(buff[p2 + i]);
    return arr2;
  },
  readASCIIArray: function(buff, p2, l) {
    var s = [];
    for (var i = 0; i < l; i++)
      s.push(String.fromCharCode(buff[p2 + i]));
    return s;
  },
  t: function() {
    var ab = new ArrayBuffer(8);
    return {
      buff: ab,
      int8: new Int8Array(ab),
      uint8: new Uint8Array(ab),
      int16: new Int16Array(ab),
      uint16: new Uint16Array(ab),
      int32: new Int32Array(ab),
      uint32: new Uint32Array(ab)
    };
  }()
};
Typr["T"].CFF = {
  parseTab: function(data3, offset2, length) {
    var bin = Typr["B"];
    var CFF = Typr["T"].CFF;
    data3 = new Uint8Array(data3.buffer, offset2, length);
    offset2 = 0;
    data3[offset2];
    offset2++;
    data3[offset2];
    offset2++;
    data3[offset2];
    offset2++;
    data3[offset2];
    offset2++;
    var ninds = [];
    offset2 = CFF.readIndex(data3, offset2, ninds);
    var names = [];
    for (var i = 0; i < ninds.length - 1; i++) names.push(bin.readASCII(data3, offset2 + ninds[i], ninds[i + 1] - ninds[i]));
    offset2 += ninds[ninds.length - 1];
    var tdinds = [];
    offset2 = CFF.readIndex(data3, offset2, tdinds);
    var topDicts = [];
    for (var i = 0; i < tdinds.length - 1; i++) topDicts.push(CFF.readDict(data3, offset2 + tdinds[i], offset2 + tdinds[i + 1]));
    offset2 += tdinds[tdinds.length - 1];
    var topdict = topDicts[0];
    var sinds = [];
    offset2 = CFF.readIndex(data3, offset2, sinds);
    var strings3 = [];
    for (var i = 0; i < sinds.length - 1; i++) strings3.push(bin.readASCII(data3, offset2 + sinds[i], sinds[i + 1] - sinds[i]));
    offset2 += sinds[sinds.length - 1];
    CFF.readSubrs(data3, offset2, topdict);
    if (topdict["CharStrings"]) topdict["CharStrings"] = CFF.readBytes(data3, topdict["CharStrings"]);
    if (topdict["ROS"]) {
      offset2 = topdict["FDArray"];
      var fdind = [];
      offset2 = CFF.readIndex(data3, offset2, fdind);
      topdict["FDArray"] = [];
      for (var i = 0; i < fdind.length - 1; i++) {
        var dict = CFF.readDict(data3, offset2 + fdind[i], offset2 + fdind[i + 1]);
        CFF._readFDict(data3, dict, strings3);
        topdict["FDArray"].push(dict);
      }
      offset2 += fdind[fdind.length - 1];
      offset2 = topdict["FDSelect"];
      topdict["FDSelect"] = [];
      var fmt = data3[offset2];
      offset2++;
      if (fmt == 3) {
        var rns = bin.readUshort(data3, offset2);
        offset2 += 2;
        for (var i = 0; i < rns + 1; i++) {
          topdict["FDSelect"].push(bin.readUshort(data3, offset2), data3[offset2 + 2]);
          offset2 += 3;
        }
      } else throw fmt;
    }
    if (topdict["charset"]) topdict["charset"] = CFF.readCharset(data3, topdict["charset"], topdict["CharStrings"].length);
    CFF._readFDict(data3, topdict, strings3);
    return topdict;
  },
  _readFDict: function(data3, dict, ss) {
    var CFF = Typr["T"].CFF;
    var offset2;
    if (dict["Private"]) {
      offset2 = dict["Private"][1];
      dict["Private"] = CFF.readDict(data3, offset2, offset2 + dict["Private"][0]);
      if (dict["Private"]["Subrs"]) CFF.readSubrs(data3, offset2 + dict["Private"]["Subrs"], dict["Private"]);
    }
    for (var p2 in dict) if (["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(p2) != -1) dict[p2] = ss[dict[p2] - 426 + 35];
  },
  readSubrs: function(data3, offset2, obj) {
    obj["Subrs"] = Typr["T"].CFF.readBytes(data3, offset2);
    var bias, nSubrs = obj["Subrs"].length + 1;
    if (nSubrs < 1240) bias = 107;
    else if (nSubrs < 33900) bias = 1131;
    else bias = 32768;
    obj["Bias"] = bias;
  },
  readBytes: function(data3, offset2) {
    Typr["B"];
    var arr2 = [];
    offset2 = Typr["T"].CFF.readIndex(data3, offset2, arr2);
    var subrs = [], arl = arr2.length - 1, no = data3.byteOffset + offset2;
    for (var i = 0; i < arl; i++) {
      var ari = arr2[i];
      subrs.push(new Uint8Array(data3.buffer, no + ari, arr2[i + 1] - ari));
    }
    return subrs;
  },
  tableSE: [
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69,
    70,
    71,
    72,
    73,
    74,
    75,
    76,
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    0,
    111,
    112,
    113,
    114,
    0,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    0,
    123,
    0,
    124,
    125,
    126,
    127,
    128,
    129,
    130,
    131,
    0,
    132,
    133,
    0,
    134,
    135,
    136,
    137,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    138,
    0,
    139,
    0,
    0,
    0,
    0,
    140,
    141,
    142,
    143,
    0,
    0,
    0,
    0,
    0,
    144,
    0,
    0,
    0,
    145,
    0,
    0,
    146,
    147,
    148,
    149,
    0,
    0,
    0,
    0
  ],
  glyphByUnicode: function(cff, code) {
    for (var i = 0; i < cff["charset"].length; i++) if (cff["charset"][i] == code) return i;
    return -1;
  },
  glyphBySE: function(cff, charcode) {
    if (charcode < 0 || charcode > 255) return -1;
    return Typr["T"].CFF.glyphByUnicode(cff, Typr["T"].CFF.tableSE[charcode]);
  },
  /*readEncoding : function(data, offset, num)
    {
      var bin = Typr["B"];

      var array = ['.notdef'];
      var format = data[offset];  offset++;
      //console.log("Encoding");
      //console.log(format);

      if(format==0)
      {
        var nCodes = data[offset];  offset++;
        for(var i=0; i<nCodes; i++)  array.push(data[offset+i]);
      }
      /*
      else if(format==1 || format==2)
      {
        while(charset.length<num)
        {
          var first = bin.readUshort(data, offset);  offset+=2;
          var nLeft=0;
          if(format==1) {  nLeft = data[offset];  offset++;  }
          else          {  nLeft = bin.readUshort(data, offset);  offset+=2;  }
          for(var i=0; i<=nLeft; i++)  {  charset.push(first);  first++;  }
        }
      }

      else throw "error: unknown encoding format: " + format;

      return array;
    },*/
  readCharset: function(data3, offset2, num) {
    var bin = Typr["B"];
    var charset = [".notdef"];
    var format = data3[offset2];
    offset2++;
    if (format == 0) {
      for (var i = 0; i < num; i++) {
        var first = bin.readUshort(data3, offset2);
        offset2 += 2;
        charset.push(first);
      }
    } else if (format == 1 || format == 2) {
      while (charset.length < num) {
        var first = bin.readUshort(data3, offset2);
        offset2 += 2;
        var nLeft = 0;
        if (format == 1) {
          nLeft = data3[offset2];
          offset2++;
        } else {
          nLeft = bin.readUshort(data3, offset2);
          offset2 += 2;
        }
        for (var i = 0; i <= nLeft; i++) {
          charset.push(first);
          first++;
        }
      }
    } else throw "error: format: " + format;
    return charset;
  },
  readIndex: function(data3, offset2, inds) {
    var bin = Typr["B"];
    var count = bin.readUshort(data3, offset2) + 1;
    offset2 += 2;
    var offsize = data3[offset2];
    offset2++;
    if (offsize == 1) for (var i = 0; i < count; i++) inds.push(data3[offset2 + i]);
    else if (offsize == 2) for (var i = 0; i < count; i++) inds.push(bin.readUshort(data3, offset2 + i * 2));
    else if (offsize == 3) for (var i = 0; i < count; i++) inds.push(bin.readUint(data3, offset2 + i * 3 - 1) & 16777215);
    else if (offsize == 4) for (var i = 0; i < count; i++) inds.push(bin.readUint(data3, offset2 + i * 4));
    else if (count != 1) throw "unsupported offset size: " + offsize + ", count: " + count;
    offset2 += count * offsize;
    return offset2 - 1;
  },
  getCharString: function(data3, offset2, o) {
    var bin = Typr["B"];
    var b0 = data3[offset2], b1 = data3[offset2 + 1];
    data3[offset2 + 2];
    data3[offset2 + 3];
    data3[offset2 + 4];
    var vs = 1;
    var op = null, val2 = null;
    if (b0 <= 20) {
      op = b0;
      vs = 1;
    }
    if (b0 == 12) {
      op = b0 * 100 + b1;
      vs = 2;
    }
    if (21 <= b0 && b0 <= 27) {
      op = b0;
      vs = 1;
    }
    if (b0 == 28) {
      val2 = bin.readShort(data3, offset2 + 1);
      vs = 3;
    }
    if (29 <= b0 && b0 <= 31) {
      op = b0;
      vs = 1;
    }
    if (32 <= b0 && b0 <= 246) {
      val2 = b0 - 139;
      vs = 1;
    }
    if (247 <= b0 && b0 <= 250) {
      val2 = (b0 - 247) * 256 + b1 + 108;
      vs = 2;
    }
    if (251 <= b0 && b0 <= 254) {
      val2 = -(b0 - 251) * 256 - b1 - 108;
      vs = 2;
    }
    if (b0 == 255) {
      val2 = bin.readInt(data3, offset2 + 1) / 65535;
      vs = 5;
    }
    o.val = val2 != null ? val2 : "o" + op;
    o.size = vs;
  },
  readCharString: function(data3, offset2, length) {
    var end = offset2 + length;
    var bin = Typr["B"];
    var arr2 = [];
    while (offset2 < end) {
      var b0 = data3[offset2], b1 = data3[offset2 + 1];
      data3[offset2 + 2];
      data3[offset2 + 3];
      data3[offset2 + 4];
      var vs = 1;
      var op = null, val2 = null;
      if (b0 <= 20) {
        op = b0;
        vs = 1;
      }
      if (b0 == 12) {
        op = b0 * 100 + b1;
        vs = 2;
      }
      if (b0 == 19 || b0 == 20) {
        op = b0;
        vs = 2;
      }
      if (21 <= b0 && b0 <= 27) {
        op = b0;
        vs = 1;
      }
      if (b0 == 28) {
        val2 = bin.readShort(data3, offset2 + 1);
        vs = 3;
      }
      if (29 <= b0 && b0 <= 31) {
        op = b0;
        vs = 1;
      }
      if (32 <= b0 && b0 <= 246) {
        val2 = b0 - 139;
        vs = 1;
      }
      if (247 <= b0 && b0 <= 250) {
        val2 = (b0 - 247) * 256 + b1 + 108;
        vs = 2;
      }
      if (251 <= b0 && b0 <= 254) {
        val2 = -(b0 - 251) * 256 - b1 - 108;
        vs = 2;
      }
      if (b0 == 255) {
        val2 = bin.readInt(data3, offset2 + 1) / 65535;
        vs = 5;
      }
      arr2.push(val2 != null ? val2 : "o" + op);
      offset2 += vs;
    }
    return arr2;
  },
  readDict: function(data3, offset2, end) {
    var bin = Typr["B"];
    var dict = {};
    var carr = [];
    while (offset2 < end) {
      var b0 = data3[offset2], b1 = data3[offset2 + 1];
      data3[offset2 + 2];
      data3[offset2 + 3];
      data3[offset2 + 4];
      var vs = 1;
      var key = null, val2 = null;
      if (b0 == 28) {
        val2 = bin.readShort(data3, offset2 + 1);
        vs = 3;
      }
      if (b0 == 29) {
        val2 = bin.readInt(data3, offset2 + 1);
        vs = 5;
      }
      if (32 <= b0 && b0 <= 246) {
        val2 = b0 - 139;
        vs = 1;
      }
      if (247 <= b0 && b0 <= 250) {
        val2 = (b0 - 247) * 256 + b1 + 108;
        vs = 2;
      }
      if (251 <= b0 && b0 <= 254) {
        val2 = -(b0 - 251) * 256 - b1 - 108;
        vs = 2;
      }
      if (b0 == 255) {
        val2 = bin.readInt(data3, offset2 + 1) / 65535;
        vs = 5;
        throw "unknown number";
      }
      if (b0 == 30) {
        var nibs = [];
        vs = 1;
        while (true) {
          var b3 = data3[offset2 + vs];
          vs++;
          var nib0 = b3 >> 4, nib1 = b3 & 15;
          if (nib0 != 15) nibs.push(nib0);
          if (nib1 != 15) nibs.push(nib1);
          if (nib1 == 15) break;
        }
        var s = "";
        var chars = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"];
        for (var i = 0; i < nibs.length; i++) s += chars[nibs[i]];
        val2 = parseFloat(s);
      }
      if (b0 <= 21) {
        var keys = [
          "version",
          "Notice",
          "FullName",
          "FamilyName",
          "Weight",
          "FontBBox",
          "BlueValues",
          "OtherBlues",
          "FamilyBlues",
          "FamilyOtherBlues",
          "StdHW",
          "StdVW",
          "escape",
          "UniqueID",
          "XUID",
          "charset",
          "Encoding",
          "CharStrings",
          "Private",
          "Subrs",
          "defaultWidthX",
          "nominalWidthX"
        ];
        key = keys[b0];
        vs = 1;
        if (b0 == 12) {
          var keys = [
            "Copyright",
            "isFixedPitch",
            "ItalicAngle",
            "UnderlinePosition",
            "UnderlineThickness",
            "PaintType",
            "CharstringType",
            "FontMatrix",
            "StrokeWidth",
            "BlueScale",
            "BlueShift",
            "BlueFuzz",
            "StemSnapH",
            "StemSnapV",
            "ForceBold",
            "",
            "",
            "LanguageGroup",
            "ExpansionFactor",
            "initialRandomSeed",
            "SyntheticBase",
            "PostScript",
            "BaseFontName",
            "BaseFontBlend",
            "",
            "",
            "",
            "",
            "",
            "",
            "ROS",
            "CIDFontVersion",
            "CIDFontRevision",
            "CIDFontType",
            "CIDCount",
            "UIDBase",
            "FDArray",
            "FDSelect",
            "FontName"
          ];
          key = keys[b1];
          vs = 2;
        }
      }
      if (key != null) {
        dict[key] = carr.length == 1 ? carr[0] : carr;
        carr = [];
      } else carr.push(val2);
      offset2 += vs;
    }
    return dict;
  }
};
Typr["T"].cmap = {
  parseTab: function(data3, offset2, length) {
    var obj = { tables: [], ids: {}, off: offset2 };
    data3 = new Uint8Array(data3.buffer, offset2, length);
    offset2 = 0;
    var bin = Typr["B"], rU = bin.readUshort, cmap = Typr["T"].cmap;
    rU(data3, offset2);
    offset2 += 2;
    var numTables = rU(data3, offset2);
    offset2 += 2;
    var offs = [];
    for (var i = 0; i < numTables; i++) {
      var platformID = rU(data3, offset2);
      offset2 += 2;
      var encodingID = rU(data3, offset2);
      offset2 += 2;
      var noffset = bin.readUint(data3, offset2);
      offset2 += 4;
      var id = "p" + platformID + "e" + encodingID;
      var tind = offs.indexOf(noffset);
      if (tind == -1) {
        tind = obj.tables.length;
        var subt = {};
        offs.push(noffset);
        var format = subt.format = rU(data3, noffset);
        if (format == 0) subt = cmap.parse0(data3, noffset, subt);
        else if (format == 4) subt = cmap.parse4(data3, noffset, subt);
        else if (format == 6) subt = cmap.parse6(data3, noffset, subt);
        else if (format == 12) subt = cmap.parse12(data3, noffset, subt);
        obj.tables.push(subt);
      }
      if (obj.ids[id] != null) console.log("multiple tables for one platform+encoding: " + id);
      obj.ids[id] = tind;
    }
    return obj;
  },
  parse0: function(data3, offset2, obj) {
    var bin = Typr["B"];
    offset2 += 2;
    var len = bin.readUshort(data3, offset2);
    offset2 += 2;
    bin.readUshort(data3, offset2);
    offset2 += 2;
    obj.map = [];
    for (var i = 0; i < len - 6; i++) obj.map.push(data3[offset2 + i]);
    return obj;
  },
  parse4: function(data3, offset2, obj) {
    var bin = Typr["B"], rU = bin.readUshort, rUs = bin.readUshorts;
    var offset0 = offset2;
    offset2 += 2;
    var length = rU(data3, offset2);
    offset2 += 2;
    rU(data3, offset2);
    offset2 += 2;
    var segCountX2 = rU(data3, offset2);
    offset2 += 2;
    var segCount = segCountX2 >>> 1;
    obj.searchRange = rU(data3, offset2);
    offset2 += 2;
    obj.entrySelector = rU(data3, offset2);
    offset2 += 2;
    obj.rangeShift = rU(data3, offset2);
    offset2 += 2;
    obj.endCount = rUs(data3, offset2, segCount);
    offset2 += segCount * 2;
    offset2 += 2;
    obj.startCount = rUs(data3, offset2, segCount);
    offset2 += segCount * 2;
    obj.idDelta = [];
    for (var i = 0; i < segCount; i++) {
      obj.idDelta.push(bin.readShort(data3, offset2));
      offset2 += 2;
    }
    obj.idRangeOffset = rUs(data3, offset2, segCount);
    offset2 += segCount * 2;
    obj.glyphIdArray = rUs(data3, offset2, offset0 + length - offset2 >> 1);
    return obj;
  },
  parse6: function(data3, offset2, obj) {
    var bin = Typr["B"];
    offset2 += 2;
    bin.readUshort(data3, offset2);
    offset2 += 2;
    bin.readUshort(data3, offset2);
    offset2 += 2;
    obj.firstCode = bin.readUshort(data3, offset2);
    offset2 += 2;
    var entryCount = bin.readUshort(data3, offset2);
    offset2 += 2;
    obj.glyphIdArray = [];
    for (var i = 0; i < entryCount; i++) {
      obj.glyphIdArray.push(bin.readUshort(data3, offset2));
      offset2 += 2;
    }
    return obj;
  },
  parse12: function(data3, offset2, obj) {
    var bin = Typr["B"], rU = bin.readUint;
    offset2 += 4;
    rU(data3, offset2);
    offset2 += 4;
    rU(data3, offset2);
    offset2 += 4;
    var nGroups = rU(data3, offset2) * 3;
    offset2 += 4;
    var gps = obj.groups = new Uint32Array(nGroups);
    for (var i = 0; i < nGroups; i += 3) {
      gps[i] = rU(data3, offset2 + (i << 2));
      gps[i + 1] = rU(data3, offset2 + (i << 2) + 4);
      gps[i + 2] = rU(data3, offset2 + (i << 2) + 8);
    }
    return obj;
  }
};
Typr["T"].CBLC = {
  parseTab: function(data3, offset2, length) {
    var bin = Typr["B"], ooff = offset2;
    bin.readUshort(data3, offset2);
    offset2 += 2;
    bin.readUshort(data3, offset2);
    offset2 += 2;
    var numSizes = bin.readUint(data3, offset2);
    offset2 += 4;
    var out = [];
    for (var i = 0; i < numSizes; i++) {
      var off = bin.readUint(data3, offset2);
      offset2 += 4;
      bin.readUint(data3, offset2);
      offset2 += 4;
      bin.readUint(data3, offset2);
      offset2 += 4;
      offset2 += 4;
      offset2 += 2 * 12;
      bin.readUshort(data3, offset2);
      offset2 += 2;
      bin.readUshort(data3, offset2);
      offset2 += 2;
      offset2 += 4;
      var coff = ooff + off;
      for (var j2 = 0; j2 < 3; j2++) {
        var fgI = bin.readUshort(data3, coff);
        coff += 2;
        var lgI = bin.readUshort(data3, coff);
        coff += 2;
        var nxt = bin.readUint(data3, coff);
        coff += 4;
        var gcnt = lgI - fgI + 1;
        var ioff = ooff + off + nxt;
        var inF = bin.readUshort(data3, ioff);
        ioff += 2;
        if (inF != 1) throw inF;
        var imF = bin.readUshort(data3, ioff);
        ioff += 2;
        var imgo = bin.readUint(data3, ioff);
        ioff += 4;
        var oarr = [];
        for (var gi = 0; gi < gcnt; gi++) {
          var sbitO = bin.readUint(data3, ioff + gi * 4);
          oarr.push(imgo + sbitO);
        }
        out.push([fgI, lgI, imF, oarr]);
      }
    }
    return out;
  }
};
Typr["T"].CBDT = {
  parseTab: function(data3, offset2, length) {
    Typr["B"];
    return new Uint8Array(data3.buffer, data3.byteOffset + offset2, length);
  }
};
Typr["T"].glyf = {
  parseTab: function(data3, offset2, length, font2) {
    var obj = [], ng = font2["maxp"]["numGlyphs"];
    for (var g2 = 0; g2 < ng; g2++) obj.push(null);
    return obj;
  },
  _parseGlyf: function(font2, g2) {
    var bin = Typr["B"];
    var data3 = font2["_data"], loca = font2["loca"];
    if (loca[g2] == loca[g2 + 1]) return null;
    var offset2 = Typr["findTable"](data3, "glyf", font2["_offset"])[0] + loca[g2];
    var gl = {};
    gl.noc = bin.readShort(data3, offset2);
    offset2 += 2;
    gl.xMin = bin.readShort(data3, offset2);
    offset2 += 2;
    gl.yMin = bin.readShort(data3, offset2);
    offset2 += 2;
    gl.xMax = bin.readShort(data3, offset2);
    offset2 += 2;
    gl.yMax = bin.readShort(data3, offset2);
    offset2 += 2;
    if (gl.xMin >= gl.xMax || gl.yMin >= gl.yMax) return null;
    if (gl.noc > 0) {
      gl.endPts = [];
      for (var i = 0; i < gl.noc; i++) {
        gl.endPts.push(bin.readUshort(data3, offset2));
        offset2 += 2;
      }
      var instructionLength = bin.readUshort(data3, offset2);
      offset2 += 2;
      if (data3.length - offset2 < instructionLength) return null;
      gl.instructions = bin.readBytes(data3, offset2, instructionLength);
      offset2 += instructionLength;
      var crdnum = gl.endPts[gl.noc - 1] + 1;
      gl.flags = [];
      for (var i = 0; i < crdnum; i++) {
        var flag = data3[offset2];
        offset2++;
        gl.flags.push(flag);
        if ((flag & 8) != 0) {
          var rep = data3[offset2];
          offset2++;
          for (var j2 = 0; j2 < rep; j2++) {
            gl.flags.push(flag);
            i++;
          }
        }
      }
      gl.xs = [];
      for (var i = 0; i < crdnum; i++) {
        var i8 = (gl.flags[i] & 2) != 0, same = (gl.flags[i] & 16) != 0;
        if (i8) {
          gl.xs.push(same ? data3[offset2] : -data3[offset2]);
          offset2++;
        } else {
          if (same) gl.xs.push(0);
          else {
            gl.xs.push(bin.readShort(data3, offset2));
            offset2 += 2;
          }
        }
      }
      gl.ys = [];
      for (var i = 0; i < crdnum; i++) {
        var i8 = (gl.flags[i] & 4) != 0, same = (gl.flags[i] & 32) != 0;
        if (i8) {
          gl.ys.push(same ? data3[offset2] : -data3[offset2]);
          offset2++;
        } else {
          if (same) gl.ys.push(0);
          else {
            gl.ys.push(bin.readShort(data3, offset2));
            offset2 += 2;
          }
        }
      }
      var x = 0, y = 0;
      for (var i = 0; i < crdnum; i++) {
        x += gl.xs[i];
        y += gl.ys[i];
        gl.xs[i] = x;
        gl.ys[i] = y;
      }
    } else {
      var ARG_1_AND_2_ARE_WORDS = 1 << 0;
      var ARGS_ARE_XY_VALUES = 1 << 1;
      var WE_HAVE_A_SCALE = 1 << 3;
      var MORE_COMPONENTS = 1 << 5;
      var WE_HAVE_AN_X_AND_Y_SCALE = 1 << 6;
      var WE_HAVE_A_TWO_BY_TWO = 1 << 7;
      var WE_HAVE_INSTRUCTIONS = 1 << 8;
      gl.parts = [];
      var flags;
      do {
        flags = bin.readUshort(data3, offset2);
        offset2 += 2;
        var part = { m: { a: 1, b: 0, c: 0, d: 1, tx: 0, ty: 0 }, p1: -1, p2: -1 };
        gl.parts.push(part);
        part.glyphIndex = bin.readUshort(data3, offset2);
        offset2 += 2;
        if (flags & ARG_1_AND_2_ARE_WORDS) {
          var arg1 = bin.readShort(data3, offset2);
          offset2 += 2;
          var arg2 = bin.readShort(data3, offset2);
          offset2 += 2;
        } else {
          var arg1 = bin.readInt8(data3, offset2);
          offset2++;
          var arg2 = bin.readInt8(data3, offset2);
          offset2++;
        }
        if (flags & ARGS_ARE_XY_VALUES) {
          part.m.tx = arg1;
          part.m.ty = arg2;
        } else {
          part.p1 = arg1;
          part.p2 = arg2;
        }
        if (flags & WE_HAVE_A_SCALE) {
          part.m.a = part.m.d = bin.readF2dot14(data3, offset2);
          offset2 += 2;
        } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
          part.m.a = bin.readF2dot14(data3, offset2);
          offset2 += 2;
          part.m.d = bin.readF2dot14(data3, offset2);
          offset2 += 2;
        } else if (flags & WE_HAVE_A_TWO_BY_TWO) {
          part.m.a = bin.readF2dot14(data3, offset2);
          offset2 += 2;
          part.m.b = bin.readF2dot14(data3, offset2);
          offset2 += 2;
          part.m.c = bin.readF2dot14(data3, offset2);
          offset2 += 2;
          part.m.d = bin.readF2dot14(data3, offset2);
          offset2 += 2;
        }
      } while (flags & MORE_COMPONENTS);
      if (flags & WE_HAVE_INSTRUCTIONS) {
        var numInstr = bin.readUshort(data3, offset2);
        offset2 += 2;
        gl.instr = [];
        for (var i = 0; i < numInstr; i++) {
          gl.instr.push(data3[offset2]);
          offset2++;
        }
      }
    }
    return gl;
  }
};
Typr["T"].head = {
  parseTab: function(data3, offset2, length) {
    var bin = Typr["B"];
    var obj = {};
    bin.readFixed(data3, offset2);
    offset2 += 4;
    obj["fontRevision"] = bin.readFixed(data3, offset2);
    offset2 += 4;
    bin.readUint(data3, offset2);
    offset2 += 4;
    bin.readUint(data3, offset2);
    offset2 += 4;
    obj["flags"] = bin.readUshort(data3, offset2);
    offset2 += 2;
    obj["unitsPerEm"] = bin.readUshort(data3, offset2);
    offset2 += 2;
    obj["created"] = bin.readUint64(data3, offset2);
    offset2 += 8;
    obj["modified"] = bin.readUint64(data3, offset2);
    offset2 += 8;
    obj["xMin"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["yMin"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["xMax"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["yMax"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["macStyle"] = bin.readUshort(data3, offset2);
    offset2 += 2;
    obj["lowestRecPPEM"] = bin.readUshort(data3, offset2);
    offset2 += 2;
    obj["fontDirectionHint"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["indexToLocFormat"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["glyphDataFormat"] = bin.readShort(data3, offset2);
    offset2 += 2;
    return obj;
  }
};
Typr["T"].hhea = {
  parseTab: function(data3, offset2, length) {
    var bin = Typr["B"];
    var obj = {};
    bin.readFixed(data3, offset2);
    offset2 += 4;
    var keys = [
      "ascender",
      "descender",
      "lineGap",
      "advanceWidthMax",
      "minLeftSideBearing",
      "minRightSideBearing",
      "xMaxExtent",
      "caretSlopeRise",
      "caretSlopeRun",
      "caretOffset",
      "res0",
      "res1",
      "res2",
      "res3",
      "metricDataFormat",
      "numberOfHMetrics"
    ];
    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var func = key == "advanceWidthMax" || key == "numberOfHMetrics" ? bin.readUshort : bin.readShort;
      obj[key] = func(data3, offset2 + i * 2);
    }
    return obj;
  }
};
Typr["T"].hmtx = {
  parseTab: function(data3, offset2, length, font2) {
    var bin = Typr["B"];
    var aWidth = [];
    var lsBearing = [];
    var nG = font2["maxp"]["numGlyphs"], nH = font2["hhea"]["numberOfHMetrics"];
    var aw = 0, lsb = 0, i = 0;
    while (i < nH) {
      aw = bin.readUshort(data3, offset2 + (i << 2));
      lsb = bin.readShort(data3, offset2 + (i << 2) + 2);
      aWidth.push(aw);
      lsBearing.push(lsb);
      i++;
    }
    while (i < nG) {
      aWidth.push(aw);
      lsBearing.push(lsb);
      i++;
    }
    return { aWidth, lsBearing };
  }
};
Typr["T"].kern = {
  parseTab: function(data3, offset2, length, font2) {
    var bin = Typr["B"], kern = Typr["T"].kern;
    var version3 = bin.readUshort(data3, offset2);
    if (version3 == 1) return kern.parseV1(data3, offset2, length, font2);
    var nTables = bin.readUshort(data3, offset2 + 2);
    offset2 += 4;
    var map3 = { glyph1: [], rval: [] };
    for (var i = 0; i < nTables; i++) {
      offset2 += 2;
      var length = bin.readUshort(data3, offset2);
      offset2 += 2;
      var coverage = bin.readUshort(data3, offset2);
      offset2 += 2;
      var format = coverage >>> 8;
      format &= 15;
      if (format == 0) offset2 = kern.readFormat0(data3, offset2, map3);
    }
    return map3;
  },
  parseV1: function(data3, offset2, length, font2) {
    var bin = Typr["B"], kern = Typr["T"].kern;
    bin.readFixed(data3, offset2);
    var nTables = bin.readUint(data3, offset2 + 4);
    offset2 += 8;
    var map3 = { glyph1: [], rval: [] };
    for (var i = 0; i < nTables; i++) {
      bin.readUint(data3, offset2);
      offset2 += 4;
      var coverage = bin.readUshort(data3, offset2);
      offset2 += 2;
      bin.readUshort(data3, offset2);
      offset2 += 2;
      var format = coverage & 255;
      if (format == 0) offset2 = kern.readFormat0(data3, offset2, map3);
    }
    return map3;
  },
  readFormat0: function(data3, offset2, map3) {
    var bin = Typr["B"], rUs = bin.readUshort;
    var pleft = -1;
    var nPairs = rUs(data3, offset2);
    rUs(data3, offset2 + 2);
    rUs(data3, offset2 + 4);
    rUs(data3, offset2 + 6);
    offset2 += 8;
    for (var j2 = 0; j2 < nPairs; j2++) {
      var left = rUs(data3, offset2);
      offset2 += 2;
      var right = rUs(data3, offset2);
      offset2 += 2;
      var value = bin.readShort(data3, offset2);
      offset2 += 2;
      if (left != pleft) {
        map3.glyph1.push(left);
        map3.rval.push({ glyph2: [], vals: [] });
      }
      var rval = map3.rval[map3.rval.length - 1];
      rval.glyph2.push(right);
      rval.vals.push(value);
      pleft = left;
    }
    return offset2;
  }
};
Typr["T"].loca = {
  parseTab: function(data3, offset2, length, font2) {
    var bin = Typr["B"];
    var obj = [];
    var ver = font2["head"]["indexToLocFormat"];
    var len = font2["maxp"]["numGlyphs"] + 1;
    if (ver == 0) for (var i = 0; i < len; i++) obj.push(bin.readUshort(data3, offset2 + (i << 1)) << 1);
    if (ver == 1) for (var i = 0; i < len; i++) obj.push(bin.readUint(data3, offset2 + (i << 2)));
    return obj;
  }
};
Typr["T"].maxp = {
  parseTab: function(data3, offset2, length) {
    var bin = Typr["B"], rU = bin.readUshort;
    var obj = {};
    bin.readUint(data3, offset2);
    offset2 += 4;
    obj["numGlyphs"] = rU(data3, offset2);
    offset2 += 2;
    return obj;
  }
};
Typr["T"].name = {
  parseTab: function(data3, offset2, length) {
    var bin = Typr["B"];
    var obj = {};
    bin.readUshort(data3, offset2);
    offset2 += 2;
    var count = bin.readUshort(data3, offset2);
    offset2 += 2;
    var stringOffset = bin.readUshort(data3, offset2);
    offset2 += 2;
    var ooo = offset2 - 6 + stringOffset;
    var names = [
      "copyright",
      "fontFamily",
      "fontSubfamily",
      "ID",
      "fullName",
      "version",
      "postScriptName",
      "trademark",
      "manufacturer",
      "designer",
      "description",
      "urlVendor",
      "urlDesigner",
      "licence",
      "licenceURL",
      "---",
      "typoFamilyName",
      "typoSubfamilyName",
      "compatibleFull",
      "sampleText",
      "postScriptCID",
      "wwsFamilyName",
      "wwsSubfamilyName",
      "lightPalette",
      "darkPalette"
    ];
    var rU = bin.readUshort;
    for (var i = 0; i < count; i++) {
      var platformID = rU(data3, offset2);
      offset2 += 2;
      var encodingID = rU(data3, offset2);
      offset2 += 2;
      var languageID = rU(data3, offset2);
      offset2 += 2;
      var nameID = rU(data3, offset2);
      offset2 += 2;
      var slen = rU(data3, offset2);
      offset2 += 2;
      var noffset = rU(data3, offset2);
      offset2 += 2;
      var soff = ooo + noffset;
      var str;
      if (platformID == 0) str = bin.readUnicode(data3, soff, slen / 2);
      else if (platformID == 3 && encodingID == 0) str = bin.readUnicode(data3, soff, slen / 2);
      else if (platformID == 1 && encodingID == 25) str = bin.readUnicode(data3, soff, slen / 2);
      else if (encodingID == 0) str = bin.readASCII(data3, soff, slen);
      else if (encodingID == 1) str = bin.readUnicode(data3, soff, slen / 2);
      else if (encodingID == 3) str = bin.readUnicode(data3, soff, slen / 2);
      else if (encodingID == 4) str = bin.readUnicode(data3, soff, slen / 2);
      else if (encodingID == 5) str = bin.readUnicode(data3, soff, slen / 2);
      else if (encodingID == 10) str = bin.readUnicode(data3, soff, slen / 2);
      else if (platformID == 1) {
        str = bin.readASCII(data3, soff, slen);
        console.log("reading unknown MAC encoding " + encodingID + " as ASCII");
      } else {
        console.log("unknown encoding " + encodingID + ", platformID: " + platformID);
        str = bin.readASCII(data3, soff, slen);
      }
      var tid = "p" + platformID + "," + languageID.toString(16);
      if (obj[tid] == null) obj[tid] = {};
      var name = names[nameID];
      if (name == null) name = "_" + nameID;
      obj[tid][name] = str;
      obj[tid]["_lang"] = languageID;
    }
    var out = Typr["T"].name.selectOne(obj), ff = "fontFamily";
    if (out[ff] == null) {
      for (var p2 in obj) if (obj[p2][ff] != null) out[ff] = obj[p2][ff];
    }
    return out;
  },
  selectOne: function(obj) {
    var psn = "postScriptName";
    for (var p2 in obj) if (obj[p2][psn] != null && obj[p2]["_lang"] == 1033) return obj[p2];
    for (var p2 in obj) if (obj[p2][psn] != null && obj[p2]["_lang"] == 0) return obj[p2];
    for (var p2 in obj) if (obj[p2][psn] != null && obj[p2]["_lang"] == 3084) return obj[p2];
    for (var p2 in obj) if (obj[p2][psn] != null) return obj[p2];
    var out;
    for (var p2 in obj) {
      out = obj[p2];
      break;
    }
    console.log("returning name table with languageID " + out._lang);
    if (out[psn] == null && out["ID"] != null) out[psn] = out["ID"];
    return out;
  }
};
Typr["T"].OS2 = {
  parseTab: function(data3, offset2, length) {
    var bin = Typr["B"];
    var ver = bin.readUshort(data3, offset2);
    offset2 += 2;
    var OS2 = Typr["T"].OS2;
    var obj = {};
    if (ver == 0) OS2.version0(data3, offset2, obj);
    else if (ver == 1) OS2.version1(data3, offset2, obj);
    else if (ver == 2 || ver == 3 || ver == 4) OS2.version2(data3, offset2, obj);
    else if (ver == 5) OS2.version5(data3, offset2, obj);
    else throw "unknown OS/2 table version: " + ver;
    return obj;
  },
  version0: function(data3, offset2, obj) {
    var bin = Typr["B"];
    obj["xAvgCharWidth"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["usWeightClass"] = bin.readUshort(data3, offset2);
    offset2 += 2;
    obj["usWidthClass"] = bin.readUshort(data3, offset2);
    offset2 += 2;
    obj["fsType"] = bin.readUshort(data3, offset2);
    offset2 += 2;
    obj["ySubscriptXSize"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["ySubscriptYSize"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["ySubscriptXOffset"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["ySubscriptYOffset"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["ySuperscriptXSize"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["ySuperscriptYSize"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["ySuperscriptXOffset"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["ySuperscriptYOffset"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["yStrikeoutSize"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["yStrikeoutPosition"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["sFamilyClass"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["panose"] = bin.readBytes(data3, offset2, 10);
    offset2 += 10;
    obj["ulUnicodeRange1"] = bin.readUint(data3, offset2);
    offset2 += 4;
    obj["ulUnicodeRange2"] = bin.readUint(data3, offset2);
    offset2 += 4;
    obj["ulUnicodeRange3"] = bin.readUint(data3, offset2);
    offset2 += 4;
    obj["ulUnicodeRange4"] = bin.readUint(data3, offset2);
    offset2 += 4;
    obj["achVendID"] = bin.readASCII(data3, offset2, 4);
    offset2 += 4;
    obj["fsSelection"] = bin.readUshort(data3, offset2);
    offset2 += 2;
    obj["usFirstCharIndex"] = bin.readUshort(data3, offset2);
    offset2 += 2;
    obj["usLastCharIndex"] = bin.readUshort(data3, offset2);
    offset2 += 2;
    obj["sTypoAscender"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["sTypoDescender"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["sTypoLineGap"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["usWinAscent"] = bin.readUshort(data3, offset2);
    offset2 += 2;
    obj["usWinDescent"] = bin.readUshort(data3, offset2);
    offset2 += 2;
    return offset2;
  },
  version1: function(data3, offset2, obj) {
    var bin = Typr["B"];
    offset2 = Typr["T"].OS2.version0(data3, offset2, obj);
    obj["ulCodePageRange1"] = bin.readUint(data3, offset2);
    offset2 += 4;
    obj["ulCodePageRange2"] = bin.readUint(data3, offset2);
    offset2 += 4;
    return offset2;
  },
  version2: function(data3, offset2, obj) {
    var bin = Typr["B"], rU = bin.readUshort;
    offset2 = Typr["T"].OS2.version1(data3, offset2, obj);
    obj["sxHeight"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["sCapHeight"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["usDefault"] = rU(data3, offset2);
    offset2 += 2;
    obj["usBreak"] = rU(data3, offset2);
    offset2 += 2;
    obj["usMaxContext"] = rU(data3, offset2);
    offset2 += 2;
    return offset2;
  },
  version5: function(data3, offset2, obj) {
    var rU = Typr["B"].readUshort;
    offset2 = Typr["T"].OS2.version2(data3, offset2, obj);
    obj["usLowerOpticalPointSize"] = rU(data3, offset2);
    offset2 += 2;
    obj["usUpperOpticalPointSize"] = rU(data3, offset2);
    offset2 += 2;
    return offset2;
  }
};
Typr["T"].post = {
  parseTab: function(data3, offset2, length) {
    var bin = Typr["B"];
    var obj = {};
    obj["version"] = bin.readFixed(data3, offset2);
    offset2 += 4;
    obj["italicAngle"] = bin.readFixed(data3, offset2);
    offset2 += 4;
    obj["underlinePosition"] = bin.readShort(data3, offset2);
    offset2 += 2;
    obj["underlineThickness"] = bin.readShort(data3, offset2);
    offset2 += 2;
    return obj;
  }
};
Typr["T"].SVG = {
  parseTab: function(data3, offset2, length) {
    var bin = Typr["B"];
    var obj = { entries: [], svgs: [] };
    var offset0 = offset2;
    bin.readUshort(data3, offset2);
    offset2 += 2;
    var svgDocIndexOffset = bin.readUint(data3, offset2);
    offset2 += 4;
    bin.readUint(data3, offset2);
    offset2 += 4;
    offset2 = svgDocIndexOffset + offset0;
    var numEntries = bin.readUshort(data3, offset2);
    offset2 += 2;
    for (var i = 0; i < numEntries; i++) {
      var startGlyphID = bin.readUshort(data3, offset2);
      offset2 += 2;
      var endGlyphID = bin.readUshort(data3, offset2);
      offset2 += 2;
      var svgDocOffset = bin.readUint(data3, offset2);
      offset2 += 4;
      var svgDocLength = bin.readUint(data3, offset2);
      offset2 += 4;
      var sbuf = new Uint8Array(data3.buffer, offset0 + svgDocOffset + svgDocIndexOffset, svgDocLength);
      if (sbuf[0] == 31 && sbuf[1] == 139 && sbuf[2] == 8) sbuf = pako["inflate"](sbuf);
      var svg = bin.readUTF8(sbuf, 0, sbuf.length);
      for (var f = startGlyphID; f <= endGlyphID; f++) {
        obj.entries[f] = obj.svgs.length;
      }
      obj.svgs.push(svg);
    }
    return obj;
  }
};
Typr["T"].sbix = {
  parseTab: function(data3, offset2, length, obj) {
    var numGlyphs = obj["maxp"]["numGlyphs"];
    var ooff = offset2;
    var bin = Typr["B"];
    var numStrikes = bin.readUint(data3, offset2 + 4);
    var out = [];
    for (var si = numStrikes - 1; si < numStrikes; si++) {
      var off = ooff + bin.readUint(data3, offset2 + 8 + si * 4);
      for (var gi = 0; gi < numGlyphs; gi++) {
        var aoff = bin.readUint(data3, off + 4 + gi * 4);
        var noff = bin.readUint(data3, off + 4 + gi * 4 + 4);
        if (aoff == noff) {
          out[gi] = null;
          continue;
        }
        var go = off + aoff;
        var tag = bin.readASCII(data3, go + 4, 4);
        if (tag != "png ") throw tag;
        out[gi] = new Uint8Array(data3.buffer, data3.byteOffset + go + 8, noff - aoff - 8);
      }
    }
    return out;
  }
};
Typr["T"].colr = {
  parseTab: function(data3, offset2, length) {
    var bin = Typr["B"];
    var ooff = offset2;
    offset2 += 2;
    var num = bin.readUshort(data3, offset2);
    offset2 += 2;
    var boff = bin.readUint(data3, offset2);
    offset2 += 4;
    var loff = bin.readUint(data3, offset2);
    offset2 += 4;
    var lnum = bin.readUshort(data3, offset2);
    offset2 += 2;
    var base2 = {};
    var coff = ooff + boff;
    for (var i = 0; i < num; i++) {
      base2["g" + bin.readUshort(data3, coff)] = [bin.readUshort(data3, coff + 2), bin.readUshort(data3, coff + 4)];
      coff += 6;
    }
    var lays = [];
    coff = ooff + loff;
    for (var i = 0; i < lnum; i++) {
      lays.push(bin.readUshort(data3, coff), bin.readUshort(data3, coff + 2));
      coff += 4;
    }
    return [base2, lays];
  }
};
Typr["T"].cpal = {
  parseTab: function(data3, offset2, length) {
    var bin = Typr["B"];
    var ooff = offset2;
    var vsn = bin.readUshort(data3, offset2);
    offset2 += 2;
    if (vsn == 0) {
      bin.readUshort(data3, offset2);
      offset2 += 2;
      bin.readUshort(data3, offset2);
      offset2 += 2;
      var tot = bin.readUshort(data3, offset2);
      offset2 += 2;
      var fst = bin.readUint(data3, offset2);
      offset2 += 4;
      return new Uint8Array(data3.buffer, ooff + fst, tot * 4);
    } else throw vsn;
  }
};
Typr["T"].GSUB = {
  parseTab: function(data3, offset2, length, obj) {
    var bin = Typr["B"], rU = bin.readUshort;
    bin.readUint;
    var off = offset2;
    rU(data3, off);
    off += 2;
    rU(data3, off);
    off += 2;
    rU(data3, off);
    off += 2;
    var flO = rU(data3, off);
    off += 2;
    rU(data3, off);
    off += 2;
    off = offset2 + flO;
    var fmap = {};
    var cnt = rU(data3, off);
    off += 2;
    for (var i = 0; i < cnt; i++) {
      var tag = bin.readASCII(data3, off, 4);
      off += 4;
      rU(data3, off);
      off += 2;
      fmap[tag] = true;
    }
    return fmap;
  }
};
Typr["T"].fvar = {
  parseTab: function(data3, offset2, length, obj) {
    var name = obj["name"];
    var off = offset2;
    var bin = Typr["B"];
    var axes = [], inst = [];
    off += 8;
    var acnt = bin.readUshort(data3, off);
    off += 2;
    off += 2;
    var icnt = bin.readUshort(data3, off);
    off += 2;
    var isiz = bin.readUshort(data3, off);
    off += 2;
    for (var i = 0; i < acnt; i++) {
      var tag = bin.readASCII(data3, off, 4);
      var min = bin.readFixed(data3, off + 4);
      var def = bin.readFixed(data3, off + 8);
      var max = bin.readFixed(data3, off + 12);
      var flg = bin.readUshort(data3, off + 16);
      var nid = bin.readUshort(data3, off + 18);
      axes.push([tag, min, def, max, flg, name["_" + nid]]);
      off += 20;
    }
    for (var i = 0; i < icnt; i++) {
      var snid = bin.readUshort(data3, off), pnid = null;
      var flg = bin.readUshort(data3, off + 2);
      var crd = [];
      for (var j2 = 0; j2 < acnt; j2++) crd.push(bin.readFixed(data3, off + 4 + j2 * 4));
      off += 4 + acnt * 4;
      if ((isiz & 3) == 2) {
        pnid = bin.readUshort(data3, off);
        off += 2;
      }
      inst.push([name["_" + snid], flg, crd, pnid]);
    }
    return [axes, inst];
  }
};
Typr["T"].gvar = function() {
  var EMBEDDED_PEAK_TUPLE = 32768;
  var INTERMEDIATE_REGION = 16384;
  var PRIVATE_POINT_NUMBERS = 8192;
  var DELTAS_ARE_ZERO = 128;
  var DELTAS_ARE_WORDS = 64;
  var POINTS_ARE_WORDS = 128;
  var SHARED_POINT_NUMBERS = 32768;
  var bin = Typr["B"];
  function readTuple(data3, o, acnt) {
    var tup = [];
    for (var j2 = 0; j2 < acnt; j2++) tup.push(bin.readF2dot14(data3, o + j2 * 2));
    return tup;
  }
  function readTupleVarHeader(data3, off, vcnt, acnt, eoff) {
    var out = [];
    for (var j2 = 0; j2 < vcnt; j2++) {
      var dsiz = bin.readUshort(data3, off);
      off += 2;
      var tind = bin.readUshort(data3, off), flag = tind & 61440;
      tind = tind & 4095;
      off += 2;
      var peak = null, start = null, end = null;
      if (flag & EMBEDDED_PEAK_TUPLE) {
        peak = readTuple(data3, off, acnt);
        off += acnt * 2;
      }
      if (flag & INTERMEDIATE_REGION) {
        start = readTuple(data3, off, acnt);
        off += acnt * 2;
      }
      if (flag & INTERMEDIATE_REGION) {
        end = readTuple(data3, off, acnt);
        off += acnt * 2;
      }
      out.push([dsiz, tind, flag, start, peak, end]);
    }
    return out;
  }
  function readPointNumbers(data3, off, gid) {
    var cnt = data3[off];
    off++;
    if (cnt == 0) return [[], off];
    if (127 < cnt) {
      cnt = (cnt & 127) << 8 | data3[off++];
    }
    var pts = [], last2 = 0;
    while (pts.length < cnt) {
      var v = data3[off];
      off++;
      var wds = (v & POINTS_ARE_WORDS) != 0;
      v = (v & 127) + 1;
      for (var i = 0; i < v; i++) {
        var dif = 0;
        if (wds) {
          dif = bin.readUshort(data3, off);
          off += 2;
        } else {
          dif = data3[off];
          off++;
        }
        last2 += dif;
        pts.push(last2);
      }
    }
    return [pts, off];
  }
  function parseTab(data3, offset2, length, obj) {
    var off = offset2 + 4;
    var acnt = bin.readUshort(data3, off);
    off += 2;
    var tcnt = bin.readUshort(data3, off);
    off += 2;
    var toff = bin.readUint(data3, off);
    off += 4;
    var gcnt = bin.readUshort(data3, off);
    off += 2;
    bin.readUshort(data3, off);
    off += 2;
    var goff = bin.readUint(data3, off);
    off += 4;
    var offs = [];
    for (var i = 0; i < gcnt + 1; i++) offs.push(bin.readUint(data3, off + i * 4));
    var tups = [], mins = [], maxs = [];
    off = offset2 + toff;
    for (var i = 0; i < tcnt; i++) {
      var peak = readTuple(data3, off + i * acnt * 2, acnt), imin = [], imax = [];
      tups.push(peak);
      mins.push(imin);
      maxs.push(imax);
      for (var k = 0; k < acnt; k++) {
        imin[k] = Math.min(peak[k], 0);
        imax[k] = Math.max(peak[k], 0);
      }
    }
    var i8 = new Int8Array(data3.buffer);
    var tabs = [];
    for (var i = 0; i < gcnt; i++) {
      off = offset2 + goff + offs[i];
      var vcnt = bin.readUshort(data3, off);
      off += 2;
      var snum = vcnt & SHARED_POINT_NUMBERS;
      vcnt &= 4095;
      var soff = bin.readUshort(data3, off);
      off += 2;
      var hdr = readTupleVarHeader(data3, off, vcnt, acnt);
      var tab = [];
      tabs.push(tab);
      off = offset2 + goff + offs[i] + soff;
      var sind = null;
      if (snum) {
        var oo = readPointNumbers(data3, off);
        sind = oo[0];
        off = oo[1];
      }
      for (var j2 = 0; j2 < vcnt; j2++) {
        var vr = hdr[j2], end = off + vr[0];
        var ind = sind;
        if (vr[2] & PRIVATE_POINT_NUMBERS) {
          var oo = readPointNumbers(data3, off);
          ind = oo[0];
          off = oo[1];
        }
        var ds = [];
        while (off < end) {
          var cb = data3[off++];
          var cnt = (cb & 63) + 1;
          if (cb & DELTAS_ARE_ZERO) {
            for (var k = 0; k < cnt; k++) ds.push(0);
          } else if (cb & DELTAS_ARE_WORDS) {
            for (var k = 0; k < cnt; k++) ds.push(bin.readShort(data3, off + k * 2));
            off += cnt * 2;
          } else {
            for (var k = 0; k < cnt; k++) ds.push(i8[off + k]);
            off += cnt;
          }
        }
        var ti = vr[1];
        tab.push([[
          vr[3] ? vr[3] : mins[ti],
          vr[4] ? vr[4] : tups[ti],
          vr[5] ? vr[5] : maxs[ti]
        ], ds, ind.length == 0 ? null : ind]);
        if (ind.length != 0 && ind.length * 2 != ds.length) throw "e";
      }
    }
    return tabs;
  }
  return { parseTab };
}();
Typr["T"].avar = {
  parseTab: function(data3, offset2, length, obj) {
    var off = offset2;
    var bin = Typr["B"], out = [];
    off += 6;
    var acnt = bin.readUshort(data3, off);
    off += 2;
    for (var ai = 0; ai < acnt; ai++) {
      var cnt = bin.readUshort(data3, off);
      off += 2;
      var poly = [];
      out.push(poly);
      for (var i = 0; i < cnt; i++) {
        var x = bin.readF2dot14(data3, off);
        var y = bin.readF2dot14(data3, off + 2);
        off += 4;
        poly.push(x, y);
      }
    }
    return out;
  }
};
Typr["T"].HVAR = {
  parseTab: function(data3, offset2, length, obj) {
    var off = offset2, oo = offset2;
    var bin = Typr["B"];
    off += 4;
    var varO = bin.readUint(data3, off);
    off += 4;
    var advO = bin.readUint(data3, off);
    off += 4;
    var lsbO = bin.readUint(data3, off);
    off += 4;
    var rsbO = bin.readUint(data3, off);
    off += 4;
    if (lsbO != 0 || rsbO != 0) throw lsbO;
    off = oo + varO;
    var ioff = off;
    var fmt = bin.readUshort(data3, off);
    off += 2;
    if (fmt != 1) throw "e";
    var vregO = bin.readUint(data3, off);
    off += 4;
    var vcnt = bin.readUshort(data3, off);
    off += 2;
    var offs = [];
    for (var i = 0; i < vcnt; i++) offs.push(bin.readUint(data3, off + i * 4));
    off += vcnt * 4;
    off = ioff + vregO;
    var acnt = bin.readUshort(data3, off);
    off += 2;
    var rcnt = bin.readUshort(data3, off);
    off += 2;
    var regs = [];
    for (var i = 0; i < rcnt; i++) {
      var crd = [[], [], []];
      regs.push(crd);
      for (var j2 = 0; j2 < acnt; j2++) {
        crd[0].push(bin.readF2dot14(data3, off + 0));
        crd[1].push(bin.readF2dot14(data3, off + 2));
        crd[2].push(bin.readF2dot14(data3, off + 4));
        off += 6;
      }
    }
    var i8 = new Int8Array(data3.buffer);
    var varStore = [];
    for (var i = 0; i < offs.length; i++) {
      off = oo + varO + offs[i];
      var vdata = [];
      varStore.push(vdata);
      var icnt = bin.readUshort(data3, off);
      off += 2;
      var dcnt = bin.readUshort(data3, off);
      off += 2;
      if (dcnt & 32768) throw "e";
      var rcnt = bin.readUshort(data3, off);
      off += 2;
      var ixs = [];
      for (var j2 = 0; j2 < rcnt; j2++) ixs.push(bin.readUshort(data3, off + j2 * 2));
      off += rcnt * 2;
      for (var k = 0; k < icnt; k++) {
        var deltaData = [];
        for (var ri = 0; ri < rcnt; ri++) {
          deltaData.push(ri < dcnt ? bin.readShort(data3, off) : i8[off]);
          off += ri < dcnt ? 2 : 1;
        }
        var dd = new Array(regs.length);
        dd.fill(0);
        vdata.push(dd);
        for (var j2 = 0; j2 < ixs.length; j2++) dd[ixs[j2]] = deltaData[j2];
      }
    }
    off = oo + advO;
    var fmt = data3[off++];
    if (fmt != 0) throw "e";
    var entryFormat = data3[off++];
    var mapCount = bin.readUshort(data3, off);
    off += 2;
    var INNER_INDEX_BIT_COUNT_MASK = 15;
    var MAP_ENTRY_SIZE_MASK = 48;
    var entrySize = ((entryFormat & MAP_ENTRY_SIZE_MASK) >> 4) + 1;
    var dfs = [];
    for (var i = 0; i < mapCount; i++) {
      var entry = 0;
      if (entrySize == 1) entry = data3[off++];
      else {
        entry = bin.readUshort(data3, off);
        off += 2;
      }
      var outerIndex = entry >> (entryFormat & INNER_INDEX_BIT_COUNT_MASK) + 1;
      var innerIndex = entry & (1 << (entryFormat & INNER_INDEX_BIT_COUNT_MASK) + 1) - 1;
      dfs.push(varStore[outerIndex][innerIndex]);
    }
    return [regs, dfs];
  }
};
Typr["U"] = function() {
  var P = {
    MoveTo: function(p2, x, y) {
      p2.cmds.push("M");
      p2.crds.push(x, y);
    },
    LineTo: function(p2, x, y) {
      p2.cmds.push("L");
      p2.crds.push(x, y);
    },
    CurveTo: function(p2, a2, b3, c4, d2, e2, f) {
      p2.cmds.push("C");
      p2.crds.push(a2, b3, c4, d2, e2, f);
    },
    qCurveTo: function(p2, a2, b3, c4, d2) {
      p2.cmds.push("Q");
      p2.crds.push(a2, b3, c4, d2);
    },
    ClosePath: function(p2) {
      p2.cmds.push("Z");
    }
  };
  function getGlyphPosition(font2, gls, i1, ltr) {
    var g1 = gls[i1], g2 = gls[i1 + 1], kern = font2["kern"];
    if (kern) {
      var ind1 = kern.glyph1.indexOf(g1);
      if (ind1 != -1) {
        var ind2 = kern.rval[ind1].glyph2.indexOf(g2);
        if (ind2 != -1) return [0, 0, kern.rval[ind1].vals[ind2], 0];
      }
    }
    return [0, 0, 0, 0];
  }
  function shape2(font2, str, prm) {
    if (prm == null) prm = {};
    prm["ltr"];
    prm["fts"];
    var axs = prm["axs"];
    if (font2["fvar"] && axs == null) axs = font2["fvar"][1][font2["_index"]][2];
    var HVAR = font2["HVAR"];
    if (axs && HVAR) {
      axs = _normalizeAxis(font2, axs);
    }
    var gls = [];
    for (var i2 = 0; i2 < str.length; i2++) {
      var cc = str.codePointAt(i2);
      if (cc > 65535) i2++;
      gls.push(codeToGlyph(font2, cc));
    }
    var shape3 = [];
    for (var i2 = 0; i2 < gls.length; i2++) {
      var padj = getGlyphPosition(font2, gls, i2);
      var gid = gls[i2];
      var ax = font2["hmtx"].aWidth[gid] + padj[2];
      if (HVAR && HVAR[1][gid]) {
        var difs = HVAR[1][gid];
        for (var j2 = 0; j2 < HVAR[0].length; j2++) {
          ax += _interpolate(HVAR[0][j2], axs) * difs[j2];
        }
      }
      shape3.push({ "g": gid, "cl": i2, "dx": 0, "dy": 0, "ax": ax, "ay": 0 });
    }
    return shape3;
  }
  function shapeToPath(font2, shape3, prm) {
    var tpath = { cmds: [], crds: [] };
    var x = 0, y = 0, clr, axs;
    if (prm) {
      clr = prm["clr"];
      axs = prm["axs"];
    }
    for (var i2 = 0; i2 < shape3.length; i2++) {
      var it2 = shape3[i2];
      var path2 = glyphToPath(font2, it2["g"], false, axs), crds = path2["crds"];
      for (var j2 = 0; j2 < crds.length; j2 += 2) {
        tpath.crds.push(crds[j2] + x + it2["dx"]);
        tpath.crds.push(crds[j2 + 1] + y + it2["dy"]);
      }
      if (clr) tpath.cmds.push(clr);
      for (var j2 = 0; j2 < path2["cmds"].length; j2++) tpath.cmds.push(path2["cmds"][j2]);
      var clen = tpath.cmds.length;
      if (clr) {
        if (clen != 0 && tpath.cmds[clen - 1] != "X") tpath.cmds.push("X");
      }
      x += it2["ax"];
      y += it2["ay"];
    }
    return { "cmds": tpath.cmds, "crds": tpath.crds };
  }
  function arrSearch(arr2, k, v) {
    var l = 0, r = ~~(arr2.length / k);
    while (l + 1 != r) {
      var mid = l + (r - l >>> 1);
      if (arr2[mid * k] <= v) l = mid;
      else r = mid;
    }
    return l * k;
  }
  var wha = [9, 10, 11, 12, 13, 32, 133, 160, 5760, 6158, 8232, 8233, 8239, 8288, 12288, 65279], whm = {};
  for (var i = 0; i < wha.length; i++) whm[wha[i]] = 1;
  for (var i = 8192; i <= 8205; i++) whm[i] = 1;
  function codeToGlyph(font2, code) {
    if (font2["_ctab"] == null) {
      var cmap = font2["cmap"];
      var tind = -1, pps = [
        "p3e10",
        "p0e4",
        "p3e1",
        "p1e0",
        "p0e3",
        "p0e1",
        "p3e0",
        "p3e5"
        /*Korean*/
      ];
      for (var i2 = 0; i2 < pps.length; i2++) if (cmap.ids[pps[i2]] != null) {
        tind = cmap.ids[pps[i2]];
        break;
      }
      if (tind == -1) throw "no familiar platform and encoding!";
      font2["_ctab"] = cmap.tables[tind];
    }
    var tab = font2["_ctab"], fmt = tab.format, gid = -1;
    if (fmt == 0) {
      if (code >= tab.map.length) gid = 0;
      else gid = tab.map[code];
    } else if (fmt == 4) {
      var ec = tab.endCount;
      gid = 0;
      if (code <= ec[ec.length - 1]) {
        var sind = arrSearch(ec, 1, code);
        if (ec[sind] < code) sind++;
        if (code >= tab.startCount[sind]) {
          var gli = 0;
          if (tab.idRangeOffset[sind] != 0) gli = tab.glyphIdArray[code - tab.startCount[sind] + (tab.idRangeOffset[sind] >> 1) - (tab.idRangeOffset.length - sind)];
          else gli = code + tab.idDelta[sind];
          gid = gli & 65535;
        }
      }
    } else if (fmt == 6) {
      var off = code - tab.firstCode, arr2 = tab.glyphIdArray;
      if (off < 0 || off >= arr2.length) gid = 0;
      else gid = arr2[off];
    } else if (fmt == 12) {
      var grp = tab.groups;
      gid = 0;
      if (code <= grp[grp.length - 2]) {
        var i2 = arrSearch(grp, 3, code);
        if (grp[i2] <= code && code <= grp[i2 + 1]) {
          gid = grp[i2 + 2] + (code - grp[i2]);
        }
      }
    } else throw "unknown cmap table format " + tab.format;
    var SVG = font2["SVG "], loca = font2["loca"];
    if (gid != 0 && font2["CFF "] == null && (SVG == null || SVG.entries[gid] == null) && loca && loca[gid] == loca[gid + 1] && whm[code] == null) gid = 0;
    return gid;
  }
  function glyphToPath(font2, gid, noColor, axs) {
    var path2 = { cmds: [], crds: [] };
    if (font2["fvar"]) {
      if (axs == null) axs = font2["fvar"][1][font2["_index"]][2];
      axs = _normalizeAxis(font2, axs);
    }
    var SVG = font2["SVG "], CFF = font2["CFF "], COLR = font2["COLR"], CBLC = font2["CBLC"], CBDT = font2["CBDT"], sbix = font2["sbix"], upng = window["UPNG"];
    var strike = null;
    if (CBLC && upng) {
      for (var i2 = 0; i2 < CBLC.length; i2++) if (CBLC[i2][0] <= gid && gid <= CBLC[i2][1]) strike = CBLC[i2];
    }
    if (strike || sbix && sbix[gid]) {
      if (strike && strike[2] != 17) throw "not a PNG";
      if (font2["__tmp"] == null) font2["__tmp"] = {};
      var cmd = font2["__tmp"]["g" + gid];
      if (cmd == null) {
        var bmp, len;
        if (sbix) {
          bmp = sbix[gid];
          len = bmp.length;
        } else {
          var boff = strike[3][gid - strike[0]] + 5;
          len = CBDT[boff + 1] << 16 | CBDT[boff + 2] << 8 | CBDT[boff + 3];
          boff += 4;
          bmp = new Uint8Array(CBDT.buffer, CBDT.byteOffset + boff, len);
        }
        var str = "";
        for (var i2 = 0; i2 < len; i2++) str += String.fromCharCode(bmp[i2]);
        cmd = font2["__tmp"]["g" + gid] = "data:image/png;base64," + btoa(str);
      }
      path2.cmds.push(cmd);
      var upe = font2["head"]["unitsPerEm"] * 1.15;
      var gw = Math.round(upe), gh = Math.round(upe), dy = Math.round(-gh * 0.15);
      path2.crds.push(0, gh + dy, gw, gh + dy, gw, dy, 0, dy);
    } else if (SVG && SVG.entries[gid]) {
      var p2 = SVG.entries[gid];
      if (p2 != null) {
        if (typeof p2 == "number") {
          var svg = SVG.svgs[p2];
          if (typeof svg == "string") {
            var prsr = new DOMParser();
            var doc = prsr["parseFromString"](svg, "image/svg+xml");
            svg = SVG.svgs[p2] = doc.getElementsByTagName("svg")[0];
          }
          p2 = Typr["U"]["SVG"].toPath(svg, gid);
          SVG.entries[gid] = p2;
        }
        path2 = p2;
      }
    } else if (noColor != true && COLR && COLR[0]["g" + gid] && COLR[0]["g" + gid][1] > 1) {
      let toHex = function(n3) {
        var o = n3.toString(16);
        return (o.length == 1 ? "0" : "") + o;
      };
      var CPAL = font2["CPAL"], gl = COLR[0]["g" + gid];
      for (var i2 = 0; i2 < gl[1]; i2++) {
        var lid = gl[0] + i2;
        var cgl = COLR[1][2 * lid], pid = COLR[1][2 * lid + 1] * 4;
        var pth = glyphToPath(font2, cgl, cgl == gid);
        var col = "#" + toHex(CPAL[pid + 2]) + toHex(CPAL[pid + 1]) + toHex(CPAL[pid + 0]);
        path2.cmds.push(col);
        path2.cmds = path2.cmds.concat(pth["cmds"]);
        path2.crds = path2.crds.concat(pth["crds"]);
        path2.cmds.push("X");
      }
    } else if (CFF) {
      var pdct = CFF["Private"];
      var state = { x: 0, y: 0, stack: [], nStems: 0, haveWidth: false, width: pdct ? pdct["defaultWidthX"] : 0, open: false };
      if (CFF["ROS"]) {
        var gi = 0;
        while (CFF["FDSelect"][gi + 2] <= gid) gi += 2;
        pdct = CFF["FDArray"][CFF["FDSelect"][gi + 1]]["Private"];
      }
      _drawCFF(CFF["CharStrings"][gid], state, CFF, pdct, path2);
    } else if (font2["glyf"]) {
      _drawGlyf(gid, font2, path2, axs);
    }
    return { "cmds": path2.cmds, "crds": path2.crds };
  }
  function _drawGlyf(gid, font2, path2, axs) {
    var gl = font2["glyf"][gid];
    if (gl == null) gl = font2["glyf"][gid] = Typr["T"].glyf._parseGlyf(font2, gid);
    if (gl != null) {
      if (gl.noc > -1) _simpleGlyph(gl, font2, gid, path2, axs);
      else _compoGlyph(gl, font2, gid, path2, axs);
    }
  }
  function _interpolate(axs, v) {
    v.length;
    var S2 = 1;
    var s = axs[0];
    var p2 = axs[1];
    var e2 = axs[2];
    for (var i2 = 0; i2 < v.length; i2++) {
      var AS = 1;
      if (s[i2] > p2[i2] || p2[i2] > e2[i2]) AS = 1;
      else if (s[i2] < 0 && e2[i2] > 0 && p2[i2] != 0) AS = 1;
      else if (p2[i2] == 0) AS = 1;
      else if (v[i2] < s[i2] || v[i2] > e2[i2]) AS = 0;
      else {
        if (v[i2] == p2[i2]) AS = 1;
        else if (v[i2] < p2[i2]) AS = (v[i2] - s[i2]) / (p2[i2] - s[i2]);
        else AS = (e2[i2] - v[i2]) / (e2[i2] - p2[i2]);
      }
      S2 = S2 * AS;
    }
    return S2;
  }
  function _normalizeAxis(font2, vv) {
    var fvar = font2["fvar"], avar = font2["avar"];
    var fv = fvar ? fvar[0] : null;
    var nv = [];
    for (var i2 = 0; i2 < fv.length; i2++) {
      var min = fv[i2][1], def = fv[i2][2], max = fv[i2][3], v = Math.max(min, Math.min(max, vv[i2]));
      if (v < def) nv[i2] = (def - v) / (min - def);
      else if (v > def) nv[i2] = (v - def) / (max - def);
      else nv[i2] = 0;
      if (avar && nv[i2] != -1) {
        var av = avar[i2], j2 = 0;
        for (; j2 < av.length; j2 += 2) if (av[j2] >= nv[i2]) break;
        var f = (nv[i2] - av[j2 - 2]) / (av[j2] - av[j2 - 2]);
        nv[i2] = f * av[j2 + 1] + (1 - f) * av[j2 - 1];
      }
    }
    return nv;
  }
  function interpolateDeltas(dfs, ind, xs, ys, endPts) {
    var N = xs.length, ndfs = new Array(N * 2 + 8);
    ndfs.fill(0);
    for (var i2 = 0; i2 < N; i2++) {
      var dx = 0, dy = 0, ii = ind.indexOf(i2);
      if (ii != -1) {
        dx = dfs[ii];
        dy = dfs[ind.length + ii];
      } else {
        var cmp = 0;
        while (endPts[cmp] < i2) cmp++;
        var cmp0 = cmp == 0 ? 0 : endPts[cmp - 1] + 1;
        var cmp1 = endPts[cmp];
        var i0 = -1, i1 = -1;
        for (var j2 = 0; j2 < ind.length; j2++) {
          var v = ind[j2];
          if (v < cmp0 || v > cmp1 || v >= N) continue;
          i0 = j2;
          if (i1 == -1) i1 = j2;
        }
        for (var j2 = 0; j2 < ind.length; j2++) {
          var v = ind[j2];
          if (v < cmp0 || v > cmp1 || v >= N) continue;
          if (v < i2) i0 = j2;
          if (i2 < v) {
            i1 = j2;
            break;
          }
        }
        for (var ax = 0; ax < 2; ax++) {
          var crd = ax == 0 ? xs : ys, ofs = ax * ind.length, dlt = 0;
          var c0 = crd[ind[i0]], c14 = crd[ind[i1]], cC = crd[i2];
          var d02 = dfs[ofs + i0], d1 = dfs[ofs + i1];
          if (c0 == c14) {
            if (d02 == d1) dlt = d02;
            else dlt = 0;
          } else {
            if (cC <= Math.min(c0, c14)) {
              if (c0 < c14) dlt = d02;
              else dlt = d1;
            } else if (Math.max(c0, c14) <= cC) {
              if (c0 < c14) dlt = d1;
              else dlt = d02;
            } else {
              var prop = (cC - c0) / (c14 - c0);
              dlt = prop * d1 + (1 - prop) * d02;
            }
          }
          if (ax == 0) dx = dlt;
          else dy = dlt;
        }
      }
      ndfs[i2] = dx;
      ndfs[N + 4 + i2] = dy;
    }
    return ndfs;
  }
  function _simpleGlyph(gl, font2, gid, p2, axs) {
    var xs = gl.xs, ys = gl.ys;
    if (font2["fvar"] && axs) {
      xs = xs.slice(0);
      ys = ys.slice(0);
      var gvar = font2["gvar"];
      var gv = gvar ? gvar[gid] : null;
      for (var vi = 0; vi < gv.length; vi++) {
        var axv = gv[vi][0];
        var S2 = _interpolate(axv, axs);
        if (S2 < 1e-9) continue;
        var dfs = gv[vi][1], ind = gv[vi][2];
        if (ind) {
          dfs = gv[vi][1] = interpolateDeltas(dfs, ind, xs, ys, gl.endPts);
          gv[vi][2] = null;
        }
        if (dfs.length == xs.length * 2 + 8)
          for (var i2 = 0; i2 < xs.length; i2++) {
            xs[i2] += S2 * dfs[i2];
            ys[i2] += S2 * dfs[i2 + xs.length + 4];
          }
      }
    }
    for (var c4 = 0; c4 < gl.noc; c4++) {
      var i0 = c4 == 0 ? 0 : gl.endPts[c4 - 1] + 1;
      var il = gl.endPts[c4];
      for (var i2 = i0; i2 <= il; i2++) {
        var pr = i2 == i0 ? il : i2 - 1;
        var nx = i2 == il ? i0 : i2 + 1;
        var onCurve = gl.flags[i2] & 1;
        var prOnCurve = gl.flags[pr] & 1;
        var nxOnCurve = gl.flags[nx] & 1;
        var x = xs[i2], y = ys[i2];
        if (i2 == i0) {
          if (onCurve) {
            if (prOnCurve) P.MoveTo(p2, xs[pr], ys[pr]);
            else {
              P.MoveTo(p2, x, y);
              continue;
            }
          } else {
            if (prOnCurve) P.MoveTo(p2, xs[pr], ys[pr]);
            else P.MoveTo(p2, Math.floor((xs[pr] + x) * 0.5), Math.floor((ys[pr] + y) * 0.5));
          }
        }
        if (onCurve) {
          if (prOnCurve) P.LineTo(p2, x, y);
        } else {
          if (nxOnCurve) P.qCurveTo(p2, x, y, xs[nx], ys[nx]);
          else P.qCurveTo(p2, x, y, Math.floor((x + xs[nx]) * 0.5), Math.floor((y + ys[nx]) * 0.5));
        }
      }
      P.ClosePath(p2);
    }
  }
  function _compoGlyph(gl, font2, gid, p2, axs) {
    var dx = [0, 0, 0, 0, 0, 0], dy = [0, 0, 0, 0, 0, 0], ccnt = gl.parts.length;
    if (font2["fvar"] && axs) {
      var gvar = font2["gvar"];
      var gv = gvar ? gvar[gid] : null;
      for (var vi = 0; vi < gv.length; vi++) {
        var axv = gv[vi][0];
        var S2 = _interpolate(axv, axs);
        if (S2 < 1e-6) continue;
        var dfs = gv[vi][1], ind = gv[vi][2];
        if (ind == null)
          for (var i2 = 0; i2 < ccnt; i2++) {
            dx[i2] += S2 * dfs[i2];
            dy[i2] += S2 * dfs[i2 + ccnt + 4];
          }
        else
          for (var j2 = 0; j2 < ind.length; j2++) {
            var i2 = ind[j2];
            dx[i2] += S2 * dfs[0];
            dy[i2] += S2 * dfs[0 + ccnt];
          }
      }
    }
    for (var j2 = 0; j2 < ccnt; j2++) {
      var path2 = { cmds: [], crds: [] };
      var prt = gl.parts[j2];
      _drawGlyf(prt.glyphIndex, font2, path2, axs);
      var m3 = prt.m, tx = m3.tx + dx[j2], ty = m3.ty + dy[j2];
      for (var i2 = 0; i2 < path2.crds.length; i2 += 2) {
        var x = path2.crds[i2], y = path2.crds[i2 + 1];
        p2.crds.push(x * m3.a + y * m3.c + tx);
        p2.crds.push(x * m3.b + y * m3.d + ty);
      }
      for (var i2 = 0; i2 < path2.cmds.length; i2++) p2.cmds.push(path2.cmds[i2]);
    }
  }
  function pathToSVG(path2, prec) {
    var cmds = path2["cmds"], crds = path2["crds"];
    if (prec == null) prec = 5;
    function num(v) {
      return parseFloat(v.toFixed(prec));
    }
    function merge2(o) {
      var no = [], lstF = false, lstC = "";
      for (var i3 = 0; i3 < o.length; i3++) {
        var it2 = o[i3], isF = typeof it2 == "number";
        if (!isF) {
          if (it2 == lstC && it2.length == 1 && it2 != "m") continue;
          lstC = it2;
        }
        if (lstF && isF && it2 >= 0) no.push(" ");
        no.push(it2);
        lstF = isF;
      }
      return no.join("");
    }
    var out = [], co = 0, lmap = { "M": 2, "L": 2, "Q": 4, "C": 6 };
    var x = 0, y = 0, ex = 0, ey = 0, mx = 0, my = 0;
    for (var i2 = 0; i2 < cmds.length; i2++) {
      var cmd = cmds[i2], cc = lmap[cmd] ? lmap[cmd] : 0;
      var o0 = [], dx, dy, rx, ry;
      if (cmd == "L") {
        dx = crds[co] - x;
        dy = crds[co + 1] - y;
        rx = num(dx + ex);
        ry = num(dy + ey);
        if (cmds[i2 + 1] == "Z" && crds[co] == mx && crds[co + 1] == my) {
          rx = dx;
          ry = dy;
        } else if (rx == 0 && ry == 0) ;
        else if (rx == 0) o0.push("v", ry);
        else if (ry == 0) o0.push("h", rx);
        else {
          o0.push("l", rx, ry);
        }
      } else {
        o0.push(cmd.toLowerCase());
        for (var j2 = 0; j2 < cc; j2 += 2) {
          dx = crds[co + j2] - x;
          dy = crds[co + j2 + 1] - y;
          rx = num(dx + ex);
          ry = num(dy + ey);
          o0.push(rx, ry);
        }
      }
      if (cc != 0) {
        ex += dx - rx;
        ey += dy - ry;
      }
      var ou = o0;
      for (var j2 = 0; j2 < ou.length; j2++) out.push(ou[j2]);
      if (cc != 0) {
        co += cc;
        x = crds[co - 2];
        y = crds[co - 1];
      }
      if (cmd == "M") {
        mx = x;
        my = y;
      }
      if (cmd == "Z") {
        x = mx;
        y = my;
      }
    }
    return merge2(out);
  }
  function SVGToPath(d2) {
    var pth = { cmds: [], crds: [] };
    Typr["U"]["SVG"].svgToPath(d2, pth);
    return { "cmds": pth.cmds, "crds": pth.crds };
  }
  function mipmapB(buff, w, h, hlp) {
    var nw = w >> 1, nh = h >> 1;
    var nbuf = new Uint8Array(nw * nh * 4);
    var sb32 = new Uint32Array(buff.buffer), nb32 = new Uint32Array(nbuf.buffer);
    for (var y = 0; y < nh; y++)
      for (var x = 0; x < nw; x++) {
        var ti = y * nw + x, si = (y << 1) * w + (x << 1);
        var c0 = sb32[si], c14 = sb32[si + 1], c24 = sb32[si + w], c34 = sb32[si + w + 1];
        var a0 = c0 >>> 24, a1 = c14 >>> 24, a2 = c24 >>> 24, a3 = c34 >>> 24, a4 = a0 + a1 + a2 + a3;
        if (a4 == 1020) {
          var r = (c0 >>> 0 & 255) + (c14 >>> 0 & 255) + (c24 >>> 0 & 255) + (c34 >>> 0 & 255) + 2 >>> 2;
          var g2 = (c0 >>> 8 & 255) + (c14 >>> 8 & 255) + (c24 >>> 8 & 255) + (c34 >>> 8 & 255) + 2 >>> 2;
          var b3 = (c0 >>> 16 & 255) + (c14 >>> 16 & 255) + (c24 >>> 16 & 255) + (c34 >>> 16 & 255) + 2 >>> 2;
          nb32[ti] = 255 << 24 | b3 << 16 | g2 << 8 | r;
        } else if (a4 == 0) nb32[ti] = 0;
        else {
          var r = (c0 >>> 0 & 255) * a0 + (c14 >>> 0 & 255) * a1 + (c24 >>> 0 & 255) * a2 + (c34 >>> 0 & 255) * a3;
          var g2 = (c0 >>> 8 & 255) * a0 + (c14 >>> 8 & 255) * a1 + (c24 >>> 8 & 255) * a2 + (c34 >>> 8 & 255) * a3;
          var b3 = (c0 >>> 16 & 255) * a0 + (c14 >>> 16 & 255) * a1 + (c24 >>> 16 & 255) * a2 + (c34 >>> 16 & 255) * a3;
          var ia = 1 / a4;
          r = ~~(r * ia + 0.5);
          g2 = ~~(g2 * ia + 0.5);
          b3 = ~~(b3 * ia + 0.5);
          nb32[ti] = a4 + 2 >>> 2 << 24 | b3 << 16 | g2 << 8 | r;
        }
      }
    return { buff: nbuf, w: nw, h: nh };
  }
  var __cnv, __ct;
  function pathToContext(path2, ctx) {
    var c4 = 0, cmds = path2["cmds"], crds = path2["crds"];
    for (var j2 = 0; j2 < cmds.length; j2++) {
      var cmd = cmds[j2];
      if (cmd == "M") {
        ctx.moveTo(crds[c4], crds[c4 + 1]);
        c4 += 2;
      } else if (cmd == "L") {
        ctx.lineTo(crds[c4], crds[c4 + 1]);
        c4 += 2;
      } else if (cmd == "C") {
        ctx.bezierCurveTo(crds[c4], crds[c4 + 1], crds[c4 + 2], crds[c4 + 3], crds[c4 + 4], crds[c4 + 5]);
        c4 += 6;
      } else if (cmd == "Q") {
        ctx.quadraticCurveTo(crds[c4], crds[c4 + 1], crds[c4 + 2], crds[c4 + 3]);
        c4 += 4;
      } else if (cmd[0] == "d") {
        var upng = window["UPNG"];
        var x0 = crds[c4], y0 = crds[c4 + 1], x1 = crds[c4 + 2], y1 = crds[c4 + 3], x2 = crds[c4 + 4], y2 = crds[c4 + 5], x3 = crds[c4 + 6], y3 = crds[c4 + 7];
        c4 += 8;
        if (upng == null) {
          ctx.moveTo(x0, y0);
          ctx.lineTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.lineTo(x3, y3);
          ctx.closePath();
          continue;
        }
        var dx0 = x1 - x0, dy0 = y1 - y0, dx1 = x3 - x0, dy1 = y3 - y0;
        var sbmp = atob(cmd.slice(22));
        var bmp = new Uint8Array(sbmp.length);
        for (var i2 = 0; i2 < sbmp.length; i2++) bmp[i2] = sbmp.charCodeAt(i2);
        var img = upng["decode"](bmp.buffer), w = img["width"], h = img["height"];
        var nbmp = new Uint8Array(upng["toRGBA8"](img)[0]);
        var tr = ctx["getTransform"]();
        var scl = Math.sqrt(Math.abs(tr["a"] * tr["d"] - tr["b"] * tr["c"])) * Math.sqrt(dx1 * dx1 + dy1 * dy1) / h;
        while (scl < 0.5) {
          var nd = mipmapB(nbmp, w, h);
          nbmp = nd.buff;
          w = nd.w;
          h = nd.h;
          scl *= 2;
        }
        if (__cnv == null) {
          __cnv = document.createElement("canvas");
          __ct = __cnv.getContext("2d");
        }
        if (__cnv.width != w || __cnv.height != h) {
          __cnv.width = w;
          __cnv.height = h;
        }
        __ct.putImageData(new ImageData(new Uint8ClampedArray(nbmp.buffer), w, h), 0, 0);
        ctx.save();
        ctx.transform(dx0, dy0, dx1, dy1, x0, y0);
        ctx.scale(1 / w, 1 / h);
        ctx.drawImage(__cnv, 0, 0);
        ctx.restore();
      } else if (cmd.charAt(0) == "#" || cmd.charAt(0) == "r") {
        ctx.beginPath();
        ctx.fillStyle = cmd;
      } else if (cmd.charAt(0) == "O" && cmd != "OX") {
        ctx.beginPath();
        var pts = cmd.split("-");
        ctx.lineWidth = parseFloat(pts[2]);
        ctx.lineCap = ["butt", "round", "square"][parseFloat(pts[3])];
        ctx.lineJoin = ["miter", "round", "bevel"][parseFloat(pts[4])];
        ctx.miterLimit = parseFloat(pts[5]);
        ctx.lineDashOffset = parseFloat(pts[6]);
        ctx.setLineDash(pts[7].split(",").map(parseFloat));
        ctx.strokeStyle = pts[1];
      } else if (cmd == "Z") {
        ctx.closePath();
      } else if (cmd == "X") {
        ctx.fill();
      } else if (cmd == "OX") {
        ctx.stroke();
      }
    }
  }
  function _drawCFF(cmds, state, font2, pdct, p2) {
    var stack = state.stack;
    var nStems = state.nStems, haveWidth = state.haveWidth, width = state.width, open = state.open;
    var i2 = 0;
    var x = state.x, y = state.y, c1x = 0, c1y = 0, c2x = 0, c2y = 0, c3x = 0, c3y = 0, c4x = 0, c4y = 0, jpx = 0, jpy = 0;
    var CFF = Typr["T"].CFF;
    var nominalWidthX = pdct["nominalWidthX"];
    var o = { val: 0, size: 0 };
    while (i2 < cmds.length) {
      CFF.getCharString(cmds, i2, o);
      var v = o.val;
      i2 += o.size;
      if (v == "o1" || v == "o18") {
        var hasWidthArg;
        hasWidthArg = stack.length % 2 !== 0;
        if (hasWidthArg && !haveWidth) {
          width = stack.shift() + nominalWidthX;
        }
        nStems += stack.length >> 1;
        stack.length = 0;
        haveWidth = true;
      } else if (v == "o3" || v == "o23") {
        var hasWidthArg;
        hasWidthArg = stack.length % 2 !== 0;
        if (hasWidthArg && !haveWidth) {
          width = stack.shift() + nominalWidthX;
        }
        nStems += stack.length >> 1;
        stack.length = 0;
        haveWidth = true;
      } else if (v == "o4") {
        if (stack.length > 1 && !haveWidth) {
          width = stack.shift() + nominalWidthX;
          haveWidth = true;
        }
        if (open) P.ClosePath(p2);
        y += stack.pop();
        P.MoveTo(p2, x, y);
        open = true;
      } else if (v == "o5") {
        while (stack.length > 0) {
          x += stack.shift();
          y += stack.shift();
          P.LineTo(p2, x, y);
        }
      } else if (v == "o6" || v == "o7") {
        var count = stack.length;
        var isX = v == "o6";
        for (var j2 = 0; j2 < count; j2++) {
          var sval = stack.shift();
          if (isX) x += sval;
          else y += sval;
          isX = !isX;
          P.LineTo(p2, x, y);
        }
      } else if (v == "o8" || v == "o24") {
        var count = stack.length;
        var index = 0;
        while (index + 6 <= count) {
          c1x = x + stack.shift();
          c1y = y + stack.shift();
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          x = c2x + stack.shift();
          y = c2y + stack.shift();
          P.CurveTo(p2, c1x, c1y, c2x, c2y, x, y);
          index += 6;
        }
        if (v == "o24") {
          x += stack.shift();
          y += stack.shift();
          P.LineTo(p2, x, y);
        }
      } else if (v == "o11") break;
      else if (v == "o1234" || v == "o1235" || v == "o1236" || v == "o1237") {
        if (v == "o1234") {
          c1x = x + stack.shift();
          c1y = y;
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          jpx = c2x + stack.shift();
          jpy = c2y;
          c3x = jpx + stack.shift();
          c3y = c2y;
          c4x = c3x + stack.shift();
          c4y = y;
          x = c4x + stack.shift();
          P.CurveTo(p2, c1x, c1y, c2x, c2y, jpx, jpy);
          P.CurveTo(p2, c3x, c3y, c4x, c4y, x, y);
        }
        if (v == "o1235") {
          c1x = x + stack.shift();
          c1y = y + stack.shift();
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          jpx = c2x + stack.shift();
          jpy = c2y + stack.shift();
          c3x = jpx + stack.shift();
          c3y = jpy + stack.shift();
          c4x = c3x + stack.shift();
          c4y = c3y + stack.shift();
          x = c4x + stack.shift();
          y = c4y + stack.shift();
          stack.shift();
          P.CurveTo(p2, c1x, c1y, c2x, c2y, jpx, jpy);
          P.CurveTo(p2, c3x, c3y, c4x, c4y, x, y);
        }
        if (v == "o1236") {
          c1x = x + stack.shift();
          c1y = y + stack.shift();
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          jpx = c2x + stack.shift();
          jpy = c2y;
          c3x = jpx + stack.shift();
          c3y = c2y;
          c4x = c3x + stack.shift();
          c4y = c3y + stack.shift();
          x = c4x + stack.shift();
          P.CurveTo(p2, c1x, c1y, c2x, c2y, jpx, jpy);
          P.CurveTo(p2, c3x, c3y, c4x, c4y, x, y);
        }
        if (v == "o1237") {
          c1x = x + stack.shift();
          c1y = y + stack.shift();
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          jpx = c2x + stack.shift();
          jpy = c2y + stack.shift();
          c3x = jpx + stack.shift();
          c3y = jpy + stack.shift();
          c4x = c3x + stack.shift();
          c4y = c3y + stack.shift();
          if (Math.abs(c4x - x) > Math.abs(c4y - y)) {
            x = c4x + stack.shift();
          } else {
            y = c4y + stack.shift();
          }
          P.CurveTo(p2, c1x, c1y, c2x, c2y, jpx, jpy);
          P.CurveTo(p2, c3x, c3y, c4x, c4y, x, y);
        }
      } else if (v == "o14") {
        if (stack.length > 0 && stack.length != 4 && !haveWidth) {
          width = stack.shift() + font2["nominalWidthX"];
          haveWidth = true;
        }
        if (stack.length == 4) {
          var adx = stack.shift();
          var ady = stack.shift();
          var bchar = stack.shift();
          var achar = stack.shift();
          var bind = CFF.glyphBySE(font2, bchar);
          var aind = CFF.glyphBySE(font2, achar);
          _drawCFF(font2["CharStrings"][bind], state, font2, pdct, p2);
          state.x = adx;
          state.y = ady;
          _drawCFF(font2["CharStrings"][aind], state, font2, pdct, p2);
        }
        if (open) {
          P.ClosePath(p2);
          open = false;
        }
      } else if (v == "o19" || v == "o20") {
        var hasWidthArg;
        hasWidthArg = stack.length % 2 !== 0;
        if (hasWidthArg && !haveWidth) {
          width = stack.shift() + nominalWidthX;
        }
        nStems += stack.length >> 1;
        stack.length = 0;
        haveWidth = true;
        i2 += nStems + 7 >> 3;
      } else if (v == "o21") {
        if (stack.length > 2 && !haveWidth) {
          width = stack.shift() + nominalWidthX;
          haveWidth = true;
        }
        y += stack.pop();
        x += stack.pop();
        if (open) P.ClosePath(p2);
        P.MoveTo(p2, x, y);
        open = true;
      } else if (v == "o22") {
        if (stack.length > 1 && !haveWidth) {
          width = stack.shift() + nominalWidthX;
          haveWidth = true;
        }
        x += stack.pop();
        if (open) P.ClosePath(p2);
        P.MoveTo(p2, x, y);
        open = true;
      } else if (v == "o25") {
        while (stack.length > 6) {
          x += stack.shift();
          y += stack.shift();
          P.LineTo(p2, x, y);
        }
        c1x = x + stack.shift();
        c1y = y + stack.shift();
        c2x = c1x + stack.shift();
        c2y = c1y + stack.shift();
        x = c2x + stack.shift();
        y = c2y + stack.shift();
        P.CurveTo(p2, c1x, c1y, c2x, c2y, x, y);
      } else if (v == "o26") {
        if (stack.length % 2) {
          x += stack.shift();
        }
        while (stack.length > 0) {
          c1x = x;
          c1y = y + stack.shift();
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          x = c2x;
          y = c2y + stack.shift();
          P.CurveTo(p2, c1x, c1y, c2x, c2y, x, y);
        }
      } else if (v == "o27") {
        if (stack.length % 2) {
          y += stack.shift();
        }
        while (stack.length > 0) {
          c1x = x + stack.shift();
          c1y = y;
          c2x = c1x + stack.shift();
          c2y = c1y + stack.shift();
          x = c2x + stack.shift();
          y = c2y;
          P.CurveTo(p2, c1x, c1y, c2x, c2y, x, y);
        }
      } else if (v == "o10" || v == "o29") {
        var obj = v == "o10" ? pdct : font2;
        if (stack.length == 0) {
          console.log("error: empty stack");
        } else {
          var ind = stack.pop();
          var subr = obj["Subrs"][ind + obj["Bias"]];
          state.x = x;
          state.y = y;
          state.nStems = nStems;
          state.haveWidth = haveWidth;
          state.width = width;
          state.open = open;
          _drawCFF(subr, state, font2, pdct, p2);
          x = state.x;
          y = state.y;
          nStems = state.nStems;
          haveWidth = state.haveWidth;
          width = state.width;
          open = state.open;
        }
      } else if (v == "o30" || v == "o31") {
        var count, count1 = stack.length;
        var index = 0;
        var alternate = v == "o31";
        count = count1 & -3;
        index += count1 - count;
        while (index < count) {
          if (alternate) {
            c1x = x + stack.shift();
            c1y = y;
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            y = c2y + stack.shift();
            if (count - index == 5) {
              x = c2x + stack.shift();
              index++;
            } else x = c2x;
            alternate = false;
          } else {
            c1x = x;
            c1y = y + stack.shift();
            c2x = c1x + stack.shift();
            c2y = c1y + stack.shift();
            x = c2x + stack.shift();
            if (count - index == 5) {
              y = c2y + stack.shift();
              index++;
            } else y = c2y;
            alternate = true;
          }
          P.CurveTo(p2, c1x, c1y, c2x, c2y, x, y);
          index += 4;
        }
      } else if ((v + "").charAt(0) == "o") {
        console.log("Unknown operation: " + v, cmds);
        throw v;
      } else stack.push(v);
    }
    state.x = x;
    state.y = y;
    state.nStems = nStems;
    state.haveWidth = haveWidth;
    state.width = width;
    state.open = open;
  }
  function initHB(hurl, resp) {
    var codeLength = function(code) {
      var len = 0;
      if ((code & 4294967295 - (1 << 7) + 1) == 0) {
        len = 1;
      } else if ((code & 4294967295 - (1 << 11) + 1) == 0) {
        len = 2;
      } else if ((code & 4294967295 - (1 << 16) + 1) == 0) {
        len = 3;
      } else if ((code & 4294967295 - (1 << 21) + 1) == 0) {
        len = 4;
      }
      return len;
    };
    fetch(hurl).then(function(x) {
      return x["arrayBuffer"]();
    }).then(function(ab) {
      return WebAssembly["instantiate"](ab);
    }).then(function(res) {
      console.log("HB ready");
      var exp = res["instance"]["exports"], mem = exp["memory"];
      var heapu8, u32, i32, f32;
      var __lastFnt, blob, blobPtr, face, font2;
      Typr["U"]["shapeHB"] = /* @__PURE__ */ function() {
        var toJson = function(ptr) {
          var length = exp["hb_buffer_get_length"](ptr);
          var result = [];
          var iPtr32 = exp["hb_buffer_get_glyph_infos"](ptr, 0) >>> 2;
          var pPtr32 = exp["hb_buffer_get_glyph_positions"](ptr, 0) >>> 2;
          for (var i2 = 0; i2 < length; ++i2) {
            var a2 = iPtr32 + i2 * 5, b3 = pPtr32 + i2 * 5;
            result.push({
              "g": u32[a2 + 0],
              "cl": u32[a2 + 2],
              "ax": i32[b3 + 0],
              "ay": i32[b3 + 1],
              "dx": i32[b3 + 2],
              "dy": i32[b3 + 3]
            });
          }
          return result;
        };
        var te;
        return function(fnt, str, prm) {
          var fdata = fnt["_data"], fn2 = fnt["name"]["postScriptName"];
          var ltr = prm["ltr"], fts = prm["fts"], axs = prm["axs"];
          if (fnt["fvar"] && axs == null) axs = fnt["fvar"][1][fnt["_index"]][2];
          heapu8 = new Uint8Array(mem.buffer);
          u32 = new Uint32Array(mem.buffer);
          i32 = new Int32Array(mem.buffer);
          f32 = new Float32Array(mem.buffer);
          if (__lastFnt != fn2) {
            if (blob != null) {
              exp["hb_blob_destroy"](blob);
              exp["free"](blobPtr);
              exp["hb_face_destroy"](face);
              exp["hb_font_destroy"](font2);
            }
            blobPtr = exp["malloc"](fdata.byteLength);
            heapu8.set(fdata, blobPtr);
            blob = exp["hb_blob_create"](blobPtr, fdata.byteLength, 2, 0, 0);
            face = exp["hb_face_create"](blob, fnt["_index"]);
            font2 = exp["hb_font_create"](face);
            __lastFnt = fn2;
          }
          if (window["TextEncoder"] == null) {
            alert("Your browser is too old. Please, update it.");
            return;
          }
          if (te == null) te = new window["TextEncoder"]("utf8");
          var buffer = exp["hb_buffer_create"]();
          var bytes = te["encode"](str);
          var len = bytes.length, strp = exp["malloc"](len);
          heapu8.set(bytes, strp);
          exp["hb_buffer_add_utf8"](buffer, strp, len, 0, len);
          exp["free"](strp);
          var bin = Typr["B"];
          var feat = 0;
          if (fts) {
            feat = exp["malloc"](16 * fts.length);
            for (var i2 = 0; i2 < fts.length; i2++) {
              var fe = fts[i2];
              var off = feat + i2 * 16, qo = off >>> 2;
              bin.writeASCII(heapu8, off, fe[0].split("").reverse().join(""));
              u32[qo + 1] = fe[1];
              u32[qo + 2] = fe[2];
              u32[qo + 3] = fe[3];
            }
          }
          var vdat = 0;
          if (axs && fnt["fvar"]) {
            var axes = fnt["fvar"][0];
            vdat = exp["malloc"](8 * axs.length);
            for (var i2 = 0; i2 < axs.length; i2++) {
              var off = vdat + i2 * 8, qo = off >>> 2;
              bin.writeASCII(heapu8, off, axes[i2][0].split("").reverse().join(""));
              f32[qo + 1] = axs[i2];
            }
          }
          if (axs) exp["hb_font_set_variations"](font2, vdat, axs.length);
          exp["hb_buffer_set_direction"](buffer, ltr ? 4 : 5);
          exp["hb_buffer_guess_segment_properties"](buffer);
          exp["hb_shape"](font2, buffer, feat, fts ? fts.length : 0);
          var json2 = toJson(buffer);
          exp["hb_buffer_destroy"](buffer);
          if (fts) exp["free"](feat);
          if (axs) exp["free"](vdat);
          var arr2 = json2.slice(0);
          if (!ltr) arr2.reverse();
          var ci = 0, bi = 0;
          for (var i2 = 1; i2 < arr2.length; i2++) {
            var gl = arr2[i2], cl = gl["cl"];
            while (true) {
              var cpt = str.codePointAt(ci), cln = codeLength(cpt);
              if (bi + cln <= cl) {
                bi += cln;
                ci += cpt <= 65535 ? 1 : 2;
              } else break;
            }
            gl["cl"] = ci;
          }
          return json2;
        };
      }();
      resp();
    });
  }
  return { "shape": shape2, "shapeToPath": shapeToPath, "codeToGlyph": codeToGlyph, "glyphToPath": glyphToPath, "pathToSVG": pathToSVG, "SVGToPath": SVGToPath, "pathToContext": pathToContext, "initHB": initHB };
}();

// node_modules/p5/dist/type/p5.Font.js
var import_bezier_path = __toESM(require_bezier_path());
var import_file_saver12 = __toESM(require_FileSaver());
var pathArgCounts = { M: 2, L: 2, C: 6, Q: 4 };
var validFontTypes = ["ttf", "otf", "woff"];
var validFontTypesRe = new RegExp(`\\.(${validFontTypes.join("|")})`, "i");
var extractFontNameRe = new RegExp(`([^/]+)(\\.(?:${validFontTypes.join("|")}))`, "i");
var invalidFontError = "Sorry, only TTF, OTF and WOFF files are supported.";
var fontFaceVariations = ["weight", "stretch", "style"];
var Font = class {
  constructor(p2, fontFace, name, path2, data3) {
    if (!(fontFace instanceof FontFace)) {
      throw Error("FontFace is required");
    }
    this._pInst = p2;
    this.name = name;
    this.path = path2;
    this.data = data3;
    this.face = fontFace;
  }
  /**
   * Checks whether a font has glyph point data and
   * can thus be used for textToPoints(), WEBGL mode, etc.
   * @private
   */
  static hasGlyphData(textFont) {
    let { font: font2 } = textFont;
    return typeof font2 === "object" && typeof font2.data !== "undefined";
  }
  fontBounds(str, x, y, width, height, options2) {
    var _a2;
    ({ width, height, options: options2 } = this._parseArgs(width, height, options2));
    let renderer2 = ((_a2 = options2 == null ? void 0 : options2.graphics) == null ? void 0 : _a2._renderer) || this._pInst._renderer;
    if (!renderer2) throw Error("p5 or graphics required for fontBounds()");
    return renderer2.fontBounds(str, x, y, width, height);
  }
  textBounds(str, x, y, width, height, options2) {
    var _a2;
    ({ width, height, options: options2 } = this._parseArgs(width, height, options2));
    let renderer2 = ((_a2 = options2 == null ? void 0 : options2.graphics) == null ? void 0 : _a2._renderer) || this._pInst._renderer;
    if (!renderer2) throw Error("p5 or graphics required for fontBounds()");
    return renderer2.textBounds(str, x, y, width, height);
  }
  /**
   * Returns a flat array of path commands that describe the outlines of a string of text.
   *
   * Each command is represented as an array of the form `[type, ...coords]`, where:
   * - `type` is one of `'M'`, `'L'`, `'Q'`, `'C'`, or `'Z'`,
   * - `coords` are the numeric values needed for that command.
   *
   * `'M'` indicates a "move to" (starting a new contour),
   * `'L'` a line segment,
   * `'Q'` a quadratic bezier,
   * `'C'` a cubic bezier, and
   * `'Z'` closes the current path.
   *
   * The first two parameters, `x` and `y`, specify the baseline origin for the text.
   * Optionally, you can provide a `width` and `height` for text wrapping; if you don't need
   * wrapping, you can omit them and directly pass `options` as the fourth parameter.
   *
   * @param  {String} str            The text to convert into path commands.
   * @param  {Number} x              x‐coordinate of the text baseline.
   * @param  {Number} y              y‐coordinate of the text baseline.
   * @param  {Number} [width]        Optional width for text wrapping.
   * @param  {Number} [height]       Optional height for text wrapping.
   * @param  {Object} [options]      Configuration object for rendering text.
   * @return {Array<Array>}          A flat array of path commands.
   *
   * @example
   * <div>
   * <code>
   * let font;
   *
   * async function setup() {
   *   font = await loadFont('assets/inconsolata.otf');
   *   createCanvas(200, 200);
   *   background(220);
   *   noLoop();
   * }
   *
   * function draw() {
   *   background(220);
   *   stroke(0);
   *   noFill();
   *   textSize(60);
   *
   *   // Get path commands for "Hello" (drawn at baseline x=50, y=100):
   *   const pathCommands = font.textToPaths('Hello', 30, 110);
   *
   *   beginShape();
   *   for (let i = 0; i < pathCommands.length; i++) {
   *     const cmd = pathCommands[i];
   *     const type = cmd[0];
   *
   *     switch (type) {
   *       case 'M': {
   *         // Move to (start a new contour)
   *         const x = cmd[1];
   *         const y = cmd[2];
   *         endContour(); // In case we were already drawing
   *         beginContour();
   *         vertex(x, y);
   *         break;
   *       }
   *       case 'L': {
   *         // Line to
   *         const x = cmd[1];
   *         const y = cmd[2];
   *         vertex(x, y);
   *         break;
   *       }
   *       case 'Q': {
   *         // Quadratic bezier
   *         const cx = cmd[1];
   *         const cy = cmd[2];
   *         const x = cmd[3];
   *         const y = cmd[4];
   *         bezierOrder(2);
   *         bezierVertex(cx, cy);
   *         bezierVertex(x, y);
   *         break;
   *       }
   *       case 'C': {
   *         // Cubic bezier
   *         const cx1 = cmd[1];
   *         const cy1 = cmd[2];
   *         const cx2 = cmd[3];
   *         const cy2 = cmd[4];
   *         const x = cmd[5];
   *         const y = cmd[6];
   *         bezierOrder(3);
   *         bezierVertex(cx1, cy1);
   *         bezierVertex(cx2, cy2);
   *         bezierVertex(x, y);
   *         break;
   *       }
   *       case 'Z': {
   *         // Close path
   *         endContour(CLOSE);
   *         beginContour();
   *         break;
   *       }
   *     }
   *   }
   *   endContour();
   *   endShape();
   * }
   * </code>
   * </div>
   */
  textToPaths(str, x, y, width, height, options2) {
    ({ width, height, options: options2 } = this._parseArgs(width, height, options2));
    if (!this.data) {
      throw Error('No font data available for "' + this.name + '"\nTry downloading a local copy of the font file');
    }
    let lines = this._lineateAndPathify(str, x, y, width, height, options2);
    let glyphs = lines.map((o) => o.glyphs).flat();
    return glyphs.map((g2) => g2.path.commands).flat();
  }
  /**
   * Returns an array of points outlining a string of text written using the
   * font.
   *
   * Each point object in the array has three properties that describe the
   * point's location and orientation, called its path angle. For example,
   * `{ x: 10, y: 20, alpha: 450 }`.
   *
   * The first parameter, `str`, is a string of text. The second and third
   * parameters, `x` and `y`, are the text's position. By default, they set the
   * coordinates of the bounding box's bottom-left corner. See
   * <a href="#/p5/textAlign">textAlign()</a> for more ways to align text.
   *
   * The fourth parameter, `options`, is also optional. `font.textToPoints()`
   * expects an object with the following properties:
   *
   * `sampleFactor` is the ratio of the text's path length to the number of
   * samples. It defaults to 0.1. Higher values produce more points along the
   * path and are more precise.
   *
   * `simplifyThreshold` removes collinear points if it's set to a number other
   * than 0. The value represents the threshold angle to use when determining
   * whether two edges are collinear.
   *
   * @param  {String} str        string of text.
   * @param  {Number} x          x-coordinate of the text.
   * @param  {Number} y          y-coordinate of the text.
   * @param  {Object} [options]  object with sampleFactor and simplifyThreshold
   *                             properties.
   * @return {Array<Object>} array of point objects, each with `x`, `y`, and `alpha` (path angle) properties.
   *
   * @example
   * <div>
   * <code>
   * let font;
   *
   * async function setup() {
   *   createCanvas(100, 100);
   *   font = await loadFont('assets/inconsolata.otf');
   *
   *   background(200);
   *   textSize(35);
   *
   *   // Get the point array.
   *   let points = font.textToPoints('p5*js', 6, 60, { sampleFactor: 0.5 });
   *
   *   // Draw a dot at each point.
   *   for (let p of points) {
   *     point(p.x, p.y);
   *   }
   *
   *   describe('A set of black dots outlining the text "p5*js" on a gray background.');
   * }
   * </code>
   * </div>
   */
  textToPoints(str, x, y, width, height, options2) {
    const contourPoints = this.textToContours(str, x, y, width, height, options2);
    return contourPoints.reduce((acc, next) => {
      acc.push(...next);
      return acc;
    }, []);
  }
  /**
   * Returns an array of arrays of points outlining a string of text written using the
   * font. Each array represents a contour, so the letter O will have two outer arrays:
   * one for the outer edge of the shape, and one for the inner edge of the hole.
   *
   * Each point object in a contour array has three properties that describe the
   * point's location and orientation, called its path angle. For example,
   * `{ x: 10, y: 20, alpha: 450 }`.
   *
   * The first parameter, `str`, is a string of text. The second and third
   * parameters, `x` and `y`, are the text's position. By default, they set the
   * coordinates of the bounding box's bottom-left corner. See
   * <a href="#/p5/textAlign">textAlign()</a> for more ways to align text.
   *
   * The fourth parameter, `options`, is also optional. `font.textToPoints()`
   * expects an object with the following properties:
   *
   * `sampleFactor` is the ratio of the text's path length to the number of
   * samples. It defaults to 0.1. Higher values produce more points along the
   * path and are more precise.
   *
   * `simplifyThreshold` removes collinear points if it's set to a number other
   * than 0. The value represents the threshold angle to use when determining
   * whether two edges are collinear.
   *
   * @param  {String} str        string of text.
   * @param  {Number} x          x-coordinate of the text.
   * @param  {Number} y          y-coordinate of the text.
   * @param  {Object} [options]  object with sampleFactor and simplifyThreshold
   *                             properties.
   * @return {Array<Array<Object>>} array of point objects, each with `x`, `y`, and `alpha` (path angle) properties.
   *
   * @example
   * <div>
   * <code>
   * let font;
   *
   * async function setup() {
   *   createCanvas(100, 100);
   *   font = await loadFont('/assets/inconsolata.otf');
   * }
   *
   * function draw() {
   *   background(200);
   *   textAlign(CENTER, CENTER);
   *   textSize(30);
   *
   *   // Get the point array.
   *   let contours = font.textToContours('p5*js', width/2, height/2, { sampleFactor: 0.5 });
   *
   *   beginShape();
   *   for (const pts of contours) {
   *     beginContour();
   *     for (const pt of pts) {
   *       vertex(pt.x + 5*sin(pt.y*0.1 + millis()*0.01), pt.y);
   *     }
   *     endContour(CLOSE);
   *   }
   *   endShape();
   *
   *   describe('The text p5*js wobbling over time');
   * }
   * </code>
   * </div>
   */
  textToContours(str, x = 0, y = 0, width, height, options2) {
    ({ width, height, options: options2 } = this._parseArgs(width, height, options2));
    const cmds = this.textToPaths(str, x, y, width, height, options2);
    const cmdContours = [];
    for (const cmd of cmds) {
      if (cmd[0] === "M") {
        cmdContours.push([]);
      }
      cmdContours[cmdContours.length - 1].push(cmd);
    }
    return cmdContours.map((commands) => pathToPoints(commands, options2, this));
  }
  /**
      *
      * Converts text into a 3D model that can be rendered in WebGL mode.
      *
      * This method transforms flat text into extruded 3D geometry, allowing
      * for dynamic effects like depth, warping, and custom shading.
      *
      * It works by taking the outlines (contours) of each character in the
      * provided text string and constructing a 3D shape from them.
      *
      * Once your 3D text is ready, you can rotate it in 3D space using <a href="#/p5/orbitControl">orbitControl()</a>
      * — just click and drag with your mouse to see it from all angles!
      *
      * Use the extrude slider to give your letters depth: slide it up, and your
      * flat text turns into a solid, multi-dimensional object.
      *
      * You can also choose from various fonts such as "Anton", "Montserrat", or "Source Serif",
      * much like selecting fancy fonts in a word processor,
      *
      * The generated model (a Geometry object) can be manipulated further—rotated, scaled,
      * or styled with shaders—to create engaging, interactive visual art.
      *
      * @param {String} str The text string to convert into a 3D model.
      * @param {Number} x The x-coordinate for the starting position of the text.
      * @param {Number} y The y-coordinate for the starting position of the text.
      * @param {Number} width Maximum width of the text block (wraps text if exceeded).
      * @param {Number} height Maximum height of the text block.
      * @param {Object} [options] Configuration options for the 3D text:
      * @param {Number} [options.extrude=0] The depth to extrude the text. A value of 0 produces
      * flat text; higher values create thicker, 3D models.
      * @param {Number} [options.sampleFactor=1] A factor controlling the level of detail for the text contours.
      *  Higher values result in smoother curves.
      * @return {p5.Geometry} A geometry object representing the 3D model of the text.
      *
      * @example
      * <div modernizr='webgl'>
      * <code>
      * let font;
      * let geom;
      *
      * async function setup() {
      *   createCanvas(200, 200, WEBGL);
      *   font = await loadFont('https://fonts.gstatic.com/s/anton/v25/1Ptgg87LROyAm0K08i4gS7lu.ttf');
      *
      *   geom = font.textToModel("Hello", 50, 0, { sampleFactor: 2 });
      *   geom.clearColors();
      *   geom.normalize();
      * }
      *
      * function draw() {
      *   background(255);
      *   orbitControl();
      *   fill("red");
      *   strokeWeight(4);
      *   scale(min(width, height) / 300);
      *   model(geom);
      *   describe('A red non-extruded "Hello" in Anton on white canvas, rotatable via mouse.');
      * }
      * </code>
      * </div>
      *
      * @example
      * <div modernizr='webgl'>
      * <code>
      * let font;
      * let geom;
      *
      * async function setup() {
      *   createCanvas(200, 200, WEBGL);
      *
      *   // Alternative fonts:
      *   // Anton: 'https://fonts.gstatic.com/s/anton/v25/1Ptgg87LROyAm0K08i4gS7lu.ttf'
      *   // Montserrat: 'https://fonts.gstatic.com/s/montserrat/v29/JTUHjIg1_i6t8kCHKm4532VJOt5-QNFgpCtr6Ew-Y3tcoqK5.ttf'
      *   // Source Serif: 'https://fonts.gstatic.com/s/sourceserif4/v8/vEFy2_tTDB4M7-auWDN0ahZJW3IX2ih5nk3AucvUHf6OAVIJmeUDygwjihdqrhxXD-wGvjU.ttf'
      *
      *   // Using Source Serif for this example:
      *   font = await loadFont('https://fonts.gstatic.com/s/sourceserif4/v8/vEFy2_tTDB4M7-auWDN0ahZJW3IX2ih5nk3AucvUHf6OAVIJmeUDygwjihdqrhxXD-wGvjU.ttf');
      *
      *   geom = font.textToModel("Hello", 50, 0, { sampleFactor: 2, extrude: 5 });
      *   geom.clearColors();
      *   geom.normalize();
      * }
      *
      * function draw() {
      *   background(255);
      *   orbitControl();
      *   fill("red");
      *   strokeWeight(4);
      *   scale(min(width, height) / 300);
      *   model(geom);
      *   describe('3D red extruded "Hello" in Source Serif on white, rotatable via mouse.');
      * }
      * </code>
      * </div>
      *
      * @example
      * <div modernizr='webgl'>
      * <code>
      * let geom;
      * let activeFont;
      * let artShader;
      * let lineShader;
      *
      * // Define parameters as simple variables
      * let words = 'HELLO';
      * let warp = 1;
      * let extrude = 5;
      * let palette = ["#ffe03d", "#fe4830", "#d33033", "#6d358a", "#1c509e", "#00953c"];
      *
      * async function setup() {
      *   createCanvas(200, 200, WEBGL);
      *
      *   // Using Anton as the default font for this example:
      *
      *  // Alternative fonts:
      *  // Anton: 'https://fonts.gstatic.com/s/anton/v25/1Ptgg87LROyAm0K08i4gS7lu.ttf'
      *  // Montserrat: 'https://fonts.gstatic.com/s/montserrat/v29/JTUHjIg1_i6t8kCHKm4532VJOt5-QNFgpCtr6Ew-Y3tcoqK5.ttf'
      *  // Source Serif: 'https://fonts.gstatic.com/s/sourceserif4/v8/vEFy2_tTDB4M7-auWDN0ahZJW3IX2ih5nk3AucvUHf6OAVIJmeUDygwjihdqrhxXD-wGvjU.ttf'
      *   activeFont = await loadFont('https://fonts.gstatic.com/s/anton/v25/1Ptgg87LROyAm0K08i4gS7lu.ttf');
      *
      *   geom = activeFont.textToModel(words, 0, 50, { sampleFactor: 2, extrude });
      *   geom.clearColors();
      *   geom.normalize();
      *
      *   artShader = baseMaterialShader().modify({
      *     uniforms: {
      *       'float time': () => millis(),
      *       'float warp': () => warp,
      *       'float numColors': () => palette.length,
      *       'vec3[6] colors': () => palette.flatMap((c) => [red(c)/255, green(c)/255, blue(c)/255]),
      *     },
      *     vertexDeclarations: 'out vec3 vPos;',
      *     fragmentDeclarations: 'in vec3 vPos;',
      *     'Vertex getObjectInputs': `(Vertex inputs) {
      *       vPos = inputs.position;
      *       inputs.position.x += 5. * warp * sin(inputs.position.y * 0.1 + time * 0.001) / (1. + warp);
      *       inputs.position.y += 5. * warp * sin(inputs.position.x * 0.1 + time * 0.0009) / (1. + warp);
      *       return inputs;
      *     }`,
      *     'vec4 getFinalColor': `(vec4 _c) {
      *       float x = vPos.x * 0.005;
      *       float a = floor(fract(x) * numColors);
      *       float b = a == numColors - 1. ? 0. : a + 1.;
      *       float t = fract(x * numColors);
      *       vec3 c = mix(colors[int(a)], colors[int(b)], t);
      *       return vec4(c, 1.);
      *     }`
      *   });
      *
      *   lineShader = baseStrokeShader().modify({
      *     uniforms: {
      *       'float time': () => millis(),
      *       'float warp': () => warp,
      *     },
      *     'StrokeVertex getObjectInputs': `(StrokeVertex inputs) {
      *       inputs.position.x += 5. * warp * sin(inputs.position.y * 0.1 + time * 0.001) / (1. + warp);
      *       inputs.position.y += 5. * warp * sin(inputs.position.x * 0.1 + time * 0.0009) / (1. + warp);
      *       return inputs;
      *     }`,
      *   });
      * }
      *
      * function draw() {
      *   background(255);
      *   orbitControl();
      *   shader(artShader);
      *   strokeShader(lineShader);
      *   strokeWeight(4);
      *   scale(min(width, height) / 210);
      *   model(geom);
      *   describe('3D wavy with different color sets "Hello" in Anton on white canvas, rotatable via mouse.');
      * }
      * </code>
      * </div>
      */
  textToModel(str, x, y, width, height, options2) {
    ({ width, height, options: options2 } = this._parseArgs(width, height, options2));
    const extrude = (options2 == null ? void 0 : options2.extrude) || 0;
    const contours = this.textToContours(str, x, y, width, height, options2);
    const geom = this._pInst.buildGeometry(() => {
      if (extrude === 0) {
        const prevValidateFaces = this._pInst._renderer._validateFaces;
        this._pInst._renderer._validateFaces = true;
        this._pInst.beginShape();
        this._pInst.normal(0, 0, 1);
        for (const contour of contours) {
          this._pInst.beginContour();
          for (const { x: x2, y: y2 } of contour) {
            this._pInst.vertex(x2, y2);
          }
          this._pInst.endContour(this._pInst.CLOSE);
        }
        this._pInst.endShape();
        this._pInst._renderer._validateFaces = prevValidateFaces;
      } else {
        const prevValidateFaces = this._pInst._renderer._validateFaces;
        this._pInst._renderer._validateFaces = true;
        for (const side of [1, -1]) {
          this._pInst.beginShape();
          for (const contour of contours) {
            this._pInst.beginContour();
            for (const { x: x2, y: y2 } of contour) {
              this._pInst.vertex(x2, y2, side * extrude * 0.5);
            }
            this._pInst.endContour(this._pInst.CLOSE);
          }
          this._pInst.endShape();
        }
        this._pInst._renderer._validateFaces = prevValidateFaces;
        for (const contour of contours) {
          this._pInst.beginShape(this._pInst.QUAD_STRIP);
          for (const v of contour) {
            for (const side of [-1, 1]) {
              this._pInst.vertex(v.x, v.y, side * extrude * 0.5);
            }
          }
          this._pInst.endShape();
        }
      }
    });
    if (extrude !== 0) {
      geom.computeNormals();
      for (const face of geom.faces) {
        if (face.every((idx) => geom.vertices[idx].z <= -extrude * 0.5 + 0.1)) {
          for (const idx of face) geom.vertexNormals[idx].set(0, 0, -1);
          face.reverse();
        }
      }
    }
    return geom;
  }
  variations() {
    var _a2;
    let vars = {};
    if (this.data) {
      let axes = (_a2 = this.face) == null ? void 0 : _a2.axes;
      if (axes) {
        axes.forEach((ax) => {
          vars[ax.tag] = ax.value;
        });
      }
    }
    fontFaceVariations.forEach((v) => {
      let val2 = this.face[v];
      if (val2 !== "normal") {
        vars[v] = vars[v] || val2;
      }
    });
    return vars;
  }
  metadata() {
    var _a2;
    let meta = ((_a2 = this.data) == null ? void 0 : _a2.name) || {};
    for (let p2 in this.face) {
      if (!/^load/.test(p2)) {
        meta[p2] = meta[p2] || this.face[p2];
      }
    }
    return meta;
  }
  static async list(log2 = false) {
    if (log2) {
      console.log("There are", document.fonts.size, "font-faces\n");
      let loaded = 0;
      for (let fontFace of document.fonts.values()) {
        console.log("FontFace: {");
        for (let property in fontFace) {
          console.log("  " + property + ": " + fontFace[property]);
        }
        console.log("}\n");
        if (fontFace.status === "loaded") {
          loaded++;
        }
      }
      console.log(loaded + " loaded");
    }
    return await Array.from(document.fonts);
  }
  /////////////////////////////// HELPERS ////////////////////////////////
  _verticalAlign(size) {
    var _a2, _b2, _c2;
    const { sCapHeight } = ((_a2 = this.data) == null ? void 0 : _a2["OS/2"]) || {};
    const { unitsPerEm = 1e3 } = ((_b2 = this.data) == null ? void 0 : _b2.head) || {};
    const { ascender = 0, descender = 0 } = ((_c2 = this.data) == null ? void 0 : _c2.hhea) || {};
    const current2 = ascender / 2;
    const target = (sCapHeight || ascender + descender) / 2;
    const offset2 = target - current2;
    return offset2 * size / unitsPerEm;
  }
  /*
    Returns an array of line objects, each containing { text, x, y, glyphs: [ {g, path} ] }
  */
  _lineateAndPathify(str, x, y, width, height, options2 = {}) {
    var _a2, _b2, _c2;
    let renderer2 = ((_a2 = options2 == null ? void 0 : options2.graphics) == null ? void 0 : _a2._renderer) || this._pInst._renderer;
    let setBaseline = renderer2.drawingContext.textBaseline;
    let { lines, bounds } = renderer2._computeBounds(
      textCoreConstants._FONT_BOUNDS,
      str,
      x,
      y,
      width,
      height,
      { ignoreRectMode: true, ...options2 }
    );
    lines = this._position(renderer2, lines, bounds, width, height);
    let uPE = ((_c2 = (_b2 = this.data) == null ? void 0 : _b2.head) == null ? void 0 : _c2.unitsPerEm) || 1e3;
    let scale2 = renderer2.states.textSize / uPE;
    const axs = this._currentAxes(renderer2);
    let pathsForLine = lines.map((l) => this._lineToGlyphs(l, { scale: scale2, axs }));
    renderer2.drawingContext.textBaseline = setBaseline;
    return pathsForLine;
  }
  _currentAxes(renderer2) {
    var _a2, _b2;
    let axs;
    if ((((_b2 = (_a2 = this.data) == null ? void 0 : _a2.fvar) == null ? void 0 : _b2.length) ?? 0) > 0) {
      const fontAxes = this.data.fvar[0];
      axs = fontAxes.map(([tag, minVal, defaultVal, maxVal, flags, name]) => {
        if (!renderer2) return defaultVal;
        if (tag === "wght") {
          return renderer2.states.fontWeight;
        } else if (tag === "wdth") {
          return 100;
        } else if (renderer2.textCanvas().style.fontVariationSettings) {
          const match = new RegExp(`\\b${tag}s+(d+)`).exec(renderer2.textCanvas().style.fontVariationSettings);
          if (match) {
            return parseInt(match[1]);
          } else {
            return defaultVal;
          }
        } else {
          return defaultVal;
        }
      });
    }
    return axs;
  }
  _textToPathPoints(str, x, y, width, height, options2) {
    ({ width, height, options: options2 } = this._parseArgs(width, height, options2));
    let cmds = this.textToPaths(str, x, y, width, height, options2);
    const subdivide = (pts2, pt1, pt2, md) => {
      if (fn.dist(pt1.x, pt1.y, pt2.x, pt2.y) > md) {
        let middle = { x: (pt1.x + pt2.x) / 2, y: (pt1.y + pt2.y) / 2 };
        pts2.push(middle);
        subdivide(pts2, pt1, middle, md);
        subdivide(pts2, middle, pt2, md);
      }
    };
    let pts = [];
    let { textSize } = this._pInst._renderer.states;
    let maxDist = textSize / this.data.head.unitsPerEm * 500;
    for (let i = 0; i < cmds.length; i++) {
      let { type: type3, data: d2 } = cmds[i];
      if (type3 !== "Z") {
        let pt2 = { x: d2[d2.length - 2], y: d2[d2.length - 1] };
        if (type3 === "L" && pts.length && !(options2 == null ? void 0 : options2.nodivide) > 0) {
          subdivide(pts, pts[pts.length - 1], pt2, maxDist);
        }
        pts.push(pt2);
      }
    }
    return pts;
  }
  _parseArgs(width, height, options2 = {}) {
    if (typeof width === "object") {
      options2 = width;
      width = height = void 0;
    } else if (typeof height === "object") {
      options2 = height;
      height = void 0;
    }
    return { width, height, options: options2 };
  }
  _position(renderer2, lines, bounds, width, height) {
    let { textAlign, textLeading } = renderer2.states;
    let metrics = this._measureTextDefault(renderer2, "X");
    let ascent = metrics.fontBoundingBoxAscent;
    let coordify = (text2, i) => {
      let x = bounds.x;
      let y = bounds.y + i * textLeading + ascent;
      let lineWidth = renderer2._fontWidthSingle(text2);
      if (textAlign === CENTER) {
        x += (bounds.w - lineWidth) / 2;
      } else if (textAlign === RIGHT) {
        x += bounds.w - lineWidth;
      }
      if (typeof width !== "undefined") {
        switch (renderer2.states.rectMode) {
          case CENTER:
            x -= width / 2;
            y -= height / 2;
            break;
          case RADIUS:
            x -= width;
            y -= height;
            break;
        }
      }
      return { text: text2, x, y };
    };
    return lines.map(coordify);
  }
  _lineToGlyphs(line, { scale: scale2 = 1, axs } = {}) {
    if (!this.data) {
      throw Error('No font data available for "' + this.name + '"\nTry downloading a local copy of the font file');
    }
    let glyphShapes = Typr.U.shape(this.data, line.text, { axs });
    line.glyphShapes = glyphShapes;
    line.glyphs = this._shapeToPaths(glyphShapes, line, { scale: scale2, axs });
    return line;
  }
  _positionGlyphs(text2, options2) {
    var _a2;
    let renderer2 = ((_a2 = options2 == null ? void 0 : options2.graphics) == null ? void 0 : _a2._renderer) || this._pInst._renderer;
    const axs = this._currentAxes(renderer2);
    const glyphShapes = Typr.U.shape(this.data, text2, { axs });
    const positionedGlyphs = [];
    let x = 0;
    for (const glyph of glyphShapes) {
      positionedGlyphs.push({ x, index: glyph.g, shape: glyph });
      x += glyph.ax;
    }
    return positionedGlyphs;
  }
  _singleShapeToPath(shape2, { scale: scale2 = 1, x = 0, y = 0, lineX = 0, lineY = 0, axs } = {}) {
    let font2 = this.data;
    let crdIdx = 0;
    let { g: g2, ax, ay, dx, dy } = shape2;
    let { crds, cmds } = Typr.U.glyphToPath(font2, g2, true, axs);
    let glyph = {
      /*g: line.text[i], points: [],*/
      path: { commands: [] }
    };
    for (let j2 = 0; j2 < cmds.length; j2++) {
      let type3 = cmds[j2], command = [type3];
      if (type3 in pathArgCounts) {
        let argCount = pathArgCounts[type3];
        for (let k = 0; k < argCount; k += 2) {
          let gx = crds[k + crdIdx] + x + dx;
          let gy = crds[k + crdIdx + 1] + y + dy;
          let fx = lineX + gx * scale2;
          let fy = lineY + gy * -scale2;
          command.push(fx);
          command.push(fy);
        }
        crdIdx += argCount;
      }
      glyph.path.commands.push(command);
    }
    return { glyph, ax, ay };
  }
  _shapeToPaths(glyphs, line, { scale: scale2 = 1, axs } = {}) {
    let x = 0, y = 0, paths = [];
    if (glyphs.length !== line.text.length) {
      throw Error("Invalid shape data");
    }
    for (let i = 0; i < glyphs.length; i++) {
      const { glyph, ax, ay } = this._singleShapeToPath(glyphs[i], {
        scale: scale2,
        x,
        y,
        lineX: line.x,
        lineY: line.y,
        axs
      });
      paths.push(glyph);
      x += ax;
      y += ay;
    }
    return paths;
  }
  _measureTextDefault(renderer2, str) {
    let { textAlign, textBaseline } = renderer2.states;
    let ctx = renderer2.textDrawingContext();
    ctx.textAlign = "left";
    ctx.textBaseline = "alphabetic";
    let metrics = ctx.measureText(str);
    ctx.textAlign = textAlign;
    ctx.textBaseline = textBaseline;
    return metrics;
  }
  drawPaths(ctx, commands, opts) {
    ctx.strokeStyle = (opts == null ? void 0 : opts.stroke) || ctx.strokeStyle;
    ctx.fillStyle = (opts == null ? void 0 : opts.fill) || ctx.fillStyle;
    ctx.beginPath();
    commands.forEach(([type3, ...data3]) => {
      if (type3 === "M") {
        ctx.moveTo(...data3);
      } else if (type3 === "L") {
        ctx.lineTo(...data3);
      } else if (type3 === "C") {
        ctx.bezierCurveTo(...data3);
      } else if (type3 === "Q") {
        ctx.quadraticCurveTo(...data3);
      } else if (type3 === "Z") {
        ctx.closePath();
      }
    });
    if (opts == null ? void 0 : opts.fill) ctx.fill();
    if (opts == null ? void 0 : opts.stroke) ctx.stroke();
  }
  _pathsToCommands(paths, scale2) {
    let commands = [];
    for (let i = 0; i < paths.length; i++) {
      let pathData = paths[i];
      let { x, y, path: path2 } = pathData;
      let { crds, cmds } = path2;
      for (let c4 = 0, j2 = 0; j2 < cmds.length; j2++) {
        let cmd = cmds[j2], obj = { type: cmd, data: [] };
        if (cmd == "M" || cmd == "L") {
          obj.data.push(x + crds[c4] * scale2, y + crds[c4 + 1] * -scale2);
          c4 += 2;
        } else if (cmd == "C") {
          for (let i2 = 0; i2 < 6; i2 += 2) {
            obj.data.push(x + crds[c4 + i2] * scale2, y + crds[c4 + i2 + 1] * -scale2);
          }
          c4 += 6;
        } else if (cmd == "Q") {
          for (let i2 = 0; i2 < 4; i2 += 2) {
            obj.data.push(x + crds[c4 + i2] * scale2, y + crds[c4 + i2 + 1] * -scale2);
          }
          c4 += 4;
        }
        commands.push(obj);
      }
    }
    return commands;
  }
};
async function create2(pInst, name, path2, descriptors, rawFont) {
  let face = createFontFace(name, path2, descriptors, rawFont);
  if (face.status !== "loaded") await face.load();
  document.fonts.add(face);
  await document.fonts.ready;
  return new Font(pInst, face, name, path2, rawFont);
}
function createFontFace(name, path2, descriptors, rawFont) {
  var _a2;
  if (name.includes(" ")) name = "'" + name + "'";
  let fontArg = (rawFont == null ? void 0 : rawFont._compressedData) ?? (rawFont == null ? void 0 : rawFont._data);
  if (!fontArg) {
    if (!validFontTypesRe.test(path2)) {
      throw Error(invalidFontError);
    }
    if (!path2.startsWith("url(")) {
      path2 = "url(" + path2 + ")";
    }
    fontArg = path2;
  }
  if ((((_a2 = rawFont == null ? void 0 : rawFont.fvar) == null ? void 0 : _a2.length) ?? 0) > 0) {
    descriptors = descriptors || {};
    for (const [tag, minVal, defaultVal, maxVal, flags, name2] of rawFont.fvar[0]) {
      if (tag === "wght") {
        descriptors.weight = `${minVal} ${maxVal}`;
      } else if (tag === "wdth") {
        descriptors.stretch = `${minVal}% ${maxVal}%`;
      }
    }
  }
  let face = new FontFace(name, fontArg, descriptors);
  if (face.status === "error") {
    throw Error('Failed to create FontFace for "' + name + '"');
  }
  return face;
}
function extractFontName(font2, path2) {
  let result, meta = font2 == null ? void 0 : font2.name;
  if (meta) {
    if (meta.fullName) {
      return meta.fullName;
    }
    if (meta.familyName) {
      result = meta.familyName;
    }
  }
  if (!result) {
    let matches = extractFontNameRe.exec(path2);
    if (matches && matches.length >= 3) {
      result = matches[1];
    } else {
      result = path2;
    }
  }
  if (result.includes(" ")) {
    result = result.replace(/ /g, "_");
  }
  return result;
}
function pathToPoints(cmds, options2, font2) {
  const parseOpts = (options3, defaults2) => {
    if (typeof options3 !== "object") {
      options3 = defaults2;
    } else {
      for (const key in defaults2) {
        if (typeof options3[key] === "undefined") {
          options3[key] = defaults2[key];
        }
      }
    }
    return options3;
  };
  const at3 = (v, i) => {
    const s = v.length;
    return v[i < 0 ? i % s + s : i % s];
  };
  const simplify = (pts, angle) => {
    angle = angle || 0;
    let num = 0;
    for (let i = pts.length - 1; pts.length > 3 && i >= 0; --i) {
      if (collinear(at3(pts, i - 1), at3(pts, i), at3(pts, i + 1), angle)) {
        pts.splice(i % pts.length, 1);
        num++;
      }
    }
    return num;
  };
  const path2 = (0, import_bezier_path.createFromCommands)(arrayCommandsToObjects(cmds));
  let opts = parseOpts(options2, {
    sampleFactor: 0.1,
    simplifyThreshold: 0
  });
  const totalPoints = Math.max(1, Math.ceil(path2.getTotalLength() * opts.sampleFactor));
  let points = [];
  const mode = font2._pInst.angleMode();
  const DEGREES = font2._pInst.DEGREES;
  for (let i = 0; i < totalPoints; i++) {
    const length = path2.getTotalLength() * (totalPoints === 1 ? 0 : i / (totalPoints - 1));
    points.push({
      ...path2.getPointAtLength(length),
      get angle() {
        const angle = path2.getAngleAtLength(length);
        if (mode === DEGREES) {
          return angle * 180 / Math.PI;
        } else {
          return angle;
        }
      },
      // For backwards compatibility
      get alpha() {
        return this.angle;
      }
    });
  }
  if (opts.simplifyThreshold) {
    simplify(points, opts.simplifyThreshold);
  }
  return points;
}
function unquote(name) {
  if ((name.startsWith('"') || name.startsWith("'")) && name.at(0) === name.at(-1)) {
    return name.slice(1, -1).replace(/\/(['"])/g, "$1");
  }
  return name;
}
function parseCreateArgs(...args) {
  let path2 = args.shift();
  if (typeof path2 !== "string" || path2.length === 0) {
    p5._friendlyError(invalidFontError, "p5.loadFont");
  }
  let name;
  if (typeof args[0] === "string") {
    name = args.shift();
  }
  let success2, error42, options2;
  for (let i = 0; i < args.length; i++) {
    const arg = args[i];
    if (typeof arg === "function") {
      if (!success2) {
        success2 = arg;
      } else {
        error42 = arg;
      }
    } else if (typeof arg === "object") {
      options2 = arg;
    }
  }
  return { path: path2, name, success: success2, error: error42, options: options2 };
}
function font(p53, fn2) {
  p53.Font = Font;
  fn2.parseFontData = async function(pathOrData) {
    let result = pathOrData instanceof Uint8Array ? pathOrData : await fn2.loadBytes(pathOrData);
    if (!result) {
      throw Error("Failed to load font data");
    }
    let fonts = Typr.parse(result);
    if (fonts.length === 0 || fonts[0].cmap === void 0) {
      throw Error("parsing font data");
    }
    return fonts[0];
  };
  fn2.loadFont = async function(...args) {
    var _a2;
    let { path: path2, name, success: success2, error: error42, options: { sets: sets2, ...descriptors } = {} } = parseCreateArgs(...args);
    let isCSS = path2.includes("@font-face");
    if (!isCSS) {
      const info = await fetch(path2, { method: "HEAD" });
      const isCSSFile = (_a2 = info.headers.get("content-type")) == null ? void 0 : _a2.startsWith("text/css");
      if (isCSSFile) {
        isCSS = true;
        path2 = await fetch(path2).then((res) => res.text());
      }
    }
    if (isCSS) {
      const stylesheet = new CSSStyleSheet();
      await stylesheet.replace(path2);
      const possibleFonts = [];
      for (const rule of stylesheet.cssRules) {
        if (rule instanceof CSSFontFaceRule) {
          const style = rule.style;
          let name2 = unquote(style.getPropertyValue("font-family"));
          const src = style.getPropertyValue("src");
          const fontDescriptors = { ...descriptors || {} };
          for (const key of style) {
            if (key === "font-family" || key === "src") continue;
            const camelCaseKey = key.replace(/^font-/, "").split("-").map((v, i) => i === 0 ? v : `${v[0].toUpperCase()}${v.slice(1)}`).join("");
            fontDescriptors[camelCaseKey] = style.getPropertyValue(key);
          }
          possibleFonts.push({
            name: name2,
            src,
            fontDescriptors,
            loadWithData: async () => {
              let fontData;
              try {
                const urlMatch = /url\(([^\)]+)\)/.exec(src);
                if (urlMatch) {
                  let url2 = urlMatch[1];
                  if (/^['"]/.exec(url2) && url2.at(0) === url2.at(-1)) {
                    url2 = url2.slice(1, -1);
                  }
                  fontData = await fn2.parseFontData(url2);
                }
              } catch (_e) {
              }
              return create2(this, name2, src, fontDescriptors, fontData);
            },
            loadWithoutData: () => create2(this, name2, src, fontDescriptors)
          });
        }
      }
      sets2 = sets2 || ["latin"];
      const requestedGroups = (sets2 instanceof Array ? sets2 : [sets2]).map((s) => s.toLowerCase());
      const requestedCategories = unicodeRanges.filter((r) => requestedGroups.some(
        (g2) => r.category.includes(g2) && // Only include extended character sets if specifically requested
        r.category.includes("ext") === g2.includes("ext")
      ));
      const requestedRanges = new Set(
        import_unicode_range.UnicodeRange.parse(
          requestedCategories.map((c4) => `U+${c4.hexrange[0]}-${c4.hexrange[1]}`)
        )
      );
      let closestRangeOverlap = 0;
      let closestDescriptorOverlap = 0;
      let closestMatch = void 0;
      for (const font2 of possibleFonts) {
        if (!font2.fontDescriptors.unicodeRange) continue;
        const fontRange = new Set(
          import_unicode_range.UnicodeRange.parse(
            font2.fontDescriptors.unicodeRange.split(/,\s*/g)
          )
        );
        const rangeOverlap = [...fontRange.values()].filter((v) => requestedRanges.has(v)).length;
        const targetDescriptors = {
          // Default to normal style at regular weight
          style: "normal",
          weight: 400,
          // Override from anything else passed in
          ...descriptors
        };
        const descriptorOverlap = Object.keys(font2.fontDescriptors).filter((k) => font2.fontDescriptors[k] === targetDescriptors[k]).length;
        if (descriptorOverlap > closestDescriptorOverlap || descriptorOverlap === closestDescriptorOverlap && rangeOverlap >= closestRangeOverlap) {
          closestDescriptorOverlap = descriptorOverlap;
          closestRangeOverlap = rangeOverlap;
          closestMatch = font2;
        }
      }
      const picked = closestMatch || possibleFonts.at(-1);
      for (const font2 of possibleFonts) {
        if (font2 !== picked) {
          font2.loadWithoutData();
        }
      }
      return picked == null ? void 0 : picked.loadWithData();
    }
    let pfont;
    try {
      const fontData = await fn2.parseFontData(path2);
      name = name || extractFontName(fontData, path2);
      pfont = await create2(this, name, path2, descriptors, fontData);
    } catch (err2) {
      let ident = name || path2.substring(path2.lastIndexOf("/") + 1).replace(/\.[^/.]+$/, "");
      console.warn(`WARN: No glyph data for '${ident}', retrying as FontFace`);
      try {
        pfont = await create2(this, ident, path2, descriptors);
      } catch (err3) {
        if (error42) return error42(err3);
        throw err3;
      }
    }
    if (success2) return success2(pfont);
    return pfont;
  };
}
var arrayCommandsToObjects = (commands) => commands.map((command) => {
  const type3 = command[0];
  switch (type3) {
    case "Z": {
      return { type: type3 };
    }
    case "M":
    case "L": {
      const [, x, y] = command;
      return { type: type3, x, y };
    }
    case "Q": {
      const [, x1, y1, x, y] = command;
      return { type: type3, x1, y1, x, y };
    }
    case "C": {
      const [, x1, y1, x2, y2, x, y] = command;
      return { type: type3, x1, y1, x2, y2, x, y };
    }
    default: {
      throw new Error(`Unexpected path command: ${type3}`);
    }
  }
});
if (typeof p5 !== "undefined") {
  font(p5, p5.prototype);
}

// node_modules/p5/dist/webgl/text.js
var import_file_saver13 = __toESM(require_FileSaver());
var import_omggif8 = __toESM(require_omggif());
var import_libtess9 = __toESM(require_libtess_min());
var import_unicode_range2 = __toESM(require_lib());
var import_bezier_path2 = __toESM(require_bezier_path());
function text(p53, fn2) {
  RendererGL.prototype.maxCachedGlyphs = function() {
    return 200;
  };
  Font.prototype._getFontInfo = function(axs) {
    this._fontInfos = this._fontInfos || {};
    const key = JSON.stringify(axs);
    if (this._fontInfos[key]) {
      const val2 = this._fontInfos[key];
      return val2;
    } else {
      const val2 = new FontInfo(this, { axs });
      this._fontInfos[key] = val2;
      return val2;
    }
  };
  const charGridWidth = 9;
  const charGridHeight = charGridWidth;
  const strokeImageWidth = 64;
  const strokeImageHeight = 64;
  const gridImageWidth = 64;
  const gridImageHeight = 64;
  const cellImageWidth = 64;
  const cellImageHeight = 64;
  class ImageInfos {
    constructor(width, height) {
      this.width = width;
      this.height = height;
      this.infos = [];
    }
    /**
     *
     * @param {Integer} space
     * @return {Object} contains the ImageData, and pixel index into that
     *                  ImageData where the free space was allocated.
     *
     * finds free space of a given size in the ImageData list
     */
    findImage(space) {
      const imageSize = this.width * this.height;
      if (space > imageSize)
        throw new Error("font is too complex to render in 3D");
      let imageInfo, imageData;
      for (let ii = this.infos.length - 1; ii >= 0; --ii) {
        const imageInfoTest = this.infos[ii];
        if (imageInfoTest.index + space < imageSize) {
          imageInfo = imageInfoTest;
          imageData = imageInfoTest.imageData;
          break;
        }
      }
      if (!imageInfo) {
        try {
          imageData = new ImageData(this.width, this.height);
        } catch (err2) {
          let canvas2 = document.getElementsByTagName("canvas")[0];
          const created = !canvas2;
          if (!canvas2) {
            canvas2 = document.createElement("canvas");
            canvas2.style.display = "none";
            document.body.appendChild(canvas2);
          }
          const ctx = canvas2.getContext("2d");
          if (ctx) {
            imageData = ctx.createImageData(this.width, this.height);
          }
          if (created) {
            document.body.removeChild(canvas2);
          }
        }
        imageInfo = { index: 0, imageData };
        this.infos.push(imageInfo);
      }
      const index = imageInfo.index;
      imageInfo.index += space;
      imageData._dirty = true;
      return { imageData, index };
    }
  }
  function setPixel(imageInfo, r, g2, b3, a2) {
    const imageData = imageInfo.imageData;
    const pixels2 = imageData.data;
    let index = imageInfo.index++ * 4;
    pixels2[index++] = r;
    pixels2[index++] = g2;
    pixels2[index++] = b3;
    pixels2[index++] = a2;
  }
  const SQRT3 = Math.sqrt(3);
  class FontInfo {
    constructor(font2, { axs } = {}) {
      this.font = font2;
      this.axs = axs;
      this.strokeImageInfos = new ImageInfos(
        strokeImageWidth,
        strokeImageHeight
      );
      this.colDimImageInfos = new ImageInfos(gridImageWidth, gridImageHeight);
      this.rowDimImageInfos = new ImageInfos(gridImageWidth, gridImageHeight);
      this.colCellImageInfos = new ImageInfos(cellImageWidth, cellImageHeight);
      this.rowCellImageInfos = new ImageInfos(cellImageWidth, cellImageHeight);
      this.glyphInfos = {};
    }
    /**
     * @param {Glyph} glyph the x positions of points in the curve
     * @returns {Object} the glyphInfo for that glyph
     *
     * calculates rendering info for a glyph, including the curve information,
     * row & column stripes compiled into textures.
     */
    getGlyphInfo(glyph) {
      let gi = this.glyphInfos[glyph.index];
      if (gi) return gi;
      const axs = this.axs;
      const {
        glyph: {
          path: { commands }
        }
      } = this.font._singleShapeToPath(glyph.shape, { axs });
      let xMin = Infinity;
      let xMax = -Infinity;
      let yMin = Infinity;
      let yMax = -Infinity;
      for (const cmd of commands) {
        for (let i2 = 1; i2 < cmd.length; i2 += 2) {
          xMin = Math.min(xMin, cmd[i2]);
          xMax = Math.max(xMax, cmd[i2]);
          yMin = Math.min(yMin, cmd[i2 + 1]);
          yMax = Math.max(yMax, cmd[i2 + 1]);
        }
      }
      if (xMin >= xMax || yMin >= yMax || !commands.length) {
        return this.glyphInfos[glyph.index] = {};
      }
      const gWidth = xMax - xMin;
      const gHeight = yMax - yMin;
      const cmds = arrayCommandsToObjects(commands);
      let i;
      const strokes = [];
      const rows = [];
      const cols = [];
      for (i = charGridWidth - 1; i >= 0; --i) cols.push([]);
      for (i = charGridHeight - 1; i >= 0; --i) rows.push([]);
      function push(xs2, ys2, v) {
        const index = strokes.length;
        strokes.push(v);
        function minMax(rg, min, max) {
          for (let i2 = rg.length; i2-- > 0; ) {
            const v2 = rg[i2];
            if (min > v2) min = v2;
            if (max < v2) max = v2;
          }
          return { min, max };
        }
        const cellOffset = 0.5;
        const mmX = minMax(xs2, 1, 0);
        const ixMin = Math.max(
          Math.floor(mmX.min * charGridWidth - cellOffset),
          0
        );
        const ixMax = Math.min(
          Math.ceil(mmX.max * charGridWidth + cellOffset),
          charGridWidth
        );
        for (let iCol = ixMin; iCol < ixMax; ++iCol) cols[iCol].push(index);
        const mmY = minMax(ys2, 1, 0);
        const iyMin = Math.max(
          Math.floor(mmY.min * charGridHeight - cellOffset),
          0
        );
        const iyMax = Math.min(
          Math.ceil(mmY.max * charGridHeight + cellOffset),
          charGridHeight
        );
        for (let iRow = iyMin; iRow < iyMax; ++iRow) rows[iRow].push(index);
      }
      function clamp2(v, min, max) {
        if (v < min) return min;
        if (v > max) return max;
        return v;
      }
      function byte(v) {
        return clamp2(255 * v, 0, 255);
      }
      class Cubic {
        constructor(p0, c0, c14, p1) {
          this.p0 = p0;
          this.c0 = c0;
          this.c1 = c14;
          this.p1 = p1;
        }
        /**
         * @return {Object} the quadratic approximation
         *
         * converts the cubic to a quadtratic approximation by
         * picking an appropriate quadratic control point
         */
        toQuadratic() {
          return {
            x: this.p0.x,
            y: this.p0.y,
            x1: this.p1.x,
            y1: this.p1.y,
            cx: ((this.c0.x + this.c1.x) * 3 - (this.p0.x + this.p1.x)) / 4,
            cy: ((this.c0.y + this.c1.y) * 3 - (this.p0.y + this.p1.y)) / 4
          };
        }
        /**
         * @return {Number} the error
         *
         * calculates the magnitude of error of this curve's
         * quadratic approximation.
         */
        quadError() {
          return Vector.sub(
            Vector.sub(this.p1, this.p0),
            Vector.mult(Vector.sub(this.c1, this.c0), 3)
          ).mag() / 2;
        }
        /**
         * @param {Number} t the value (0-1) at which to split
         * @return {Cubic} the second part of the curve
         *
         * splits the cubic into two parts at a point 't' along the curve.
         * this cubic keeps its start point and its end point becomes the
         * point at 't'. the 'end half is returned.
         */
        split(t) {
          const m13 = Vector.lerp(this.p0, this.c0, t);
          const m22 = Vector.lerp(this.c0, this.c1, t);
          const mm1 = Vector.lerp(m13, m22, t);
          this.c1 = Vector.lerp(this.c1, this.p1, t);
          this.c0 = Vector.lerp(m22, this.c1, t);
          const pt2 = Vector.lerp(mm1, this.c0, t);
          const part1 = new Cubic(this.p0, m13, mm1, pt2);
          this.p0 = pt2;
          return part1;
        }
        /**
         * @return {Cubic[]} the non-inflecting pieces of this cubic
         *
         * returns an array containing 0, 1 or 2 cubics split resulting
         * from splitting this cubic at its inflection points.
         * this cubic is (potentially) altered and returned in the list.
         */
        splitInflections() {
          const a2 = Vector.sub(this.c0, this.p0);
          const b3 = Vector.sub(Vector.sub(this.c1, this.c0), a2);
          const c4 = Vector.sub(
            Vector.sub(Vector.sub(this.p1, this.c1), a2),
            Vector.mult(b3, 2)
          );
          const cubics = [];
          let A = b3.x * c4.y - b3.y * c4.x;
          if (A !== 0) {
            let B = a2.x * c4.y - a2.y * c4.x;
            let C = a2.x * b3.y - a2.y * b3.x;
            const disc = B * B - 4 * A * C;
            if (disc >= 0) {
              if (A < 0) {
                A = -A;
                B = -B;
                C = -C;
              }
              const Q2 = Math.sqrt(disc);
              const t0 = (-B - Q2) / (2 * A);
              let t1 = (-B + Q2) / (2 * A);
              if (t0 > 0 && t0 < 1) {
                cubics.push(this.split(t0));
                t1 = 1 - (1 - t1) / (1 - t0);
              }
              if (t1 > 0 && t1 < 1) {
                cubics.push(this.split(t1));
              }
            }
          }
          cubics.push(this);
          return cubics;
        }
      }
      function cubicToQuadratics(x02, y02, cx0, cy0, cx1, cy1, x1, y1) {
        const cubics = new Cubic(
          new Vector(x02, y02),
          new Vector(cx0, cy0),
          new Vector(cx1, cy1),
          new Vector(x1, y1)
        ).splitInflections();
        const qs = [];
        const precision = 30 / SQRT3;
        for (let cubic of cubics) {
          const tail = [];
          let t3;
          for (; ; ) {
            t3 = precision / cubic.quadError();
            if (t3 >= 0.5 * 0.5 * 0.5) {
              break;
            }
            const t = Math.pow(t3, 1 / 3);
            const start = cubic.split(t);
            const middle = cubic.split(1 - t / (1 - t));
            qs.push(start);
            tail.push(cubic);
            cubic = middle;
          }
          if (t3 < 1) {
            qs.push(cubic.split(0.5));
          }
          qs.push(cubic);
          Array.prototype.push.apply(qs, tail.reverse());
        }
        return qs;
      }
      function pushLine(x02, y02, x1, y1) {
        const mx = (x02 + x1) / 2;
        const my = (y02 + y1) / 2;
        push([x02, x1], [y02, y1], { x: x02, y: y02, cx: mx, cy: my });
      }
      function samePoint(x02, y02, x1, y1) {
        return Math.abs(x1 - x02) < 1e-5 && Math.abs(y1 - y02) < 1e-5;
      }
      let x0, y0, xs, ys;
      for (const cmd of cmds) {
        const x1 = (cmd.x - xMin) / gWidth;
        const y1 = (cmd.y - yMin) / gHeight;
        if (samePoint(x0, y0, x1, y1)) continue;
        switch (cmd.type) {
          case "M": {
            xs = x1;
            ys = y1;
            break;
          }
          case "L": {
            pushLine(x0, y0, x1, y1);
            break;
          }
          case "Q": {
            const cx = (cmd.x1 - xMin) / gWidth;
            const cy = (cmd.y1 - yMin) / gHeight;
            push([x0, x1, cx], [y0, y1, cy], { x: x0, y: y0, cx, cy });
            break;
          }
          case "Z": {
            if (!samePoint(x0, y0, xs, ys)) {
              pushLine(x0, y0, xs, ys);
              strokes.push({ x: xs, y: ys });
            } else {
              strokes.push({ x: x0, y: y0 });
            }
            break;
          }
          case "C": {
            const cx1 = (cmd.x1 - xMin) / gWidth;
            const cy1 = (cmd.y1 - yMin) / gHeight;
            const cx2 = (cmd.x2 - xMin) / gWidth;
            const cy2 = (cmd.y2 - yMin) / gHeight;
            const qs = cubicToQuadratics(x0, y0, cx1, cy1, cx2, cy2, x1, y1);
            for (let iq = 0; iq < qs.length; iq++) {
              const q = qs[iq].toQuadratic();
              push([q.x, q.x1, q.cx], [q.y, q.y1, q.cy], q);
            }
            break;
          }
          default:
            throw new Error(`unknown command type: ${cmd.type}`);
        }
        x0 = x1;
        y0 = y1;
      }
      const strokeCount = strokes.length;
      const strokeImageInfo = this.strokeImageInfos.findImage(strokeCount);
      const strokeOffset = strokeImageInfo.index;
      for (let il = 0; il < strokeCount; ++il) {
        const s = strokes[il];
        setPixel(strokeImageInfo, byte(s.x), byte(s.y), byte(s.cx), byte(s.cy));
      }
      function layout(dim, dimImageInfos, cellImageInfos) {
        const dimLength = dim.length;
        const dimImageInfo = dimImageInfos.findImage(dimLength);
        const dimOffset = dimImageInfo.index;
        let totalStrokes = 0;
        for (let id = 0; id < dimLength; ++id) {
          totalStrokes += dim[id].length;
        }
        const cellImageInfo = cellImageInfos.findImage(totalStrokes);
        for (let i2 = 0; i2 < dimLength; ++i2) {
          const strokeIndices = dim[i2];
          const strokeCount2 = strokeIndices.length;
          const cellLineIndex = cellImageInfo.index;
          setPixel(
            dimImageInfo,
            cellLineIndex >> 7,
            cellLineIndex & 127,
            strokeCount2 >> 7,
            strokeCount2 & 127
          );
          for (let iil = 0; iil < strokeCount2; ++iil) {
            const strokeIndex = strokeIndices[iil] + strokeOffset;
            setPixel(cellImageInfo, strokeIndex >> 7, strokeIndex & 127, 0, 0);
          }
        }
        return {
          cellImageInfo,
          dimOffset,
          dimImageInfo
        };
      }
      gi = this.glyphInfos[glyph.index] = {
        glyph,
        uGlyphRect: [xMin, yMin, xMax, yMax],
        strokeImageInfo,
        strokes,
        colInfo: layout(cols, this.colDimImageInfos, this.colCellImageInfos),
        rowInfo: layout(rows, this.rowDimImageInfos, this.rowCellImageInfos)
      };
      gi.uGridOffset = [gi.colInfo.dimOffset, gi.rowInfo.dimOffset];
      return gi;
    }
  }
  RendererGL.prototype._renderText = function(line, x, y, maxY, minY) {
    var _a2, _b2;
    if (!this.states.textFont || typeof this.states.textFont === "string") {
      console.log(
        "WEBGL: you must load and set a font before drawing text. See `loadFont` and `textFont` for more details."
      );
      return;
    }
    if (y >= maxY || !this.states.fillColor) {
      return;
    }
    if (!p53.Font.hasGlyphData(this.states.textFont)) {
      console.log(
        "WEBGL: only Opentype (.otf) and Truetype (.ttf) fonts with glyph data are supported"
      );
      return;
    }
    this.push();
    const doStroke = this.states.strokeColor;
    const drawMode = this.states.drawMode;
    this.states.setValue("strokeColor", null);
    this.states.setValue("drawMode", TEXTURE);
    const { font: font2 } = this.states.textFont;
    if (!font2) {
      throw new Error(
        "In WebGL mode, textFont() needs to be given the result of loadFont() instead of a font family name."
      );
    }
    const axs = font2._currentAxes(this);
    let fontInfo = font2._getFontInfo(axs);
    const pos = { x, y };
    const fontSize = this.states.textSize;
    const scale2 = fontSize / (((_b2 = (_a2 = font2.data) == null ? void 0 : _a2.head) == null ? void 0 : _b2.unitsPerEm) || 1e3);
    this.translate(pos.x, pos.y, 0);
    this.scale(scale2, scale2, 1);
    const gl = this.GL;
    const initializeShader = !this._defaultFontShader;
    const sh = this._getFontShader();
    sh.init();
    sh.bindShader();
    if (initializeShader) {
      sh.setUniform("uGridImageSize", [gridImageWidth, gridImageHeight]);
      sh.setUniform("uCellsImageSize", [cellImageWidth, cellImageHeight]);
      sh.setUniform("uStrokeImageSize", [strokeImageWidth, strokeImageHeight]);
      sh.setUniform("uGridSize", [charGridWidth, charGridHeight]);
    }
    const curFillColor = this.states.fillSet ? this.states.curFillColor : [0, 0, 0, 255];
    this._setGlobalUniforms(sh);
    this._applyColorBlend(curFillColor);
    let g2 = this.geometryBufferCache.getGeometryByID("glyph");
    if (!g2) {
      g2 = this._textGeom = new Geometry(
        1,
        1,
        function() {
          for (let i = 0; i <= 1; i++) {
            for (let j2 = 0; j2 <= 1; j2++) {
              this.vertices.push(new Vector(j2, i, 0));
              this.uvs.push(j2, i);
            }
          }
        },
        this
      );
      g2.gid = "glyph";
      g2.computeFaces().computeNormals();
      this.geometryBufferCache.ensureCached(g2);
    }
    for (const buff of this.buffers.text) {
      buff._prepareBuffer(g2, sh);
    }
    this._bindBuffer(
      this.geometryBufferCache.cache.glyph.indexBuffer,
      gl.ELEMENT_ARRAY_BUFFER
    );
    sh.setUniform("uMaterialColor", curFillColor);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    this.glyphDataCache = this.glyphDataCache || /* @__PURE__ */ new Set();
    try {
      const glyphs = font2._positionGlyphs(line);
      for (const glyph of glyphs) {
        const gi = fontInfo.getGlyphInfo(glyph);
        if (gi.uGlyphRect) {
          const rowInfo = gi.rowInfo;
          const colInfo = gi.colInfo;
          const glyphResources = [
            gi.strokeImageInfo.imageData,
            rowInfo.cellImageInfo.imageData,
            rowInfo.dimImageInfo.imageData,
            colInfo.cellImageInfo.imageData,
            colInfo.dimImageInfo.imageData
          ];
          for (const resource of glyphResources) {
            this.glyphDataCache.delete(resource);
            this.glyphDataCache.add(resource);
          }
          while (this.glyphDataCache.size > this.maxCachedGlyphs()) {
            const data3 = this.glyphDataCache.values().next().value;
            this.glyphDataCache.delete(data3);
            const tex = this.textures.get(data3);
            if (tex) {
              tex.remove();
              this.textures.delete(data3);
            }
          }
          sh.setUniform("uSamplerStrokes", gi.strokeImageInfo.imageData);
          sh.setUniform("uSamplerRowStrokes", rowInfo.cellImageInfo.imageData);
          sh.setUniform("uSamplerRows", rowInfo.dimImageInfo.imageData);
          sh.setUniform("uSamplerColStrokes", colInfo.cellImageInfo.imageData);
          sh.setUniform("uSamplerCols", colInfo.dimImageInfo.imageData);
          sh.setUniform("uGridOffset", gi.uGridOffset);
          sh.setUniform("uGlyphRect", gi.uGlyphRect);
          sh.setUniform("uGlyphOffset", glyph.x);
          sh.bindTextures();
          gl.drawElements(gl.TRIANGLES, 6, this.GL.UNSIGNED_SHORT, 0);
        }
      }
    } finally {
      sh.unbindShader();
      this.states.setValue("strokeColor", doStroke);
      this.states.setValue("drawMode", drawMode);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
      this.pop();
    }
  };
}

// node_modules/p5/dist/webgl/ShaderGenerator.js
var import_escodegen = __toESM(require_escodegen());
var noiseGLSL = "// Based on https://github.com/patriciogonzalezvivo/lygia/blob/main/generative/noise.glsl (MIT)\n// Adapted for use in p5.strands\n\nvec2 random2(vec2 st) {\n  st = vec2(dot(st, vec2(127.1, 311.7)),\n            dot(st, vec2(269.5, 183.3)));\n  return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\nfloat baseNoise(vec2 st) {\n  vec2 i = floor(st);\n  vec2 f = fract(st);\n\n  vec2 a = random2(i);\n  vec2 b = random2(i + vec2(1.0, 0.0));\n  vec2 c = random2(i + vec2(0.0, 1.0));\n  vec2 d = random2(i + vec2(1.0, 1.0));\n\n  vec2 u = f * f * (3.0 - 2.0 * f);\n\n  return mix(mix(dot(a, f - vec2(0.0, 0.0)), \n                 dot(b, f - vec2(1.0, 0.0)), u.x),\n             mix(dot(c, f - vec2(0.0, 1.0)), \n                 dot(d, f - vec2(1.0, 1.0)), u.x), u.y);\n}\n\n// Fractal noise using 4 octaves\nfloat noise(vec2 st) {\n  float result = 0.0;\n  float amplitude = 1.0;\n  float frequency = 1.0;\n\n  for (int i = 0; i < 4; i++) {\n    result += amplitude * baseNoise(st * frequency);\n    frequency *= 2.0;\n    amplitude *= 0.5;\n  }\n\n  return result;\n}\n";
function shadergenerator(p53, fn2) {
  let GLOBAL_SHADER;
  let BRANCH;
  const oldModify = p53.Shader.prototype.modify;
  p53.Shader.prototype.modify = function(shaderModifier, scope = {}) {
    if (shaderModifier instanceof Function) {
      const options2 = { srcLocations: false };
      let generatorFunction;
      {
        const sourceString = `(${shaderModifier.toString()})`;
        const ast = parse7(sourceString, {
          ecmaVersion: 2021,
          locations: options2.srcLocations
        });
        ancestor(ast, ASTCallbacks, void 0, { varyings: {} });
        const transpiledSource = import_escodegen.default.generate(ast);
        const scopeKeys = Object.keys(scope);
        const internalGeneratorFunction = new Function(
          // Create a parameter called __p5, not just p5, because users of instance mode
          // may pass in a variable called p5 as a scope variable. If we rely on a variable called
          // p5, then the scope variable called p5 might accidentally override internal function
          // calls to p5 static methods.
          "__p5",
          ...scopeKeys,
          transpiledSource.slice(
            transpiledSource.indexOf("{") + 1,
            transpiledSource.lastIndexOf("}")
          ).replaceAll(";", "")
        );
        generatorFunction = () => internalGeneratorFunction(p53, ...scopeKeys.map((key) => scope[key]));
      }
      const generator = new ShaderGenerator(generatorFunction, this, options2.srcLocations);
      const generatedModifyArgument = generator.generate();
      return oldModify.call(this, generatedModifyArgument);
    } else {
      return oldModify.call(this, shaderModifier);
    }
  };
  function replaceBinaryOperator(codeSource) {
    switch (codeSource) {
      case "+":
        return "add";
      case "-":
        return "sub";
      case "*":
        return "mult";
      case "/":
        return "div";
      case "%":
        return "mod";
      case "==":
      case "===":
        return "equalTo";
      case ">":
        return "greaterThan";
      case ">=":
        return "greaterThanEqualTo";
      case "<":
        return "lessThan";
      case "&&":
        return "and";
      case "||":
        return "or";
    }
  }
  function nodeIsUniform(ancestor2) {
    var _a2, _b2, _c2, _d;
    return ancestor2.type === "CallExpression" && // Global mode
    (((_a2 = ancestor2.callee) == null ? void 0 : _a2.type) === "Identifier" && ((_b2 = ancestor2.callee) == null ? void 0 : _b2.name.startsWith("uniform")) || // Instance mode
    ((_c2 = ancestor2.callee) == null ? void 0 : _c2.type) === "MemberExpression" && ((_d = ancestor2.callee) == null ? void 0 : _d.property.name.startsWith("uniform")));
  }
  const ASTCallbacks = {
    UnaryExpression(node, _state, ancestors) {
      if (ancestors.some(nodeIsUniform)) {
        return;
      }
      const signNode = {
        type: "Literal",
        value: node.operator
      };
      const standardReplacement = (node2) => {
        node2.type = "CallExpression";
        node2.callee = {
          type: "Identifier",
          name: "__p5.unaryNode"
        };
        node2.arguments = [node2.argument, signNode];
      };
      if (node.type === "MemberExpression") {
        const property = node.argument.property.name;
        const swizzleSets = [
          ["x", "y", "z", "w"],
          ["r", "g", "b", "a"],
          ["s", "t", "p", "q"]
        ];
        let isSwizzle = swizzleSets.some(
          (set3) => [...property].every((char) => set3.includes(char))
        ) && node.argument.type === "MemberExpression";
        if (isSwizzle) {
          node.type = "MemberExpression";
          node.object = {
            type: "CallExpression",
            callee: {
              type: "Identifier",
              name: "__p5.unaryNode"
            },
            arguments: [node.argument.object, signNode]
          };
          node.property = {
            type: "Identifier",
            name: property
          };
        } else {
          standardReplacement(node);
        }
      } else {
        standardReplacement(node);
      }
      delete node.argument;
      delete node.operator;
    },
    VariableDeclarator(node, _state, ancestors) {
      var _a2;
      if (ancestors.some(nodeIsUniform)) {
        return;
      }
      if (nodeIsUniform(node.init)) {
        const uniformNameLiteral = {
          type: "Literal",
          value: node.id.name
        };
        node.init.arguments.unshift(uniformNameLiteral);
      }
      if (node.init.callee && ((_a2 = node.init.callee.name) == null ? void 0 : _a2.startsWith("varying"))) {
        const varyingNameLiteral = {
          type: "Literal",
          value: node.id.name
        };
        node.init.arguments.unshift(varyingNameLiteral);
        _state.varyings[node.id.name] = varyingNameLiteral;
      }
    },
    Identifier(node, _state, ancestors) {
      if (ancestors.some(nodeIsUniform)) {
        return;
      }
      if (_state.varyings[node.name] && !_ancestors.some((a2) => a2.type === "AssignmentExpression" && a2.left === node)) {
        node.type = "ExpressionStatement";
        node.expression = {
          type: "CallExpression",
          callee: {
            type: "MemberExpression",
            object: {
              type: "Identifier",
              name: node.name
            },
            property: {
              type: "Identifier",
              name: "getValue"
            }
          },
          arguments: []
        };
      }
    },
    // The callbacks for AssignmentExpression and BinaryExpression handle
    // operator overloading including +=, *= assignment expressions
    ArrayExpression(node, _state, ancestors) {
      if (ancestors.some(nodeIsUniform)) {
        return;
      }
      const original = JSON.parse(JSON.stringify(node));
      node.type = "CallExpression";
      node.callee = {
        type: "Identifier",
        name: "__p5.dynamicNode"
      };
      node.arguments = [original];
    },
    AssignmentExpression(node, _state, ancestors) {
      if (ancestors.some(nodeIsUniform)) {
        return;
      }
      if (node.operator !== "=") {
        const methodName = replaceBinaryOperator(node.operator.replace("=", ""));
        const rightReplacementNode = {
          type: "CallExpression",
          callee: {
            type: "MemberExpression",
            object: node.left,
            property: {
              type: "Identifier",
              name: methodName
            }
          },
          arguments: [node.right]
        };
        node.operator = "=";
        node.right = rightReplacementNode;
      }
      if (_state.varyings[node.left.name]) {
        node.type = "ExpressionStatement";
        node.expression = {
          type: "CallExpression",
          callee: {
            type: "MemberExpression",
            object: {
              type: "Identifier",
              name: node.left.name
            },
            property: {
              type: "Identifier",
              name: "bridge"
            }
          },
          arguments: [node.right]
        };
      }
    },
    BinaryExpression(node, _state, ancestors) {
      if (ancestors.some(nodeIsUniform)) {
        return;
      }
      const unsafeTypes = ["Literal", "ArrayExpression", "Identifier"];
      if (unsafeTypes.includes(node.left.type)) {
        const leftReplacementNode = {
          type: "CallExpression",
          callee: {
            type: "Identifier",
            name: "__p5.dynamicNode"
          },
          arguments: [node.left]
        };
        node.left = leftReplacementNode;
      }
      node.type = "CallExpression";
      node.callee = {
        type: "MemberExpression",
        object: node.left,
        property: {
          type: "Identifier",
          name: replaceBinaryOperator(node.operator)
        }
      };
      node.arguments = [node.right];
    }
  };
  class BaseNode {
    constructor(isInternal, type3) {
      if (new.target === BaseNode) {
        throw new TypeError("Cannot construct BaseNode instances directly. This is an abstract class.");
      }
      this.type = type3;
      this.componentNames = [];
      this.componentsChanged = false;
      this.isInternal = isInternal;
      this.usedIn = [];
      this.dependsOn = [];
      this.srcLine = null;
      this.usedInConditional = false;
      if (GLOBAL_SHADER.srcLocations === true && isInternal === false) {
        try {
          throw new Error("StackCapture");
        } catch (e2) {
          const lines = e2.stack.split("\n");
          let userSketchLineIndex = 5;
          if (isBinaryExpressionNode(this)) {
            userSketchLineIndex--;
          }
          this.srcLine = lines[userSketchLineIndex].trim();
        }
      }
    }
    addVectorComponents() {
      if (this.type.startsWith("vec")) {
        const vectorDimensions = parseInt(this.type.slice(3));
        this.componentNames = ["x", "y", "z", "w"].slice(0, vectorDimensions);
        const proxy = this;
        for (let componentName of this.componentNames) {
          let value = new ComponentNode(proxy, componentName, "float", true);
          Object.defineProperty(this, componentName, {
            get() {
              return value;
            },
            set(newValue) {
              this.componentsChanged = true;
              if (isUnaryExpressionNode(this)) {
                this.node.value = newValue;
              } else {
                value = newValue;
              }
            }
          });
        }
      }
    }
    forceTemporaryVariable() {
      if (!(isFloatNode(this) && isVectorNode(this.parent)) || !isVariableNode(this))
        this.useTemp = true;
    }
    assertUsedInConditional(branch2) {
      this.usedInConditional = true;
      this.usedIn.push(branch2);
      this.forceTemporaryVariable();
    }
    isUsedInConditional() {
      return this.usedInConditional;
    }
    checkConditionalDependencies(context) {
      context.ifs.forEach((statement) => {
        const isUsedSatisfied = () => statement.usedInSatisfied.length >= 1;
        const isDepsSatisfied = () => statement.dependsOn.length === statement.dependsOnSatisfied.length;
        if (statement.insertionPoint > -1 || !statement.usedIn.length) return;
        if (statement.dependsOn.some((d2) => d2.node === this) && !statement.dependsOnSatisfied.includes(this)) {
          statement.dependsOnSatisfied.push(this);
        }
        if (statement.usedIn.includes(this) && !statement.usedInSatisfied.includes(this)) {
          statement.usedInSatisfied.push(this);
        }
        if (isDepsSatisfied() && isUsedSatisfied()) {
          statement.saveState(context, isDepsSatisfied(), isUsedSatisfied());
        }
      });
    }
    // The base node implements a version of toGLSL which determines whether the generated code should be stored in a temporary variable.
    toGLSLBase(context) {
      let result;
      if (this.shouldUseTemporaryVariable()) {
        let oldLength = context.declarations.length;
        result = this.getTemporaryVariable(context);
        let diff = context.declarations.length - 1 - oldLength;
        diff = diff > 0 ? diff : void 0;
        this.dependsOn.forEach((dependency) => {
          if (dependency.isVector) {
            const dependencies = dependency.originalComponents.map(
              (component, i) => component === dependency.currentComponents[i]
            );
            context.updateComponents(dependency.node, diff, dependencies);
          } else {
            context.updateComponents(dependency.node, diff);
          }
        });
      } else {
        result = this.toGLSL(context);
      }
      this.checkConditionalDependencies(context);
      return result;
    }
    shouldUseTemporaryVariable() {
      if (this.componentsChanged || hasTemporaryVariable(this) || this.useTemp) {
        return true;
      }
      if (this.isInternal || isVariableNode(this) || isConditionalNode(this) || this.type === "sampler2D") {
        return false;
      }
      let score = 0;
      score += isFunctionCallNode(this) * 2;
      score += isBinaryExpressionNode(this) * 2;
      score += isVectorType(this) * 3;
      score += this.usedIn.length;
      return score >= 4;
    }
    getTemporaryVariable(context) {
      if (!this.temporaryVariable) {
        this.temporaryVariable = `temp_${context.getNextID()}`;
        let line = "";
        if (this.srcLine) {
          line += `
// From ${this.srcLine}
`;
        }
        line += "  " + this.type + " " + this.temporaryVariable + " = " + this.toGLSL(context) + ";";
        context.declarations.push(line);
      }
      return this.temporaryVariable;
    }
    // Binary Operators
    add(other) {
      return binaryExpressionNodeConstructor(this, this.enforceType(other), "+");
    }
    sub(other) {
      return binaryExpressionNodeConstructor(this, this.enforceType(other), "-");
    }
    mult(other) {
      return binaryExpressionNodeConstructor(this, this.enforceType(other), "*");
    }
    div(other) {
      return binaryExpressionNodeConstructor(this, this.enforceType(other), "/");
    }
    mod(other) {
      return binaryExpressionNodeConstructor(this, this.enforceType(other), "%");
    }
    // Check that the types of the operands are compatible.
    enforceType(other) {
      if (isShaderNode(other)) {
        if (!isGLSLNativeType(other.type)) {
          throw new TypeError(`You've tried to perform an operation on a struct of type: ${other.type}. Try accessing a member on that struct with '.'`);
        }
        if (!isGLSLNativeType(other.type)) {
          throw new TypeError(`You've tried to perform an operation on a struct of type: ${other.type}. Try accessing a member on that struct with '.'`);
        }
        if ((isFloatType(this) || isVectorType(this)) && isIntType(other)) {
          return new FloatNode(other);
        }
        return other;
      } else if (typeof other === "number") {
        if (isIntType(this)) {
          return new IntNode(other);
        }
        return new FloatNode(other);
      } else if (Array.isArray(other)) {
        return nodeConstructors.dynamicVector(other);
      } else {
        return nodeConstructors[this.type](other);
      }
    }
    toFloat() {
      if (isFloatType(this)) {
        return this;
      } else if (isIntType(this)) {
        return new FloatNode(this);
      }
    }
    toGLSL(context) {
      throw new TypeError("Not supposed to call this function on BaseNode, which is an abstract class.");
    }
  }
  class IntNode extends BaseNode {
    constructor(x = 0, isInternal = false) {
      super(isInternal, "int");
      this.x = x;
    }
    toGLSL(context) {
      if (isShaderNode(this.x)) {
        let code = this.x.toGLSLBase(context);
        return isIntType(this.x.type) ? code : `int(${code})`;
      } else if (typeof this.x === "number") {
        return `${Math.floor(this.x)}`;
      } else {
        return `int(${this.x})`;
      }
    }
  }
  class FloatNode extends BaseNode {
    constructor(x = 0, isInternal = false, _parent = false) {
      super(isInternal, "float");
      if (Array.isArray(x)) {
        x = x[0];
      }
      if (_parent) {
        const { parent, name } = _parent;
        this.name = name;
        this.parent = parent;
      }
      this.x = x;
    }
    toGLSL(context) {
      if (isShaderNode(this.x)) {
        let code = this.x.toGLSLBase(context);
        return isFloatType(this.x) ? code : `float(${code})`;
      } else if (typeof this.x === "number") {
        return `${this.x.toFixed(4)}`;
      } else {
        return `float(${this.x})`;
      }
    }
  }
  class VectorNode extends BaseNode {
    constructor(values, type3, isInternal = false) {
      super(isInternal, type3);
      this.originalValues = conformVectorParameters(values, parseInt(type3.slice(3)));
      this.componentNames = ["x", "y", "z", "w"].slice(0, this.originalValues.length);
    }
    addVectorComponents() {
      const values = this.originalValues;
      this.componentsChanged = false;
      this.componentNames.forEach((componentName, i) => {
        const info = { name: componentName, parent: this };
        let value = isFloatNode(values[i]) ? values[i] : new FloatNode(values[i], true, info);
        Object.defineProperty(this, componentName, {
          get() {
            return value;
          },
          set(newValue) {
            this.componentsChanged = true;
            if (isUnaryExpressionNode(this)) {
              this.node.value = newValue;
            } else {
              value = isFloatNode(newValue) ? newValue : new FloatNode(newValue, true, info);
            }
          }
        });
      });
      this.originalValues = this.componentNames.map((name) => this[name]);
    }
    toGLSL(context) {
      if ((!this.componentsChanged || !this.defined) && !this.oldName) {
        let glslArgs = this.componentNames.map((_name, i) => this.originalValues[i].toGLSLBase(context)).join(", ");
        this.defined = true;
        return `${this.type}(${glslArgs})`;
      } else {
        return this.temporaryVariable;
      }
    }
  }
  class FunctionCallNode extends BaseNode {
    constructor(name, userArgs, properties, isInternal = false) {
      let functionSignature;
      const determineFunctionSignature = (props) => {
        let genType;
        let similarity = 0;
        const valid = userArgs.every((userArg, i) => {
          const userType = getType(userArg);
          let expectedArgType = props.args[i];
          if (expectedArgType === "genType") {
            if (genType === void 0 || genType === "float" && userType.startsWith("vec")) {
              genType = userType;
            }
            expectedArgType = genType;
          }
          similarity += userType === expectedArgType;
          return userType === expectedArgType || userType === "float" && expectedArgType.startsWith("vec");
        });
        return { ...props, valid, similarity, genType };
      };
      if (Array.isArray(properties)) {
        let possibleOverloads = properties.filter((o) => o.args.length === userArgs.length);
        if (possibleOverloads.length === 0) {
          const argsLengthSet = /* @__PURE__ */ new Set();
          const argsLengthArr = [];
          properties.forEach((p2) => argsLengthSet.add(p2.args.length));
          argsLengthSet.forEach((len) => argsLengthArr.push(`${len}`));
          const argsLengthStr = argsLengthArr.join(" or ");
          throw new Error(`Function '${name}' has ${properties.length} variants which expect ${argsLengthStr} arguments, but ${userArgs.length} arguments were provided.`);
        }
        const findBestOverload = function(best, current2) {
          current2 = determineFunctionSignature(current2);
          if (!current2.valid) {
            return best;
          }
          if (!best || current2.similarity > best.similarity) {
            best = current2;
          }
          return best;
        };
        functionSignature = possibleOverloads.reduce(findBestOverload, null);
      } else {
        functionSignature = determineFunctionSignature(properties);
      }
      if (!functionSignature || !functionSignature.valid) {
        const argsStrJoin = (args) => `(${args.map((arg) => arg).join(", ")})`;
        const expectedArgsString = Array.isArray(properties) ? properties.map((prop) => argsStrJoin(prop.args)).join(" or ") : argsStrJoin(properties.args);
        const providedArgsString = argsStrJoin(userArgs.map((a2) => getType(a2)));
        throw new Error(`Function '${name}' was called with wrong arguments. Most likely, you provided mixed lengths vectors as arguments.
Expected argument types: ${expectedArgsString}
Provided argument types: ${providedArgsString}
All of the arguments with expected type 'genType' should have a matching type. If one of those is different, try to find where it was created.
        `);
      }
      if (userArgs.length !== functionSignature.args.length) {
        throw new Error(`Function '${name}' expects ${functionSignature.args.length} arguments, but ${userArgs.length} were provided.`);
      }
      userArgs = userArgs.map((arg, i) => {
        if (!isShaderNode(arg)) {
          const typeName = functionSignature.args[i] === "genType" ? functionSignature.genType : functionSignature.args[i];
          arg = nodeConstructors[typeName](arg);
        } else if (isFloatType(arg) && functionSignature.args[i] === "genType" && functionSignature.genType !== "float") {
          arg = nodeConstructors[functionSignature.genType](arg);
        }
        return arg;
      });
      if (functionSignature.returnType === "genType") {
        functionSignature.returnType = functionSignature.genType;
      }
      super(isInternal, functionSignature.returnType);
      this.name = name;
      this.args = userArgs;
      this.argumentTypes = functionSignature.args;
    }
    deconstructArgs(context) {
      let argsString = this.args.map((argNode, i) => {
        if (isIntType(argNode) && this.argumentTypes[i] != "float") {
          argNode = argNode.toFloat();
        }
        argNode.toGLSLBase(context);
        return argNode.toGLSLBase(context);
      }).join(", ");
      return argsString;
    }
    toGLSL(context) {
      return `${this.name}(${this.deconstructArgs(context)})`;
    }
  }
  class VariableNode extends BaseNode {
    constructor(name, type3, isInternal = false) {
      super(isInternal, type3);
      this.name = name;
    }
    toGLSL(context) {
      return `${this.name}`;
    }
  }
  class ComponentNode extends BaseNode {
    constructor(parent, componentName, type3, isInternal = false) {
      super(isInternal, type3);
      this.parent = parent;
      this.componentName = componentName;
      this.type = type3;
    }
    toGLSL(context) {
      let parentName = this.parent.toGLSLBase(context);
      if (!isVariableNode(this.parent) && !hasTemporaryVariable(this.parent)) {
        parentName = `(${parentName})`;
      }
      return `${parentName}.${this.componentName}`;
    }
  }
  class VaryingNode extends VariableNode {
    constructor(name, type3, isInternal = false) {
      super(name, type3, isInternal);
      this.timesChanged = 0;
      this.tempVars = 0;
    }
    getValue() {
      const context = GLOBAL_SHADER.context;
      if (!context.varyings[this.name] || !this.timesChanged) {
        return this;
      }
      let values = context.varyings[this.name].splice(0, this.timesChanged);
      let snapshot;
      values.forEach((val2, i) => {
        let { value } = val2;
        context.declarations.push(`  ${this.name} = ${value.toGLSLBase(context)};`);
        if (i === values.length - 1) {
          const tempName = `${this.name}_${this.tempVars++}`;
          snapshot = dynamicAddSwizzleTrap(new VariableNode(tempName, this.type, true));
          context.declarations.push(`  ${this.type} ${tempName} = ${this.name};`);
        }
      });
      this.timesChanged = 0;
      return snapshot;
    }
    bridge(value) {
      if (!isShaderNode(value) || this.type.startsWith("vec") && getType(value) === "float") {
        value = nodeConstructors[this.type](value);
      }
      GLOBAL_SHADER.registerVarying(this, value);
      this.timesChanged += 1;
    }
  }
  class BinaryExpressionNode extends BaseNode {
    constructor(left, right, operator, isInternal = false) {
      super(isInternal, null);
      this.operator = operator;
      this.left = left;
      this.right = right;
      for (const operand of [left, right]) {
        operand.usedIn.push(this);
      }
      this.type = this.determineType();
    }
    // We know that both this.left and this.right are nodes because of BaseNode.enforceType
    determineType() {
      if (["==", ">", ">=", "<", "<=", "||", "!", "&&"].includes(this.operator)) {
        return "bool";
      } else if (this.left.type === this.right.type) {
        return this.left.type;
      } else if (isVectorType(this.left) && isFloatType(this.right)) {
        return this.left.type;
      } else if (isVectorType(this.right) && isFloatType(this.left)) {
        return this.right.type;
      } else if (isFloatType(this.left) && isIntType(this.right) || isIntType(this.left) && isFloatType(this.right)) {
        return "float";
      } else {
        throw new Error("Incompatible types for binary operator");
      }
    }
    processOperand(operand, context) {
      if (operand.temporaryVariable) {
        return operand.temporaryVariable;
      }
      let code = operand.toGLSLBase(context);
      if (isBinaryExpressionNode(operand) && !operand.temporaryVariable) {
        code = `(${code})`;
      }
      if (this.type === "float" && isIntType(operand)) {
        code = `float(${code})`;
      }
      return code;
    }
    toGLSL(context) {
      const a2 = this.processOperand(this.left, context);
      const b3 = this.processOperand(this.right, context);
      return `${a2} ${this.operator} ${b3}`;
    }
  }
  class ModulusNode extends BinaryExpressionNode {
    constructor(a2, b3, isInternal) {
      super(a2, b3, isInternal);
    }
    toGLSL(context) {
      if (isVectorType(this) || isFloatType(this)) {
        return `mod(${this.left.toGLSLBase(context)}, ${this.right.toGLSLBase(context)})`;
      }
      return `${this.processOperand(context, this.left)} % ${this.processOperand(context, this.right)}`;
    }
  }
  class UnaryExpressionNode extends BaseNode {
    constructor(node, operator, isInternal = false) {
      super(isInternal, node.type);
      this.node = node;
      this.operator = operator;
    }
    toGLSL(context) {
      let mainStr = this.node.toGLSLBase(context);
      if (!isVariableNode(this.node) && !hasTemporaryVariable(this.node) && !isPrimitiveNode(this.node)) {
        mainStr = `(${mainStr})`;
      }
      return `${this.operator}${mainStr}`;
    }
  }
  BaseNode.prototype.equalTo = function(other) {
    return binaryExpressionNodeConstructor(this, this.enforceType(other), "==");
  };
  BaseNode.prototype.greaterThan = function(other) {
    return binaryExpressionNodeConstructor(this, this.enforceType(other), ">");
  };
  BaseNode.prototype.greaterThanEqualTo = function(other) {
    return binaryExpressionNodeConstructor(this, this.enforceType(other), ">=");
  };
  BaseNode.prototype.lessThan = function(other) {
    return binaryExpressionNodeConstructor(this, this.enforceType(other), "<");
  };
  BaseNode.prototype.lessThanEqualTo = function(other) {
    return binaryExpressionNodeConstructor(this, this.enforceType(other), "<=");
  };
  BaseNode.prototype.not = function() {
    return new UnaryExpressionNode(this.condition, "!", true);
  };
  BaseNode.prototype.or = function(other) {
    return new binaryExpressionNodeConstructor(this, this.enforceType(other), "||", true);
  };
  BaseNode.prototype.and = function(other) {
    return new binaryExpressionNodeConstructor(this, this.enforceType(other), "&&", true);
  };
  function branch(callback) {
    const branch2 = new BranchNode();
    callback();
    BRANCH = null;
    return branch2;
  }
  class ConditionalNode {
    constructor(condition, branchCallback) {
      this.dependsOn = [];
      this.usedIn = [];
      this.dependsOnSatisfied = [];
      this.usedInSatisfied = [];
      this.states = [];
      this.if(condition, branchCallback);
      this.insertionPoint = -1;
      this.elseIfs = [];
      this.elseBranch = null;
      GLOBAL_SHADER.context.ifs.push(this);
    }
    if(condition, branchCallback) {
      this.condition = condition;
      this.conditionString = condition.toGLSL(GLOBAL_SHADER.context);
      this.ifBranch = branch(branchCallback);
      this.ifBranch.parent = this;
    }
    elseIf(condition, branchCallback) {
      let elseBranch = branch(branchCallback);
      branchCallback.parent = this;
      this.elseIfs.push({ condition, elseBranch });
      return this;
    }
    else(branchCallback) {
      this.elseBranch = branch(branchCallback);
      this.elseBranch.parent = this;
      return this;
    }
    thenDiscard() {
      return new ConditionalDiscard(this.condition);
    }
    saveState(context, usedInSatisfied, dependsOnSatisfied) {
      this.states.push({
        line: context.declarations.length,
        usedInSatisfied,
        dependsOnSatisfied
      });
      this.insertionPoint = context.declarations.length - 1;
    }
    toGLSL(context) {
      const oldLength = context.declarations.length;
      this.dependsOn.forEach((dep) => context.updateComponents(dep.node));
      const newLength = context.declarations.length;
      const diff = newLength - oldLength;
      this.insertionPoint += diff;
      let codelines = [
        `
  if (${this.conditionString}) {`,
        `
    ${this.ifBranch.toGLSL(context)}`,
        `
  }`
      ];
      if (this.elseIfs.length) {
        this.elseIfs.forEach((elif) => {
          let { condition, elseBranch } = elif;
          codelines.push(` else if (${condition.toGLSL(context)}) {`);
          codelines.push(`
    ${elseBranch.toGLSL(context)}`);
          codelines.push(`
  }`);
        });
      }
      if (this.elseBranch) {
        codelines.push(` else {`);
        codelines.push(`
    ${this.elseBranch.toGLSL(context)}`);
        codelines.push(`
  }
`);
      }
      codelines.push("\n");
      return codelines.flat().join("");
    }
  }
  fn2.assign = function(node, value) {
    if (!BRANCH) {
      throw new error('assign() is supposed to be used inside of conditional branchs. Use the "=" operator as normal otherwise.');
    }
    BRANCH.assign(node, value);
  };
  class BranchNode {
    constructor() {
      BRANCH = this;
      this.statements = [];
      this.assignments = [];
      this.dependsOn = [];
      this.declarations = [];
      let parent = null;
      Object.defineProperty(this, "parent", {
        get() {
          return parent;
        },
        set(newParent) {
          newParent.dependsOn.push(...this.dependsOn);
          parent = newParent;
        }
      });
    }
    assign(node, value) {
      if (!isShaderNode(value) || value.type !== node.type) {
        value = nodeConstructors[node.type](value);
        this.declarations.push(value);
        this.assignments.push({ node });
      } else {
        this.assignments.push({ node, value });
      }
      node = node.parent ? node.parent : node;
      value = value.parent ? value.parent : value;
      if ([node, value].some((n3) => this.dependsOn.some((d2) => d2.node === n3))) {
        return;
      }
      node.assertUsedInConditional(this);
      this.dependsOn.push(makeDependencyObject(node));
      if (value.shouldUseTemporaryVariable()) {
        value.assertUsedInConditional(this);
        this.dependsOn.push(makeDependencyObject(value));
      }
    }
    toGLSL(context) {
      let declarationsIndex = 0;
      this.assignments.forEach(({ node, value }) => {
        let statement;
        let result;
        if (!value) {
          let decl = this.declarations[declarationsIndex];
          declarationsIndex++;
          decl.temporaryVariable = `temp_${context.getNextID()}`;
          this.statements.push(
            `${decl.type} ${decl.temporaryVariable} = ${decl.toGLSL(context)};`
          );
          result = decl.toGLSLBase(context);
        } else {
          result = value.toGLSLBase(context);
        }
        if (isVariableNode(node) || hasTemporaryVariable(node)) {
          statement = `${node.toGLSLBase(context)} = ${result};`;
        } else if (isFloatNode(node) && node.name) {
          statement = `${node.parent.toGLSLBase(context)}.${node.name} = ${result};`;
        } else {
          node.temporaryVariable = `temp_${context.getNextID()}`;
          statement = `${node.type} ${node.toGLSLBase(context)} = ${result};`;
        }
        this.statements.push(statement);
      });
      return this.statements.join(`
    `);
    }
  }
  class ConditionalDiscard {
    constructor(condition) {
      this.condition = condition;
    }
    toGLSL(context) {
      context.discardConditions.push(`if (${this.condition}{discard;})`);
    }
  }
  function getType(node) {
    if (isShaderNode(node)) {
      return node.type;
    } else if (Array.isArray(node) && node.length > 1) {
      return `vec${node.length}`;
    } else if (typeof node === "number" || Array.isArray(node) && node.length === 1) {
      return "float";
    }
    return void 0;
  }
  function computeVectorLength(values) {
    let length = 0;
    if (Array.isArray(values)) {
      for (let val2 of values) {
        if (isVectorType(val2)) {
          length += parseInt(val2.type.slice(3));
        } else length += 1;
      }
    } else if (isVectorType(values)) {
      length += parseInt(val.type.slice(3));
    }
    if (![2, 3, 4].includes(length)) {
      throw new Error(`You have attempted to construct a vector with ${length} values. Only vec2, vec3, and vec4 types are supported.`);
    }
    return length;
  }
  p53.dynamicNode = function(input) {
    if (isShaderNode(input)) {
      return input;
    } else if (typeof input === "number") {
      return new FloatNode(input);
    } else if (Array.isArray(input)) {
      return nodeConstructors.dynamicVector(input);
    }
  };
  p53.unaryNode = function(input, sign) {
    input = p53.dynamicNode(input);
    return dynamicAddSwizzleTrap(new UnaryExpressionNode(input, sign));
  };
  function isShaderNode(node) {
    return node instanceof BaseNode;
  }
  function isIntType(node) {
    return isShaderNode(node) && node.type === "int";
  }
  function isFloatType(node) {
    return isShaderNode(node) && node.type === "float";
  }
  function isFloatNode(node) {
    return node instanceof FloatNode;
  }
  function isVectorType(node) {
    return isShaderNode(node) && (node.type === "vec2" || node.type === "vec3" || node.type === "vec4");
  }
  function isBinaryExpressionNode(node) {
    return node instanceof BinaryExpressionNode;
  }
  function isVariableNode(node) {
    return node instanceof VariableNode || node instanceof ComponentNode;
  }
  function isConditionalNode(node) {
    return node instanceof ConditionalNode || node instanceof BranchNode;
  }
  function hasTemporaryVariable(node) {
    return node.temporaryVariable;
  }
  function isPrimitiveNode(node) {
    return node instanceof FloatNode || node instanceof IntNode || node instanceof VectorNode;
  }
  function isFunctionCallNode(node) {
    return node instanceof FunctionCallNode;
  }
  function isVectorNode(node) {
    return node instanceof VectorNode;
  }
  function isUnaryExpressionNode(node) {
    return node instanceof UnaryExpressionNode;
  }
  function isGLSLNativeType(typeName) {
    const glslNativeTypes = ["int", "float", "vec2", "vec3", "vec4", "sampler2D"];
    return glslNativeTypes.includes(typeName);
  }
  class ShaderGenerator {
    constructor(userCallback, originalShader, srcLocations) {
      GLOBAL_SHADER = this;
      this.userCallback = userCallback;
      this.srcLocations = srcLocations;
      this.cleanup = () => {
      };
      this.generateHookOverrides(originalShader);
      this.output = {
        vertexDeclarations: /* @__PURE__ */ new Set(),
        fragmentDeclarations: /* @__PURE__ */ new Set(),
        uniforms: {}
      };
      this.uniformNodes = [];
      this.resetGLSLContext();
      this.isGenerating = false;
    }
    generate() {
      const prevFESDisabled = p53.disableFriendlyErrors;
      p53.disableFriendlyErrors = true;
      this.isGenerating = true;
      this.userCallback();
      this.output.vertexDeclarations = [...this.output.vertexDeclarations].join("\n");
      this.output.fragmentDeclarations = [...this.output.fragmentDeclarations].join("\n");
      this.isGenerating = false;
      this.cleanup();
      p53.disableFriendlyErrors = prevFESDisabled;
      return this.output;
    }
    // This method generates the hook overrides which the user calls in their modify function.
    generateHookOverrides(originalShader) {
      const availableHooks = {
        ...originalShader.hooks.vertex,
        ...originalShader.hooks.fragment
      };
      const windowOverrides = {};
      const fnOverrides = {};
      Object.keys(availableHooks).forEach((hookName) => {
        const hookTypes = originalShader.hookTypes(hookName);
        this[hookTypes.name] = function(userCallback) {
          const argNodes = [];
          const argsArray = [];
          hookTypes.parameters.forEach((parameter) => {
            if (!isGLSLNativeType(parameter.type.typeName)) {
              const structArg = {};
              parameter.type.properties.forEach((property) => {
                structArg[property.name] = variableConstructor(`${parameter.name}.${property.name}`, property.type.typeName, true);
              });
              argNodes.push(structArg);
            } else {
              argNodes.push(
                variableConstructor(parameter.name, parameter.type.typeName, true)
              );
            }
            const qualifiers = parameter.type.qualifiers.length > 0 ? parameter.type.qualifiers.join(" ") : "";
            argsArray.push(`${qualifiers} ${parameter.type.typeName} ${parameter.name}`.trim());
          });
          let returnedValue = userCallback(...argNodes);
          const expectedReturnType = hookTypes.returnType;
          const toGLSLResults = {};
          if (!isGLSLNativeType(expectedReturnType.typeName)) {
            Object.entries(returnedValue).forEach(([propertyName, propertyNode]) => {
              propertyNode = p53.dynamicNode(propertyNode);
              toGLSLResults[propertyName] = propertyNode.toGLSLBase(this.context);
              this.context.updateComponents(propertyNode);
            });
          } else {
            if (!isShaderNode(returnedValue)) {
              returnedValue = nodeConstructors[expectedReturnType.typeName](returnedValue);
            } else if (isFloatType(returnedValue) && expectedReturnType.typeName.startsWith("vec")) {
              returnedValue = nodeConstructors[expectedReturnType.typeName](returnedValue);
            }
            toGLSLResults["notAProperty"] = returnedValue.toGLSLBase(this.context);
            this.context.updateComponents(returnedValue);
          }
          this.context.ifs.forEach((statement) => {
            if (statement.usedIn.length === 0) {
              return;
            }
            const lines = statement.toGLSL(this.context);
            this.context.declarations.splice(statement.insertionPoint, 0, lines);
          });
          let codeLines = [
            `(${argsArray.join(", ")}) {`,
            ...this.context.declarations,
            `
  ${hookTypes.returnType.typeName} finalReturnValue;`
          ];
          Object.entries(toGLSLResults).forEach(([propertyName, result]) => {
            const propString = expectedReturnType.properties ? `.${propertyName}` : "";
            codeLines.push(`  finalReturnValue${propString} = ${result};`);
          });
          this.context.declarations = [];
          for (let key in this.context.varyings) {
            const declArray = this.context.varyings[key];
            const finalVaryingAssignments = [];
            declArray.forEach((obj) => {
              const { node, value } = obj;
              finalVaryingAssignments.push(`  ${node.name} = ${value.toGLSLBase(this.context)};`);
              finalVaryingAssignments.unshift(...this.context.declarations);
              node.timesChanged = 0;
            });
            codeLines.push(...finalVaryingAssignments);
          }
          codeLines.push("  return finalReturnValue;", "}");
          this.output[hookName] = codeLines.join("\n");
          this.resetGLSLContext();
        };
        windowOverrides[hookTypes.name] = window[hookTypes.name];
        fnOverrides[hookTypes.name] = fn2[hookTypes.name];
        window[hookTypes.name] = function(userOverride) {
          GLOBAL_SHADER[hookTypes.name](userOverride);
        };
        fn2[hookTypes.name] = function(userOverride) {
          GLOBAL_SHADER[hookTypes.name](userOverride);
        };
      });
      this.cleanup = () => {
        for (const key in windowOverrides) {
          window[key] = windowOverrides[key];
        }
        for (const key in fnOverrides) {
          fn2[key] = fnOverrides[key];
        }
      };
    }
    registerVarying(node, value) {
      if (!Array.isArray(this.context.varyings[node.name])) {
        this.context.varyings[node.name] = [];
      }
      this.context.varyings[node.name].push({ node, value });
      this.output.vertexDeclarations.add(`OUT ${node.type} ${node.name};`);
      this.output.fragmentDeclarations.add(`IN ${node.type} ${node.name};`);
    }
    resetGLSLContext() {
      this.uniformNodes.forEach((node) => {
        node.usedIn = [];
        node.temporaryVariable = void 0;
      });
      this.context = {
        id: 0,
        getNextID() {
          return this.id++;
        },
        declarations: [],
        varyings: [],
        ifs: [],
        updateComponents: function(node, _emplaceAt, _changedComponents) {
          if (node.componentsChanged) {
            if (!_changedComponents) {
              _changedComponents = node.componentNames.map(() => true);
            }
            const lines = [];
            if (isVectorNode(node)) {
              node.componentNames.forEach((name, i) => {
                if (!_changedComponents[i]) return;
                if (node[name] !== node.originalValues[i]) {
                  const replacement = nodeConstructors["float"](node[name]);
                  const line = `  ${node.temporaryVariable}.${name} = ${replacement.toGLSLBase(this)};`;
                  lines.push(line);
                }
              });
            } else {
              const components = node.componentNames.map((name) => {
                return node[name];
              });
              const replacement = nodeConstructors[node.type](components);
              const line = `  ${node.temporaryVariable} = ${replacement.toGLSLBase(this)};`;
              lines.push(line);
            }
            if (_emplaceAt) {
              this.declarations.splice(_emplaceAt, 0, ...lines);
            } else {
              this.declarations.push(...lines);
            }
            node.componentsChanged = false;
          }
        }
      };
      this.uniformNodes = [];
    }
  }
  function makeDependencyObject(dep) {
    if (isVectorType(dep)) {
      return {
        node: dep,
        isVector: true,
        originalComponents: [...dep.componentNames.map((name) => dep[name])],
        get currentComponents() {
          return dep.componentNames.map((name) => dep[name]);
        }
      };
    } else {
      return {
        node: dep,
        isVector: false
      };
    }
  }
  function makeDependencyArray(dependencies) {
    return dependencies.map((dep) => makeDependencyObject(dep));
  }
  function conformVectorParameters(value, vectorDimensions) {
    if (!Array.isArray(value)) {
      value = [value];
    }
    value = value.flat();
    value = value.map((val2) => {
      if (isVectorType(val2)) {
        const componentArray = val2.componentNames.map((comp) => val2[comp]);
        return componentArray;
      } else {
        return val2;
      }
    }).flat();
    if (value.length === 1 && !isVectorNode(value[0])) {
      value = Array(vectorDimensions).fill(value[0]);
    }
    return value;
  }
  function swizzleTrap(size) {
    const swizzleSets = [
      ["x", "y", "z", "w"],
      ["r", "g", "b", "a"],
      ["s", "t", "p", "q"]
    ].map((s) => s.slice(0, size));
    return {
      get(target, property, receiver) {
        if (property in target) {
          return Reflect.get(...arguments);
        } else {
          for (const set3 of swizzleSets) {
            if ([...property].every((char) => set3.includes(char))) {
              if (property.length === 1) {
                return target[swizzleSets[0][set3.indexOf(property[0])]];
              }
              const components = [...property].map((char) => {
                const index = set3.indexOf(char);
                const mappedChar = swizzleSets[0][index];
                return target[mappedChar];
              });
              const type3 = `vec${property.length}`;
              return nodeConstructors[type3](components);
            }
          }
        }
      },
      set(target, property, value, receiver) {
        for (const set3 of swizzleSets) {
          const propertyCharArray = [...property];
          if (propertyCharArray.every((char) => set3.includes(char))) {
            const newValues = Array.isArray(value) ? value : Array(property.length).fill(value);
            propertyCharArray.forEach((char, i) => {
              const index = set3.indexOf(char);
              const realProperty = swizzleSets[0][index];
              Reflect.set(target, realProperty, newValues[i], receiver);
            });
            return true;
          }
        }
        return Reflect.set(...arguments);
      }
    };
  }
  fn2.If = function(condition, branch2) {
    return new ConditionalNode(condition, branch2);
  };
  fn2.instanceID = function() {
    return variableConstructor("gl_InstanceID", "int");
  };
  fn2.getTexture = function(...userArgs) {
    const props = { args: ["sampler2D", "vec2"], returnType: "vec4", isp5Function: true };
    return fnNodeConstructor("getTexture", userArgs, props);
  };
  const GLSLTypesToIdentifiers = {
    int: "Int",
    float: "Float",
    vec2: "Vector2",
    vec3: "Vector3",
    vec4: "Vector4",
    sampler2D: "Texture"
  };
  function dynamicAddSwizzleTrap(node, _size2) {
    if (node.type.startsWith("vec") || _size2) {
      const size = parseInt(node.type.slice(3));
      node = new Proxy(node, swizzleTrap(size));
      node.addVectorComponents();
    }
    return node;
  }
  function binaryExpressionNodeConstructor(a2, b3, operator, isInternal) {
    let node;
    if (operator === "%") {
      node = new ModulusNode(a2, b3);
    } else {
      node = new BinaryExpressionNode(a2, b3, operator, isInternal);
    }
    return dynamicAddSwizzleTrap(node);
  }
  function variableConstructor(name, type3, isInternal) {
    const node = new VariableNode(name, type3, isInternal);
    return dynamicAddSwizzleTrap(node);
  }
  function fnNodeConstructor(name, userArgs, properties, isInternal) {
    let node = new FunctionCallNode(name, userArgs, properties, isInternal);
    node = dynamicAddSwizzleTrap(node);
    node.dependsOn = makeDependencyArray(node.args);
    const dependsOnConditionals = node.args.map((arg) => {
      const conditionals = arg.usedIn.filter((n3) => isConditionalNode(n3)).map((c4) => {
        if (c4 instanceof BranchNode) {
          return c4.parent;
        } else {
          return c4;
        }
      });
      return conditionals;
    }).flat();
    dependsOnConditionals.forEach((conditional) => conditional.usedIn.push(node));
    return node;
  }
  const nodeConstructors = {
    int: (value) => new IntNode(value),
    float: (value) => new FloatNode(value),
    vec2: (value) => dynamicAddSwizzleTrap(new VectorNode(value, "vec2")),
    vec3: (value) => dynamicAddSwizzleTrap(new VectorNode(value, "vec3")),
    vec4: (value) => dynamicAddSwizzleTrap(new VectorNode(value, "vec4")),
    dynamicVector: function(value) {
      const size = computeVectorLength(value);
      return this[`vec${size}`](value);
    }
  };
  for (const glslType in GLSLTypesToIdentifiers) {
    const typeIdentifier = GLSLTypesToIdentifiers[glslType];
    const uniformMethodName = `uniform${typeIdentifier}`;
    ShaderGenerator.prototype[uniformMethodName] = function(...args) {
      let [name, ...defaultValue] = args;
      if (glslType.startsWith("vec") && !(defaultValue[0] instanceof Function)) {
        defaultValue = conformVectorParameters(defaultValue, parseInt(glslType.slice(3)));
        this.output.uniforms[`${glslType} ${name}`] = defaultValue;
      } else {
        this.output.uniforms[`${glslType} ${name}`] = defaultValue[0];
      }
      const uniform = variableConstructor(name, glslType, false);
      this.uniformNodes.push(uniform);
      return uniform;
    };
    fn2[uniformMethodName] = function(...args) {
      return GLOBAL_SHADER[uniformMethodName](...args);
    };
    if (glslType === "sampler2D") {
      continue;
    }
    const varyingMethodName = `varying${typeIdentifier}`;
    ShaderGenerator.prototype[varyingMethodName] = function(name) {
      return dynamicAddSwizzleTrap(new VaryingNode(name, glslType, false));
    };
    fn2[varyingMethodName] = function(name) {
      return GLOBAL_SHADER[varyingMethodName](name);
    };
    const originalFn = fn2[glslType];
    fn2[glslType] = function(...value) {
      if (GLOBAL_SHADER == null ? void 0 : GLOBAL_SHADER.isGenerating) {
        if (glslType.startsWith("vec")) {
          value = conformVectorParameters(value, parseInt(glslType.slice(3)));
        } else {
          value = value[0];
        }
        return nodeConstructors[glslType](value);
      } else if (originalFn) {
        return originalFn.apply(this, value);
      } else {
        p53._friendlyError(
          `It looks like you've called ${glslType} outside of a shader's modify() function.`
        );
      }
    };
  }
  const builtInGLSLFunctions = {
    //////////// Trigonometry //////////
    "acos": { args: ["genType"], returnType: "genType", isp5Function: true },
    "acosh": { args: ["genType"], returnType: "genType", isp5Function: false },
    "asin": { args: ["genType"], returnType: "genType", isp5Function: true },
    "asinh": { args: ["genType"], returnType: "genType", isp5Function: false },
    "atan": [
      { args: ["genType"], returnType: "genType", isp5Function: false },
      { args: ["genType", "genType"], returnType: "genType", isp5Function: false }
    ],
    "atanh": { args: ["genType"], returnType: "genType", isp5Function: false },
    "cos": { args: ["genType"], returnType: "genType", isp5Function: true },
    "cosh": { args: ["genType"], returnType: "genType", isp5Function: false },
    "degrees": { args: ["genType"], returnType: "genType", isp5Function: true },
    "radians": { args: ["genType"], returnType: "genType", isp5Function: true },
    "sin": { args: ["genType"], returnType: "genType", isp5Function: true },
    "sinh": { args: ["genType"], returnType: "genType", isp5Function: false },
    "tan": { args: ["genType"], returnType: "genType", isp5Function: true },
    "tanh": { args: ["genType"], returnType: "genType", isp5Function: false },
    ////////// Mathematics //////////
    "abs": { args: ["genType"], returnType: "genType", isp5Function: true },
    "ceil": { args: ["genType"], returnType: "genType", isp5Function: true },
    "clamp": { args: ["genType", "genType", "genType"], returnType: "genType", isp5Function: false },
    "dFdx": { args: ["genType"], returnType: "genType", isp5Function: false },
    "dFdy": { args: ["genType"], returnType: "genType", isp5Function: false },
    "exp": { args: ["genType"], returnType: "genType", isp5Function: true },
    "exp2": { args: ["genType"], returnType: "genType", isp5Function: false },
    "floor": { args: ["genType"], returnType: "genType", isp5Function: true },
    "fma": { args: ["genType", "genType", "genType"], returnType: "genType", isp5Function: false },
    "fract": { args: ["genType"], returnType: "genType", isp5Function: true },
    "fwidth": { args: ["genType"], returnType: "genType", isp5Function: false },
    "inversesqrt": { args: ["genType"], returnType: "genType", isp5Function: true },
    // 'isinf': {},
    // 'isnan': {},
    "log": { args: ["genType"], returnType: "genType", isp5Function: true },
    "log2": { args: ["genType"], returnType: "genType", isp5Function: false },
    "max": [
      { args: ["genType", "genType"], returnType: "genType", isp5Function: true },
      { args: ["genType", "float"], returnType: "genType", isp5Function: true }
    ],
    "min": [
      { args: ["genType", "genType"], returnType: "genType", isp5Function: true },
      { args: ["genType", "float"], returnType: "genType", isp5Function: true }
    ],
    "mix": [
      { args: ["genType", "genType", "genType"], returnType: "genType", isp5Function: false },
      { args: ["genType", "genType", "float"], returnType: "genType", isp5Function: false }
    ],
    // 'mod': {},
    // 'modf': {},
    "pow": { args: ["genType", "genType"], returnType: "genType", isp5Function: true },
    "round": { args: ["genType"], returnType: "genType", isp5Function: true },
    "roundEven": { args: ["genType"], returnType: "genType", isp5Function: false },
    // 'sign': {},
    "smoothstep": [
      { args: ["genType", "genType", "genType"], returnType: "genType", isp5Function: false },
      { args: ["float", "float", "genType"], returnType: "genType", isp5Function: false }
    ],
    "sqrt": { args: ["genType"], returnType: "genType", isp5Function: true },
    "step": { args: ["genType", "genType"], returnType: "genType", isp5Function: false },
    "trunc": { args: ["genType"], returnType: "genType", isp5Function: false },
    ////////// Vector //////////
    "cross": { args: ["vec3", "vec3"], returnType: "vec3", isp5Function: true },
    "distance": { args: ["genType", "genType"], returnType: "float", isp5Function: true },
    "dot": { args: ["genType", "genType"], returnType: "float", isp5Function: true },
    // 'equal': {},
    "faceforward": { args: ["genType", "genType", "genType"], returnType: "genType", isp5Function: false },
    "length": { args: ["genType"], returnType: "float", isp5Function: false },
    "normalize": { args: ["genType"], returnType: "genType", isp5Function: true },
    // 'notEqual': {},
    "reflect": { args: ["genType", "genType"], returnType: "genType", isp5Function: false },
    "refract": { args: ["genType", "genType", "float"], returnType: "genType", isp5Function: false },
    ////////// Texture sampling //////////
    "texture": { args: ["sampler2D", "vec2"], returnType: "vec4", isp5Function: true }
  };
  Object.entries(builtInGLSLFunctions).forEach(([functionName, properties]) => {
    const isp5Function = Array.isArray(properties) ? properties[0].isp5Function : properties.isp5Function;
    if (isp5Function) {
      const originalFn = fn2[functionName];
      fn2[functionName] = function(...args) {
        if (GLOBAL_SHADER == null ? void 0 : GLOBAL_SHADER.isGenerating) {
          return fnNodeConstructor(functionName, args, properties);
        } else {
          return originalFn.apply(this, args);
        }
      };
    } else {
      fn2[functionName] = function(...args) {
        if (GLOBAL_SHADER == null ? void 0 : GLOBAL_SHADER.isGenerating) {
          return new fnNodeConstructor(functionName, args, properties);
        } else {
          p53._friendlyError(
            `It looks like you've called ${functionName} outside of a shader's modify() function.`
          );
        }
      };
    }
  });
  const originalLerp = fn2.lerp;
  fn2.lerp = function(...args) {
    if (GLOBAL_SHADER == null ? void 0 : GLOBAL_SHADER.isGenerating) {
      return this.mix(...args);
    } else {
      return originalLerp.apply(this, args);
    }
  };
  const originalNoise = fn2.noise;
  fn2.noise = function(...args) {
    if (!(GLOBAL_SHADER == null ? void 0 : GLOBAL_SHADER.isGenerating)) {
      return originalNoise.apply(this, args);
    }
    GLOBAL_SHADER.output.vertexDeclarations.add(noiseGLSL);
    GLOBAL_SHADER.output.fragmentDeclarations.add(noiseGLSL);
    let nodeArgs;
    if (args.length === 2) {
      nodeArgs = [fn2.vec2(args[0], args[1])];
    } else {
      nodeArgs = args;
    }
    return fnNodeConstructor("noise", nodeArgs, {
      args: ["vec2"],
      returnType: "float"
    });
  };
}
if (typeof p5 !== "undefined") {
  p5.registerAddon(shadergenerator);
}

// node_modules/p5/dist/webgl/index.js
var import_file_saver14 = __toESM(require_FileSaver());
var import_omggif9 = __toESM(require_omggif());
var import_libtess10 = __toESM(require_libtess_min());
var import_unicode_range3 = __toESM(require_lib());
var import_bezier_path3 = __toESM(require_bezier_path());
var import_escodegen2 = __toESM(require_escodegen());
function webgl(p53) {
  rendererGL(p53, p53.prototype);
  primitives3D(p53, p53.prototype);
  interaction(p53, p53.prototype);
  light(p53, p53.prototype);
  loading2(p53, p53.prototype);
  material(p53, p53.prototype);
  text(p53, p53.prototype);
  renderBuffer(p53, p53.prototype);
  quat(p53, p53.prototype);
  matrix(p53, p53.prototype);
  geometry(p53, p53.prototype);
  camera(p53, p53.prototype);
  framebuffer(p53, p53.prototype);
  dataArray(p53, p53.prototype);
  shader(p53, p53.prototype);
  texture(p53, p53.prototype);
  shadergenerator(p53, p53.prototype);
}

// node_modules/p5/dist/type/index.js
var import_file_saver15 = __toESM(require_FileSaver());
var import_unicode_range4 = __toESM(require_lib());
var import_bezier_path4 = __toESM(require_bezier_path());
function type2(p53) {
  p53.registerAddon(textCore);
  p53.registerAddon(font);
}

// node_modules/p5/dist/core/init.js
var import_file_saver16 = __toESM(require_FileSaver());
var import_omggif10 = __toESM(require_omggif());
var import_libtess11 = __toESM(require_libtess_min());
var _globalInit = () => {
  if (typeof window._setupDone !== "undefined") {
    console.warn(
      "p5.js seems to have been imported multiple times. Please remove the duplicate import"
    );
    return;
  }
  if (!window.mocha) {
    const p5ReadyEvent = new Event("p5Ready");
    window.dispatchEvent(p5ReadyEvent);
    if ((window.setup && typeof window.setup === "function" || window.draw && typeof window.draw === "function") && !p52.instance) {
      new p52();
    }
  }
};
var waitForDocumentReady = () => new Promise((resolve, reject) => {
  if (document.readyState === "complete") {
    resolve();
  } else {
    window.addEventListener("load", resolve, false);
  }
});
var waitingForTranslator = typeof IS_MINIFIED === "undefined" ? initialize() : Promise.resolve();

// node_modules/p5/dist/app.js
var import_file_saver17 = __toESM(require_FileSaver());
var import_omggif11 = __toESM(require_omggif());
var import_libtess12 = __toESM(require_libtess_min());
var import_unicode_range5 = __toESM(require_lib());
var import_bezier_path5 = __toESM(require_bezier_path());
var import_escodegen3 = __toESM(require_escodegen());
shape(p52);
accessibility(p52);
color2(p52);
friendlyErrors(p52);
data2(p52);
dom2(p52);
events(p52);
image3(p52);
io(p52);
math2(p52);
utilities(p52);
webgl(p52);
type2(p52);
Promise.all([waitForDocumentReady(), waitingForTranslator]).then(_globalInit);
export {
  p52 as default
};
/*! Bundled license information:

file-saver/FileSaver.js:
  (*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js *)

pako/dist/pako.esm.mjs:
  (*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) *)
*/
//# sourceMappingURL=p5.js.map
